<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TanXZ</title>
  
  <subtitle>少而好学，如曰出之阳；壮而好学，如曰中之光；老而好学，如炳烛之明。学然后知不足，教然后知困。知不足，然后能自反也；知困，然后能自强也。</subtitle>
  <link href="https://www.tanxz.com/atom.xml" rel="self"/>
  
  <link href="https://www.tanxz.com/"/>
  <updated>2020-12-19T13:27:50.295Z</updated>
  <id>https://www.tanxz.com/</id>
  
  <author>
    <name>TanXZ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何进行科学搜索</title>
    <link href="https://www.tanxz.com/posts/73533081/index.html"/>
    <id>https://www.tanxz.com/posts/73533081/index.html</id>
    <published>2020-12-19T13:27:50.000Z</published>
    <updated>2020-12-19T13:27:50.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;</summary>
      
    
    
    
    <category term="域.业务领域" scheme="https://www.tanxz.com/categories/%E5%9F%9F-%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/"/>
    
    <category term="术.解决方案" scheme="https://www.tanxz.com/categories/%E5%9F%9F-%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/%E6%9C%AF-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    <category term="技.技术研究" scheme="https://www.tanxz.com/categories/%E5%9F%9F-%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/%E6%9C%AF-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%8A%80-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    <category term="阵.技术应用" scheme="https://www.tanxz.com/categories/%E5%9F%9F-%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/%E6%9C%AF-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%8A%80-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/%E9%98%B5-%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/"/>
    
    <category term="法.手段方法" scheme="https://www.tanxz.com/categories/%E5%9F%9F-%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/%E6%9C%AF-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%8A%80-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/%E9%98%B5-%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/%E6%B3%95-%E6%89%8B%E6%AE%B5%E6%96%B9%E6%B3%95/"/>
    
    <category term="理.理论学习" scheme="https://www.tanxz.com/categories/%E5%9F%9F-%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/%E6%9C%AF-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%8A%80-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/%E9%98%B5-%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/%E6%B3%95-%E6%89%8B%E6%AE%B5%E6%96%B9%E6%B3%95/%E7%90%86-%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="器.工具使用" scheme="https://www.tanxz.com/categories/%E5%9F%9F-%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/%E6%9C%AF-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%8A%80-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/%E9%98%B5-%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/%E6%B3%95-%E6%89%8B%E6%AE%B5%E6%96%B9%E6%B3%95/%E7%90%86-%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E5%99%A8-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    <category term="杂.杂七杂八" scheme="https://www.tanxz.com/categories/%E5%9F%9F-%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F/%E6%9C%AF-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%8A%80-%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/%E9%98%B5-%E6%8A%80%E6%9C%AF%E5%BA%94%E7%94%A8/%E6%B3%95-%E6%89%8B%E6%AE%B5%E6%96%B9%E6%B3%95/%E7%90%86-%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E5%99%A8-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/%E6%9D%82-%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://www.tanxz.com/posts/0/index.html"/>
    <id>https://www.tanxz.com/posts/0/index.html</id>
    <published>2020-12-19T13:26:24.400Z</published>
    <updated>2020-12-19T13:27:16.444Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux命令killall</title>
    <link href="https://www.tanxz.com/posts/1026478353/index.html"/>
    <id>https://www.tanxz.com/posts/1026478353/index.html</id>
    <published>2020-12-18T15:55:13.495Z</published>
    <updated>2020-12-18T15:55:13.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux命令killall"><a href="#Linux命令killall" class="headerlink" title="Linux命令killall"></a>Linux命令killall</h1><p><a href="https://www.runoob.com/linux/linux-command-manual.html"><img src= "/img/loading.gif" data-lazy-src="https://www.runoob.com/images/up.gif" alt="Linux 命令大全"> Linux 命令大全</a></p><p>Linux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。</p><p>kill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">killall [选项]  name<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li>name ： 进程名</li></ul><p>选项包含如下几个参数：</p><ul><li>-e | –exact ： 进程需要和名字完全相符</li><li>-I | –ignore-case ：忽略大小写</li><li>-g | –process-group ：结束进程组</li><li>-i | –interactive ：结束之前询问</li><li>-l | –list ：列出所有的信号名称</li><li>-q | –quite ：进程没有结束时，不输出任何信息</li><li>-r | –regexp ：将进程名模式解释为扩展的正则表达式。</li><li>-s | –signal ：发送指定信号</li><li>-u | –user ：结束指定用户的进程</li><li>-v | –verbose ：显示详细执行过程</li><li>-w | –wait ：等待所有的进程都结束</li><li>-V |–version ：显示版本信息</li><li>–help ：显示帮助信息</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> killall -9 php-fpm          //结束所有的 php-fpm 进程</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux命令killall&quot;&gt;&lt;a href=&quot;#Linux命令killall&quot; class=&quot;headerlink&quot; title=&quot;Linux命令killall&quot;&gt;&lt;/a&gt;Linux命令killall&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.r</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux查看内存使用情况</title>
    <link href="https://www.tanxz.com/posts/1026478353/index.html"/>
    <id>https://www.tanxz.com/posts/1026478353/index.html</id>
    <published>2020-12-18T15:55:13.491Z</published>
    <updated>2020-12-18T15:55:13.493Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。</p></blockquote><p>有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 <code>free</code>、<code>ps</code>。而另一些命令允许通过多种方式展示系统的性能统计信息，比如 <code>top</code>。在这篇文章中，我们将介绍一些命令以帮助你确定当前占用着最多内存资源的用户或者进程。</p><p>下面是一些按照进程查看内存使用情况的命令：</p><h3 id="按照进程查看内存使用情况"><a href="#按照进程查看内存使用情况" class="headerlink" title="按照进程查看内存使用情况"></a>按照进程查看内存使用情况</h3><h4 id="使用-top"><a href="#使用-top" class="headerlink" title="使用 top"></a>使用 top</h4><p><code>top</code> 是最好的查看内存使用情况的命令之一。为了查看哪个进程使用着最多的内存，一个简单的办法就是启动 <code>top</code>，然后按下 <code>shift+m</code>，这样便可以查看按照内存占用百分比从高到底排列的进程。当你按下了 <code>shift+m</code> ，你的 <code>top</code> 应该会得到类似于下面这样的输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$toptop - 09:39:34 up 5 days, 3 min,  3 users,  load average: 4.77, 4.43, 3.72Tasks: 251 total,   3 running, 247 sleeping,   1 stopped,   0 zombie%Cpu(s): 50.6 us, 35.9 sy,  0.0 ni, 13.4 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    128.9 free,   2509.3 used,   3306.2 buff&#x2F;cacheMiB Swap:   2048.0 total,   2045.7 free,      2.2 used.   3053.5 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3309580 550188 168372 S   0.3   9.0   1:33.27 Web Content32469 nemo      20   0 3492840 447372 163296 S   7.3   7.3   3:55.60 firefox32542 nemo      20   0 2845732 433388 140984 S   6.0   7.1   4:11.16 Web Content  342 nemo      20   0 2848520 352288 118972 S  10.3   5.8   4:04.89 Web Content 2389 nemo      20   0 1774412 236700  90044 S  39.7   3.9   9:32.64 vlc29527 nemo      20   0 2735792 225980  84744 S   9.6   3.7   3:02.35 gnome-shell30497 nemo      30  10 1088476 159636  88884 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 140952  33128 S   0.0   2.3   0:04.58 gnome-software32533 nemo      20   0 2389088 104712  79544 S   0.0   1.7   0:01.43 WebExtensions 2256 nemo      20   0 1217884 103424  31304 T   0.0   1.7   0:00.28 vlc 1713 nemo      20   0 2374396  79588  61452 S   0.0   1.3   0:00.49 Web Content29306 nemo      20   0  389668  74376  54340 S   2.3   1.2   0:57.25 Xorg32739 nemo      20   0  289528  58900  34480 S   1.0   1.0   1:04.08 RDD Process29732 nemo      20   0  789196  57724  42428 S   0.0   0.9   0:00.38 evolution-alarm 2373 root      20   0  150408  57000   9924 S   0.3   0.9  10:15.35 nessusd<br></code></pre></td></tr></table></figure><p>注意 <code>%MEM</code> 排序。列表的大小取决于你的窗口大小，但是占据着最多的内存的进程将会显示在列表的顶端。</p><h4 id="使用-ps"><a href="#使用-ps" class="headerlink" title="使用 ps"></a>使用 ps</h4><p><code>ps</code> 命令中的一列用来展示每个进程的内存使用情况。为了展示和查看哪个进程使用着最多的内存，你可以将 <code>ps</code> 命令的结果传递给 <code>sort</code> 命令。下面是一个有用的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ ps aux | sort -rnk 4 | head -5nemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4<br></code></pre></td></tr></table></figure><p>在上面的例子中（文中已截断），<code>sort</code> 命令使用了 <code>-r</code> 选项（反转）、<code>-n</code> 选项（数字值）、<code>-k</code> 选项（关键字），使 <code>sort</code> 命令对 <code>ps</code> 命令的结果按照第四列（内存使用情况）中的数字逆序进行排列并输出。如果我们首先显示 <code>ps</code> 命令的标题，那么将会便于查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ ps aux | head -1; ps aux | sort -rnk 4 | head -5USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4<br></code></pre></td></tr></table></figure><p>如果你喜欢这个命令，你可以用下面的命令为他指定一个别名，如果你想一直使用它，不要忘记把该命令添加到你的 <code>~/.bashrc</code> 文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ alias mem-by-proc&#x3D;&quot;ps aux | head -1; ps aux | sort -rnk 4&quot;<br></code></pre></td></tr></table></figure><p>下面是一些根据用户查看内存使用情况的命令：</p><h3 id="按用户查看内存使用情况"><a href="#按用户查看内存使用情况" class="headerlink" title="按用户查看内存使用情况"></a>按用户查看内存使用情况</h3><h4 id="使用-top-1"><a href="#使用-top-1" class="headerlink" title="使用 top"></a>使用 top</h4><p>按照用户检查内存使用情况会更复杂一些，因为你需要找到一种方法把用户所拥有的所有进程统计为单一的内存使用量。</p><p>如果你只想查看单个用户进程使用情况，<code>top</code> 命令可以采用与上文中同样的方法进行使用。只需要添加 <code>-U</code> 选项并在其后面指定你要查看的用户名，然后按下 <code>shift+m</code> 便可以按照内存使用有多到少进行查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ top -U nemotop - 10:16:33 up 5 days, 40 min,  3 users,  load average: 1.91, 1.82, 2.15Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie%Cpu(s): 28.5 us, 36.8 sy,  0.0 ni, 34.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    224.1 free,   2752.9 used,   2967.4 buff&#x2F;cacheMiB Swap:   2048.0 total,   2042.7 free,      5.2 used.   2812.0 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3315724 623748 165440 S   1.0  10.2   1:48.78 Web Content32469 nemo      20   0 3629380 607492 161688 S   2.3  10.0   6:06.89 firefox32542 nemo      20   0 2886700 404980 136648 S   5.6   6.7   6:50.01 Web Content  342 nemo      20   0 2922248 375784 116096 S  19.5   6.2   8:16.07 Web Content 2389 nemo      20   0 1762960 234644  87452 S   0.0   3.9  13:57.53 vlc29527 nemo      20   0 2736924 227260  86092 S   0.0   3.7   4:09.11 gnome-shell30497 nemo      30  10 1088476 156372  85620 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 138160  30336 S   0.0   2.3   0:04.62 gnome-software32533 nemo      20   0 2389088 102532  76808 S   0.0   1.7   0:01.79 WebExtensions<br></code></pre></td></tr></table></figure><h4 id="使用-ps-1"><a href="#使用-ps-1" class="headerlink" title="使用 ps"></a>使用 ps</h4><p>你依旧可以使用 <code>ps</code> 命令通过内存使用情况来排列某个用户的进程。在这个例子中，我们将使用 <code>grep</code> 命令来筛选得到某个用户的所有进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ ps aux | head -1; ps aux | grep ^nemo| sort -rnk 4 | moreUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo     32469  7.1 11.5 3724364 701388 ?      Sl   08:54   7:21 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo       400  2.0  8.9 3308556 543232 ?      Sl   08:59   2:01 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni&#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32542  7.9  7.1 2903084 436196 ?      Sl   08:55   8:07 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342 10.8  7.0 2941056 426484 ?      Rl   08:59  10:45 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 16.9  3.8 1762960 234644 pts&#x2F;1  Sl+  09:15  13:57 vlc videos&#x2F;edge_computing.mp4nemo     29527  3.9  3.7 2736924 227448 ?      Ssl  08:50   4:11 &#x2F;usr&#x2F;bin&#x2F;gnome-shell<br></code></pre></td></tr></table></figure><h3 id="使用-ps-和其他命令的搭配"><a href="#使用-ps-和其他命令的搭配" class="headerlink" title="使用 ps 和其他命令的搭配"></a>使用 ps 和其他命令的搭配</h3><p>如果你想比较某个用户与其他用户内存使用情况将会比较复杂。在这种情况中，创建并排序一个按照用户总的内存使用量是一个不错的方法，但是它需要做一些更多的工作，并涉及到许多命令。在下面的脚本中，我们使用 <code>ps aux | grep -v COMMAND | awk &#39;&#123;print $1&#125;&#39; | sort -u</code> 命令得到了用户列表。其中包含了系统用户比如 <code>syslog</code>。我们对每个任务使用 <code>awk</code> 命令以收集每个用户总的内存使用情况。在最后一步中，我们展示每个用户总的内存使用量（按照从大到小的顺序）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">#!&#x2F;bin&#x2F;bashstats&#x3D;””echo &quot;%   user&quot;echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;# collect the datafor user in &#96;ps aux | grep -v COMMAND | awk &#39;&#123;print $1&#125;&#39; | sort -u&#96;do  stats&#x3D;&quot;$stats\n&#96;ps aux | egrep ^$user | awk &#39;BEGIN&#123;total&#x3D;0&#125;; \    &#123;total +&#x3D; $4&#125;;END&#123;print total,$1&#125;&#39;&#96;&quot;done# sort data numerically (largest first)echo -e $stats | grep -v ^$ | sort -rn | head<br></code></pre></td></tr></table></figure><p>这个脚本的输出可能如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ .&#x2F;show_user_mem_usage%   user&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;69.6 nemo5.8 root0.5 www-data0.3 shs0.2 whoopsie0.2 systemd+0.2 colord0.2 clamav0 syslog0 rtkit<br></code></pre></td></tr></table></figure><p>在 Linux 有许多方法可以报告内存使用情况。可以通过一些用心设计的工具和命令，来查看并获得某个进程或者用户占用着最多的内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 &lt;code&gt;free&lt;/code&gt;、&lt;cod</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://www.tanxz.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>待办事项</title>
    <link href="https://www.tanxz.com/posts/3858194484/index.html"/>
    <id>https://www.tanxz.com/posts/3858194484/index.html</id>
    <published>2020-12-18T15:40:25.000Z</published>
    <updated>2020-12-19T13:25:21.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="近期待办事项清单"><a href="#近期待办事项清单" class="headerlink" title="近期待办事项清单"></a>近期待办事项清单</h2><ul><li><input disabled="" type="checkbox"> 搭建博客：规范化历史文章目录</li><li><input disabled="" type="checkbox"> 搭建博客：博客的分类设计</li><li><input disabled="" type="checkbox"> 搭建博客：对历史文章进行重分类管理</li><li><input checked="" disabled="" type="checkbox"> 添加常用工具类网站</li><li><input checked="" disabled="" type="checkbox"> 添加百度、bing、cnzz站点统计功能</li></ul>]]></content>
    
    
    <summary type="html">今日事，今日毕。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Mac系统下升级node版本</title>
    <link href="https://www.tanxz.com/posts/1345941684/index.html"/>
    <id>https://www.tanxz.com/posts/1345941684/index.html</id>
    <published>2020-12-18T15:04:43.623Z</published>
    <updated>2020-12-18T15:04:43.623Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一步：使用npm安装n模块"><a href="#第一步：使用npm安装n模块" class="headerlink" title="第一步：使用npm安装n模块"></a>第一步：使用npm安装n模块</h4><p>n模块是专门用来管理nodejs版本的，名字就叫n执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install -g n<br></code></pre></td></tr></table></figure><h4 id="第二步：使用n模块升级node"><a href="#第二步：使用n模块升级node" class="headerlink" title="第二步：使用n模块升级node"></a>第二步：使用n模块升级node</h4><p><em>第一种是升级到最新版本</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo n latest<br></code></pre></td></tr></table></figure><p><em>第二种是升级到稳定版本（建议用稳定版本）</em></p><p><code>sudo n stable</code></p><p>安装成功！（若版本未切换成功则进入第三步手动修改环境变量）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">node -v<br>v11.10.1<br></code></pre></td></tr></table></figure><p>最后升级npm到最新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo npm install npm@latest -g<br></code></pre></td></tr></table></figure><h4 id="第三步：修改NODE-HOME环境变量"><a href="#第三步：修改NODE-HOME环境变量" class="headerlink" title="第三步：修改NODE_HOME环境变量"></a>第三步：修改NODE_HOME环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vi /etc/profile<br>+<br>export NODE_HOME=/usr/local/n/versions/node/12.0.0<br>export PATH=$NODE_HOME/bin:$PATH<br></code></pre></td></tr></table></figure><p>激活环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">source &#x2F;etc&#x2F;profile<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">如何在Mac系统下升级node版本</summary>
    
    
    
    
    <category term="mac" scheme="https://www.tanxz.com/tags/mac/"/>
    
    <category term="node" scheme="https://www.tanxz.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客：如何使用Hexo写作</title>
    <link href="https://www.tanxz.com/posts/3878378061/index.html"/>
    <id>https://www.tanxz.com/posts/3878378061/index.html</id>
    <published>2020-12-18T15:04:43.617Z</published>
    <updated>2020-12-18T18:13:05.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章将讲解如果使用hexo命令生成页面、文章及如何配置文章模板等操作。</p></blockquote><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th align="left">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left"><code>post</code></td><td align="left"><code>source/_posts</code></td></tr><tr><td align="left"><code>page</code></td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>draft</code></td><td align="left"><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>Disabling layout</p><p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href="https://hexo.io/zh-cn/docs/front-matter#布局">this section</a> for more details.</p></blockquote><h3 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">标题（小写，空格将会被替换为短杠）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">建立的年份，比如， <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">建立的月份（有前导零），比如， <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">建立的月份（无前导零），比如， <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">建立的日期（有前导零），比如， <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">建立的日期（无前导零），比如， <code>7</code></td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><h3 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h3><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo new photo &quot;My Gallery&quot;<br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件建立日期</td></tr></tbody></table><h3 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章将讲解如果使用hexo命令生成页面、文章及如何配置文章模板等操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你可以执行下列命令来创建一篇新文章或者新的页面。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="博客" scheme="https://www.tanxz.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="https://www.tanxz.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客：Hexo常用命令</title>
    <link href="https://www.tanxz.com/posts/2628717197/index.html"/>
    <id>https://www.tanxz.com/posts/2628717197/index.html</id>
    <published>2020-12-18T15:04:43.617Z</published>
    <updated>2020-12-18T15:04:43.617Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文章将讲解在搭建Hexo博客过程中的常用命令及命令的参数说明</p></blockquote><a id="more"></a><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> hexo init [folder]</span><br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>This command is a shortcut that runs the following steps:</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> including <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> into the current directory or a target folder if specified.</li><li>Install dependencies using a package manager: <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>, <a href="https://pnpm.js.org/">pnpm</a> or <a href="https://docs.npmjs.com/cli/install">npm</a>, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> by default.</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo new [layout] <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo new &quot;post title with whitespace&quot;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo new page --path about&#x2F;me &quot;About me&quot;<br></code></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo new page --path about&#x2F;me<br></code></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo generate<br></code></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo g<br></code></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo publish [layout] &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo server<br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo deploy<br></code></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo d<br></code></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo migrate &lt;type&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo list &lt;type&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo version<br></code></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo --safe<br></code></pre></td></tr></table></figure><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo --debug<br></code></pre></td></tr></table></figure><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo --silent<br></code></pre></td></tr></table></figure><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain"># 使用 custom.yml 代替默认的 _config.yml<br>$ hexo server --config custom.yml<br><br># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain"># 使用 custom.yml 代替默认的 _config.yml<br>$ hexo server --config custom.yml<br><br># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo --draft<br></code></pre></td></tr></table></figure><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd<br></code></pre></td></tr></table></figure><p>自定义当前工作目录（Current working directory）的路径。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文章将讲解在搭建Hexo博客过程中的常用命令及命令的参数说明&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="博客" scheme="https://www.tanxz.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="https://www.tanxz.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客：NexT主题配置</title>
    <link href="https://www.tanxz.com/posts/3878378062/index.html"/>
    <id>https://www.tanxz.com/posts/3878378062/index.html</id>
    <published>2020-12-18T15:04:43.617Z</published>
    <updated>2020-12-18T18:38:04.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>前文：<a href="https://blog.csdn.net/weixin_39345384/article/details/80095883">Windows下通过GitHub+Hexo搭建个人博客的步骤</a>；<br>博主的个人博客：<a href="https://hunter1023.github.io/">https://hunter1023.github.io/</a> 按照本篇博客美化。</p><p>在 Hexo 中有<strong>2份</strong>主要的配置文件，其名称都是<code>_config.yml</code>。 其中，一份位于<strong>博客根目录下</strong>，主要包含 <strong>Hexo 本身的配置</strong>；另一份位于<code>themes/next/</code>目录下，用于配置<strong>主题相关的选项</strong>。</p><hr><h1 id="2-基础设置"><a href="#2-基础设置" class="headerlink" title="2. 基础设置"></a>2. 基础设置</h1><h2 id="2-1-设置站点名、作者昵称和站点描述等内容"><a href="#2-1-设置站点名、作者昵称和站点描述等内容" class="headerlink" title="2.1 设置站点名、作者昵称和站点描述等内容"></a>2.1 设置站点名、作者昵称和站点描述等内容</h2><p>打开<strong>根目录下的<code>_config.yml</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain"># Site<br>title: 特叔服务<br>subtitle: <br>keywords:<br>author: Hunter<br>description: Tough times never last, but tough people do.<br></code></pre></td></tr></table></figure><hr><h2 id="2-2-NexT主题的安装"><a href="#2-2-NexT主题的安装" class="headerlink" title="2.2. NexT主题的安装"></a>2.2. NexT主题的安装</h2><p>顾名思义，所谓主题就是界面的展示样式。Hexo安装主题，只需要将主题文件拷贝至博客所在目录的<code>themes</code>目录下，修改相关配置文件即可生效。</p><p>博客所在目录下打开<code>git bash</code>，再通过<code>Git clone https://github.com/theme-next/hexo-theme-next themes/next</code>即可完成。</p><hr><h2 id="2-3-启用主题"><a href="#2-3-启用主题" class="headerlink" title="2.3 启用主题"></a>2.3 启用主题</h2><p>打开<strong>根目录下的<code>_config.yml</code></strong>,查找<code>theme</code>字段，将字段改为<code>theme: next</code>(<strong>冒号<code>:</code>之后要有空格分隔，否则无效</strong>) ，之后通过<code>hexo g</code>和<code>hexo s</code>，再在浏览器中访问<code>localhost:4000</code>即可本地预览主题效果。</p><hr><h1 id="3-主题设定"><a href="#3-主题设定" class="headerlink" title="3. 主题设定"></a>3. 主题设定</h1><h2 id="3-1-选择scheme"><a href="#3-1-选择scheme" class="headerlink" title="3.1 选择scheme"></a>3.1 选择scheme</h2><p>打开<code>themes/next/</code>下的<code>_config.yml</code>,查找<code>scheme</code>，可以看到如下四种不同的风格方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">scheme: Muse<br>#scheme: Mist<br>#scheme: Pisces<br>#scheme: Gemini<br></code></pre></td></tr></table></figure><p>去掉<code>#</code>注释，即启用对应的scheme，博主采用Muse主题，大家可以依次测试效果，选择自己喜欢的scheme。</p><hr><h2 id="3-2-设置语言"><a href="#3-2-设置语言" class="headerlink" title="3.2 设置语言"></a>3.2 设置语言</h2><p>博客框架默认的语言是英文，前往<code>/themes/next/languages</code>，查看当前NexT版本简体中文对照文件的名称是<code>zh-Hans</code>还是<code>zh-CN</code>。</p><p>再前往根目录下的<code>_config.yml</code>，查找<code>language</code>，设置成<code>language: zh-Hans</code>或<code>language: zh-CN</code>，即显示简体中文。</p><hr><h2 id="3-3-设置菜单及对应页面"><a href="#3-3-设置菜单及对应页面" class="headerlink" title="3.3 设置菜单及对应页面"></a>3.3 设置菜单及对应页面</h2><ul><li><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>menu</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">menu:<br>  home: &#x2F; || home<br>  #about: &#x2F;about&#x2F; || user<br>  tags: &#x2F;tags&#x2F; || tags<br>  categories: &#x2F;categories&#x2F; || th<br>  archives: &#x2F;archives&#x2F; || archive<br>  #schedule: &#x2F;schedule&#x2F; || calendar<br>  #sitemap: &#x2F;sitemap.xml || sitemap<br>  #commonweal: &#x2F;404&#x2F; || heartbeat<br></code></pre></td></tr></table></figure><p>去掉<code>#</code>注释即可显示对应的菜单项，也可自定义新的菜单项。 <code>||</code>之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。</p></li><li><p>新添加的菜单需要翻译对应的中文<br>打开<code>hexo/theme/next/languages/zh-CN.yml</code>，在menu下自定义，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">menu:<br>  resources: 资源<br></code></pre></td></tr></table></figure></li><li><p><code>hexo new page &quot;categories&quot;</code><br>此时在根目录的<code>source</code>文件夹下会生成一个categories文件，文件中有一个<code>index.md</code>文件，修改内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">---<br>title: 分类<br>date: 2017-12-14 13:05:38<br>type: &quot;categories&quot;<br>comments: false<br>---<br></code></pre></td></tr></table></figure><p>注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。</p></li></ul><hr><h2 id="3-4-设定站点建立时间"><a href="#3-4-设定站点建立时间" class="headerlink" title="3.4 设定站点建立时间"></a>3.4 设定站点建立时间</h2><p>打开<strong><code>themes/next/</code>下的<code>_config.yml</code></strong>，查找<code>since</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">footer:<br>  # Specify the date when the site was setup.<br>  # If not defined, current year will be used.<br>  #since: 2015<br></code></pre></td></tr></table></figure><p><strong>如果不设置，默认显示当前年份</strong>。</p><hr><h1 id="4-美化"><a href="#4-美化" class="headerlink" title="4. 美化"></a>4. 美化</h1><h2 id="4-1-设置头像"><a href="#4-1-设置头像" class="headerlink" title="4.1 设置头像"></a>4.1 设置头像</h2><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>avatar</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain"># Sidebar Avatar<br># in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif<br># in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif<br>avatar: http:&#x2F;&#x2F;XXXXXXXXX<br></code></pre></td></tr></table></figure><p><code>avatar</code>的值是<strong>图片的链接地址</strong>(完整的URI 或者 站内的相对地址皆可)</p><table><thead><tr><th>地址</th><th>值</th></tr></thead><tbody><tr><td>完整的URI</td><td><a href="http://example.com/avatar.png">http://example.com/avatar.png</a></td></tr><tr><td>站点内地址</td><td>图片放至<code>themes/next/source/images/</code>配置为：<code>avatar: /images/图片名</code></td></tr><tr><td>站点内地址</td><td>图片放至<strong>根目录下</strong><code>source/uploads/</code>(初始无uploads文件夹，自行创建)目录下配置为：<code>avatar: /uploads/图片名</code></td></tr></tbody></table><p><strong>之后创建博文，对图片的引用 同样可以按照上述地址获取</strong>。</p><hr><h2 id="4-2-网站图标设置"><a href="#4-2-网站图标设置" class="headerlink" title="4.2 网站图标设置"></a>4.2 网站图标设置</h2><ul><li><p>图标素材网站：<a href="https://www.iconfont.cn/">iconfont</a>；<a href="https://www.easyicon.net/">easyicon</a></p></li><li><p>下载16x16以及32x32大小的<strong>PNG格式图标</strong>，置于<code>/themes/next/source/images/</code>下</p></li><li><p>打开**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure><p>下的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">_config.yml<br></code></pre></td></tr></table></figure><p>**，查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">favicon<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">favicon:<br>  small: &#x2F;images&#x2F;favicon-16x16-next.png<br>  medium: &#x2F;images&#x2F;favicon-32x32-next.png<br>  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png<br>  safari_pinned_tab: &#x2F;images&#x2F;logo.svg<br>  #android_manifest: &#x2F;images&#x2F;manifest.json<br>  #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml<br></code></pre></td></tr></table></figure><p>修改small和medium的路径为下载的图标路径</p></li></ul><hr><h2 id="4-3-背景动画"><a href="#4-3-背景动画" class="headerlink" title="4.3 背景动画"></a>4.3 背景动画</h2><h3 id="4-3-1-Canvas-nest风格"><a href="#4-3-1-Canvas-nest风格" class="headerlink" title="4.3.1 Canvas-nest风格"></a>4.3.1 <a href="https://blog.csdn.net/weixin_39345384/article/details/80544660">Canvas-nest风格</a></h3><h3 id="4-3-2-JavaScript-3D-library风格"><a href="#4-3-2-JavaScript-3D-library风格" class="headerlink" title="4.3.2 JavaScript 3D library风格"></a>4.3.2 JavaScript 3D library风格</h3><ol><li>进入theme/next目录</li><li>执行命令：<code>git clone https://github.com/theme-next/theme-next-three source/lib/three</code></li><li>将<code>themes/next/_config.yml</code>中查找<code>theme-next-three</code>，将想要的效果改为true即可：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain"># three_waves<br>three_waves: false<br># canvas_lines<br>canvas_lines: true<br># canvas_sphere<br>canvas_sphere: false<br></code></pre></td></tr></table></figure><hr><h2 id="4-4-背景图片-顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色"><a href="#4-4-背景图片-顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色" class="headerlink" title="4.4 背景图片/顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色"></a>4.4 背景图片/顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;背景图片<br>body&#123;   <br>        background:url(图片链接);<br>        background-size:cover;<br>        background-repeat:no-repeat;<br>        background-attachment:fixed;<br>        background-position:center;<br>&#125;<br>&#x2F;&#x2F;顶栏图片<br>.header &#123;<br>          background:url(图片链接) none repeat scroll !important;<br>&#125;<br>&#x2F;&#x2F;底栏背景色<br>.footer &#123;<br>          background:rgba(颜色rgb,透明度) none repeat scroll !important;<br>&#125;<br>&#x2F;&#x2F;侧栏图片及内部文字颜色修改<br>#sidebar &#123;<br>            background:url(图片链接);<br>            background-size: cover;<br>            background-position:center;<br>            background-repeat:no-repeat;<br>            p,span,a &#123;color: 颜色代码;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的css样式属性都可以根据图片修改，以达到满意的效果。</p><hr><h2 id="4-5-侧栏置于左侧，修改控制按钮样式"><a href="#4-5-侧栏置于左侧，修改控制按钮样式" class="headerlink" title="4.5 侧栏置于左侧，修改控制按钮样式"></a>4.5 侧栏置于左侧，修改控制按钮样式</h2><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>sidebar</code></p><h3 id="4-5-1-设置侧栏在左侧-右侧"><a href="#4-5-1-设置侧栏在左侧-右侧" class="headerlink" title="4.5.1 设置侧栏在左侧/右侧"></a>4.5.1 设置侧栏在左侧/右侧</h3><ul><li><p>Pisces或Gemini方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">sidebar:<br>position: left<br>#position: right<br></code></pre></td></tr></table></figure></li><li><p>Mist或Muse方案</p></li></ul><ol><li><p>打开<code>next/source/js/src/motion.js</code>，查找<code>paddingRight</code>，把所有（2个）<code>PaddingRight</code>更改为<code>paddingLeft</code>即可。</p></li><li><p>打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">next&#x2F;source&#x2F;css&#x2F;_custom&#x2F;custom.styl<br></code></pre></td></tr></table></figure><p>，添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;侧边栏置于左侧<br>.sidebar &#123;<br>  left: 0;<br>&#125;<br>&#x2F;&#x2F;侧栏开关置于左侧<br>.sidebar-toggle &#123;<br>  left: $b2t-position-right;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>打开<code>next/source/css/_common/components/back-to-top.styl</code>，将<code>right: $b2t-position-right;</code>改为<code>left: $b2t-position-right;</code></p></li></ol><h3 id="4-5-2-显示侧边栏的时机"><a href="#4-5-2-显示侧边栏的时机" class="headerlink" title="4.5.2 显示侧边栏的时机"></a>4.5.2 显示侧边栏的时机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">#post - 默认行为，在文章页面（拥有目录列表）时显示<br>#always - 在所有页面中都显示<br>#hide - 在所有页面中都隐藏（可以手动展开）<br>#remove - 完全移除<br>display: post<br>#display: always<br>#display: hide<br>#display: remove<br></code></pre></td></tr></table></figure><hr><h3 id="4-5-3-侧边栏控制按钮样式修改"><a href="#4-5-3-侧边栏控制按钮样式修改" class="headerlink" title="4.5.3 侧边栏控制按钮样式修改"></a>4.5.3 侧边栏控制按钮样式修改</h3><p>打开<code>themes/next/layout/source/js/src/motion.js</code>，找到如下代码处，更换close的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plain">var sidebarToggleLine1st &#x3D; new SidebarToggleLine(&#123;<br>    el: &#39;.sidebar-toggle-line-first&#39;,<br>    status: &#123;<br>      arrow: &#123;width: &#39;50%&#39;, rotateZ: &#39;45deg&#39;, top: &#39;2px&#39;, left: &#39;6px&#39;&#125;,<br>      &#x2F;&#x2F; close: &#123;width: &#39;100%&#39;, rotateZ: &#39;-45deg&#39;, top: &#39;5px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;X形<br>      close: &#123;width: &#39;50%&#39;, rotateZ: &#39;-45deg&#39;, top: &#39;2px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;箭头形<br>    &#125;<br>  &#125;);<br>  var sidebarToggleLine2nd &#x3D; new SidebarToggleLine(&#123;<br>    el: &#39;.sidebar-toggle-line-middle&#39;,<br>    status: &#123;<br>      arrow: &#123;width: &#39;90%&#39;&#125;,<br>      &#x2F;&#x2F; close: &#123;opacity: 0&#125; &#x2F;&#x2F;X形<br>      close: &#123;width: &#39;90%&#39;&#125; &#x2F;&#x2F;箭头形<br>    &#125;<br>  &#125;);<br>  var sidebarToggleLine3rd &#x3D; new SidebarToggleLine(&#123;<br>    el: &#39;.sidebar-toggle-line-last&#39;,<br>    status: &#123;<br>      arrow: &#123;width: &#39;50%&#39;, rotateZ: &#39;-45deg&#39;, top: &#39;-2px&#39;, left: &#39;6px&#39;&#125;,<br>      &#x2F;&#x2F; close: &#123;width: &#39;100%&#39;, rotateZ: &#39;45deg&#39;, top: &#39;-5px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;X形<br>      close: &#123;width: &#39;50%&#39;, rotateZ: &#39;45deg&#39;, top: &#39;-2px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;箭头形<br>    &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure><hr><h2 id="4-6-文章底部标签显示的优化"><a href="#4-6-文章底部标签显示的优化" class="headerlink" title="4.6 文章底部标签显示的优化"></a>4.6 文章底部标签显示的优化</h2><p>修改<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p><h2 id="4-7-文章添加阴影、透明效果"><a href="#4-7-文章添加阴影、透明效果" class="headerlink" title="4.7 文章添加阴影、透明效果"></a>4.7 文章添加阴影、透明效果</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 主页文章添加阴影效果<br>.post &#123;<br>   margin-top: 60px;<br>   margin-bottom: 60px;<br>   padding: 25px;<br>   background:rgba(255,255,255,0.9) none repeat scroll !important;<br>   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);<br>   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-8-Hexo添加文章时自动打开编辑器"><a href="#4-8-Hexo添加文章时自动打开编辑器" class="headerlink" title="4.8 Hexo添加文章时自动打开编辑器"></a>4.8 Hexo添加文章时自动打开编辑器</h2><ul><li>首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。<br>如果没有这个scripts目录，则新建一个。</li><li>scripts目录新建的JavaScript脚本文件可以任意取名。</li></ul><p>通过这个脚本，我们用其来监听<code>hexo new</code>这个动作，并在检测到<code>hexo new</code>之后，执行编辑器打开的命令。</p><ul><li>如果你是windows平台的Hexo用户，则将下列内容写入你的脚本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">var spawn &#x3D; require(&#39;child_process&#39;).exec;<br>hexo.on(&#39;new&#39;, function(data)&#123;<br>  spawn(&#39;start  &quot;markdown编辑器绝对路径.exe&quot; &#39; + data.path);<br>&#125;);<br></code></pre></td></tr></table></figure><p>如果你是Mac平台Hexo用户，则将下列内容写入你的脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">var exec &#x3D; require(&#39;child_process&#39;).exec;<br>hexo.on(&#39;new&#39;, function(data)&#123;<br>    exec(&#39;open -a &quot;markdown编辑器绝对路径.app&quot; &#39; + data.path);<br>&#125;);<br></code></pre></td></tr></table></figure><hr><h2 id="4-9-点击侧栏头像回到首页"><a href="#4-9-点击侧栏头像回到首页" class="headerlink" title="4.9 点击侧栏头像回到首页"></a>4.9 点击侧栏头像回到首页</h2><p>修改<code>/themes/next/layout/_macro/sidebar.swig</code>，找到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot;<br>    src&#x3D;&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &#39;&#x2F;avatar.gif&#39;) ) &#125;&#125;&quot;<br>    alt&#x3D;&quot;&#123;&#123; theme.author &#125;&#125;&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure><p>在其前后加上<code>&lt;a href=&quot;/&quot;&gt;&lt;/a&gt;</code>即可，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;<br>   &lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot;<br>       src&#x3D;&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &#39;&#x2F;avatar.gif&#39;) ) &#125;&#125;&quot;<br>       alt&#x3D;&quot;&#123;&#123; theme.author &#125;&#125;&quot; &#x2F;&gt;<br>&lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="4-10-修改中文字体"><a href="#4-10-修改中文字体" class="headerlink" title="4.10 修改中文字体"></a>4.10 修改中文字体</h2><ol><li><p>前往<a href="https://fonts.google.com/">Google Fonts</a>查看合适的字体</p></li><li><p>打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure><p>下的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">_config.yml<br></code></pre></td></tr></table></figure><p>，查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">font<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">font:<br>enable: true<br> # Uri of fonts host. E.g. &#x2F;&#x2F;fonts.googleapis.com (Default). 修改为墙内镜像<br>host: https:&#x2F;&#x2F;fonts.loli.net<br>global:<br>external: true<br>family: Noto Serif SC &#x2F;&#x2F; 挑选的字体<br>size: 16<br></code></pre></td></tr></table></figure><ol><li>修改<code>/themes/next/source/css/_variables/base.styl</code><br>将</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">$font-family-monospace    &#x3D; consolas, Menlo, $font-family-chinese, monospace<br>$font-family-monospace    &#x3D; get_font_family(&#39;codes&#39;), consolas, Menlo, $font-family-chinese, monospace if get_font_family(&#39;codes&#39;)<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">$font-family-monospace    &#x3D; consolas, Menlo, $font-family-base, monospace<br>$font-family-monospace    &#x3D; get_font_family(&#39;codes&#39;), consolas, Menlo, $font-family-base, monospace if get_font_family(&#39;codes&#39;)<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="4-11-新建文章时，在相同目录下创建同名文件夹（便于图片管理）"><a href="#4-11-新建文章时，在相同目录下创建同名文件夹（便于图片管理）" class="headerlink" title="4.11 新建文章时，在相同目录下创建同名文件夹（便于图片管理）"></a>4.11 新建文章时，在相同目录下创建同名文件夹（便于图片管理）</h2><ul><li>打开站点配置文件<code>_config.yml</code>，搜索<code>post_asset_folder</code>字段，设置其值为<code>true</code></li><li>安装hexo-asset-image：<code>npm install hexo-asset-image --save</code></li><li>此时<code>hexo new &quot;fileName&quot;</code>会在<code>/source/_posts</code>目录下创建同名的文件夹</li><li>只需在 md 文件里使用 <code>![title](图片名.jpg)</code> ，无需路径名就可以插入图片。</li></ul><hr><h2 id="4-12-首页显示文章摘要（阅读全文）及配图（文章内不重复显示）"><a href="#4-12-首页显示文章摘要（阅读全文）及配图（文章内不重复显示）" class="headerlink" title="4.12 首页显示文章摘要（阅读全文）及配图（文章内不重复显示）"></a>4.12 首页显示文章摘要（阅读全文）及配图（文章内不重复显示）</h2><ol><li><p>打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure><p>下的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">_config.yml<br></code></pre></td></tr></table></figure><p>，查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">excerpt<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">auto_excerpt: &#x2F;&#x2F;自动摘录<br>  enable: true<br>  length: 150 &#x2F;&#x2F;摘录字数<br>read_more_btn: true &#x2F;&#x2F;显示全文按钮<br></code></pre></td></tr></table></figure></li><li><p>打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">themes\next\layout\_macro\post.swig<br></code></pre></td></tr></table></figure><p>，在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;% if is_index %&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;% if post.description and theme.excerpt_description %&#125;<br></code></pre></td></tr></table></figure><p>之间添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;% if post.images %&#125;<br>&lt;div class&#x3D;&quot;out-img-topic&quot;&gt;<br>&lt;img src&#x3D;&#123;&#123; post.images &#125;&#125; class&#x3D;&quot;img-topic&quot;&gt;<br>&lt;&#x2F;div&gt;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure></li><li><p>向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">themes\next\source\css\_custom\custom.styl<br></code></pre></td></tr></table></figure><p>中添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F;文章摘要配图<br>&#x2F;&#x2F;图片外部的容器方框，限制图片大小<br>.out-img-topic &#123;<br>  display: block;<br>  max-height:500px;<br>  margin-bottom: 24px;<br>  overflow: hidden;<br>&#125;<br>&#x2F;&#x2F;图片<br>img.img-topic &#123;<br>  display: block ;<br>  margin-left: .7em;<br>  margin-right: .7em;<br>  padding: 0;<br>  float: right;<br>  clear: right;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将摘要图片储存于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">themes\next\source\images<br></code></pre></td></tr></table></figure><p>中，建议</p><p>在此路径下</p><p>单独建一个文件夹存放摘要图片，</p><p>这个图片和文章中插图的存放路径不同，不是一个概念</p><p>。然后在文章YAML头信息中添加images字段，将值填为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;images&#x2F;imagename.jpg<br></code></pre></td></tr></table></figure><p>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">images: &quot;images&#x2F;文章摘要配图&#x2F;Win10桌面.png&quot;<br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="4-13-给页面、侧边栏添加背景图片"><a href="#4-13-给页面、侧边栏添加背景图片" class="headerlink" title="4.13 给页面、侧边栏添加背景图片"></a>4.13 给页面、侧边栏添加背景图片</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">body &#123;<br>  background: url(&#x2F;images&#x2F;blogbk.jpg) no-repeat;<br>  &#x2F;* 背景图垂直、水平均居中 *&#x2F;<br>  background-position: center center;<br>  &#x2F;* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 *&#x2F;<br>  background-attachment: fixed;<br>  &#x2F;* 让背景图基于容器大小伸缩 *&#x2F;<br>  background-size: cover;<br>  &#x2F;* 设置背景颜色，背景图加载过程中会显示背景色 *&#x2F;<br>  background-color: rgba(0, 0, 0, 0.5);<br>&#125;<br>.sidebar &#123;<br>            background:url(&#x2F;images&#x2F;sidebar.jpg);<br>            background-size: cover;<br>            background-position:center;<br>            background-repeat:no-repeat;<br>            p,span,a &#123;color: rgba(255, 255, 255, 1);&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-14-文字背景以及半透明的设置"><a href="#4-14-文字背景以及半透明的设置" class="headerlink" title="4.14 文字背景以及半透明的设置"></a>4.14 文字背景以及半透明的设置</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">.content &#123;<br>border-radius: 20px; &#x2F;&#x2F;文章背景设置圆角<br>padding: 30px 60px 30px 60px;<br>background:rgba(255, 255, 255, 0.8) none repeat scroll !important;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-15-去除NexT主题Markdown分割线渲染效果"><a href="#4-15-去除NexT主题Markdown分割线渲染效果" class="headerlink" title="4.15 去除NexT主题Markdown分割线渲染效果"></a>4.15 去除NexT主题Markdown分割线渲染效果</h2><p>修改<code>/source/css/_common/scaffolding/base.styl</code>，注释或删除以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">background-image: repeating-linear-gradient(<br>    -45deg,<br>    white,<br>    white 4px,<br>    transparent 4px,<br>    transparent 8px<br>  );<br>1234567<br></code></pre></td></tr></table></figure><hr><h2 id="4-16-图片可点击放大查看，放大后可关闭"><a href="#4-16-图片可点击放大查看，放大后可关闭" class="headerlink" title="4.16 图片可点击放大查看，放大后可关闭"></a>4.16 图片可点击放大查看，放大后可关闭</h2><ul><li>打开站点配置文件<code>_config.yml</code>，搜索<code>fancybox</code>字段，设置其值为<code>true</code></li><li>进入到<code>theme/text/</code>文件夹下，打开<code>git bash</code></li><li><code>git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox</code></li></ul><hr><h2 id="4-17-博客总访问量统计"><a href="#4-17-博客总访问量统计" class="headerlink" title="4.17 博客总访问量统计"></a>4.17 博客总访问量统计</h2><ul><li><p>打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure><p>下的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">_config.yml<br></code></pre></td></tr></table></figure><p>，查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">busuanzi<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">busuanzi_count:<br>  enable: true<br>  total_visitors: false<br>  total_visitors_icon: user<br>  total_views: false<br>  total_views_icon: eye<br>  post_views: true<br>  post_views_icon: eye<br></code></pre></td></tr></table></figure><p>当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动</p></li><li><p>打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig<br></code></pre></td></tr></table></figure><p>，在最后添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;<br>  本站访问次数：&lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;<br>&lt;&#x2F;span&gt;<br></code></pre></td></tr></table></figure><h2 id="4-18-文章末尾添加版权声明"><a href="#4-18-文章末尾添加版权声明" class="headerlink" title="4.18 文章末尾添加版权声明"></a>4.18 文章末尾添加版权声明</h2></li></ul><p><strong>效果：</strong><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdn.net/2018062323493260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTM0NTM4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>配置：</strong><br>查找主题配置文件<code>themes/next/_config.yml</code>中的<code>creative_commons</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">creative_commons:<br>  license: by-nc-sa<br>  sidebar: false<br>  post: true  # 将false改为true即可显示版权信息<br>  language:<br></code></pre></td></tr></table></figure><hr><h2 id="4-19-本地搜索（其余搜索方案的劣势只有收费）"><a href="#4-19-本地搜索（其余搜索方案的劣势只有收费）" class="headerlink" title="4.19 本地搜索（其余搜索方案的劣势只有收费）"></a>4.19 本地搜索（其余搜索方案的劣势只有收费）</h2><ul><li><p><code>npm install hexo-generator-search</code></p></li><li><p>查找主题配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">themes&#x2F;next&#x2F;_config.yml<br></code></pre></td></tr></table></figure><p>中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">local_search<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">local_search:<br>  enable: true<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="4-20-图床和上传工具"><a href="#4-20-图床和上传工具" class="headerlink" title="4.20 图床和上传工具"></a>4.20 图床和上传工具</h2><p><a href="https://zhuanlan.zhihu.com/p/35270383">盘点一下免费好用的图床</a></p><h2 id="4-21-文章置顶"><a href="#4-21-文章置顶" class="headerlink" title="4.21 文章置顶"></a>4.21 文章置顶</h2><p><a href="http://wangwlj.com/2018/01/09/blog_pin_post/">Hexo博客彻底解决置顶问题</a><br>效果：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190329140445995.png" alt="在这里插入图片描述"><br>注：若有多篇文章需要置顶，排序方式为 在需要置顶的文章的<code>Front-matter</code>的<code>top:</code>填写阿拉伯数字即可，数越大，排序越靠前。</p><h2 id="4-22-添加粒子时钟"><a href="#4-22-添加粒子时钟" class="headerlink" title="4.22 添加粒子时钟"></a>4.22 添加粒子时钟</h2><p>博客应用canvas粒子时钟的操作步骤：</p><p>在<code>\themes\next\layout\_custom\</code>目录下，新建<code>clock.swig</code>文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;div style&#x3D;&quot;&quot;&gt;<br>  &lt;canvas id&#x3D;&quot;canvas&quot; style&#x3D;&quot;width:60%;&quot;&gt;当前浏览器不支持canvas，请更换浏览器后再试&lt;&#x2F;canvas&gt;<br>&lt;&#x2F;div&gt;<br>&lt;script&gt;<br>(function()&#123;<br><br>   var digit&#x3D;<br>    [<br>        [<br>            [0,0,1,1,1,0,0],<br>            [0,1,1,0,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,0,1,1,0],<br>            [0,0,1,1,1,0,0]<br>        ],&#x2F;&#x2F;0<br>        [<br>            [0,0,0,1,1,0,0],<br>            [0,1,1,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [1,1,1,1,1,1,1]<br>        ],&#x2F;&#x2F;1<br>        [<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,1,1,0,0,0,0],<br>            [1,1,0,0,0,0,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,1,1,1,1,1]<br>        ],&#x2F;&#x2F;2<br>        [<br>            [1,1,1,1,1,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;3<br>        [<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,1,0],<br>            [0,0,1,1,1,1,0],<br>            [0,1,1,0,1,1,0],<br>            [1,1,0,0,1,1,0],<br>            [1,1,1,1,1,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,1,1]<br>        ],&#x2F;&#x2F;4<br>        [<br>            [1,1,1,1,1,1,1],<br>            [1,1,0,0,0,0,0],<br>            [1,1,0,0,0,0,0],<br>            [1,1,1,1,1,1,0],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;5<br>        [<br>            [0,0,0,0,1,1,0],<br>            [0,0,1,1,0,0,0],<br>            [0,1,1,0,0,0,0],<br>            [1,1,0,0,0,0,0],<br>            [1,1,0,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;6<br>        [<br>            [1,1,1,1,1,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,0,1,1,0,0,0]<br>        ],&#x2F;&#x2F;7<br>        [<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;8<br>        [<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,1,1,0,0,0,0]<br>        ],&#x2F;&#x2F;9<br>        [<br>            [0,0,0,0,0,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,0,0,0,0,0],<br>            [0,0,0,0,0,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,0,0,0,0,0]<br>        ]&#x2F;&#x2F;:<br>    ];<br><br>var canvas &#x3D; document.getElementById(&#39;canvas&#39;);<br><br>if(canvas.getContext)&#123;<br>    var cxt &#x3D; canvas.getContext(&#39;2d&#39;);<br>    &#x2F;&#x2F;声明canvas的宽高<br>    var H &#x3D; 100,W &#x3D; 700;<br>    canvas.height &#x3D; H;<br>    canvas.width &#x3D; W;<br>    cxt.fillStyle &#x3D; &#39;#f00&#39;;<br>    cxt.fillRect(10,10,50,50);<br><br>    &#x2F;&#x2F;存储时间数据<br>    var data &#x3D; [];<br>    &#x2F;&#x2F;存储运动的小球<br>    var balls &#x3D; [];<br>    &#x2F;&#x2F;设置粒子半径<br>    var R &#x3D; canvas.height&#x2F;20-1;<br>    (function()&#123;<br>        var temp &#x3D; &#x2F;(\d)(\d):(\d)(\d):(\d)(\d)&#x2F;.exec(new Date());<br>        &#x2F;&#x2F;存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成<br>        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);<br>    &#125;)();<br><br>    &#x2F;*生成点阵数字*&#x2F;<br>    function renderDigit(index,num)&#123;<br>        for(var i &#x3D; 0; i &lt; digit[num].length; i++)&#123;<br>            for(var j &#x3D; 0; j &lt; digit[num][i].length; j++)&#123;<br>                if(digit[num][i][j] &#x3D;&#x3D; 1)&#123;<br>                    cxt.beginPath();<br>                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);<br>                    cxt.closePath();<br>                    cxt.fill();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    &#x2F;*更新时钟*&#x2F;<br>    function updateDigitTime()&#123;<br>        var changeNumArray &#x3D; [];<br>        var temp &#x3D; &#x2F;(\d)(\d):(\d)(\d):(\d)(\d)&#x2F;.exec(new Date());<br>        var NewData &#x3D; [];<br>        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);<br>        for(var i &#x3D; data.length-1; i &gt;&#x3D;0 ; i--)&#123;<br>            &#x2F;&#x2F;时间发生变化<br>            if(NewData[i] !&#x3D;&#x3D; data[i])&#123;<br>                &#x2F;&#x2F;将变化的数字值和在data数组中的索引存储在changeNumArray数组中<br>                changeNumArray.push(i+&#39;_&#39;+(Number(data[i])+1)%10);<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;增加小球<br>        for(var i &#x3D; 0; i&lt; changeNumArray.length; i++)&#123;<br>            addBalls.apply(this,changeNumArray[i].split(&#39;_&#39;));<br>        &#125;<br>        data &#x3D; NewData.concat();<br>    &#125;<br><br>    &#x2F;*更新小球状态*&#x2F;<br>    function updateBalls()&#123;<br>        for(var i &#x3D; 0; i &lt; balls.length; i++)&#123;<br>            balls[i].stepY +&#x3D; balls[i].disY;<br>            balls[i].x +&#x3D; balls[i].stepX;<br>            balls[i].y +&#x3D; balls[i].stepY;<br>            if(balls[i].x &gt; W + R || balls[i].y &gt; H + R)&#123;<br>                balls.splice(i,1);<br>                i--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    &#x2F;*增加要运动的小球*&#x2F;<br>    function addBalls(index,num)&#123;<br>        var numArray &#x3D; [1,2,3];<br>        var colorArray &#x3D;  [&quot;#3BE&quot;,&quot;#09C&quot;,&quot;#A6C&quot;,&quot;#93C&quot;,&quot;#9C0&quot;,&quot;#690&quot;,&quot;#FB3&quot;,&quot;#F80&quot;,&quot;#F44&quot;,&quot;#C00&quot;];<br>        for(var i &#x3D; 0; i &lt; digit[num].length; i++)&#123;<br>            for(var j &#x3D; 0; j &lt; digit[num][i].length; j++)&#123;<br>                if(digit[num][i][j] &#x3D;&#x3D; 1)&#123;<br>                    var ball &#x3D; &#123;<br>                        x:14*(R+2)*index + j*2*(R+1)+(R+1),<br>                        y:i*2*(R+1)+(R+1),<br>                        stepX:Math.floor(Math.random() * 4 -2),<br>                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],<br>                        color:colorArray[Math.floor(Math.random()*colorArray.length)],<br>                        disY:1<br>                    &#125;;<br>                    balls.push(ball);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    &#x2F;*渲染*&#x2F;<br>    function render()&#123;<br>        &#x2F;&#x2F;重置画布宽度，达到清空画布的效果<br>        canvas.height &#x3D; 100;<br>        &#x2F;&#x2F;渲染时钟<br>        for(var i &#x3D; 0; i &lt; data.length; i++)&#123;<br>            renderDigit(i,data[i]);<br>        &#125;<br>        &#x2F;&#x2F;渲染小球<br>        for(var i &#x3D; 0; i &lt; balls.length; i++)&#123;<br>            cxt.beginPath();<br>            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);<br>            cxt.fillStyle &#x3D; balls[i].color;<br>            cxt.closePath();<br>            cxt.fill();<br>        &#125;<br>    &#125;<br><br>    clearInterval(oTimer);<br>    var oTimer &#x3D; setInterval(function()&#123;<br>        &#x2F;&#x2F;更新时钟<br>        updateDigitTime();<br>        &#x2F;&#x2F;更新小球状态<br>        updateBalls();<br>        &#x2F;&#x2F;渲染<br>        render();<br>    &#125;,50);<br>&#125;<br><br>&#125;)();<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><ul><li>引用代码</li></ul><p>直接引用或者通过配置文件配置，二选一</p><ul><li>直接引用</li></ul><p>在<code>博客目录\themes\next\layout\_macro\sidebar.swig</code>尾部中引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;% include &#39;..&#x2F;_custom&#x2F;clock.swig&#39; %&#125;<br></code></pre></td></tr></table></figure><p>示意图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9jay5wbmc?x-oss-process=image/format,png" alt="img"></p><blockquote><p>注：代码块要放置在<code>sider-inner</code>的<code>div</code>块中，放在<code>div</code>块的位置决定时钟样式的展示位置。我选择放置在尾部，看着效果好点。</p></blockquote><ul><li>通过配置文件配置</li></ul><p>1、在<code>博客目录\themes\next\layout\_macro\sidebar.swig</code>尾部中引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;% if theme.diy_time.clock %&#125;<br>  &lt;!-- canvas粒子时钟 --&gt;<br>  &#123;% include &#39;..&#x2F;_custom&#x2F;clock.swig&#39; %&#125;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p>示意图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9ja19pZi5wbmc?x-oss-process=image/format,png" alt="img"></p><blockquote><p>注：代码块要放置在<code>sider-inner</code>的<code>div</code>块中，放在<code>div</code>块的位置决定时钟样式的展示位置。</p></blockquote><p>2、在主题的配置文件中加入应用代码，配置文件位置是<code>博客目录\themes\next\_config.yml</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain"># 侧栏粒子时钟<br>diy_time:<br>  runtime: true <br>  clock: true # 粒子时钟<br></code></pre></td></tr></table></figure><h2 id="4-23-添加近期文章"><a href="#4-23-添加近期文章" class="headerlink" title="4.23 添加近期文章"></a>4.23 添加近期文章</h2><p>添加配置参数 <strong>~/theme/next/_config.yml</strong> ，添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">recent_posts:<br>  enable: true<br>  recent_posts_title: 最新发表文章<br></code></pre></td></tr></table></figure><p>首先我们找到侧边栏模块 <strong>next/layout/_macro/sidebar.swig</strong> ,这个负责渲染侧边栏<br>在我们想要放置<strong>最新文章模块</strong>的地方添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#123;% if theme.recent_posts.enable %&#125;<br>  &lt;aside class&#x3D;&quot;sidebar sidebar-ads sidebar-posts&quot;&gt;<br>    &lt;div&gt;<br>      &lt;div class&#x3D;&quot;recent_posts_title&quot;&gt;<br>        &#123;&#123; theme.recent_posts.recent_posts_title &#125;&#125;<br>      &lt;&#x2F;div&gt;<br>      &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;<br>        &#123;% set posts &#x3D; site.posts.sort(&#39;-date&#39;) %&#125;<br>        &#123;% set bg_colors &#x3D; [&#39;rgb(31, 216, 210)&#39;, &#39;rgb(4, 166, 247)&#39;, &#39;rgb(70, 101, 226)&#39;, &#39;rgb(94, 137, 229)&#39;, &#39;rgb(0, 206, 123)&#39;] %&#125;<br>        &#123;% for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;<br>          &lt;li&gt;<br>            &lt;div class&#x3D;&quot;text-img&quot; style&#x3D;&quot;background:&#123;&#123;bg_colors[loop.index - 1]&#125;&#125;;&quot;&gt;&#123;&#123; post.title.substr(0, 3) &#125;&#125;&lt;&#x2F;div&gt;<br>            &lt;div class&#x3D;&quot;post-name&quot;&gt;<br>              &lt;div&gt;&#123;&#123; date(post.date, config.date_format) &#125;&#125;&lt;&#x2F;div&gt;<br>              &lt;div&gt;&lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; &gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;<br>            &lt;&#x2F;div&gt;<br>          &lt;&#x2F;li&gt;<br>        &#123;% endfor %&#125;<br>      &lt;&#x2F;ul&gt;<br>    &lt;&#x2F;div&gt;<br>  &lt;&#x2F;aside&gt;<br>  &#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p>最后重新执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">hexo clean<br>hexo g<br></code></pre></td></tr></table></figure><p>最后我们得到的效果是</p><h2 id="Google统计"><a href="#Google统计" class="headerlink" title="Google统计"></a>Google统计</h2><h2 id="Sitemap网站地图"><a href="#Sitemap网站地图" class="headerlink" title="Sitemap网站地图"></a>Sitemap网站地图</h2><h2 id="提交谷歌收录本站-Google-Search"><a href="#提交谷歌收录本站-Google-Search" class="headerlink" title="提交谷歌收录本站 Google Search"></a>提交谷歌收录本站 Google Search</h2><h2 id="文章阅读量统计"><a href="#文章阅读量统计" class="headerlink" title="文章阅读量统计"></a><a href="https://blog.csdn.net/weixin_39345384/article/details/80787998">文章阅读量统计</a></h2><hr><hr><p>参考：</p><ul><li><a href="http://mashirosorata.vicp.io/HEXO-NEXT主题个性化配置.html">HEXO+NEXT主题个性化配置</a></li><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li><li><a href="https://juejin.im/post/5c45a503f265da616b10fe4e#heading-28">[EasyHexo 专栏] #2 - 魔改 Next 不完全教程</a></li><li><a href="https://blog.csdn.net/MasterAnt_D/article/details/56839222#t50">基于Hexo+Node.js+github+coding搭建个人博客——进阶篇(从入门到入土)</a></li><li><a href="http://www.shaoyance.com/2018/01/26/Hexo博客Next主题优化总结/">Hexo博客Next主题优化总结</a></li><li><a href="https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html">为NexT主题添加文章阅读量统计功能</a></li><li><a href="http://www.cduyzh.com/hexo-settings-3/">2017年最新基于hexo搭建个人免费博客——自定义页面样式一</a></li><li><a href="https://notes.doublemine.me/2015-06-29-Hexo添加文章时自动打开编辑器.html">Hexo添加文章时自动打开编辑器</a></li><li><a href="https://blog.yleao.com/2018/0901/hexo-next主题下的美化.html#next主题下点击侧边栏头像回到博客首页">next主题下点击侧边栏头像回到博客首页</a></li><li><a href="https://reuixiy.github.io/beautiful/share/2018/12/11/noto-serif-sc-added-on-google-fonts.html">Google Fonts 已支持思源宋体！</a></li><li><a href="https://www.bluelzy.com/articles/change_to_next_theme.html">弃暗投明-Hexo更换next主题</a></li><li><a href="https://www.feiwuuz.com.cn/archives/5483aa06.html">hexo博客NEXT主题美化</a></li><li><a href="http://chant00.com/2015/11/04/在hexo博客中插入图片，音乐，视屏，公式/">在hexo博客中插入图片，音乐，视频</a></li></ul>]]></content>
    
    
    <summary type="html">在这篇文章中，你将学习到如何搭建Hexo博客以及如何使用NexT主题美化博客</summary>
    
    
    
    <category term="博客" scheme="https://www.tanxz.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="Hexo" scheme="https://www.tanxz.com/tags/Hexo/"/>
    
    <category term="NexT" scheme="https://www.tanxz.com/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Github访问加速设置</title>
    <link href="https://www.tanxz.com/posts/41928511/index.html"/>
    <id>https://www.tanxz.com/posts/41928511/index.html</id>
    <published>2020-12-10T14:33:34.000Z</published>
    <updated>2020-12-18T15:17:51.426Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><p>众所周知，由于github服务站点在美国，国内访问速度时好时坏，而通过DNS域名解析后速度更慢，所以我们可以直接通过设置hosts的域名对应的实际ip直接访问ip绕过域名解析，速度可以快到飞起，OK，进入正题。</p><h4 id="域名DNS解析IP"><a href="#域名DNS解析IP" class="headerlink" title="域名DNS解析IP"></a>域名DNS解析IP</h4><h5 id="DNS解析域名对应ip"><a href="#DNS解析域名对应ip" class="headerlink" title="DNS解析域名对应ip"></a>DNS解析域名对应ip</h5><ul><li>访问<a href="https://www.ping.cn/dns/">https://www.ping.cn/dns/</a></li></ul><p><img src= "/img/loading.gif" data-lazy-src="../../img/image-20201216105335033.png" alt="image-20201216105335033"></p><ul><li><p>找到当前网络运营商、解析时间最小的对应IP</p><p><img src= "/img/loading.gif" data-lazy-src="../../img/image-20201216105708714.png" alt="image-20201216105708714"></p></li></ul><h5 id="Mac系统下命令查询域名对应ip"><a href="#Mac系统下命令查询域名对应ip" class="headerlink" title="Mac系统下命令查询域名对应ip"></a>Mac系统下命令查询域名对应ip</h5><p><em>这种方式查询出来的ip，无法保证ip的访问速度，推荐使用第一种方式。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">MacBook-Pro-6:~ tanxinzheng$ nslookup www.github.com<br>Server:114.114.114.114<br>Address:114.114.114.114#53<br><br>Non-authoritative answer:<br>www.github.comcanonical name &#x3D; github.com.<br>Name:github.com<br>Address: 13.250.177.223<br></code></pre></td></tr></table></figure><h4 id="修改hosts映射Github域名"><a href="#修改hosts映射Github域名" class="headerlink" title="修改hosts映射Github域名"></a>修改hosts映射Github域名</h4><p>管理员模式下编辑hosts</p><ul><li><p>Mac系统在 /etc/hosts</p></li><li><p>Windows系统在 C:/windows/System/etc/hosts</p></li></ul><p>将映射代码添加在hosts文件尾部（该ip为上海地区的最小解析时间，请大家实际情况修改）</p><p><em>注：若需要加快github访问不只是单纯的需要映射github.com域名</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain"># github ip<br>13.229.188.59 github.com<br>52.128.23.153githubusercontent.com<br></code></pre></td></tr></table></figure><h4 id="刷新本地DNS解析缓存"><a href="#刷新本地DNS解析缓存" class="headerlink" title="刷新本地DNS解析缓存"></a>刷新本地DNS解析缓存</h4><ul><li><p>Windows</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">ipconfig</span> /flushdns<br></code></pre></td></tr></table></figure></li><li><p>Mac</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo killall -HUP mDNSResponder<br></code></pre></td></tr></table></figure></li><li><p>Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /etc/init.d/networking restart<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;原理概述&quot;&gt;&lt;a href=&quot;#原理概述&quot; class=&quot;headerlink&quot; title=&quot;原理概述&quot;&gt;&lt;/a&gt;原理概述&lt;/h3&gt;&lt;p&gt;众所周知，由于github服务站点在美国，国内访问速度时好时坏，而通过DNS域名解析后速度更慢，所以我们可以直接通过设置ho</summary>
      
    
    
    
    <category term="技术" scheme="https://www.tanxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="git" scheme="https://www.tanxz.com/tags/git/"/>
    
    <category term="github" scheme="https://www.tanxz.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Windows下git配置ssh密钥</title>
    <link href="https://www.tanxz.com/posts/41928510/index.html"/>
    <id>https://www.tanxz.com/posts/41928510/index.html</id>
    <published>2020-12-10T14:33:34.000Z</published>
    <updated>2020-12-18T15:04:43.616Z</updated>
    
    <content type="html"><![CDATA[<h4 id="检查用户-SSH目录"><a href="#检查用户-SSH目录" class="headerlink" title="检查用户.SSH目录"></a>检查用户.SSH目录</h4><p>若存在则直接使用已生成的ssh公私密钥，跳过生成SSH公私密钥步骤</p><p><strong>若需要免密提交则要保证生成的ssh公私密钥是未输入密码的</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">PS C:\Users\tanxz\.ssh&gt; ls<br><br>    目录: C:\Users\tanxz\.ssh<br><br><br>Mode                 LastWriteTime         Length Name<br>----                 -------------         ------ ----<br>-a----        2020&#x2F;12&#x2F;16      0:31           1679 id_rsa<br>-a----        2020&#x2F;12&#x2F;16      0:31            402 id_rsa.pub<br>-a----        2020&#x2F;12&#x2F;16      0:34            185 known_hosts<br></code></pre></td></tr></table></figure><h4 id="生成SSH公私密钥"><a href="#生成SSH公私密钥" class="headerlink" title="生成SSH公私密钥"></a>生成SSH公私密钥</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++">C:\Users\tanxz&gt; ssh-keygen -t rsa -C <span class="hljs-string">&quot;tanxinzheng@139.com&quot;</span><br>Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key <span class="hljs-built_in">pair</span>.<br><span class="hljs-function">Enter file in which to save the <span class="hljs-title">key</span> <span class="hljs-params">(C:\Users\tanxz/.ssh/id_rsa)</span>:</span><br><span class="hljs-function">Enter <span class="hljs-title">passphrase</span> <span class="hljs-params">(empty <span class="hljs-keyword">for</span> no passphrase)</span>:</span><br><span class="hljs-function">Enter same passphrase again:</span><br>Your identification has been saved in C:\Users\tanxz/.ssh/id_rsa.<br>Your <span class="hljs-keyword">public</span> key has been saved in C:\Users\tanxz/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>SHA256:<span class="hljs-number">9B</span>M2DGD4+BKfyMjWhrP0b4xdHlk4I9JG/dJB0BwR0Nc tanxinzheng@<span class="hljs-number">139.</span>com<br>The key<span class="hljs-number">&#x27;</span>s randomart image is:<br>+---[RSA <span class="hljs-number">2048</span>]----+<br>|     .oo+B=+ .   |<br>|    ... .o= . E  |<br>|     =  .+=o     |<br>|    + =.=o+o     |<br>| . = B oS*o      |<br>|  B * + +  .     |<br>| o = = o .       |<br>|  . o + .        |<br>|     o.          |<br>+----[SHA256]-----+<br></code></pre></td></tr></table></figure><h4 id="添加SSH公钥到github和gitee"><a href="#添加SSH公钥到github和gitee" class="headerlink" title="添加SSH公钥到github和gitee"></a>添加SSH公钥到github和gitee</h4><p>打开.ssh目录下的id_rsa.pub文件，复制里面的内容，到github和gitee设置中找到的SSH key的信息，添加即可。</p><h4 id="测试是否ssh密钥是否有效"><a href="#测试是否ssh密钥是否有效" class="headerlink" title="测试是否ssh密钥是否有效"></a>测试是否ssh密钥是否有效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">C:\Users\tanxz\.ssh&gt; ssh -T git@github.com<br>Hi tanxinzheng! You&#39;ve successfully authenticated, but GitHub does not provide shell access.<br>PS C:\Users\tanxz\.ssh&gt; ssh -T git@gitee.com<br>Hi tanxinzheng! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.<br></code></pre></td></tr></table></figure><p>若显示以上信息，恭喜你以后终于不用输入密码了！！：）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;检查用户-SSH目录&quot;&gt;&lt;a href=&quot;#检查用户-SSH目录&quot; class=&quot;headerlink&quot; title=&quot;检查用户.SSH目录&quot;&gt;&lt;/a&gt;检查用户.SSH目录&lt;/h4&gt;&lt;p&gt;若存在则直接使用已生成的ssh公私密钥，跳过生成SSH公私密钥步骤&lt;/p&gt;
</summary>
      
    
    
    
    <category term="技术" scheme="https://www.tanxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="git" scheme="https://www.tanxz.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>如何申请SSL免费证书</title>
    <link href="https://www.tanxz.com/posts/1125805289/index.html"/>
    <id>https://www.tanxz.com/posts/1125805289/index.html</id>
    <published>2020-12-10T13:38:18.000Z</published>
    <updated>2020-12-18T15:04:43.635Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>搭建https协议网上有许多教程，但各种因为网站的搭建情况都有很多特殊情况导致有些场景出现&gt;  问题，这里分别整理了不同业务场景对应的搭建教程。</p></blockquote><a id="more"></a><h4 id="Certbot申请证书"><a href="#Certbot申请证书" class="headerlink" title="Certbot申请证书"></a>Certbot申请证书</h4><blockquote><p>适用场景：拥有服务器权限，可命令行操作服务器</p></blockquote><p>请直接参考该文章：<a href="https://blog.51cto.com/wzlinux/2385116">Nginx 通过 certbot 为网站自动配置 SSL 证书并续期</a></p><h4 id="Freessl申请证书"><a href="#Freessl申请证书" class="headerlink" title="Freessl申请证书"></a>Freessl申请证书</h4><blockquote><p>适用场景：服务器在第三方平台，没有操作服务器的权限只有配置证书的权限</p></blockquote><p>之前在使用OSS搭建Hexo博客时由于OSS存储服务器是由阿里云控制的，无法使用certbot的方式安装证书，又不想用阿里云的证书，查找实践许久终于找到了一种靠谱的解决方案，就是使用<a href="https://freessl.cn/平台的Keymanager工具，方便快捷有效。">https://freessl.cn/平台的Keymanager工具，方便快捷有效。</a></p><ul><li><p>首先，注册<a href="https://freessl.cn/的账号（注册就不截图了）">https://freessl.cn/的账号（注册就不截图了）</a></p></li><li><p>下载KeyManger工具，下载地址：<a href="https://keymanager.trustasia.com/release/KeyManager-Setup-4.4.19.exe">https://keymanager.trustasia.com/release/KeyManager-Setup-4.4.19.exe</a></p></li><li><p>安装好之后，登录注册FreeSSL后进入KeyManager，如下图</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="../../img/image-20201217233631334.png" alt="image-20201217233631334"></p><ul><li>申请证书，填写证书信息，如图</li></ul><p><img src= "/img/loading.gif" data-lazy-src="../../img/image-20201217233848143.png" alt="image-20201217233848143"></p><ul><li>获取DNS验证信息</li></ul><p><img src= "/img/loading.gif" data-lazy-src="../../img/image-20201217234030155.png" alt="image-20201217234030155"></p><ul><li>将验证信息填入阿里云解析记录，如下图，完成后点击上一步的【我已配置完成】。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="../../img/image-20201217232930044.png" alt="image-20201217232930044"></p><ul><li>进入证书管理可看到生成的证书，点击证书详情</li></ul><p><img src= "/img/loading.gif" data-lazy-src="../../img/image-20201217233140546.png" alt="image-20201217233140546"></p><ul><li>获取证书PEM信息，如下图，到这一步就OK了，拿到这个证书，怎么配置就看你怎么用，是直接上传到服务器还是使用OSS证书托管都可以。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="../../img/image-20201217233418235.png" alt="image-20201217233418235"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;搭建https协议网上有许多教程，但各种因为网站的搭建情况都有很多特殊情况导致有些场景出现&amp;gt;  问题，这里分别整理了不同业务场景对应的搭建教程。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="技术" scheme="https://www.tanxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="https" scheme="https://www.tanxz.com/tags/https/"/>
    
    <category term="ssl" scheme="https://www.tanxz.com/tags/ssl/"/>
    
  </entry>
  
  <entry>
    <title>Docker之Redis Cluster搭建</title>
    <link href="https://www.tanxz.com/posts/41928529/index.html"/>
    <id>https://www.tanxz.com/posts/41928529/index.html</id>
    <published>2020-12-10T08:33:34.000Z</published>
    <updated>2020-12-18T15:04:43.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Docker 版本 19.03.8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">MacBook-Pro-6:~ tanxinzheng$ docker -v<br>Docker version 19.03.8, build afacb8b<br></code></pre></td></tr></table></figure><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>搭建的部署主要分为</p><ul><li>架构设计</li><li>编写Docker Compose编排文件</li><li>创建redis cluster配置文件</li><li>启动服务容器</li><li>创建Redis集群</li></ul><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>redis集群模式必须要有3个主节点3个从节点才能正常启动集群模式</p><ul><li>主节点端口：7000 | 7001 | 7002</li><li>从节点端口：7003 | 7004 | 7005</li></ul><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>为节省内存资源，主从节点都部署在单机实例中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs plain">version: &#39;2&#39;<br><br>services:<br>  cluster:<br>    image: daocloud.io&#x2F;redis<br>    container_name: redis-cluster<br>    # 添加该参数后服务后台运行后，容器不会自动退出<br>    tty: true<br>    restart: always<br>    # linux环境下建议使用host模式<br>    network_mode: host<br><br>    volumes:<br>      - .&#x2F;data:&#x2F;data<br>      - .&#x2F;config:&#x2F;etc&#x2F;redis  <br>    ports:<br>      - &quot;7000:7000&quot;<br>      - &quot;7001:7001&quot;<br>      - &quot;7002:7002&quot;<br>      - &quot;7003:7003&quot;<br>      - &quot;7004:7004&quot;<br>      - &quot;7005:7005&quot;<br>    ## 必须使用宿主机ip 作为集群总线ip，否则宿主机无法访问到容器内的redis集群ip <br>    # 也可以加在配置文件中<br>    #  --cluster-announce-ip 172.16.65.218 <br>    command: <br>      - &#x2F;bin&#x2F;bash <br>      - -c <br>      - |<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7000.conf  --cluster-announce-ip 172.16.65.218 &amp; <br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7001.conf  --cluster-announce-ip 172.16.65.218 &amp;<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7002.conf  --cluster-announce-ip 172.16.65.218 &amp;<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7003.conf  --cluster-announce-ip 172.16.65.218 &amp; <br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7004.conf  --cluster-announce-ip 172.16.65.218 &amp;<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7005.conf  --cluster-announce-ip 172.16.65.218 <br></code></pre></td></tr></table></figure><h3 id="redis-700X-conf"><a href="#redis-700X-conf" class="headerlink" title="redis_700X.conf"></a>redis_700X.conf</h3><p>根据各端口修改配置中的端口号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plain">port 7000<br># 绑定机器的内网IP或者公网IP,一定要设置，不要用 127.0.0.1<br>bind 0.0.0.0<br># 启用集群模式<br>cluster-enabled yes<br># 集群节点文件<br>cluster-config-file nodes_7000.conf<br># 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录<br>dir &#x2F;data&#x2F;7000&#x2F;<br># 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间<br>cluster-node-timeout 5000<br># 集群广播ip<br>#cluster-announce-ip 172.20.0.4<br>#cluster-announce-port 7000<br># 开启AOF模式<br>appendonly yes<br># 关闭保护模式<br>protected-mode no<br># 是否后台启动<br>daemonize no<br># pid file所在目录<br>pidfile &#x2F;var&#x2F;run&#x2F;redis_7000.pid <br># 客户端访问密码<br># requirepass redis2020<br># 日志文件<br>logfile &#x2F;var&#x2F;log&#x2F;redis_7001.log<br></code></pre></td></tr></table></figure><h2 id="启动Redis-Cluster"><a href="#启动Redis-Cluster" class="headerlink" title="启动Redis Cluster"></a>启动Redis Cluster</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">docker-compose up -d<br></code></pre></td></tr></table></figure><h3 id="创建Redis集群"><a href="#创建Redis集群" class="headerlink" title="创建Redis集群"></a>创建Redis集群</h3><ul><li>进入容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ docker exec -it redis-cluster &#x2F;bin&#x2F;bash<br></code></pre></td></tr></table></figure></li><li>创建集群<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ redis-cli --cluster create 127.0.0.1:7000 \<br>                           127.0.0.1:7001 \<br>                           127.0.0.1:7002 \<br>                           127.0.0.1:7003 \<br>                           127.0.0.1:7004 \<br>                           127.0.0.1:7005 \<br>                           --cluster-replicas 1<br></code></pre></td></tr></table></figure><h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs plain">## -c表示集群模式进入<br>root@docker-desktop:&#x2F;data# redis-cli -c -h localhost -p 7000<br><br>## 查看集群信息 cluster_state为ok则表示集群创建成功<br>localhost:7000&gt; cluster info<br>cluster_state:ok<br>cluster_slots_assigned:16384<br>cluster_slots_ok:16384<br>cluster_slots_pfail:0<br>cluster_slots_fail:0<br>cluster_known_nodes:6<br>cluster_size:1<br>cluster_current_epoch:6<br>cluster_my_epoch:3<br>cluster_stats_messages_ping_sent:5290<br>cluster_stats_messages_pong_sent:5299<br>cluster_stats_messages_update_sent:1<br>cluster_stats_messages_sent:10590<br>cluster_stats_messages_ping_received:5294<br>cluster_stats_messages_pong_received:5290<br>cluster_stats_messages_meet_received:5<br>cluster_stats_messages_update_received:3<br>cluster_stats_messages_received:10592<br><br>## 查看集群节点信息<br>localhost:7000&gt; cluster nodes<br>6b7f8c4767feb376a99e79068748253afcf6ea5a 127.0.0.1:7001@17001 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594235646 3 connected<br>52b109a6491a2e4280b6a66642716939d0f46e89 127.0.0.1:7004@17004 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594236555 5 connected<br>df7dcbf82ecba0ff044f2715b052674e73ec1ca6 127.0.0.1:7000@17000 myself,slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594234000 1 connected<br>51f5c9fb771a702933d8bc29fcd13eb41811e2bb 127.0.0.1:7005@17005 master - 0 1607594236000 6 connected<br>ef7fdf2421427d1da29da4c1dab9e8c26ca12854 127.0.0.1:7002@17002 master - 0 1607594236657 3 connected 0-16383<br>cf7327c9ec3b374ebc6ba3f49c6bd5e0a7098601 127.0.0.1:7003@17003 master - 0 1607594235544 4 connected<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>[1] <a href="https://redis.io/topics/cluster-tutorial">Redis Cluster</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;Docker 版本 19.03.8&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    
    <category term="redis" scheme="https://www.tanxz.com/tags/redis/"/>
    
    <category term="cluster" scheme="https://www.tanxz.com/tags/cluster/"/>
    
    <category term="docker" scheme="https://www.tanxz.com/tags/docker/"/>
    
    <category term="docker-compose" scheme="https://www.tanxz.com/tags/docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建博客：基于Github Action工作流自动部署Hexo</title>
    <link href="https://www.tanxz.com/posts/2231850037/index.html"/>
    <id>https://www.tanxz.com/posts/2231850037/index.html</id>
    <published>2020-04-16T03:54:14.000Z</published>
    <updated>2020-12-19T11:51:21.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo搭建"><a href="#Hexo搭建" class="headerlink" title="Hexo搭建"></a>Hexo搭建</h1><p>这段就pass了，只要这篇主要讲解Github Action部署</p><h1 id="创建github-ssh-私钥和公钥"><a href="#创建github-ssh-私钥和公钥" class="headerlink" title="创建github ssh 私钥和公钥"></a>创建github ssh 私钥和公钥</h1><p>在本地运行如下命令生成id_rsa和id_rsa.pub文件，一路回车，不要输入密码！！！不要输入密码！！！不要输入密码！！！（被这个坑的我想哭T_T，一直验证不通过）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">$ ssh-keygen -t rsa -C &quot;tanxinzheng@<span class="hljs-number">139</span>.com&quot; #此处修改为你github的注册邮箱<br></code></pre></td></tr></table></figure><h1 id="Github设置"><a href="#Github设置" class="headerlink" title="Github设置"></a>Github设置</h1><ul><li>将id_rsa私钥放入项目的settings/secures配置中</li><li>将id_rsa.pub公钥填入账号的settings/SSH keys配置中</li></ul><h1 id="创建Github-Action工作流脚本"><a href="#创建Github-Action工作流脚本" class="headerlink" title="创建Github Action工作流脚本"></a>创建Github Action工作流脚本</h1><p>在项目该目录下创建~./.github/workflows/main.yml文件，将下面的配置信息填入，并修改自己的信息即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">CI</span><br><span class="hljs-comment"># 触发执行的操作和分支名称</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">generate-source</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">source</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># 分支号</span><br>          <span class="hljs-attr">ref:</span> <span class="hljs-string">generate-source</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">hexo</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">ACTION_DEPLOY_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.HEXO_DEPLOY_PRI</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>          <span class="hljs-string">mkdir</span> <span class="hljs-string">-p</span> <span class="hljs-string">~/.ssh/</span><br>          <span class="hljs-string">echo</span> <span class="hljs-string">&quot;$ACTION_DEPLOY_KEY&quot;</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>          <span class="hljs-string">chmod</span> <span class="hljs-number">600</span> <span class="hljs-string">~/.ssh/id_rsa</span><br>          <span class="hljs-string">ssh-keyscan</span> <span class="hljs-string">github.com</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">~/.ssh/known_hosts</span><br>          <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.email</span> <span class="hljs-string">&quot;tanxinzheng@139.com&quot;</span><br>          <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;tanxinzheng&quot;</span><br>          <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">hexo-cli</span> <span class="hljs-string">-g</span><br>          <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">deploy</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>          <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><br>          <span class="hljs-string">hexo</span> <span class="hljs-string">d</span><br></code></pre></td></tr></table></figure><h1 id="Github-Action执行部署"><a href="#Github-Action执行部署" class="headerlink" title="Github Action执行部署"></a>Github Action执行部署</h1><p>在Github Action页面执行即可，push之后会自动部署。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo搭建&quot;&gt;&lt;a href=&quot;#Hexo搭建&quot; class=&quot;headerlink&quot; title=&quot;Hexo搭建&quot;&gt;&lt;/a&gt;Hexo搭建&lt;/h1&gt;&lt;p&gt;这段就pass了，只要这篇主要讲解Github Action部署&lt;/p&gt;
&lt;h1 id=&quot;创建github-</summary>
      
    
    
    
    <category term="技术研究" scheme="https://www.tanxz.com/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
    <category term="Hexo" scheme="https://www.tanxz.com/tags/Hexo/"/>
    
    <category term="Github" scheme="https://www.tanxz.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Java【基础篇之HashMap及hashcode】</title>
    <link href="https://www.tanxz.com/posts/2936205123/index.html"/>
    <id>https://www.tanxz.com/posts/2936205123/index.html</id>
    <published>2019-10-10T02:12:00.000Z</published>
    <updated>2020-12-18T15:04:43.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、hashcode是什么"><a href="#一、hashcode是什么" class="headerlink" title="一、hashcode是什么"></a>一、hashcode是什么</h2><p>要理解hashcode首先要理解hash表这个概念</p><ol><li><p>哈希表<br>hash表也称散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的hashcode是什么记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。<br>简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。<br>具有快速查找和插入操作的优点</p></li><li><p>hashcode<br>hashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置<br>每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode</p><h2 id="二、hashcode的作用"><a href="#二、hashcode的作用" class="headerlink" title="二、hashcode的作用"></a>二、hashcode的作用</h2><p> HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p><p> 对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p><p>在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题</p><p>如何判别在集合中是否已经存在该对象了？</p><p>首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。    此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了。</p><p> 这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。</p><pre><code>所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</code></pre></li></ol><h2 id="三、-hashCode-和equals"><a href="#三、-hashCode-和equals" class="headerlink" title="三、 hashCode()和equals()"></a>三、 hashCode()和equals()</h2><p>Java的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)</p><ol><li>equals方法<br>Object类中equals()方法实现如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。</p><p>虽然可以重写equals()方法，但是有一些注意事项；JDK中说明了实现equals()方法应该遵守的约定</p><p>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。<br>2. hashCode 方法<br>Object类中hashCode()方法的声明如下：</p><p>public native int hashCode();<br>可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。</p><p>与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：</p><p>（1）hashCode()在哈希表中起作用，如java.util.HashMap。<br>（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。<br>（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。<br>（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。<br>重写hashcode()的原则</p><p>（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。<br>（2）hashCode()方法不能太过简单，否则哈希冲突过多。<br>（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能<br>hashCode()重写方法</p><p>《Effective Java》中提出了一种简单通用的hashCode算法：</p><p>初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;</p><p>选取equals方法中用于比较的所有域（之所以只选择equals()中使用的域，是为了保证上述原则的第1条），然后针对每个域的属性进行计算：</p><p>复制代码<br>(1) 如果是boolean值，则计算f ? 1:0<br>(2) 如果是bytecharshortint,则计算(int)f<br>(3) 如果是long值，则计算(int)(f ^ (f &gt;&gt;&gt; 32))<br>(4) 如果是float值，则计算Float.floatToIntBits(f)<br>(5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int<br>(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0<br>(7) 如果是数组，那么需要为每个元素当做单独的域来处理。java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上。<br>复制代码<br>最后，把每个域的散列码合并到对象的哈希码中。</p><h2 id="四、HashMap中的hash-函数"><a href="#四、HashMap中的hash-函数" class="headerlink" title="四、HashMap中的hash()函数"></a>四、HashMap中的hash()函数</h2><p>HashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">static final int hash(Object key) &#123;<br>    int h;<br>    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码类似作用是为了增加hashcode的随机性</p><p>key.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p><p>hashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个”与”操作</p><p>static int indexFor(int h, int length) { return h &amp; (length-1);}<br>这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h &amp; (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。<br>  01111010 00111100 00100101<br>&amp; 00000000 00000000 00001111</p><hr><p>  00000000 00000000 00000101<br>  //高位全部归零，只保留末四位<br>but 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上成个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。</p><p>这时候 “hash”函数作用就出来了</p><p>右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。<br>设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。<br>根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。<br>hashMap中 MAXIMUM_CAPACITY = 1 &lt;&lt; 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、hashcode是什么&quot;&gt;&lt;a href=&quot;#一、hashcode是什么&quot; class=&quot;headerlink&quot; title=&quot;一、hashcode是什么&quot;&gt;&lt;/a&gt;一、hashcode是什么&lt;/h2&gt;&lt;p&gt;要理解hashcode首先要理解hash表这个概念&lt;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://www.tanxz.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Mac使用openssl生成pem证书</title>
    <link href="https://www.tanxz.com/posts/250724270/index.html"/>
    <id>https://www.tanxz.com/posts/250724270/index.html</id>
    <published>2018-12-06T16:00:00.000Z</published>
    <updated>2020-12-18T15:04:43.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="https://www.jianshu.com/p/e311a6537467">openssl命令详解</a></p></blockquote><hr><h1 id="常规方式"><a href="#常规方式" class="headerlink" title="常规方式"></a>常规方式</h1><ul><li>生成私钥(key文件)<br><code>openssl genrsa -out client.key 4096</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200804191059375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200804191113618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gikNX2aZ-1596539441689)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p74)]"></li><li>生成签名请求(csr文件)<br><code>openssl req -new -key client.key -out client.csr</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200804191128743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lPkpDIT9-1596539441690)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p75)]"></li><li>签发证书<br><code>openssl x509 -req -days 365 -in client.csr -signkey client.key -out client.crt</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200804191353313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><hr><h1 id="一键生成自签名证书"><a href="#一键生成自签名证书" class="headerlink" title="一键生成自签名证书"></a>一键生成自签名证书</h1><p><code>openssl req -new -x509 -newkey rsa:4096 -keyout test.key -out test.crt</code><br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200804191401941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jt7UJ692-1596539441692)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p76)]"></p><blockquote><p>tips<br>输入的密码必须大于等于4位。<br>Common Name可以输入：*.yourdomain.com，这种方式生成通配符域名证书。<br>证书文件crt中存储的是证书信息与公钥信息，key文件存储的是私钥信息，csr是申请证书所需要的中间文件。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/e311a6537467&quot;&gt;</summary>
      
    
    
    
    <category term="技术" scheme="https://www.tanxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Mac" scheme="https://www.tanxz.com/tags/Mac/"/>
    
    <category term="RAS" scheme="https://www.tanxz.com/tags/RAS/"/>
    
  </entry>
  
  <entry>
    <title>Mac使用openssl生成pem证书</title>
    <link href="https://www.tanxz.com/posts/250724269/index.html"/>
    <id>https://www.tanxz.com/posts/250724269/index.html</id>
    <published>2018-12-06T16:00:00.000Z</published>
    <updated>2020-12-18T15:04:43.623Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>openssl，若已安装则跳过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">brew install openssl<br></code></pre></td></tr></table></figure><h4 id="生成RSA私钥"><a href="#生成RSA私钥" class="headerlink" title="生成RSA私钥"></a>生成RSA私钥</h4><p>使用openssl来生成RSA私钥文件，输入如下命令(该命令会生成2048位的私钥)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">openssl genrsa -out rsa_private_key.pem 2048<br></code></pre></td></tr></table></figure><p>显示如下结果则生成私钥成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">MacBook-Pro-6:pem tanxinzheng$ openssl genrsa -out rsa_private_key.pem 2048<br>Generating RSA private key, 2048 bit long modulus<br>....................+++<br>.+++<br>e is 65537 (0x10001)<br>MacBook-Pro-6:pem tanxinzheng$ ll<br>total 8<br>-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem<br></code></pre></td></tr></table></figure><p>查看私钥文件内容，RSA私钥格式如下：</p><blockquote><p>注：因太长…..省略部分内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">-----BEGIN RSA PRIVATE KEY-----<br>MIIEowIBAAKCAQEAzVHzaYFDgEDhIllCBZppYKsaLdYaC9D7IdkBMqroteeHRCaW<br>rUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX&#x2F;JsuYCUnqi3M0iqAFYWIyX7sXoKG<br>p3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdYhImkxzt&#x2F;njmQRJCLjNl7fHh6sc1R<br>G7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0Gn8dObD0G&#x2F;kuQEWFJpmIBbzT9zizv<br>........<br>2xYP&#x2F;ZoYb6wAe4PzYlJTi&#x2F;rD8vBdLuBqBKInBfHDe4WvUgOv4Xiu1vxs7lDPyPw5<br>2RnLAoGBANpHS9MdFlO6CtOVC1HYMifGY4LcxN7mnJJld2LP7v08pRzhwokMaIBu<br>cBH&#x2F;R0utDLsU9nivvdKjeacQ70pLPpAqDLsQWQxLvOXLLCooLC3RJqpsQp1l4g&#x2F;I<br>sqBVHkCKFTWAw7K28sZdchBHtM&#x2F;ELH5Tbac2uPEEWtDpzBJ8n4on<br>-----END RSA PRIVATE KEY-----<br></code></pre></td></tr></table></figure><h4 id="生成RSA公钥"><a href="#生成RSA公钥" class="headerlink" title="生成RSA公钥"></a>生成RSA公钥</h4><p>使用如下命令生成公钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem<br></code></pre></td></tr></table></figure><p>显示如下结果则生成公钥成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">MacBook-Pro-6:pem tanxinzheng$ openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem<br>writing RSA key<br>MacBook-Pro-6:pem tanxinzheng$ ll<br>total 16<br>-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem<br>-rw-r--r--  1 tanxinzheng  staff   451 Dec 17 18:47 rsa_public_key.pem<br></code></pre></td></tr></table></figure><p>查看公钥文件内容，RSA公钥格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">-----BEGIN PUBLIC KEY-----<br>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzVHzaYFDgEDhIllCBZpp<br>YKsaLdYaC9D7IdkBMqroteeHRCaWrUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX<br>&#x2F;JsuYCUnqi3M0iqAFYWIyX7sXoKGp3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdY<br>hImkxzt&#x2F;njmQRJCLjNl7fHh6sc1RG7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0G<br>n8dObD0G&#x2F;kuQEWFJpmIBbzT9zizvWsI5gc3jl1Ifp3urk+cexWmZpqavCRK08aee<br>5+yqXOk3xk8dqjX4zk6J66bDbiEYQXZcZTaCnTDDiZ4&#x2F;UiqTue9lKZeUoveuwIfX<br>WwIDAQAB<br>-----END PUBLIC KEY-----<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h4&gt;&lt;p&gt;openssl，若已安装则跳过&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="技术" scheme="https://www.tanxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Mac" scheme="https://www.tanxz.com/tags/Mac/"/>
    
    <category term="RAS" scheme="https://www.tanxz.com/tags/RAS/"/>
    
  </entry>
  
  <entry>
    <title>kafka入门教程[一]</title>
    <link href="https://www.tanxz.com/posts/1125805293/index.html"/>
    <id>https://www.tanxz.com/posts/1125805293/index.html</id>
    <published>2018-04-10T13:38:18.000Z</published>
    <updated>2020-12-18T15:04:43.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概念理解"><a href="#一、概念理解" class="headerlink" title="一、概念理解"></a>一、概念理解</h2><p><strong>Kafka</strong>是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p><a id="more"></a><h3 id="（1）产生背景"><a href="#（1）产生背景" class="headerlink" title="（1）产生背景"></a>（1）产生背景</h3><p>当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：</p><ol><li>如何收集这些巨大的信息</li><li>如何分析它</li><li>如何及时做到如上两点</li></ol><p>以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁-消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。</p><p><strong>Kafka诞生</strong><br>Kafka由 linked-in 开源<br>kafka-即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。<br>kafka-高产出的分布式消息系统(A high-throughput distributed messaging system)</p><h3 id="（2）Kafka的特性"><a href="#（2）Kafka的特性" class="headerlink" title="（2）Kafka的特性"></a>（2）Kafka的特性</h3><ul><li><strong>高吞吐量、低延迟</strong>：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li><li><strong>可扩展性</strong>：kafka集群支持热扩展</li><li><strong>持久性、可靠性</strong>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li><li><strong>容错性</strong>：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li><li><strong>高并发</strong>：支持数千个客户端同时读写</li></ul><h3 id="（3）Kafka场景应用"><a href="#（3）Kafka场景应用" class="headerlink" title="（3）Kafka场景应用"></a>（3）Kafka场景应用</h3><ul><li><strong>日志收集</strong>：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li><li><strong>消息系统</strong>：解耦和生产者和消费者、缓存消息等。</li><li><strong>用户活动跟踪</strong>：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li><li><strong>运营指标</strong>：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li><li><strong>流式处理</strong>：比如spark streaming和storm</li><li><strong>事件源</strong></li></ul><h3 id="（4）Kafka一些重要设计思想"><a href="#（4）Kafka一些重要设计思想" class="headerlink" title="（4）Kafka一些重要设计思想"></a>（4）Kafka一些重要设计思想</h3><ul><li><strong>Consumergroup</strong>：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。</li><li><strong>消息状态</strong>：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。</li><li><strong>消息持久化</strong>：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。</li><li><strong>消息有效期</strong>：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。</li><li><strong>批量发送</strong>：Kafka支持以消息集合为单位进行批量发送，以提高push效率。</li><li><strong>push-and-pull</strong> :Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。</li><li><strong>Kafka集群中broker之间的关系</strong>：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。</li><li><strong>负载均衡方面</strong>： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。</li><li><strong>同步异步</strong>：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</li><li><strong>分区机制partition</strong>：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。</li><li><strong>离线数据装载</strong>：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。</li><li><strong>插件支持</strong>：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。</li></ul><h2 id="二、消息队列通信的模式"><a href="#二、消息队列通信的模式" class="headerlink" title="二、消息队列通信的模式"></a>二、消息队列通信的模式</h2><h3 id="（1）点对点模式"><a href="#（1）点对点模式" class="headerlink" title="（1）点对点模式"></a>（1）点对点模式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200624144932564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p><h3 id="（2）发布订阅模式"><a href="#（2）发布订阅模式" class="headerlink" title="（2）发布订阅模式"></a>（2）发布订阅模式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020062414495136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！</p><h2 id="三、Kafka的架构原理"><a href="#三、Kafka的架构原理" class="headerlink" title="三、Kafka的架构原理"></a>三、Kafka的架构原理</h2><p>上面简单的介绍了为什么需要消息队列以及消息队列通信的两种模式，下面主角介绍Kafka。Kafka是一种<strong>高吞吐量的分布式发布订阅消息系统</strong>，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。。</p><h3 id="（1）基础架构与名词解释"><a href="#（1）基础架构与名词解释" class="headerlink" title="（1）基础架构与名词解释"></a>（1）基础架构与名词解释</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200624145628396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Producer：Producer即生产者，消息的产生者，是消息的入口。</li><li>Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……</li><li>Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。</li><li>Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！</li><li>Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</li><li>Message：每一条发送的消息主体。</li><li>Consumer：消费者，即消息的消费方，是消息的出口。</li><li>Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！</li><li>Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。</li></ul><h3 id="（2）工作流程分析"><a href="#（2）工作流程分析" class="headerlink" title="（2）工作流程分析"></a>（2）工作流程分析</h3><h4 id="（1）发送数据"><a href="#（1）发送数据" class="headerlink" title="（1）发送数据"></a>（1）发送数据</h4><p>我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，<strong>Producer在写入数据的时候永远的找leader</strong>，不会直接将数据写入<strong>follower</strong>！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200624150617430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200624150636117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：</p><ol><li><strong>方便扩展</strong>：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。</li><li><strong>提高并发</strong>：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li></ol><p>熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：</p><ol><li>partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。</li><li>如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。</li><li>如果既没指定partition，又没有设置key，则会轮询选出一个partition。</li></ol><p>保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为<strong>0、1、all</strong>。</p><ul><li>0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。</li><li>1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。</li><li>all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</li></ul><p>最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。</p><h4 id="（2）保存数据"><a href="#（2）保存数据" class="headerlink" title="（2）保存数据"></a>（2）保存数据</h4><p>Producer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。</p><h5 id="（1）Partition-结构"><a href="#（1）Partition-结构" class="headerlink" title="（1）Partition 结构"></a>（1）Partition 结构</h5><p>前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200624170905606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。</p><h5 id="（2）Message结构"><a href="#（2）Message结构" class="headerlink" title="（2）Message结构"></a>（2）Message结构</h5><p>上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：</p><ul><li><strong>offset</strong>：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！</li><li><strong>消息大小</strong>：消息大小占用4byte，用于描述消息的大小。</li><li><strong>消息体</strong>：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。</li></ul><h5 id="（3）存储策略"><a href="#（3）存储策略" class="headerlink" title="（3）存储策略"></a>（3）存储策略</h5><p>无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？</p><ul><li>基于时间，默认配置是168小时（7天）。</li><li>基于大小，默认配置是1073741824。</li></ul><p>需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！</p><h4 id="（3）消费数据"><a href="#（3）消费数据" class="headerlink" title="（3）消费数据"></a>（3）消费数据</h4><p>消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka采用的是点对点的模式，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找<strong>leader</strong>去拉取。</p><p>多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！我们看下图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200624171149382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，<strong>建议消费者组的consumer的数量与partition的数量一致</strong>！</p><p>在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：<br><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200624171235860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。</li><li>打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的相对offset为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。</li><li>根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。</li></ol><p>这套机制是建立在offset为有序的基础上，利用segment+有序offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、概念理解&quot;&gt;&lt;a href=&quot;#一、概念理解&quot; class=&quot;headerlink&quot; title=&quot;一、概念理解&quot;&gt;&lt;/a&gt;一、概念理解&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Kafka&lt;/strong&gt;是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://www.tanxz.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kafka" scheme="https://www.tanxz.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令systemd</title>
    <link href="https://www.tanxz.com/posts/1026478354/index.html"/>
    <id>https://www.tanxz.com/posts/1026478354/index.html</id>
    <published>2017-12-19T16:00:00.000Z</published>
    <updated>2020-12-18T15:55:13.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Systemd-概述"><a href="#Systemd-概述" class="headerlink" title="Systemd 概述"></a><strong>Systemd 概述</strong></h2><h3 id="Systemd-简介"><a href="#Systemd-简介" class="headerlink" title="Systemd 简介"></a><strong>Systemd 简介</strong></h3><p>Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。</p><p>Systemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。</p><ol><li>更少的进程</li></ol><p>Systemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。</p><ol><li>允许更多的进程并行启动</li></ol><p>在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。</p><ol><li>使用 CGroup 跟踪和管理进程的生命周期</li></ol><p>在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。</p><p>而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。</p><ol><li>统一管理服务日志</li></ol><p>Systemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。</p><h3 id="Systemd-架构"><a href="#Systemd-架构" class="headerlink" title="Systemd 架构"></a><strong>Systemd 架构</strong></h3><p><img src= "/img/loading.gif" data-lazy-src="https://ask.qcloudimg.com/http-save/yehe-5449090/97kx52pwuj.png?imageView2/2/w/1620" alt="img"></p><h2 id="Systemd-的-Unit-文件"><a href="#Systemd-的-Unit-文件" class="headerlink" title="Systemd 的 Unit 文件"></a><strong>Systemd 的 Unit 文件</strong></h2><p>Systemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）。</p><p>在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。</p><ol><li>Systemd 支持的 12 种 Unit 文件类型</li></ol><ul><li>.automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</li><li>.device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系</li><li>.mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件</li><li>.path：用于监控指定目录或文件的变化，并触发其它 Unit 运行</li><li>.scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</li><li>.service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</li><li>.slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件</li><li>.snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照</li><li>.socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动</li><li>.swap：定义一个用户做虚拟内存的交换分区</li><li>.target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式</li><li>.timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能</li></ul><ol><li>Systemd 目录</li></ol><p>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p><ul><li>/etc/systemd/system：系统或用户自定义的配置文件</li><li>/run/systemd/system：软件运行时生成的配置文件</li><li>/usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。<ul><li>CentOS 7：Unit 文件指向该目录</li><li>ubuntu 16：被移到了 /lib/systemd/system</li></ul></li></ul><p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p><ol><li>Unit 和 Target</li></ol><p>Unit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。</p><p>Target 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。</p><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p><h2 id="Systemd-Service-Unit"><a href="#Systemd-Service-Unit" class="headerlink" title="Systemd Service Unit"></a><strong>Systemd Service Unit</strong></h2><h3 id="Unit-文件结构"><a href="#Unit-文件结构" class="headerlink" title="Unit 文件结构"></a><strong>Unit 文件结构</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[Unit]<br>Description=Hello World<br>After=docker.service<br>Requires=docker.service<br>[Service]<br>TimeoutStartSec=<span class="hljs-number">0</span><br>ExecStartPre=-<span class="hljs-regexp">/usr/</span>bin/docker kill busybox1<br>ExecStartPre=-<span class="hljs-regexp">/usr/</span>bin/docker rm busybox1<br>ExecStartPre=<span class="hljs-regexp">/usr/</span>bin/docker pull busybox<br>ExecStart=<span class="hljs-regexp">/usr/</span>bin/docker run --name busybox1 busybox /bin/ sh -c <span class="hljs-string">&quot;while true; do echo Hello World; sleep 1; done&quot;</span><br>ExecStop=<span class="hljs-string">&quot;/usr/bin/docker stop busybox1&quot;</span><br>ExecStopPost=<span class="hljs-string">&quot;/usr/bin/docker rm busybox1&quot;</span><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>如下所示，Systemd 服务的 Unit 文件可以分为三个配置区段：</p><ul><li>Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式</li><li>Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法</li></ul><h4 id="Unit-段"><a href="#Unit-段" class="headerlink" title="Unit 段"></a><strong>Unit 段</strong></h4><ul><li>Description：描述这个 Unit 文件的信息</li><li>Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径</li><li>Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止</li><li>Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功</li><li>After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务</li><li>Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行</li><li>Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启</li><li>Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动</li><li>OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块</li><li>Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然</li></ul><h4 id="Install-段"><a href="#Install-段" class="headerlink" title="Install 段"></a><strong>Install 段</strong></h4><p>这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束：</p><ul><li>WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># find /etc/systemd/system/* -type d<br>/etc/systemd/system/<span class="hljs-keyword">default</span>.target.wants<br>/etc/systemd/system/getty.target.wants<br>/etc/systemd/system/graphical.target.wants<br>/etc/systemd/system/multi-user.target.wants<br>/etc/systemd/system/network-online.target.wants<br>/etc/systemd/system/paths.target.wants<br>/etc/systemd/system/shutdown.target.wants<br>/etc/systemd/system/sockets.target.wants<br>/etc/systemd/system/sysinit.target.wants<br>/etc/systemd/system/timers.target.wants<br></code></pre></td></tr></table></figure><ul><li>RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .required 后缀构成的子目录中</li><li>Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit</li><li>Alias：当前 Unit 可用于启动的别名</li></ul><ol><li>SysV-init 运行级别与 Systemd Target 对应的 Unit 文件</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://ask.qcloudimg.com/http-save/yehe-5449090/mvna7qlr41.png?imageView2/2/w/1620" alt="img"></p><p>通过 systemctl list-units –type=target 命令可以获取当前正在使用的运行目标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># systemctl list-units --type=target<br>UNIT                   LOAD   ACTIVE SUB    DESCRIPTION<br>basic.target           loaded active active Basic System<br>cryptsetup.target      loaded active active Encrypted Volumes<br>getty.target           loaded active active Login Prompts<br>graphical.target       loaded active active Graphical Interface<br>local-fs-pre.target    loaded active active Local File Systems (Pre)<br>local-fs.target        loaded active active Local File Systems<br>multi-user.target      loaded active active Multi-User System<br>network-online.target  loaded active active Network is Online<br>network.target         loaded active active Network<br>nss-user-lookup.target loaded active active User and Group Name Lookups<br>paths.target           loaded active active Paths<br>remote-fs-pre.target   loaded active active Remote File Systems (Pre)<br>remote-fs.target       loaded active active Remote File Systems<br>slices.target          loaded active active Slices<br>sockets.target         loaded active active Sockets<br>sound.target           loaded active active Sound Card<br>swap.target            loaded active active Swap<br>sysinit.target         loaded active active System Initialization<br>time-sync.target       loaded active active System Time Synchronized<br>timers.target          loaded active active Timers<br>LOAD   = Reflects whether the unit definition was properly loaded.<br>ACTIVE = The high-level unit activation state, i.e. generalization <span class="hljs-keyword">of</span> SUB.<br>SUB    = The low-level unit activation state, values depend on unit type.<br><span class="hljs-number">20</span> loaded units listed. Pass --all to see loaded but inactive units, too.<br>To show all installed unit files use <span class="hljs-string">&#x27;systemctl list-unit-files&#x27;</span>.<br></code></pre></td></tr></table></figure><h4 id="Service-段"><a href="#Service-段" class="headerlink" title="Service 段"></a><strong>Service 段</strong></h4><p>用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段分为服务生命周期和服务上下文配置两个方面。</p><ol><li>服务生命周期控制相关</li></ol><ul><li>Type：定义启动时的进程行为，它有以下几种值：<ul><li>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</li><li>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li><li>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li><li>Type=dbus：当前服务通过D-Bus启动</li><li>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</li><li>Type=idle：若有其他任务执行完毕，当前服务才会运行</li></ul></li><li>RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。</li><li>ExecStart：启动当前服务的命令</li><li>ExecStartPre：启动当前服务之前执行的命令</li><li>ExecStartPos：启动当前服务之后执行的命令</li><li>ExecReload：重启当前服务时执行的命令</li><li>ExecStop：停止当前服务时执行的命令</li><li>ExecStopPost：停止当其服务之后执行的命令</li><li>RestartSec：自动重启当前服务间隔的秒数</li><li>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li><li>TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测</li><li>TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程</li></ul><ol><li>服务上下文配置相关</li></ol><ul><li>Environment：为服务指定环境变量</li><li>EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义</li><li>Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级</li><li>WorkingDirectory：指定服务的工作目录</li><li>RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件</li><li>User：指定运行服务的用户</li><li>Group：指定运行服务的用户组</li><li>MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private<ul><li>shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上</li><li>slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上</li><li>private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上</li></ul></li><li>LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等</li></ul><blockquote><p>注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。</p></blockquote><h3 id="Unit-文件占位符和模板"><a href="#Unit-文件占位符和模板" class="headerlink" title="Unit 文件占位符和模板"></a><strong>Unit 文件占位符和模板</strong></h3><h4 id="Unit-文件占位符"><a href="#Unit-文件占位符" class="headerlink" title="Unit 文件占位符"></a><strong>Unit 文件占位符</strong></h4><p>在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行被动态地替换实际的值。</p><ul><li>%n：完整的 Unit 文件名字，包括 .service 后缀名</li><li>%p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号</li><li>%i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名</li><li>%t：存放系统运行文件的目录，通常是 “run”</li><li>%u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root</li><li>%U：运行服务的用户 ID</li><li>%h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值</li><li>%s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值</li><li>%m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用</li><li>%b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变</li><li>%H：实际运行节点的主机名</li><li>%v：内核版本，即 “uname -r” 命令输出的内容</li><li>%%：在 Unit 模板文件中表示一个普通的百分号</li></ul><h4 id="Unit-模板"><a href="#Unit-模板" class="headerlink" title="Unit 模板"></a><strong>Unit 模板</strong></h4><p>在现实中，往往有一些应用需要被复制多份运行。例如，用于同一个<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>器分流的多个服务实例，或者为每个 SSH 连接建立一个独立的 sshd 服务进程。</p><p>Unit 模板文件的写法与普通的服务 Unit 文件基本相同，不过 Unit 模板的文件名是以 @ 符号结尾的。通过模板启动服务实例时，需要在其文件名的 @ 字符后面附加一个参数字符串。</p><ol><li>示例：apache@.service</li></ol><ul><li>apache@.service 模板</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[Unit]<br>Description=My Advanced Service Template<br>After=etcd.service docker.service<br>[Service]<br>TimeoutStartSec=<span class="hljs-number">0</span><br>ExecStartPre=-<span class="hljs-regexp">/usr/</span>bin/docker kill apache%i<br>ExecStartPre=-<span class="hljs-regexp">/usr/</span>bin/docker rm apache%i<br>ExecStartPre=<span class="hljs-regexp">/usr/</span>bin/docker pull coreos/apache<br>ExecStart=<span class="hljs-regexp">/usr/</span>bin/docker run --name apache%i -p %i:<span class="hljs-number">80</span> coreos/apache /usr/sbin/apache2ctl -D FOREGROUND<br>ExecStartPost=<span class="hljs-regexp">/usr/</span>bin/etcdctl set /domains/example.com/%H:%i running<br>ExecStop=<span class="hljs-regexp">/usr/</span>bin/docker stop apache1<br>ExecStopPost=<span class="hljs-regexp">/usr/</span>bin/docker rm apache1<br>ExecStopPost=<span class="hljs-regexp">/usr/</span>bin/etcdctl rm /domains/example.com/%H:%i<br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><ul><li>启动 Unit 模板的服务实例</li></ul><p>在服务启动时需要在 @ 后面放置一个用于区分服务实例的附加字符参数，通常这个参数用于监控的端口号或控制台 TTY 编译号。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># systemctl start apache@8080.service<br></code></pre></td></tr></table></figure><p>Systemd 在运行服务时，总是会先尝试找到一个完整匹配的 Unit 文件，如果没有找到，才会尝试选择匹配模板。例如上面的命令，System 首先会在约定的目录下寻找名为 <a href="mailto:apache@8080.service">apache@8080.service</a> 的文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 <a href="mailto:apache@8080.service">apache@8080.service</a>，systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。</p><h2 id="Systemd-的资源管理"><a href="#Systemd-的资源管理" class="headerlink" title="Systemd 的资源管理"></a><strong>Systemd 的资源管理</strong></h2><h3 id="Systemctl-命令"><a href="#Systemctl-命令" class="headerlink" title="Systemctl 命令"></a><strong>Systemctl 命令</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># systemctl --help<br>systemctl [OPTIONS...] &#123;COMMAND&#125; ...<br>Query or send control commands to the systemd manager.<br>  -h --help           Show <span class="hljs-built_in">this</span> help<br>     --version        Show package version<br>     --system         Connect to system manager<br>  -H --host=[USER@]HOST<br>                      Operate on remote host<br>  -M --machine=CONTAINER<br>                      Operate on local container<br>  -t --type=TYPE      List units <span class="hljs-keyword">of</span> a particular type<br>     --state=STATE    List units <span class="hljs-keyword">with</span> particular LOAD or SUB or ACTIVE state<br>  -p --property=NAME  Show only properties by <span class="hljs-built_in">this</span> name<br>  -a --all            Show all loaded units/properties, including dead/empty<br>                      ones. To list all units installed on the system, use<br>                      the <span class="hljs-string">&#x27;list-unit-files&#x27;</span> command instead.<br>  -l --full           Don<span class="hljs-string">&#x27;t ellipsize unit names on output</span><br><span class="hljs-string">  -r --recursive      Show unit list of host and local containers</span><br><span class="hljs-string">     --reverse        Show reverse dependencies with &#x27;</span>list-dependencies<span class="hljs-string">&#x27;</span><br><span class="hljs-string">     --job-mode=MODE  Specify how to deal with already queued jobs, when</span><br><span class="hljs-string">                      queueing a new job</span><br><span class="hljs-string">     --show-types     When showing sockets, explicitly show their type</span><br><span class="hljs-string">  -i --ignore-inhibitors</span><br><span class="hljs-string">                      When shutting down or sleeping, ignore inhibitors</span><br><span class="hljs-string">     --kill-who=WHO   Who to send signal to</span><br><span class="hljs-string">  -s --signal=SIGNAL  Which signal to send</span><br><span class="hljs-string">     --now            Start or stop unit in addition to enabling or disabling it</span><br><span class="hljs-string">  -q --quiet          Suppress output</span><br><span class="hljs-string">     --no-block       Do not wait until operation finished</span><br><span class="hljs-string">     --no-wall        Don&#x27;</span>t send wall message before halt/power-off/reboot<br>     --no-reload      Don<span class="hljs-string">&#x27;t reload daemon after en-/dis-abling unit files</span><br><span class="hljs-string">     --no-legend      Do not print a legend (column headers and hints)</span><br><span class="hljs-string">     --no-pager       Do not pipe output into a pager</span><br><span class="hljs-string">     --no-ask-password</span><br><span class="hljs-string">                      Do not ask for system passwords</span><br><span class="hljs-string">     --global         Enable/disable unit files globally</span><br><span class="hljs-string">     --runtime        Enable unit files only temporarily until next reboot</span><br><span class="hljs-string">  -f --force          When enabling unit files, override existing symlinks</span><br><span class="hljs-string">                      When shutting down, execute action immediately</span><br><span class="hljs-string">     --preset-mode=   Apply only enable, only disable, or all presets</span><br><span class="hljs-string">     --root=PATH      Enable unit files in the specified root directory</span><br><span class="hljs-string">  -n --lines=INTEGER  Number of journal entries to show</span><br><span class="hljs-string">  -o --output=STRING  Change journal output mode (short, short-iso,</span><br><span class="hljs-string">                              short-precise, short-monotonic, verbose,</span><br><span class="hljs-string">                              export, json, json-pretty, json-sse, cat)</span><br><span class="hljs-string">     --plain          Print unit dependencies as a list instead of a tree</span><br><span class="hljs-string">Unit Commands:</span><br><span class="hljs-string">  list-units [PATTERN...]         List loaded units</span><br><span class="hljs-string">  list-sockets [PATTERN...]       List loaded sockets ordered by address</span><br><span class="hljs-string">  list-timers [PATTERN...]        List loaded timers ordered by next elapse</span><br><span class="hljs-string">  start NAME...                   Start (activate) one or more units</span><br><span class="hljs-string">  stop NAME...                    Stop (deactivate) one or more units</span><br><span class="hljs-string">  reload NAME...                  Reload one or more units</span><br><span class="hljs-string">  restart NAME...                 Start or restart one or more units</span><br><span class="hljs-string">  try-restart NAME...             Restart one or more units if active</span><br><span class="hljs-string">  reload-or-restart NAME...       Reload one or more units if possible,</span><br><span class="hljs-string">                                  otherwise start or restart</span><br><span class="hljs-string">  reload-or-try-restart NAME...   Reload one or more units if possible,</span><br><span class="hljs-string">                                  otherwise restart if active</span><br><span class="hljs-string">  isolate NAME                    Start one unit and stop all others</span><br><span class="hljs-string">  kill NAME...                    Send signal to processes of a unit</span><br><span class="hljs-string">  is-active PATTERN...            Check whether units are active</span><br><span class="hljs-string">  is-failed PATTERN...            Check whether units are failed</span><br><span class="hljs-string">  status [PATTERN...|PID...]      Show runtime status of one or more units</span><br><span class="hljs-string">  show [PATTERN...|JOB...]        Show properties of one or more</span><br><span class="hljs-string">                                  units/jobs or the manager</span><br><span class="hljs-string">  cat PATTERN...                  Show files and drop-ins of one or more units</span><br><span class="hljs-string">  set-property NAME ASSIGNMENT... Sets one or more properties of a unit</span><br><span class="hljs-string">  help PATTERN...|PID...          Show manual for one or more units</span><br><span class="hljs-string">  reset-failed [PATTERN...]       Reset failed state for all, one, or more</span><br><span class="hljs-string">                                  units</span><br><span class="hljs-string">  list-dependencies [NAME]        Recursively show units which are required</span><br><span class="hljs-string">                                  or wanted by this unit or by which this</span><br><span class="hljs-string">                                  unit is required or wanted</span><br><span class="hljs-string">Unit File Commands:</span><br><span class="hljs-string">  list-unit-files [PATTERN...]    List installed unit files</span><br><span class="hljs-string">  enable NAME...                  Enable one or more unit files</span><br><span class="hljs-string">  disable NAME...                 Disable one or more unit files</span><br><span class="hljs-string">  reenable NAME...                Reenable one or more unit files</span><br><span class="hljs-string">  preset NAME...                  Enable/disable one or more unit files</span><br><span class="hljs-string">                                  based on preset configuration</span><br><span class="hljs-string">  preset-all                      Enable/disable all unit files based on</span><br><span class="hljs-string">                                  preset configuration</span><br><span class="hljs-string">  is-enabled NAME...              Check whether unit files are enabled</span><br><span class="hljs-string">  mask NAME...                    Mask one or more units</span><br><span class="hljs-string">  unmask NAME...                  Unmask one or more units</span><br><span class="hljs-string">  link PATH...                    Link one or more units files into</span><br><span class="hljs-string">                                  the search path</span><br><span class="hljs-string">  add-wants TARGET NAME...        Add &#x27;</span>Wants<span class="hljs-string">&#x27; dependency for the target</span><br><span class="hljs-string">                                  on specified one or more units</span><br><span class="hljs-string">  add-requires TARGET NAME...     Add &#x27;</span>Requires<span class="hljs-string">&#x27; dependency for the target</span><br><span class="hljs-string">                                  on specified one or more units</span><br><span class="hljs-string">  edit NAME...                    Edit one or more unit files</span><br><span class="hljs-string">  get-default                     Get the name of the default target</span><br><span class="hljs-string">  set-default NAME                Set the default target</span><br><span class="hljs-string">Machine Commands:</span><br><span class="hljs-string">  list-machines [PATTERN...]      List local containers and host</span><br><span class="hljs-string">Job Commands:</span><br><span class="hljs-string">  list-jobs [PATTERN...]          List jobs</span><br><span class="hljs-string">  cancel [JOB...]                 Cancel all, one, or more jobs</span><br><span class="hljs-string">Snapshot Commands:</span><br><span class="hljs-string">  snapshot [NAME]                 Create a snapshot</span><br><span class="hljs-string">  delete NAME...                  Remove one or more snapshots</span><br><span class="hljs-string">Environment Commands:</span><br><span class="hljs-string">  show-environment                Dump environment</span><br><span class="hljs-string">  set-environment NAME=VALUE...   Set one or more environment variables</span><br><span class="hljs-string">  unset-environment NAME...       Unset one or more environment variables</span><br><span class="hljs-string">  import-environment [NAME...]    Import all or some environment variables</span><br><span class="hljs-string">Manager Lifecycle Commands:</span><br><span class="hljs-string">  daemon-reload                   Reload systemd manager configuration</span><br><span class="hljs-string">  daemon-reexec                   Reexecute systemd manager</span><br><span class="hljs-string">System Commands:</span><br><span class="hljs-string">  is-system-running               Check whether system is fully running</span><br><span class="hljs-string">  default                         Enter system default mode</span><br><span class="hljs-string">  rescue                          Enter system rescue mode</span><br><span class="hljs-string">  emergency                       Enter system emergency mode</span><br><span class="hljs-string">  halt                            Shut down and halt the system</span><br><span class="hljs-string">  poweroff                        Shut down and power-off the system</span><br><span class="hljs-string">  reboot [ARG]                    Shut down and reboot the system</span><br><span class="hljs-string">  kexec                           Shut down and reboot the system with kexec</span><br><span class="hljs-string">  exit                            Request user instance exit</span><br><span class="hljs-string">  switch-root ROOT [INIT]         Change to a different root file system</span><br><span class="hljs-string">  suspend                         Suspend the system</span><br><span class="hljs-string">  hibernate                       Hibernate the system</span><br><span class="hljs-string">  hybrid-sleep                    Hibernate and suspend the system</span><br></code></pre></td></tr></table></figure><h3 id="Unit-管理"><a href="#Unit-管理" class="headerlink" title="Unit 管理"></a><strong>Unit 管理</strong></h3><ol><li>查看当前系统的所有 Unit</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 列出正在运行的 Unit<br>$ systemctl list-units<br><br># 列出所有Unit，包括没有找到配置文件的或者启动失败的<br>$ systemctl list-units --all<br><br># 列出所有没有运行的 Unit<br>$ systemctl list-units --all --state=inactive<br><br># 列出所有加载失败的 Unit<br>$ systemctl list-units --failed<br><br># 列出所有正在运行的、类型为 service 的 Unit<br>$ systemctl list-units --type=service<br><br># 查看 Unit 配置文件的内容<br>$ systemctl cat docker.service<br></code></pre></td></tr></table></figure><ol><li>查看 Unit 的状态</li></ol><ul><li>enabled：已建立启动链接</li><li>disabled：没建立启动链接</li><li>static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖</li><li>masked：该配置文件被禁止建立启动链接</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 显示系统状态<br>$ systemctl status<br><br># 显示单个 Unit 的状态<br>$ ystemctl status bluetooth.service<br><br># 显示远程主机的某个 Unit 的状态<br>$ systemctl -H root@rhel7.example.com status httpd.service<br></code></pre></td></tr></table></figure><ol><li>Unit 的管理</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 立即启动一个服务<br>$ sudo systemctl start apache.service<br><br># 立即停止一个服务<br>$ sudo systemctl stop apache.service<br><br># 重启一个服务<br>$ sudo systemctl restart apache.service<br><br># 杀死一个服务的所有子进程<br>$ sudo systemctl kill apache.service<br><br># 重新加载一个服务的配置文件<br>$ sudo systemctl reload apache.service<br><br># 重载所有修改过的配置文件<br>$ sudo systemctl daemon-reload<br><br># 显示某个 Unit 的所有底层参数<br>$ systemctl show httpd.service<br><br># 显示某个 Unit 的指定属性的值<br>$ systemctl show -p CPUShares httpd.service<br><br># 设置某个 Unit 的指定属性<br>$ sudo systemctl set-property httpd.service CPUShares=<span class="hljs-number">500</span><br></code></pre></td></tr></table></figure><ol><li>查看 Unit 的依赖关系</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 列出一个 Unit 的所有依赖，默认不会列出 target 类型<br>$ systemctl list-dependencies nginx.service<br><br># 列出一个 Unit 的所有依赖，包括 target 类型<br>$ systemctl list-dependencies --all nginx.service<br></code></pre></td></tr></table></figure><h3 id="服务的生命周期"><a href="#服务的生命周期" class="headerlink" title="服务的生命周期"></a><strong>服务的生命周期</strong></h3><p>当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。</p><ol><li>服务的激活</li></ol><ul><li>systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中</li><li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li></ul><ol><li>服务的启动和停止</li></ol><ul><li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li><li>systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令</li><li>systemctl restart：重启服务</li><li>systemctl kill：立即杀死服务</li></ul><ol><li>服务的开机启动和取消</li></ol><ul><li>systemctl enable：除了激活服务以外，也可以置服务为开机启动</li><li>systemctl disable：取消服务的开机启动</li></ul><ol><li>服务的修改和移除</li></ol><ul><li>systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件</li><li>systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。</li></ul><h3 id="Target-管理"><a href="#Target-管理" class="headerlink" title="Target 管理"></a><strong>Target 管理</strong></h3><p>Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p><p>在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 查看当前系统的所有 Target<br>$ systemctl list-unit-files --type=target<br><br># 查看一个 Target 包含的所有 Unit<br>$ systemctl list-dependencies multi-user.target<br><br># 查看启动时的默认 Target<br>$ systemctl get-<span class="hljs-keyword">default</span><br><br># 设置启动时的默认 Target<br>$ sudo systemctl set-<span class="hljs-keyword">default</span> multi-user.target<br><br># 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程<br>$ sudo systemctl isolate multi-user.target<br></code></pre></td></tr></table></figure><ol><li>Target 与 SysV-init 进程的主要区别：</li></ol><ul><li>默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</li><li>启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。</li><li>配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。</li></ul><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a><strong>日志管理</strong></h3><p>Systemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。</p><p>Systemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。</p><p>默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 查看所有日志（默认情况下 ，只保存本次启动的日志）<br>$ sudo journalctl<br><br># 查看内核日志（不显示应用日志）：--dmesg 或 -k<br>$ sudo journalctl -k<br><br># 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b<br>$ sudo journalctl -b<br>$ sudo journalctl -b -<span class="hljs-number">0</span><br><br># 查看上一次启动的日志（需更改设置）<br>$ sudo journalctl -b -<span class="hljs-number">1</span><br><br># 查看指定服务的日志：--unit 或 -u<br>$ sudo journalctl -u docker.servcie<br><br># 查看指定服务的日志<br>$ sudo journalctl /usr/lib/systemd/systemd<br><br># 实时滚动显示最新日志<br>$ sudo journalctl -f<br><br># 查看指定时间的日志<br>$ sudo journalctl --since=<span class="hljs-string">&quot;2012-10-30 18:17:16&quot;</span><br>$ sudo journalctl --since <span class="hljs-string">&quot;20 min ago&quot;</span><br>$ sudo journalctl --since yesterday<br>$ sudo journalctl --since <span class="hljs-string">&quot;2015-01-10&quot;</span> --until <span class="hljs-string">&quot;2015-01-11 03:00&quot;</span><br>$ sudo journalctl --since <span class="hljs-number">09</span>:<span class="hljs-number">00</span> --until <span class="hljs-string">&quot;1 hour ago&quot;</span><br><br># 显示尾部的最新 10 行日志：--lines 或 -n<br>$ sudo journalctl -n<br><br># 显示尾部指定行数的日志<br>$ sudo journalctl -n <span class="hljs-number">20</span><br><br># 将最新的日志显示在前面<br>$ sudo journalctl -r -u docker.service<br><br># 改变输出的格式：--output 或 -o<br>$ sudo journalctl -r -u docker.service -o json-pretty<br><br># 查看指定进程的日志<br>$ sudo journalctl _PID=<span class="hljs-number">1</span><br><br># 查看某个路径的脚本的日志<br>$ sudo journalctl /usr/bin/bash<br><br># 查看指定用户的日志<br>$ sudo journalctl _UID=<span class="hljs-number">33</span> --since today<br><br># 查看某个 Unit 的日志<br>$ sudo journalctl -u nginx.service<br>$ sudo journalctl -u nginx.service --since today<br><br># 实时滚动显示某个 Unit 的最新日志<br>$ sudo journalctl -u nginx.service -f<br><br># 合并显示多个 Unit 的日志<br>$ journalctl -u nginx.service -u php-fpm.service --since today<br><br># 查看指定优先级（及其以上级别）的日志，共有 8 级<br># 0: emerg<br># 1: alert<br># 2: crit<br># 3: err<br># 4: warning<br># 5: notice<br># 6: info<br># 7: debug<br>$ sudo journalctl -p err -b<br><br># 日志默认分页输出，--no-pager 改为正常的标准输出<br>$ sudo journalctl --no-pager<br><br># 以 JSON 格式（单行）输出<br>$ sudo journalctl -b -u nginx.service -o json<br><br># 以 JSON 格式（多行）输出，可读性更好<br>$ sudo journalctl -b -u nginx.serviceqq<br> -o json-pretty<br><br># 显示日志占据的硬盘空间<br>$ sudo journalctl --disk-usage<br><br># 指定日志文件占据的最大空间<br>$ sudo journalctl --vacuum-size=1G<br><br># 指定日志文件保存多久<br>$ sudo journalctl --vacuum-time=1years<br></code></pre></td></tr></table></figure><h2 id="Systemd-工具集"><a href="#Systemd-工具集" class="headerlink" title="Systemd 工具集"></a><strong>Systemd 工具集</strong></h2><ul><li>systemctl：用于检查和控制各种系统服务和资源的状态</li><li>bootctl：用于查看和管理系统启动分区</li><li>hostnamectl：用于查看和修改系统的主机名和主机信息</li><li>journalctl：用于查看系统日志和各类应用服务日志</li><li>localectl：用于查看和管理系统的地区信息</li><li>loginctl：用于管理系统已登录用户和 Session 的信息</li><li>machinectl：用于操作 Systemd 容器</li><li>timedatectl：用于查看和管理系统的时间和时区信息</li><li>systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈</li><li>systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容</li><li>systemd-cat：用于将其他命令的输出重定向到系统日志</li><li>systemd-cgls：递归地显示指定 CGroup 的继承链</li><li>systemd-cgtop：显示系统当前最耗资源的 CGroup 单元</li><li>systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符</li><li>systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库</li><li>systemd-delta：对比当前系统配置与默认系统配置的差异</li><li>systemd-detect-virt：显示主机的虚拟化类型</li><li>systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件</li><li>systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID</li><li>systemd-notify：Systemd 的内部工具，用于通知服务的状态变化</li><li>systemd-nspawn：用于创建 Systemd 容器</li><li>systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置</li><li>systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行</li><li>systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线</li><li>systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录</li><li>systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求</li></ul><ol><li>systemctl</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 重启系统<br>$ sudo systemctl reboot<br><br># 关闭系统，切断电源<br>$ sudo systemctl poweroff<br><br># CPU停止工作<br>$ sudo systemctl halt<br><br># 暂停系统<br>$ sudo systemctl suspend<br><br># 让系统进入冬眠状态<br>$ sudo systemctl hibernate<br><br># 让系统进入交互式休眠状态<br>$ sudo systemctl hybrid-sleep<br><br># 启动进入救援状态（单用户状态）<br>$ sudo systemctl rescue<br></code></pre></td></tr></table></figure><ol><li>systemd-analyze</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 查看启动耗时<br>$ systemd-analyze<br><br># 查看每个服务的启动耗时<br>$ systemd-analyze blame<br><br># 显示瀑布状的启动过程流<br>$ systemd-analyze critical-chain<br><br># 显示指定服务的启动流<br>$ systemd-analyze critical-chain atd.service<br></code></pre></td></tr></table></figure><ol><li>hostnamectl</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 显示当前主机的信息<br>$ hostnamectl<br><br># 设置主机名。<br>$ sudo hostnamectl set-hostname rhel7<br></code></pre></td></tr></table></figure><ol><li>timedatectl</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 查看当前时区设置<br>$ timedatectl<br><br># 显示所有可用的时区<br>$ timedatectl list-timezones<br><br># 设置当前时区<br>$ sudo timedatectl set-timezone America/New_York<br>$ sudo timedatectl set-time YYYY-MM-DD<br>$ sudo timedatectl set-time HH:MM:SS<br></code></pre></td></tr></table></figure><ol><li>loginctl</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 列出当前 session<br>$ loginctl list-sessions<br><br># 列出当前登录用户<br>$ loginctl list-users<br><br># 列出显示指定用户的信息<br>$ loginctl show-user ruanyf<br></code></pre></td></tr></table></figure><ol><li>systemd-ask-password</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$ PASSWORD=$(systemd-ask-password <span class="hljs-string">&quot;Input Your Passowrd:&quot;</span>)<br></code></pre></td></tr></table></figure><ol><li>systemd-run</li></ol><p>systemd-run 可以将一个指定的操作变成后台运行的服务。它的效果似乎与直接在命令后加上表示后台运行的 &amp; 符号很相似。然而，它让命令成为服务还意味着，它的生命周期将由 Systemd 控制。具体来说，包括以下好处：</p><ul><li>服务的生命击期由 Systemd 接管，不会随着启动它的控制台关闭而结束</li><li>可以通过 systemctl 工具管理服务的状态</li><li>可以通过 journalctl 工具查看和管理服务的日志信息</li><li>可以通过 Systemd 提供的方法限制服务的 CPU、内存、磁盘 IO 等系统资源的使用情况。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Systemd-概述&quot;&gt;&lt;a href=&quot;#Systemd-概述&quot; class=&quot;headerlink&quot; title=&quot;Systemd 概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;Systemd 概述&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;Systemd-简介&quot;&gt;&lt;a h</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://www.tanxz.com/tags/Linux/"/>
    
    <category term="Centos" scheme="https://www.tanxz.com/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Markdown导出带目录的html文件</title>
    <link href="https://www.tanxz.com/posts/3058308324/index.html"/>
    <id>https://www.tanxz.com/posts/3058308324/index.html</id>
    <published>2017-10-15T04:10:23.000Z</published>
    <updated>2020-12-18T18:38:37.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>使用下面命令进行全局安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">npm install -g i5ting_toc<br></code></pre></td></tr></table></figure><hr><h2 id="插件用法"><a href="#插件用法" class="headerlink" title="插件用法"></a>插件用法</h2><p>安装好 i5ting_toc 后，就可以使用简单的命令了。比如输入<code>i5ting_toc -h</code>查看插件用法，如下图示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190905160156342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h2 id="md-文件转-html-文件"><a href="#md-文件转-html-文件" class="headerlink" title="md 文件转 html 文件"></a>md 文件转 html 文件</h2><p><strong>这里我在本地给大家演示一遍。</strong></p><ul><li>进入md文件所在目录</li></ul><p>如下图示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190905160538563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>输入命令<code>i5ting_toc -f index.md -o</code></li></ul><p>如下图示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190905160831569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>命令执行完后，md文件目录下生成了一个preview文件夹，我们需要的html文件夹就在里面，然后直接浏览器打开这个html即可。如下图示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190905161030886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190905161108879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>希望本文对各位同学能有所帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装插件&quot;&gt;&lt;a href=&quot;#安装插件&quot; class=&quot;headerlink&quot; title=&quot;安装插件&quot;&gt;&lt;/a&gt;安装插件&lt;/h2&gt;&lt;p&gt;使用下面命令进行全局安装：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="写作" scheme="https://www.tanxz.com/categories/%E5%86%99%E4%BD%9C/"/>
    
    
    <category term="Markdown" scheme="https://www.tanxz.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
