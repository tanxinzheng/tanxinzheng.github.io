{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/img/hexo-github-action.jpg","path":"img/hexo-github-action.jpg","modified":0,"renderable":0},{"_id":"source/img/hexo.jpeg","path":"img/hexo.jpeg","modified":0,"renderable":0},{"_id":"source/img/spring-cloud.jpeg","path":"img/spring-cloud.jpeg","modified":0,"renderable":0},{"_id":"source/img/linux.jpeg","path":"img/linux.jpeg","modified":0,"renderable":0},{"_id":"source/music/Memories-Maroon 5.jpg","path":"music/Memories-Maroon 5.jpg","modified":0,"renderable":0},{"_id":"source/music/Passenger.jpg","path":"music/Passenger.jpg","modified":0,"renderable":0},{"_id":"source/music/Someone You Loved-Lewis Capaldi.jpg","path":"music/Someone You Loved-Lewis Capaldi.jpg","modified":0,"renderable":0},{"_id":"source/music/Sketch Plane-Cam Kelley.jpg","path":"music/Sketch Plane-Cam Kelley.jpg","modified":0,"renderable":0},{"_id":"source/img/wechatpay.jpg","path":"img/wechatpay.jpg","modified":0,"renderable":0},{"_id":"source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":0},{"_id":"source/img/docker.png","path":"img/docker.png","modified":0,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":0},{"_id":"source/img/default_thumbnail.jpg","path":"img/default_thumbnail.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"source/img/java.jpeg","path":"img/java.jpeg","modified":0,"renderable":0},{"_id":"source/img/default.png","path":"img/default.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"source/img/banner.jpg","path":"img/banner.jpg","modified":0,"renderable":0},{"_id":"source/music/someone you loved.mp3","path":"music/someone you loved.mp3","modified":0,"renderable":0},{"_id":"source/music/memories.mp3","path":"music/memories.mp3","modified":0,"renderable":0},{"_id":"source/music/Simple Song.mp3","path":"music/Simple Song.mp3","modified":0,"renderable":0},{"_id":"source/music/M800002kitDY3lqvHN.mp3","path":"music/M800002kitDY3lqvHN.mp3","modified":0,"renderable":0},{"_id":"source/img/720430-20181226134259735-1931086473.png","path":"img/720430-20181226134259735-1931086473.png","modified":0,"renderable":0},{"_id":"source/img/720430-20181226134250810-1685533200.png","path":"img/720430-20181226134250810-1685533200.png","modified":0,"renderable":0},{"_id":"source/img/720430-20181226134308841-1109691453.png","path":"img/720430-20181226134308841-1109691453.png","modified":0,"renderable":0},{"_id":"source/img/720430-20181226134321094-1025894099.png","path":"img/720430-20181226134321094-1025894099.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/background.jpg","path":"images/background.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1585668906000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1585668906000},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1585668906000},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1585668906000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1585668906000},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1585668906000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1585668906000},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1585668906000},{"_id":"themes/next/_config.yml","hash":"b60b177f9cb53bf055d537409e03c3c4daafa50a","modified":1585668906000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1585668906000},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1585668906000},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1585668906000},{"_id":"source/_data/next.yml","hash":"23b8b1b64d7c95574e43509d1828ba78b2e1f739","modified":1608034313126},{"_id":"source/_drafts/hashtable-learning.md","hash":"d9bb5099980d04170ee62b4c7202a125c5487dca","modified":1587314053058},{"_id":"source/_drafts/data-structure-overview.md","hash":"315c759573a38c9ad62d8ed0a0e1f787a7600655","modified":1604986871695},{"_id":"source/_data/fluid_config.yml","hash":"43ea67e99b7f39487c90e9d9edc503c51fd9e95a","modified":1607994066077},{"_id":"source/_drafts/.DS_Store","hash":"23507b682cc6652f55072d30d75a60e9cb45d8c5","modified":1587395061901},{"_id":"source/_drafts/mac-brew-update.md","hash":"4b8cc48bc4a4687e1c787fd5a056bb207eb98c6d","modified":1587270394871},{"_id":"source/_drafts/mysql-index-learning.md","hash":"583bd27a0120822b8ca038b2ead7eaacb50b5802","modified":1587397504144},{"_id":"source/_drafts/tools-list.md","hash":"7db6ac4b5d1ff22de28c99552644c184650f6f64","modified":1587312444853},{"_id":"source/_posts/redis-cluster.md","hash":"2bc00c49dc8345f7ffa5bbd607f9a58f6a9aa6df","modified":1607594339819},{"_id":"source/categories/index.md","hash":"1f6f9db5cf4cba5be4d91278021eb9873b80d376","modified":1587143104377},{"_id":"source/about/index.md","hash":"b42d17bc522f1e7c3b49a344deb5e2bec2354403","modified":1587140393983},{"_id":"source/_posts/data-structure-overview.md","hash":"7d8308fd5c95687c767775e5a1c57d9d1c9c677d","modified":1594017746149},{"_id":"source/img/hexo-github-action.jpg","hash":"518d9efbbbc5f270f54775083e3ad5d397fa3256","modified":1587209572791},{"_id":"source/img/hexo.jpeg","hash":"adaaf4d9ebaea9c4a43bb90187368967a48f8888","modified":1587209427211},{"_id":"source/img/spring-cloud.jpeg","hash":"7d01a6e80f2aa14cedb2e429cde591df5a526ea4","modified":1587209893814},{"_id":"source/img/linux.jpeg","hash":"b437e6194f139a064d3e096f9fd4a107ef02dde8","modified":1587209976005},{"_id":"source/music/Memories-Maroon 5.jpg","hash":"782d0e6854c8823f40e9ae04d3903eceece3f66e","modified":1587214223762},{"_id":"source/music/Passenger.jpg","hash":"3351e31cd4d73ffcaf420f8328f4571ecea3625e","modified":1587226672228},{"_id":"source/music/Someone You Loved-Lewis Capaldi.jpg","hash":"aa2ae6acaf6c5ab8f4fbb588f8563622a4c0c809","modified":1587226271670},{"_id":"source/tags/index.md","hash":"7c33368714c02998c88ee12fd0c129599c478fa5","modified":1586971414956},{"_id":"source/music/Sketch Plane-Cam Kelley.jpg","hash":"2faabd0f61fb058d5d370f073ee0fd596f6b009a","modified":1587226985422},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1585668906000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1585668906000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1585668906000},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1585668906000},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1585668906000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1585668906000},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1585668906000},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1585668906000},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1585668906000},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1585668906000},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1585668906000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1585668906000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1585668906000},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1585668906000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1585668906000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1585668906000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1585668906000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1585668906000},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1585668906000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1585668906000},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1585668906000},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1585668906000},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1585668906000},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1585668906000},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1585668906000},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1585668906000},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1585668906000},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1585668906000},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1585668906000},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1585668906000},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1585668906000},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1585668906000},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1585668906000},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1585668906000},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1585668906000},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1585668906000},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1585668906000},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1585668906000},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1585668906000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1585668906000},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1585668906000},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1585668906000},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1585668906000},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1585668906000},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1585668906000},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1585668906000},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1585668906000},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1585668906000},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1585668906000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1585668906000},{"_id":"source/img/wechatpay.jpg","hash":"8547ff093d704c77131abe7bda9aa69ae723eac0","modified":1587266940841},{"_id":"source/_posts/data-structure-overview/linkedlist.jpg","hash":"a0e88d4b9e0f3b8fdf986a7264a82e8b5c65b52f","modified":1587390835301},{"_id":"source/_posts/data-structure-overview/hashtable.jpg","hash":"0228ea21bac82c01fdd0d9da4053897d32cb0666","modified":1587397138090},{"_id":"source/_posts/data-structure-overview/queue.png","hash":"2471e04cc8484d3796e670340ad0fa8e43232477","modified":1587390713990},{"_id":"source/_posts/data-structure-overview/heap.jpg","hash":"906ce5bed102dd1cb26e16f716793267fbe53add","modified":1587396978777},{"_id":"source/_posts/hexo/hexo写作.md","hash":"1276b9c2a15cab1b8a9198d534f2840752ca84a4","modified":1607994274082},{"_id":"source/_posts/hexo/hexo-github-action.md","hash":"d629d174492eef66471017b8ed4083caa7d40a0e","modified":1607994274082},{"_id":"source/_posts/hexo/hexo命令.md","hash":"842e2ab94b8f0a8e56ef0b21f2d0f5a77b45c6ef","modified":1607994274083},{"_id":"source/_posts/java/hashcode.md","hash":"4bd6961a2684e5bbce7522a0218e37161a0bf5ba","modified":1607994274083},{"_id":"source/_posts/java/jvm.md","hash":"16f1b3a60690bb2f1d29ae778c12b39136f40c55","modified":1607994274084},{"_id":"source/_posts/linux/linux与k8s的区别.md","hash":"20a3429a29203d3683e7e131e98201a3739ef0cc","modified":1608000870187},{"_id":"source/_posts/spring/spring-cloud-learning.md","hash":"1afee04187001ab187573d1d660939d3f561ee3c","modified":1607994274086},{"_id":"source/_posts/linux/Linux之SSH免密登录.md","hash":"a09bd0f5f4a9c9eb3cd808ce761b25800195ea1b","modified":1607994274084},{"_id":"source/_posts/中间件/kafka入门教程.md","hash":"ae15885cff93c25f313c9ac540fe6c1d4c26f4fe","modified":1607997786444},{"_id":"source/_posts/mac/Mac系统下升级node版本.md","hash":"761c3f142a3a79e840b8251c562acd6f92bf88d2","modified":1607994769802},{"_id":"source/img/alipay.jpg","hash":"d0589052ca92dc36723d0e122c0998dc829c8660","modified":1587266986049},{"_id":"source/img/docker.png","hash":"0880d9cf41fe327f3004a893a5eaa6ea382f9ea3","modified":1607994274087},{"_id":"source/img/avatar.png","hash":"61964f92efc9440d16847b1d5e5342c7d3a7a0b2","modified":1587140393984},{"_id":"source/img/default_thumbnail.jpg","hash":"1783f9565a6bc13dd2a0446d5385d27def19cac6","modified":1587140393989},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1585668906000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1585668906000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1585668906000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1585668906000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1585668906000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1585668906000},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1585668906000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1585668906000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1585668906000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1585668906000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1585668906000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1585668906000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1585668906000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1585668906000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1585668906000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1585668906000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1585668906000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"c4ec5822d644ddcedf2401837e6f6e6d3b63fbcd","modified":1585668906000},{"_id":"themes/next/layout/_macro/post.swig","hash":"71e4dc5a56cbc403d9785526f7719d824f4c8911","modified":1585668906000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1585668906000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1585668906000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"6dad1cbec13e0624f896336850d80617bf219d94","modified":1608019795951},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1585668906000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1585668906000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1585668906000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1585668906000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1585668906000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1585668906000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1585668906000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1585668906000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1585668906000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1585668906000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1585668906000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1585668906000},{"_id":"themes/next/scripts/events/index.js","hash":"bf5e93f9209d111a014a7a6a17e86c05be552d13","modified":1585668906000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1585668906000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1585668906000},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1585668906000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1585668906000},{"_id":"themes/next/scripts/filters/post.js","hash":"d86849559ae54a4098aef4e2ab9dc8f99a1d186c","modified":1585668906000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"22d77bd511fc7c1bbd12339d65004ed5bfb0713c","modified":1585668906000},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1585668906000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1585668906000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1585668906000},{"_id":"themes/next/source/css/_colors.styl","hash":"19c836f367977fb712b9868f3281ff5d757a8d5c","modified":1585668906000},{"_id":"themes/next/source/css/_mixins.styl","hash":"b79ff3debd5709397b122292fc7e551ae9d40782","modified":1585668906000},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1585668906000},{"_id":"themes/next/scripts/tags/button.js","hash":"946dd7beede408d1f090d5e9774d74763828b97c","modified":1585668906000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1585668906000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"0f133f27b61e8351cfd0959ba8a1b8551a9a8cc6","modified":1585668906000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1585668906000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1585668906000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1585668906000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1585668906000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1585668906000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1585668906000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1585668906000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1585668906000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1585668906000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1585668906000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1585668906000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1585668906000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1585668906000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1585668906000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1585668906000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1585668906000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1585668906000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1585668906000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1585668906000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1585668906000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1585668906000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1585668906000},{"_id":"themes/next/source/js/algolia-search.js","hash":"23cc3c013185eb97ef347c3b4c92d928f2f3398f","modified":1585668906000},{"_id":"themes/next/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1585668906000},{"_id":"themes/next/source/js/local-search.js","hash":"b42bd1c883ce91db8632d96e0f0e062cb6b73adc","modified":1585668906000},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1585668906000},{"_id":"themes/next/source/js/next-boot.js","hash":"a22eeb6048ddd6b9224c8a671cbcfa303a2f7a1a","modified":1585668906000},{"_id":"themes/next/source/js/utils.js","hash":"95c5d37aa06521675afcf8619cfc5dbba3d2e18a","modified":1585668906000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1585668906000},{"_id":"source/_posts/data-structure-overview/overview.png","hash":"e7ec9f16e9f389f7a20eb04f747fd0f86a8daacf","modified":1587306802908},{"_id":"source/_posts/data-structure-overview/stack.png","hash":"3736ff92eaad9a88e52c47e393513bff93b84988","modified":1587390633727},{"_id":"source/_posts/linux/linux命令/Linux命令systemd.md","hash":"988a8c67f9209663d07eb6bda0c5c327016ca401","modified":1607995102433},{"_id":"source/_posts/linux/linux命令/Linux命令killall.md","hash":"403f11fe4a2b6fb52a0706b160b1989c6b741419","modified":1607994989655},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1585668906000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"1ea12d4b9490d9065ebf1b8739b90ce5defd6398","modified":1585668906000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1585668906000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1585668906000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"12aeb9ee0d1d49d347f82a91e6bab568e1b59037","modified":1585668906000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"958e097790551c9520426a1233add03515034f35","modified":1585668906000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1585668906000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1585668906000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1585668906000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"94d54b0c65d504f772af1e62424952e092b6c21d","modified":1585668906000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"12cd9adb0c33adc484201f9e8a4e64ccf3011bae","modified":1585668906000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1585668906000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1585668906000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1585668906000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1585668906000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1585668906000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1585668906000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"ec20ff43845723e0ac2a245047c7a7e5aead6e88","modified":1585668906000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1585668906000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1585668906000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1585668906000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1585668906000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1585668906000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1585668906000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1585668906000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1585668906000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1585668906000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1585668906000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1585668906000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1585668906000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1585668906000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1585668906000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1585668906000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1585668906000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1585668906000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1585668906000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1585668906000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1585668906000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1585668906000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1585668906000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1585668906000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1585668906000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1585668906000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1585668906000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1585668906000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1585668906000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1585668906000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1585668906000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1585668906000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1585668906000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1585668906000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1f20213af8da3127701e6bb9da995e5c91be2051","modified":1585668906000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1585668906000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1585668906000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"19cbd24880d0fbbd4d5698cd54da598f03b942da","modified":1585668906000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1585668906000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1585668906000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1585668906000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6a72b5928cdab9526a288177991e4b2aedd028cf","modified":1585668906000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1585668906000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1585668906000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1585668906000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"799fdf4f258a51d45d1e2b02fb59b337e46b5b3c","modified":1585668906000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"dae390efcb5da9c021ad7f25fe2d39ff36938cc6","modified":1585668906000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"47c4f60eb7f7dc3303e84914b611dc34827069e1","modified":1585668906000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"3d9d3c14b77044d66be1898a9a934696e9127c82","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1585668906000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1585668906000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1585668906000},{"_id":"source/_posts/spring/spring-cloud-learning/7.png","hash":"4aebce32a523b2488b4c749ffa08632aee12f82e","modified":1586971414950},{"_id":"source/_posts/spring/spring-cloud-learning/1.png","hash":"abab5dc7c34d169807ac7a7b6d7cbf73638e63a6","modified":1586971414936},{"_id":"source/_posts/spring/spring-cloud-learning/2.png","hash":"5302d6db6520be044a4103187168145dd2eb3dfa","modified":1586971414938},{"_id":"source/_posts/spring/spring-cloud-learning/5.png","hash":"30f94353204cebe861c2d857e61a270a0d39d98d","modified":1586971414944},{"_id":"source/_posts/spring/spring-cloud-learning/6.png","hash":"2bbcf8a0560d84d6aa8b5cf3b4e139609d365247","modified":1586971414947},{"_id":"source/img/java.jpeg","hash":"b100e3b0e45ffdd57ca87d4976647ed2f4c09c80","modified":1587209849081},{"_id":"source/img/default.png","hash":"2e84eaeeb1f33c366bf05fa74539847da27a8560","modified":1587140393988},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"220da37051ed5dac9cf7bd126451f6aba4f94d21","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b3bea92eef0e1fe2e7e294dac2184d16b5b8d666","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"5e644b1303ab6dcd1b65ee0fd6b91309b04ce64d","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"ccb71d732b12acd02ac26ed6bbda4861d027857d","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e4f958677a75de87ee1caf7e22ba46a0602f22dd","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"82025c3ad7af12e532e2e81be98deb0a74ff23ac","modified":1585668906000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1585668906000},{"_id":"source/_posts/linux/linux与k8s的区别.assets/720430-20181226134440039-355719052.png","hash":"c8fa2724b824af9e565c8ec3c909fad02e8cc9a3","modified":1607994274085},{"_id":"source/_posts/linux/linux与k8s的区别.assets/720430-20181226134308841-1109691453.png","hash":"0880d9cf41fe327f3004a893a5eaa6ea382f9ea3","modified":1607994274085},{"_id":"source/_posts/spring/spring-cloud-learning/3.png","hash":"3ebf0ed986d4e4aa1fc327ca85b771b05745bb90","modified":1586971414940},{"_id":"source/_posts/spring/spring-cloud-learning/4.png","hash":"52162d3dc7ec73d75afa5c3b7fbd801a719d58bc","modified":1586971414942},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"c1daeb60c23945f745703ac2c3f4bf99d0ea3d95","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"89f76380091f1be49936c69bac02e984dae5ff87","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"66211794e4ed47e779ca81150cef588e0b4f2fc5","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"796eb941ba0ca03fd5ca6d15a1f6a56afd9aa174","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1585668906000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"555762730f1f31451113e8fdc84ec438ea738d90","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"a237c290e8934d1a8cbbf22b3f30503d9663021d","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1585668906000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"9b3cce30c58e57b59e45d3f668a71a4129d3a8e4","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1585668906000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1585668906000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1585668906000},{"_id":"source/_posts/data-structure-overview/tree.png","hash":"640752cff95dfa31c304680cbc1b1c7c2523425f","modified":1587396551826},{"_id":"source/_posts/spring/spring-cloud-learning/8.png","hash":"66162d84f9e742607a6036b69ec666fc0e700769","modified":1586971414956},{"_id":"source/img/banner.jpg","hash":"f73654d2ed2732a2931daa8a632bb22c1e89082b","modified":1587140393986},{"_id":"source/music/someone you loved.mp3","hash":"efce34463dd02fad2e7ee1cdfc151ae559d0297e","modified":1587226210654},{"_id":"source/music/memories.mp3","hash":"14ff8bfb41da43a206c262ea1ad1f95584a742de","modified":1587214124318},{"_id":"source/music/Simple Song.mp3","hash":"9c9e1c647434b14c9c67cfa0ad88d2ecb38ce842","modified":1587226600398},{"_id":"source/music/M800002kitDY3lqvHN.mp3","hash":"fd8a8d6c574ed2bd1373e3b4e6782ed3a035e008","modified":1587226977548},{"_id":"source/404.html","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1607999769008},{"_id":"source/img/720430-20181226134259735-1931086473.png","hash":"70db176711e85e6ba1b6031a59b00125412492d0","modified":1608000634423},{"_id":"source/img/720430-20181226134250810-1685533200.png","hash":"3b3b78ddd2fb1927cadbac96bfdfcdf829c080fb","modified":1608000639183},{"_id":"source/_posts/linux/Linux查看内存使用量.md","hash":"00f914338baadef02ca47af5d195208d382d8edc","modified":1608003514431},{"_id":"source/img/720430-20181226134308841-1109691453.png","hash":"0880d9cf41fe327f3004a893a5eaa6ea382f9ea3","modified":1607994274085},{"_id":"source/layout/_partials/footer.swig","hash":"b98af05ad1bd3f1200ae2515747b779d6114f1e3","modified":1608001457225},{"_id":"source/_posts/linux/linux与k8s的区别.assets/720430-20181226134259735-1931086473.png","hash":"70db176711e85e6ba1b6031a59b00125412492d0","modified":1608000634423},{"_id":"source/img/720430-20181226134321094-1025894099.png","hash":"fa897d20e20a15d6fb1a829904dae6455056c1ff","modified":1608000866884},{"_id":"source/_posts/linux/linux与k8s的区别.assets/720430-20181226134250810-1685533200.png","hash":"3b3b78ddd2fb1927cadbac96bfdfcdf829c080fb","modified":1608000639183},{"_id":"source/_data/styles.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608035008018},{"_id":"themes/next/source/images/background.jpg","hash":"f73654d2ed2732a2931daa8a632bb22c1e89082b","modified":1608034702518}],"Category":[],"Data":[{"_id":"next","data":{"override":true,"reminder":false,"cache":{"enable":true},"minify":false,"custom_file_path":null,"favicon":{"small":"/images/favicon-16x16-next.png","medium":"/images/favicon-32x32-next.png","apple_touch_icon":"/images/apple-touch-icon-next.png","safari_pinned_tab":"/images/logo.svg"},"language_switcher":true,"footer":{"icon":{"name":"user","animated":false,"color":"#808080"},"copyright":null,"powered":true,"beian":{"enable":false,"icp":null,"gongan_id":null,"gongan_num":null,"gongan_icon_url":null}},"creative_commons":{"license":"by-nc-sa","sidebar":false,"post":false,"language":null},"scheme":"Gemini","darkmode":false,"menu":{"home":"/ || home","about":"/about/ || user","tags":"/tags/ || tags","categories":"/categories/ || th","archives":"/archives/ || archive","schedule":"/schedule/ || calendar","sitemap":"/sitemap.xml || sitemap","commonweal":"/404.html || heartbeat"},"menu_settings":{"icons":true,"badges":false},"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"avatar":{"url":null,"rounded":false,"rotated":false},"site_state":true,"social":{"GitHub":"https://github.com/tanxinzheng || github"},"social_icons":{"enable":true,"icons_only":false,"transition":false},"links_settings":{"icon":"link","title":"Links","layout":"block"},"links":null,"toc":{"enable":true,"number":true,"wrap":false,"expand_all":false,"max_depth":6},"chat":{"enable":false,"icon":"comment","text":"Chat"},"excerpt_description":true,"read_more_btn":true,"post_meta":{"item_text":true,"created_at":true,"updated_at":{"enable":true,"another_day":true},"categories":true},"symbols_count_time":{"separated_meta":true,"item_text_post":true,"item_text_total":false},"tag_icon":false,"reward_settings":{"enable":true,"animation":false},"reward":{"wechatpay":"/img/wechatpay.jpg","alipay":"/img/alipay.jpg"},"follow_me":null,"related_posts":{"enable":false,"title":null,"display_in_home":false,"params":{"maxCount":5}},"post_edit":{"enable":false,"url":"https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name"},"post_navigation":"left","tagcloud":{"min":12,"max":30,"start":"#ccc","end":"#111","amount":200},"calendar":{"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"showDeleted":false,"singleEvents":true,"maxResults":250},"text_align":{"desktop":"justify","mobile":"justify"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":null,"codeblock":{"highlight_theme":"normal","copy_button":{"enable":false,"show_result":false,"style":null}},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"reading_progress":{"enable":false,"position":"top","color":"#37c6c0","height":"3px"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"github_banner":{"enable":false,"permalink":"https://github.com/yourname","title":"Follow me on GitHub"},"font":{"enable":false,"host":null,"global":{"external":true,"family":"Lato","size":null},"title":{"external":true,"family":null,"size":null},"headings":{"external":true,"family":null,"size":null},"posts":{"external":true,"family":null},"codes":{"external":true,"family":null}},"disable_baidu_transformation":false,"index_with_subtitle":false,"exturl":false,"google_site_verification":null,"bing_site_verification":null,"yandex_site_verification":null,"baidu_site_verification":null,"baidu_push":false,"math":{"per_page":true,"mathjax":{"enable":false,"mhchem":false},"katex":{"enable":false,"copy_tex":false}},"pjax":false,"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"quicklink":{"enable":false,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"ignores":null},"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"disqus":{"enable":false,"shortname":null,"count":true},"disqusjs":{"enable":false,"api":null,"apikey":null,"shortname":null},"changyan":{"enable":false,"appid":null,"appkey":null},"valine":{"enable":false,"appid":null,"appkey":null,"notify":false,"verify":false,"placeholder":"Just go go","avatar":"mm","guest_info":"nick,mail,link","pageSize":10,"language":null,"visitor":false,"comment_count":true,"recordIP":false,"serverURLs":null},"livere_uid":null,"gitalk":{"enable":false,"github_id":null,"repo":null,"client_id":null,"client_secret":null,"admin_user":null,"distraction_free_mode":true,"language":null},"rating":{"enable":false,"id":null,"color":"fc6423"},"add_this_id":null,"google_analytics":{"tracking_id":null,"only_pageview":false},"baidu_analytics":null,"growingio_analytics":null,"cnzz_siteid":null,"leancloud_visitors":{"enable":false,"app_id":null,"app_key":null,"server_url":null,"security":true},"firestore":{"enable":false,"collection":"articles","apiKey":null,"projectId":null},"busuanzi_count":{"enable":false,"total_visitors":true,"total_visitors_icon":"user","total_views":true,"total_views_icon":"eye","post_views":true,"post_views_icon":"eye"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"swiftype_key":null,"chatra":{"enable":false,"async":true,"id":null},"tidio":{"enable":false,"key":null},"note":{"style":"simple","icons":false,"light_bg_offset":0},"tabs":{"transition":{"tabs":false,"labels":true}},"pdf":{"enable":false,"height":"500px"},"mermaid":{"enable":false,"theme":"forest"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"pace":{"enable":false,"theme":"minimal"},"three":{"enable":false,"three_waves":false,"canvas_lines":false,"canvas_sphere":false},"canvas_ribbon":{"enable":false,"size":300,"alpha":0.6,"zIndex":-1},"vendors":{"_internal":"lib","anime":null,"fontawesome":null,"mathjax":null,"katex":null,"copy_tex_js":null,"copy_tex_css":null,"pjax":null,"jquery":null,"fancybox":null,"fancybox_css":null,"mediumzoom":null,"lazyload":null,"pangu":null,"quicklink":null,"disqusjs_js":null,"disqusjs_css":null,"valine":null,"gitalk_js":null,"gitalk_css":null,"algolia_search":null,"instant_search":null,"mermaid":null,"velocity":null,"velocity_ui":null,"pace":null,"pace_css":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null},"css":"css","js":"js","images":"images"}},{"_id":"fluid_config","data":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}},{"_id":"styles","data":""}],"Page":[{"layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"layout: categories\ncomments: false\n---","date":"2020-04-17T17:05:04.377Z","updated":"2020-04-17T17:05:04.377Z","path":"categories/index.html","title":"","_id":"ckipcgz4d0001mxcd7ujlehh3","content":"","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":""},{"title":"about","date":"2018-04-16T05:01:39.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-04-16 13:01:39\nlayout: about\n---\n","updated":"2020-04-17T16:19:53.983Z","path":"about/index.html","comments":1,"_id":"ckipcgz4g0003mxcdgcfkcttq","content":"","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":""},{"layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"layout: tags\ncomments: false\n---","date":"2020-04-15T17:23:34.956Z","updated":"2020-04-15T17:23:34.956Z","path":"tags/index.html","title":"","_id":"ckipcgz5s000omxcd66fygh5r","content":"","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":""},{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2020-12-15T02:36:09.008Z","updated":"2020-12-15T02:36:09.008Z","path":"404.html","_id":"ckipdjlfn0000xccd18qq9ltk","title":"","comments":1,"layout":"page","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","site":{"data":{"next":{"override":false,"reminder":false,"cache":{"enable":true},"minify":false,"custom_file_path":null,"favicon":{"small":"/images/favicon-16x16-next.png","medium":"/images/favicon-32x32-next.png","apple_touch_icon":"/images/apple-touch-icon-next.png","safari_pinned_tab":"/images/logo.svg"},"language_switcher":true,"footer":{"icon":{"name":"user","animated":false,"color":"#808080"},"copyright":null,"powered":true,"beian":{"enable":false,"icp":null,"gongan_id":null,"gongan_num":null,"gongan_icon_url":null}},"creative_commons":{"license":"by-nc-sa","sidebar":false,"post":false,"language":null},"scheme":"Gemini","darkmode":false,"menu":{"home":"/ || home","about":"/about/ || user","tags":"/tags/ || tags","categories":"/categories/ || th","archives":"/archives/ || archive","schedule":"/schedule/ || calendar","sitemap":"/sitemap.xml || sitemap","commonweal":"/404/ || heartbeat"},"menu_settings":{"icons":true,"badges":false},"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"avatar":{"url":null,"rounded":false,"rotated":false},"site_state":true,"social":{"GitHub":"https://github.com/tanxinzheng || github"},"social_icons":{"enable":true,"icons_only":false,"transition":false},"links_settings":{"icon":"link","title":"Links","layout":"block"},"links":null,"toc":{"enable":true,"number":true,"wrap":false,"expand_all":false,"max_depth":6},"chat":{"enable":false,"icon":"comment","text":"Chat"},"excerpt_description":true,"read_more_btn":true,"post_meta":{"item_text":true,"created_at":true,"updated_at":{"enable":true,"another_day":true},"categories":true},"symbols_count_time":{"separated_meta":true,"item_text_post":true,"item_text_total":false},"tag_icon":false,"reward_settings":{"enable":false,"animation":false},"reward":null,"follow_me":null,"related_posts":{"enable":false,"title":null,"display_in_home":false,"params":{"maxCount":5}},"post_edit":{"enable":false,"url":"https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name"},"post_navigation":"left","tagcloud":{"min":12,"max":30,"start":"#ccc","end":"#111","amount":200},"calendar":{"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"showDeleted":false,"singleEvents":true,"maxResults":250},"text_align":{"desktop":"justify","mobile":"justify"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":null,"codeblock":{"highlight_theme":"normal","copy_button":{"enable":false,"show_result":false,"style":null}},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"reading_progress":{"enable":false,"position":"top","color":"#37c6c0","height":"3px"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"github_banner":{"enable":false,"permalink":"https://github.com/yourname","title":"Follow me on GitHub"},"font":{"enable":false,"host":null,"global":{"external":true,"family":"Lato","size":null},"title":{"external":true,"family":null,"size":null},"headings":{"external":true,"family":null,"size":null},"posts":{"external":true,"family":null},"codes":{"external":true,"family":null}},"disable_baidu_transformation":false,"index_with_subtitle":false,"exturl":false,"google_site_verification":null,"bing_site_verification":null,"yandex_site_verification":null,"baidu_site_verification":null,"baidu_push":false,"math":{"per_page":true,"mathjax":{"enable":false,"mhchem":false},"katex":{"enable":false,"copy_tex":false}},"pjax":false,"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"quicklink":{"enable":false,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"ignores":null},"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"disqus":{"enable":false,"shortname":null,"count":true},"disqusjs":{"enable":false,"api":null,"apikey":null,"shortname":null},"changyan":{"enable":false,"appid":null,"appkey":null},"valine":{"enable":false,"appid":null,"appkey":null,"notify":false,"verify":false,"placeholder":"Just go go","avatar":"mm","guest_info":"nick,mail,link","pageSize":10,"language":null,"visitor":false,"comment_count":true,"recordIP":false,"serverURLs":null},"livere_uid":null,"gitalk":{"enable":false,"github_id":null,"repo":null,"client_id":null,"client_secret":null,"admin_user":null,"distraction_free_mode":true,"language":null},"rating":{"enable":false,"id":null,"color":"fc6423"},"add_this_id":null,"google_analytics":{"tracking_id":null,"only_pageview":false},"baidu_analytics":null,"growingio_analytics":null,"cnzz_siteid":null,"leancloud_visitors":{"enable":false,"app_id":null,"app_key":null,"server_url":null,"security":true},"firestore":{"enable":false,"collection":"articles","apiKey":null,"projectId":null},"busuanzi_count":{"enable":false,"total_visitors":true,"total_visitors_icon":"user","total_views":true,"total_views_icon":"eye","post_views":true,"post_views_icon":"eye"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"swiftype_key":null,"chatra":{"enable":false,"async":true,"id":null},"tidio":{"enable":false,"key":null},"note":{"style":"simple","icons":false,"light_bg_offset":0},"tabs":{"transition":{"tabs":false,"labels":true}},"pdf":{"enable":false,"height":"500px"},"mermaid":{"enable":false,"theme":"forest"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"pace":{"enable":false,"theme":"minimal"},"three":{"enable":false,"three_waves":false,"canvas_lines":false,"canvas_sphere":false},"canvas_ribbon":{"enable":false,"size":300,"alpha":0.6,"zIndex":-1},"vendors":{"_internal":"lib","anime":null,"fontawesome":null,"mathjax":null,"katex":null,"copy_tex_js":null,"copy_tex_css":null,"pjax":null,"jquery":null,"fancybox":null,"fancybox_css":null,"mediumzoom":null,"lazyload":null,"pangu":null,"quicklink":null,"disqusjs_js":null,"disqusjs_css":null,"valine":null,"gitalk_js":null,"gitalk_css":null,"algolia_search":null,"instant_search":null,"mermaid":null,"velocity":null,"velocity_ui":null,"pace":null,"pace_css":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null},"css":"css","js":"js","images":"images"},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>"}],"Post":[{"title":"【数据结构】之哈希表（散列表）","abbrlink":3309293362,"date":"2020-04-19T13:17:16.000Z","_content":"\n# 什么是哈希表？\n哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n记录的存储位置=f(关键字)\n\n这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。\n\n哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）\n    而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。\n\n## 参考\n[参考文章](https://blog.csdn.net/duan19920101/article/details/51579136?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)","source":"_drafts/hashtable-learning.md","raw":"---\ntitle: 【数据结构】之哈希表（散列表）\nabbrlink: 3309293362\ndate: 2020-04-19 21:17:16\ntags:\n  - 数据结构\n---\n\n# 什么是哈希表？\n哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n记录的存储位置=f(关键字)\n\n这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。\n\n哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）\n    而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。\n\n## 参考\n[参考文章](https://blog.csdn.net/duan19920101/article/details/51579136?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2)","slug":"hashtable-learning","published":0,"updated":"2020-04-19T16:34:13.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz450000mxcd0gyn1o4p","content":"<h1 id=\"什么是哈希表？\"><a href=\"#什么是哈希表？\" class=\"headerlink\" title=\"什么是哈希表？\"></a>什么是哈希表？</h1><p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>记录的存储位置=f(关键字)</p>\n<p>这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。</p>\n<p>哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）<br>    而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/duan19920101/article/details/51579136?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2\" target=\"_blank\" rel=\"noopener\">参考文章</a></p>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h1 id=\"什么是哈希表？\"><a href=\"#什么是哈希表？\" class=\"headerlink\" title=\"什么是哈希表？\"></a>什么是哈希表？</h1><p>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>记录的存储位置=f(关键字)</p>\n<p>这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。</p>\n<p>哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）<br>    而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/duan19920101/article/details/51579136?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2\" target=\"_blank\" rel=\"noopener\">参考文章</a></p>\n"},{"title":"MacOS平台brew update卡死","abbrlink":2155797608,"date":"2020-04-19T04:24:47.000Z","_content":"\n","source":"_drafts/mac-brew-update.md","raw":"---\ntitle: MacOS平台brew update卡死\nabbrlink: 2155797608\ndate: 2020-04-19 12:24:47\ntags:\n  - Mac\n  - Linux\n---\n\n","slug":"mac-brew-update","published":0,"updated":"2020-04-19T04:26:34.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz4e0002mxcd7nkf2iuq","content":"","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":""},{"title":"【MySQL】索引及分页详解","abbrlink":780159822,"date":"2018-07-19T13:38:18.000Z","_content":"\n# 什么是索引\n索引是数据表中一列或多列的值进行排序的一种数据结构。故此，索引本质就是数据结构。这也是为什么每次数据表建立索引都需要设置在列字段上的原因。\n\n\n# 常用的索引结构是什么\n## 参考\n# https://mp.weixin.qq.com/s/5Yl6H6up9ntZq6l8qxiogw","source":"_drafts/mysql-index-learning.md","raw":"---\ntitle: 【MySQL】索引及分页详解\ntags:\n  - MySQL\nabbrlink: 780159822\ndate: 2018-07-19 21:38:18\n---\n\n# 什么是索引\n索引是数据表中一列或多列的值进行排序的一种数据结构。故此，索引本质就是数据结构。这也是为什么每次数据表建立索引都需要设置在列字段上的原因。\n\n\n# 常用的索引结构是什么\n## 参考\n# https://mp.weixin.qq.com/s/5Yl6H6up9ntZq6l8qxiogw","slug":"mysql-index-learning","published":0,"updated":"2020-04-20T15:45:04.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz4i0005mxcda3cd4y3x","content":"<h1 id=\"什么是索引\"><a href=\"#什么是索引\" class=\"headerlink\" title=\"什么是索引\"></a>什么是索引</h1><p>索引是数据表中一列或多列的值进行排序的一种数据结构。故此，索引本质就是数据结构。这也是为什么每次数据表建立索引都需要设置在列字段上的原因。</p>\n<h1 id=\"常用的索引结构是什么\"><a href=\"#常用的索引结构是什么\" class=\"headerlink\" title=\"常用的索引结构是什么\"></a>常用的索引结构是什么</h1><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h1 id=\"https-mp-weixin-qq-com-s-5Yl6H6up9ntZq6l8qxiogw\"><a href=\"#https-mp-weixin-qq-com-s-5Yl6H6up9ntZq6l8qxiogw\" class=\"headerlink\" title=\"https://mp.weixin.qq.com/s/5Yl6H6up9ntZq6l8qxiogw\"></a><a href=\"https://mp.weixin.qq.com/s/5Yl6H6up9ntZq6l8qxiogw\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/5Yl6H6up9ntZq6l8qxiogw</a></h1>","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h1 id=\"什么是索引\"><a href=\"#什么是索引\" class=\"headerlink\" title=\"什么是索引\"></a>什么是索引</h1><p>索引是数据表中一列或多列的值进行排序的一种数据结构。故此，索引本质就是数据结构。这也是为什么每次数据表建立索引都需要设置在列字段上的原因。</p>\n<h1 id=\"常用的索引结构是什么\"><a href=\"#常用的索引结构是什么\" class=\"headerlink\" title=\"常用的索引结构是什么\"></a>常用的索引结构是什么</h1><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><h1 id=\"https-mp-weixin-qq-com-s-5Yl6H6up9ntZq6l8qxiogw\"><a href=\"#https-mp-weixin-qq-com-s-5Yl6H6up9ntZq6l8qxiogw\" class=\"headerlink\" title=\"https://mp.weixin.qq.com/s/5Yl6H6up9ntZq6l8qxiogw\"></a><a href=\"https://mp.weixin.qq.com/s/5Yl6H6up9ntZq6l8qxiogw\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/5Yl6H6up9ntZq6l8qxiogw</a></h1>"},{"title":"tools-list","abbrlink":189015225,"_content":"","source":"_drafts/tools-list.md","raw":"---\ntitle: tools-list\nabbrlink: 189015225\ntags:\n---\n","slug":"tools-list","published":0,"date":"2020-04-19T13:41:09.626Z","updated":"2020-04-19T16:07:24.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz4j0006mxcdg8vw4y8i","content":"","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":""},{"title":"Docker之Redis Cluster搭建","abbrlink":41928529,"date":"2020-12-10T08:33:34.000Z","_content":"\n## 环境\n\nDocker 版本 19.03.8\n```\nMacBook-Pro-6:~ tanxinzheng$ docker -v\nDocker version 19.03.8, build afacb8b\n```\n\n## 搭建\n搭建的部署主要分为\n- 架构设计\n- 编写Docker Compose编排文件\n- 创建redis cluster配置文件\n- 启动服务容器\n- 创建Redis集群\n\n### 架构设计\nredis集群模式必须要有3个主节点3个从节点才能正常启动集群模式\n\n- 主节点端口：7000 | 7001 | 7002\n- 从节点端口：7003 | 7004 | 7005\n\n### Docker Compose\n为节省内存资源，主从节点都部署在单机实例中\n```\nversion: '2'\n\nservices:\n  cluster:\n    image: daocloud.io/redis\n    container_name: redis-cluster\n    # 添加该参数后服务后台运行后，容器不会自动退出\n    tty: true\n    restart: always\n    # linux环境下建议使用host模式\n    network_mode: host\n\n    volumes:\n      - ./data:/data\n      - ./config:/etc/redis  \n    ports:\n      - \"7000:7000\"\n      - \"7001:7001\"\n      - \"7002:7002\"\n      - \"7003:7003\"\n      - \"7004:7004\"\n      - \"7005:7005\"\n    ## 必须使用宿主机ip 作为集群总线ip，否则宿主机无法访问到容器内的redis集群ip \n    # 也可以加在配置文件中\n    #  --cluster-announce-ip 172.16.65.218 \n    command: \n      - /bin/bash \n      - -c \n      - |\n        redis-server /etc/redis/redis_cluster_7000.conf  --cluster-announce-ip 172.16.65.218 & \n        redis-server /etc/redis/redis_cluster_7001.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7002.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7003.conf  --cluster-announce-ip 172.16.65.218 & \n        redis-server /etc/redis/redis_cluster_7004.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7005.conf  --cluster-announce-ip 172.16.65.218 \n```\n### redis_700X.conf\n根据各端口修改配置中的端口号\n```\nport 7000\n# 绑定机器的内网IP或者公网IP,一定要设置，不要用 127.0.0.1\nbind 0.0.0.0\n# 启用集群模式\ncluster-enabled yes\n# 集群节点文件\ncluster-config-file nodes_7000.conf\n# 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录\ndir /data/7000/\n# 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间\ncluster-node-timeout 5000\n# 集群广播ip\n#cluster-announce-ip 172.20.0.4\n#cluster-announce-port 7000\n# 开启AOF模式\nappendonly yes\n# 关闭保护模式\nprotected-mode no\n# 是否后台启动\ndaemonize no\n# pid file所在目录\npidfile /var/run/redis_7000.pid \n# 客户端访问密码\n# requirepass redis2020\n# 日志文件\nlogfile /var/log/redis_7001.log\n```\n\n## 启动Redis Cluster\n```\ndocker-compose up -d\n```\n\n### 创建Redis集群\n\n- 进入容器\n```\n$ docker exec -it redis-cluster /bin/bash\n```\n- 创建集群\n```\n$ redis-cli --cluster create 127.0.0.1:7000 \\\n                           127.0.0.1:7001 \\\n                           127.0.0.1:7002 \\\n                           127.0.0.1:7003 \\\n                           127.0.0.1:7004 \\\n                           127.0.0.1:7005 \\\n                           --cluster-replicas 1\n```\n\n## 查看集群状态\n\n### \n```\n## -c表示集群模式进入\nroot@docker-desktop:/data# redis-cli -c -h localhost -p 7000\n\n## 查看集群信息 cluster_state为ok则表示集群创建成功\nlocalhost:7000> cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:6\ncluster_size:1\ncluster_current_epoch:6\ncluster_my_epoch:3\ncluster_stats_messages_ping_sent:5290\ncluster_stats_messages_pong_sent:5299\ncluster_stats_messages_update_sent:1\ncluster_stats_messages_sent:10590\ncluster_stats_messages_ping_received:5294\ncluster_stats_messages_pong_received:5290\ncluster_stats_messages_meet_received:5\ncluster_stats_messages_update_received:3\ncluster_stats_messages_received:10592\n\n## 查看集群节点信息\nlocalhost:7000> cluster nodes\n6b7f8c4767feb376a99e79068748253afcf6ea5a 127.0.0.1:7001@17001 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594235646 3 connected\n52b109a6491a2e4280b6a66642716939d0f46e89 127.0.0.1:7004@17004 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594236555 5 connected\ndf7dcbf82ecba0ff044f2715b052674e73ec1ca6 127.0.0.1:7000@17000 myself,slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594234000 1 connected\n51f5c9fb771a702933d8bc29fcd13eb41811e2bb 127.0.0.1:7005@17005 master - 0 1607594236000 6 connected\nef7fdf2421427d1da29da4c1dab9e8c26ca12854 127.0.0.1:7002@17002 master - 0 1607594236657 3 connected 0-16383\ncf7327c9ec3b374ebc6ba3f49c6bd5e0a7098601 127.0.0.1:7003@17003 master - 0 1607594235544 4 connected\n```\n\n## 参考\n- [1] [Redis Cluster](https://redis.io/topics/cluster-tutorial)","source":"_posts/redis-cluster.md","raw":"---\ntitle: Docker之Redis Cluster搭建\ntags:\n  - redis\n  - cluster\n  - docker\n  - docker-compose\nabbrlink: 41928529\ndate: 2020-12-10 16:33:34\n---\n\n## 环境\n\nDocker 版本 19.03.8\n```\nMacBook-Pro-6:~ tanxinzheng$ docker -v\nDocker version 19.03.8, build afacb8b\n```\n\n## 搭建\n搭建的部署主要分为\n- 架构设计\n- 编写Docker Compose编排文件\n- 创建redis cluster配置文件\n- 启动服务容器\n- 创建Redis集群\n\n### 架构设计\nredis集群模式必须要有3个主节点3个从节点才能正常启动集群模式\n\n- 主节点端口：7000 | 7001 | 7002\n- 从节点端口：7003 | 7004 | 7005\n\n### Docker Compose\n为节省内存资源，主从节点都部署在单机实例中\n```\nversion: '2'\n\nservices:\n  cluster:\n    image: daocloud.io/redis\n    container_name: redis-cluster\n    # 添加该参数后服务后台运行后，容器不会自动退出\n    tty: true\n    restart: always\n    # linux环境下建议使用host模式\n    network_mode: host\n\n    volumes:\n      - ./data:/data\n      - ./config:/etc/redis  \n    ports:\n      - \"7000:7000\"\n      - \"7001:7001\"\n      - \"7002:7002\"\n      - \"7003:7003\"\n      - \"7004:7004\"\n      - \"7005:7005\"\n    ## 必须使用宿主机ip 作为集群总线ip，否则宿主机无法访问到容器内的redis集群ip \n    # 也可以加在配置文件中\n    #  --cluster-announce-ip 172.16.65.218 \n    command: \n      - /bin/bash \n      - -c \n      - |\n        redis-server /etc/redis/redis_cluster_7000.conf  --cluster-announce-ip 172.16.65.218 & \n        redis-server /etc/redis/redis_cluster_7001.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7002.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7003.conf  --cluster-announce-ip 172.16.65.218 & \n        redis-server /etc/redis/redis_cluster_7004.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7005.conf  --cluster-announce-ip 172.16.65.218 \n```\n### redis_700X.conf\n根据各端口修改配置中的端口号\n```\nport 7000\n# 绑定机器的内网IP或者公网IP,一定要设置，不要用 127.0.0.1\nbind 0.0.0.0\n# 启用集群模式\ncluster-enabled yes\n# 集群节点文件\ncluster-config-file nodes_7000.conf\n# 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录\ndir /data/7000/\n# 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间\ncluster-node-timeout 5000\n# 集群广播ip\n#cluster-announce-ip 172.20.0.4\n#cluster-announce-port 7000\n# 开启AOF模式\nappendonly yes\n# 关闭保护模式\nprotected-mode no\n# 是否后台启动\ndaemonize no\n# pid file所在目录\npidfile /var/run/redis_7000.pid \n# 客户端访问密码\n# requirepass redis2020\n# 日志文件\nlogfile /var/log/redis_7001.log\n```\n\n## 启动Redis Cluster\n```\ndocker-compose up -d\n```\n\n### 创建Redis集群\n\n- 进入容器\n```\n$ docker exec -it redis-cluster /bin/bash\n```\n- 创建集群\n```\n$ redis-cli --cluster create 127.0.0.1:7000 \\\n                           127.0.0.1:7001 \\\n                           127.0.0.1:7002 \\\n                           127.0.0.1:7003 \\\n                           127.0.0.1:7004 \\\n                           127.0.0.1:7005 \\\n                           --cluster-replicas 1\n```\n\n## 查看集群状态\n\n### \n```\n## -c表示集群模式进入\nroot@docker-desktop:/data# redis-cli -c -h localhost -p 7000\n\n## 查看集群信息 cluster_state为ok则表示集群创建成功\nlocalhost:7000> cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:6\ncluster_size:1\ncluster_current_epoch:6\ncluster_my_epoch:3\ncluster_stats_messages_ping_sent:5290\ncluster_stats_messages_pong_sent:5299\ncluster_stats_messages_update_sent:1\ncluster_stats_messages_sent:10590\ncluster_stats_messages_ping_received:5294\ncluster_stats_messages_pong_received:5290\ncluster_stats_messages_meet_received:5\ncluster_stats_messages_update_received:3\ncluster_stats_messages_received:10592\n\n## 查看集群节点信息\nlocalhost:7000> cluster nodes\n6b7f8c4767feb376a99e79068748253afcf6ea5a 127.0.0.1:7001@17001 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594235646 3 connected\n52b109a6491a2e4280b6a66642716939d0f46e89 127.0.0.1:7004@17004 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594236555 5 connected\ndf7dcbf82ecba0ff044f2715b052674e73ec1ca6 127.0.0.1:7000@17000 myself,slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594234000 1 connected\n51f5c9fb771a702933d8bc29fcd13eb41811e2bb 127.0.0.1:7005@17005 master - 0 1607594236000 6 connected\nef7fdf2421427d1da29da4c1dab9e8c26ca12854 127.0.0.1:7002@17002 master - 0 1607594236657 3 connected 0-16383\ncf7327c9ec3b374ebc6ba3f49c6bd5e0a7098601 127.0.0.1:7003@17003 master - 0 1607594235544 4 connected\n```\n\n## 参考\n- [1] [Redis Cluster](https://redis.io/topics/cluster-tutorial)","slug":"redis-cluster","published":1,"updated":"2020-12-10T09:58:59.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz4k0007mxcd89izgkbn","content":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>Docker 版本 19.03.8</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MacBook-Pro-6:~ tanxinzheng$ docker -v</span><br><span class=\"line\">Docker version 19.03.8, build afacb8b</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h2><p>搭建的部署主要分为</p>\n<ul>\n<li>架构设计</li>\n<li>编写Docker Compose编排文件</li>\n<li>创建redis cluster配置文件</li>\n<li>启动服务容器</li>\n<li>创建Redis集群</li>\n</ul>\n<h3 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h3><p>redis集群模式必须要有3个主节点3个从节点才能正常启动集群模式</p>\n<ul>\n<li>主节点端口：7000 | 7001 | 7002</li>\n<li>从节点端口：7003 | 7004 | 7005</li>\n</ul>\n<h3 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker Compose\"></a>Docker Compose</h3><p>为节省内存资源，主从节点都部署在单机实例中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: &#39;2&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">services:</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    image: daocloud.io&#x2F;redis</span><br><span class=\"line\">    container_name: redis-cluster</span><br><span class=\"line\">    # 添加该参数后服务后台运行后，容器不会自动退出</span><br><span class=\"line\">    tty: true</span><br><span class=\"line\">    restart: always</span><br><span class=\"line\">    # linux环境下建议使用host模式</span><br><span class=\"line\">    network_mode: host</span><br><span class=\"line\"></span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - .&#x2F;data:&#x2F;data</span><br><span class=\"line\">      - .&#x2F;config:&#x2F;etc&#x2F;redis  </span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - &quot;7000:7000&quot;</span><br><span class=\"line\">      - &quot;7001:7001&quot;</span><br><span class=\"line\">      - &quot;7002:7002&quot;</span><br><span class=\"line\">      - &quot;7003:7003&quot;</span><br><span class=\"line\">      - &quot;7004:7004&quot;</span><br><span class=\"line\">      - &quot;7005:7005&quot;</span><br><span class=\"line\">    ## 必须使用宿主机ip 作为集群总线ip，否则宿主机无法访问到容器内的redis集群ip </span><br><span class=\"line\">    # 也可以加在配置文件中</span><br><span class=\"line\">    #  --cluster-announce-ip 172.16.65.218 </span><br><span class=\"line\">    command: </span><br><span class=\"line\">      - &#x2F;bin&#x2F;bash </span><br><span class=\"line\">      - -c </span><br><span class=\"line\">      - |</span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7000.conf  --cluster-announce-ip 172.16.65.218 &amp; </span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7001.conf  --cluster-announce-ip 172.16.65.218 &amp;</span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7002.conf  --cluster-announce-ip 172.16.65.218 &amp;</span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7003.conf  --cluster-announce-ip 172.16.65.218 &amp; </span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7004.conf  --cluster-announce-ip 172.16.65.218 &amp;</span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7005.conf  --cluster-announce-ip 172.16.65.218</span><br></pre></td></tr></table></figure>\n<h3 id=\"redis-700X-conf\"><a href=\"#redis-700X-conf\" class=\"headerlink\" title=\"redis_700X.conf\"></a>redis_700X.conf</h3><p>根据各端口修改配置中的端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 7000</span><br><span class=\"line\"># 绑定机器的内网IP或者公网IP,一定要设置，不要用 127.0.0.1</span><br><span class=\"line\">bind 0.0.0.0</span><br><span class=\"line\"># 启用集群模式</span><br><span class=\"line\">cluster-enabled yes</span><br><span class=\"line\"># 集群节点文件</span><br><span class=\"line\">cluster-config-file nodes_7000.conf</span><br><span class=\"line\"># 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录</span><br><span class=\"line\">dir &#x2F;data&#x2F;7000&#x2F;</span><br><span class=\"line\"># 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间</span><br><span class=\"line\">cluster-node-timeout 5000</span><br><span class=\"line\"># 集群广播ip</span><br><span class=\"line\">#cluster-announce-ip 172.20.0.4</span><br><span class=\"line\">#cluster-announce-port 7000</span><br><span class=\"line\"># 开启AOF模式</span><br><span class=\"line\">appendonly yes</span><br><span class=\"line\"># 关闭保护模式</span><br><span class=\"line\">protected-mode no</span><br><span class=\"line\"># 是否后台启动</span><br><span class=\"line\">daemonize no</span><br><span class=\"line\"># pid file所在目录</span><br><span class=\"line\">pidfile &#x2F;var&#x2F;run&#x2F;redis_7000.pid </span><br><span class=\"line\"># 客户端访问密码</span><br><span class=\"line\"># requirepass redis2020</span><br><span class=\"line\"># 日志文件</span><br><span class=\"line\">logfile &#x2F;var&#x2F;log&#x2F;redis_7001.log</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动Redis-Cluster\"><a href=\"#启动Redis-Cluster\" class=\"headerlink\" title=\"启动Redis Cluster\"></a>启动Redis Cluster</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建Redis集群\"><a href=\"#创建Redis集群\" class=\"headerlink\" title=\"创建Redis集群\"></a>创建Redis集群</h3><ul>\n<li>进入容器<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker exec -it redis-cluster &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li>\n<li>创建集群<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ redis-cli --cluster create 127.0.0.1:7000 \\</span><br><span class=\"line\">                           127.0.0.1:7001 \\</span><br><span class=\"line\">                           127.0.0.1:7002 \\</span><br><span class=\"line\">                           127.0.0.1:7003 \\</span><br><span class=\"line\">                           127.0.0.1:7004 \\</span><br><span class=\"line\">                           127.0.0.1:7005 \\</span><br><span class=\"line\">                           --cluster-replicas 1</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"查看集群状态\"><a href=\"#查看集群状态\" class=\"headerlink\" title=\"查看集群状态\"></a>查看集群状态</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## -c表示集群模式进入</span><br><span class=\"line\">root@docker-desktop:&#x2F;data# redis-cli -c -h localhost -p 7000</span><br><span class=\"line\"></span><br><span class=\"line\">## 查看集群信息 cluster_state为ok则表示集群创建成功</span><br><span class=\"line\">localhost:7000&gt; cluster info</span><br><span class=\"line\">cluster_state:ok</span><br><span class=\"line\">cluster_slots_assigned:16384</span><br><span class=\"line\">cluster_slots_ok:16384</span><br><span class=\"line\">cluster_slots_pfail:0</span><br><span class=\"line\">cluster_slots_fail:0</span><br><span class=\"line\">cluster_known_nodes:6</span><br><span class=\"line\">cluster_size:1</span><br><span class=\"line\">cluster_current_epoch:6</span><br><span class=\"line\">cluster_my_epoch:3</span><br><span class=\"line\">cluster_stats_messages_ping_sent:5290</span><br><span class=\"line\">cluster_stats_messages_pong_sent:5299</span><br><span class=\"line\">cluster_stats_messages_update_sent:1</span><br><span class=\"line\">cluster_stats_messages_sent:10590</span><br><span class=\"line\">cluster_stats_messages_ping_received:5294</span><br><span class=\"line\">cluster_stats_messages_pong_received:5290</span><br><span class=\"line\">cluster_stats_messages_meet_received:5</span><br><span class=\"line\">cluster_stats_messages_update_received:3</span><br><span class=\"line\">cluster_stats_messages_received:10592</span><br><span class=\"line\"></span><br><span class=\"line\">## 查看集群节点信息</span><br><span class=\"line\">localhost:7000&gt; cluster nodes</span><br><span class=\"line\">6b7f8c4767feb376a99e79068748253afcf6ea5a 127.0.0.1:7001@17001 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594235646 3 connected</span><br><span class=\"line\">52b109a6491a2e4280b6a66642716939d0f46e89 127.0.0.1:7004@17004 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594236555 5 connected</span><br><span class=\"line\">df7dcbf82ecba0ff044f2715b052674e73ec1ca6 127.0.0.1:7000@17000 myself,slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594234000 1 connected</span><br><span class=\"line\">51f5c9fb771a702933d8bc29fcd13eb41811e2bb 127.0.0.1:7005@17005 master - 0 1607594236000 6 connected</span><br><span class=\"line\">ef7fdf2421427d1da29da4c1dab9e8c26ca12854 127.0.0.1:7002@17002 master - 0 1607594236657 3 connected 0-16383</span><br><span class=\"line\">cf7327c9ec3b374ebc6ba3f49c6bd5e0a7098601 127.0.0.1:7003@17003 master - 0 1607594235544 4 connected</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>[1] <a href=\"https://redis.io/topics/cluster-tutorial\" target=\"_blank\" rel=\"noopener\">Redis Cluster</a></li>\n</ul>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>Docker 版本 19.03.8</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MacBook-Pro-6:~ tanxinzheng$ docker -v</span><br><span class=\"line\">Docker version 19.03.8, build afacb8b</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h2><p>搭建的部署主要分为</p>\n<ul>\n<li>架构设计</li>\n<li>编写Docker Compose编排文件</li>\n<li>创建redis cluster配置文件</li>\n<li>启动服务容器</li>\n<li>创建Redis集群</li>\n</ul>\n<h3 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h3><p>redis集群模式必须要有3个主节点3个从节点才能正常启动集群模式</p>\n<ul>\n<li>主节点端口：7000 | 7001 | 7002</li>\n<li>从节点端口：7003 | 7004 | 7005</li>\n</ul>\n<h3 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker Compose\"></a>Docker Compose</h3><p>为节省内存资源，主从节点都部署在单机实例中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">version: &#39;2&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">services:</span><br><span class=\"line\">  cluster:</span><br><span class=\"line\">    image: daocloud.io&#x2F;redis</span><br><span class=\"line\">    container_name: redis-cluster</span><br><span class=\"line\">    # 添加该参数后服务后台运行后，容器不会自动退出</span><br><span class=\"line\">    tty: true</span><br><span class=\"line\">    restart: always</span><br><span class=\"line\">    # linux环境下建议使用host模式</span><br><span class=\"line\">    network_mode: host</span><br><span class=\"line\"></span><br><span class=\"line\">    volumes:</span><br><span class=\"line\">      - .&#x2F;data:&#x2F;data</span><br><span class=\"line\">      - .&#x2F;config:&#x2F;etc&#x2F;redis  </span><br><span class=\"line\">    ports:</span><br><span class=\"line\">      - &quot;7000:7000&quot;</span><br><span class=\"line\">      - &quot;7001:7001&quot;</span><br><span class=\"line\">      - &quot;7002:7002&quot;</span><br><span class=\"line\">      - &quot;7003:7003&quot;</span><br><span class=\"line\">      - &quot;7004:7004&quot;</span><br><span class=\"line\">      - &quot;7005:7005&quot;</span><br><span class=\"line\">    ## 必须使用宿主机ip 作为集群总线ip，否则宿主机无法访问到容器内的redis集群ip </span><br><span class=\"line\">    # 也可以加在配置文件中</span><br><span class=\"line\">    #  --cluster-announce-ip 172.16.65.218 </span><br><span class=\"line\">    command: </span><br><span class=\"line\">      - &#x2F;bin&#x2F;bash </span><br><span class=\"line\">      - -c </span><br><span class=\"line\">      - |</span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7000.conf  --cluster-announce-ip 172.16.65.218 &amp; </span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7001.conf  --cluster-announce-ip 172.16.65.218 &amp;</span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7002.conf  --cluster-announce-ip 172.16.65.218 &amp;</span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7003.conf  --cluster-announce-ip 172.16.65.218 &amp; </span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7004.conf  --cluster-announce-ip 172.16.65.218 &amp;</span><br><span class=\"line\">        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7005.conf  --cluster-announce-ip 172.16.65.218</span><br></pre></td></tr></table></figure>\n<h3 id=\"redis-700X-conf\"><a href=\"#redis-700X-conf\" class=\"headerlink\" title=\"redis_700X.conf\"></a>redis_700X.conf</h3><p>根据各端口修改配置中的端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port 7000</span><br><span class=\"line\"># 绑定机器的内网IP或者公网IP,一定要设置，不要用 127.0.0.1</span><br><span class=\"line\">bind 0.0.0.0</span><br><span class=\"line\"># 启用集群模式</span><br><span class=\"line\">cluster-enabled yes</span><br><span class=\"line\"># 集群节点文件</span><br><span class=\"line\">cluster-config-file nodes_7000.conf</span><br><span class=\"line\"># 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录</span><br><span class=\"line\">dir &#x2F;data&#x2F;7000&#x2F;</span><br><span class=\"line\"># 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间</span><br><span class=\"line\">cluster-node-timeout 5000</span><br><span class=\"line\"># 集群广播ip</span><br><span class=\"line\">#cluster-announce-ip 172.20.0.4</span><br><span class=\"line\">#cluster-announce-port 7000</span><br><span class=\"line\"># 开启AOF模式</span><br><span class=\"line\">appendonly yes</span><br><span class=\"line\"># 关闭保护模式</span><br><span class=\"line\">protected-mode no</span><br><span class=\"line\"># 是否后台启动</span><br><span class=\"line\">daemonize no</span><br><span class=\"line\"># pid file所在目录</span><br><span class=\"line\">pidfile &#x2F;var&#x2F;run&#x2F;redis_7000.pid </span><br><span class=\"line\"># 客户端访问密码</span><br><span class=\"line\"># requirepass redis2020</span><br><span class=\"line\"># 日志文件</span><br><span class=\"line\">logfile &#x2F;var&#x2F;log&#x2F;redis_7001.log</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动Redis-Cluster\"><a href=\"#启动Redis-Cluster\" class=\"headerlink\" title=\"启动Redis Cluster\"></a>启动Redis Cluster</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建Redis集群\"><a href=\"#创建Redis集群\" class=\"headerlink\" title=\"创建Redis集群\"></a>创建Redis集群</h3><ul>\n<li>进入容器<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker exec -it redis-cluster &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li>\n<li>创建集群<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ redis-cli --cluster create 127.0.0.1:7000 \\</span><br><span class=\"line\">                           127.0.0.1:7001 \\</span><br><span class=\"line\">                           127.0.0.1:7002 \\</span><br><span class=\"line\">                           127.0.0.1:7003 \\</span><br><span class=\"line\">                           127.0.0.1:7004 \\</span><br><span class=\"line\">                           127.0.0.1:7005 \\</span><br><span class=\"line\">                           --cluster-replicas 1</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"查看集群状态\"><a href=\"#查看集群状态\" class=\"headerlink\" title=\"查看集群状态\"></a>查看集群状态</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## -c表示集群模式进入</span><br><span class=\"line\">root@docker-desktop:&#x2F;data# redis-cli -c -h localhost -p 7000</span><br><span class=\"line\"></span><br><span class=\"line\">## 查看集群信息 cluster_state为ok则表示集群创建成功</span><br><span class=\"line\">localhost:7000&gt; cluster info</span><br><span class=\"line\">cluster_state:ok</span><br><span class=\"line\">cluster_slots_assigned:16384</span><br><span class=\"line\">cluster_slots_ok:16384</span><br><span class=\"line\">cluster_slots_pfail:0</span><br><span class=\"line\">cluster_slots_fail:0</span><br><span class=\"line\">cluster_known_nodes:6</span><br><span class=\"line\">cluster_size:1</span><br><span class=\"line\">cluster_current_epoch:6</span><br><span class=\"line\">cluster_my_epoch:3</span><br><span class=\"line\">cluster_stats_messages_ping_sent:5290</span><br><span class=\"line\">cluster_stats_messages_pong_sent:5299</span><br><span class=\"line\">cluster_stats_messages_update_sent:1</span><br><span class=\"line\">cluster_stats_messages_sent:10590</span><br><span class=\"line\">cluster_stats_messages_ping_received:5294</span><br><span class=\"line\">cluster_stats_messages_pong_received:5290</span><br><span class=\"line\">cluster_stats_messages_meet_received:5</span><br><span class=\"line\">cluster_stats_messages_update_received:3</span><br><span class=\"line\">cluster_stats_messages_received:10592</span><br><span class=\"line\"></span><br><span class=\"line\">## 查看集群节点信息</span><br><span class=\"line\">localhost:7000&gt; cluster nodes</span><br><span class=\"line\">6b7f8c4767feb376a99e79068748253afcf6ea5a 127.0.0.1:7001@17001 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594235646 3 connected</span><br><span class=\"line\">52b109a6491a2e4280b6a66642716939d0f46e89 127.0.0.1:7004@17004 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594236555 5 connected</span><br><span class=\"line\">df7dcbf82ecba0ff044f2715b052674e73ec1ca6 127.0.0.1:7000@17000 myself,slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594234000 1 connected</span><br><span class=\"line\">51f5c9fb771a702933d8bc29fcd13eb41811e2bb 127.0.0.1:7005@17005 master - 0 1607594236000 6 connected</span><br><span class=\"line\">ef7fdf2421427d1da29da4c1dab9e8c26ca12854 127.0.0.1:7002@17002 master - 0 1607594236657 3 connected 0-16383</span><br><span class=\"line\">cf7327c9ec3b374ebc6ba3f49c6bd5e0a7098601 127.0.0.1:7003@17003 master - 0 1607594235544 4 connected</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>[1] <a href=\"https://redis.io/topics/cluster-tutorial\" target=\"_blank\" rel=\"noopener\">Redis Cluster</a></li>\n</ul>\n"},{"title":"【数据结构】八大数据结构简介","abbrlink":2827031203,"date":"2017-02-19T13:38:18.000Z","_content":"\n# 数据结构分类\n数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。\n常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：\n\n{% asset_img overview.png %}\n\n常见数据结构大致可分为三大类，如下所示\n- 线性表：顺序表、链表、栈和队列；\n- 树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；\n- 图存储结构\n\n## 优缺点对比表\n每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。\n\n<table>\n    <tr>\n        <td>数据结构</td>\n        <td>优点</td>\n        <td>缺点</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n# 数组（Array）\n\n数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。\n\n    int[] data = new int[100]；\n    data[0]  = 1;\n\n## 优点\n- 按照索引查询元素速度快\n- 按照索引遍历数组方便\n\n## 缺点\n- 数组的大小固定后就无法扩容了\n- 数组只能存储一种类型的数据\n- 添加，删除的操作慢，因为要移动其他的元素。\n\n## 适用场景\n- 频繁查询，对存储空间要求不大，很少增加和删除的情况。\n\n# 栈（Stack）\n栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。\n{% asset_img stack.png %}\n栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。\n\n# 队列\n队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：\n{% asset_img queue.png %}\n使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。\n\n# 链表\n链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。\n{% asset_img linekdlist.jpg %}\n## 优点\n- 链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；\n- 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；\n\n## 缺点\n- 因为含有大量的指针域，占用空间较大；\n- 查找元素需要遍历链表来查找，非常耗时。\n\n## 适用场景\n数据量较小，需要频繁增加，删除操作的场景\n\n# 树\n树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n{% asset_img tree.png %}\n每个节点有零个或多个子节点；\n没有父节点的节点称为根节点；\n每一个非根节点有且只有一个父节点；\n除了根节点外，每个子节点可以分为多个不相交的子树；\n在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。\n\n二叉树是树的特殊一种，具有如下特点：\n\n- 每个结点最多有两颗子树，结点的度最大为2。\n- 左子树和右子树是有顺序的，次序不能颠倒。\n- 即使某结点只有一个子树，也要区分左右子树。\n\n二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。\n\n扩展：\n二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。\n\n# 散列表\n散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。\n{% asset_img hashtable.jpg %}\n记录的存储位置=f(key)\n\n这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。\n\n哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：\n\n从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。\n\n哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。\n\n# 堆\n{% asset_img heap.jpg %}\n堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：\n\n- 堆中某个节点的值总是不大于或不小于其父节点的值；\n- 堆总是一棵完全二叉树。\n\n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。\n\n堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。\n(ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：\n\n因为堆有序的特点，一般用来做数组中的排序，称为堆排序。\n\n# 图\n图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。\n\n按照顶点指向的方向可分为无向图和有向图：\n\n图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。\n","source":"_drafts/data-structure-overview.md","raw":"---\ntitle: 【数据结构】八大数据结构简介\ntags:\n  - 数据结构\n  - 算法\nabbrlink: 2827031203\ndate: 2017-02-19 21:38:18\n---\n\n# 数据结构分类\n数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。\n常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：\n\n{% asset_img overview.png %}\n\n常见数据结构大致可分为三大类，如下所示\n- 线性表：顺序表、链表、栈和队列；\n- 树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；\n- 图存储结构\n\n## 优缺点对比表\n每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。\n\n<table>\n    <tr>\n        <td>数据结构</td>\n        <td>优点</td>\n        <td>缺点</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n# 数组（Array）\n\n数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。\n\n    int[] data = new int[100]；\n    data[0]  = 1;\n\n## 优点\n- 按照索引查询元素速度快\n- 按照索引遍历数组方便\n\n## 缺点\n- 数组的大小固定后就无法扩容了\n- 数组只能存储一种类型的数据\n- 添加，删除的操作慢，因为要移动其他的元素。\n\n## 适用场景\n- 频繁查询，对存储空间要求不大，很少增加和删除的情况。\n\n# 栈（Stack）\n栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。\n{% asset_img stack.png %}\n栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。\n\n# 队列\n队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：\n{% asset_img queue.png %}\n使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。\n\n# 链表\n链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。\n{% asset_img linekdlist.jpg %}\n## 优点\n- 链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；\n- 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；\n\n## 缺点\n- 因为含有大量的指针域，占用空间较大；\n- 查找元素需要遍历链表来查找，非常耗时。\n\n## 适用场景\n数据量较小，需要频繁增加，删除操作的场景\n\n# 树\n树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n{% asset_img tree.png %}\n每个节点有零个或多个子节点；\n没有父节点的节点称为根节点；\n每一个非根节点有且只有一个父节点；\n除了根节点外，每个子节点可以分为多个不相交的子树；\n在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。\n\n二叉树是树的特殊一种，具有如下特点：\n\n- 每个结点最多有两颗子树，结点的度最大为2。\n- 左子树和右子树是有顺序的，次序不能颠倒。\n- 即使某结点只有一个子树，也要区分左右子树。\n\n二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。\n\n扩展：\n二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。\n\n# 散列表\n散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。\n{% asset_img hashtable.jpg %}\n记录的存储位置=f(key)\n\n这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。\n\n哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：\n\n从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。\n\n哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。\n\n# 堆\n{% asset_img heap.jpg %}\n堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：\n\n- 堆中某个节点的值总是不大于或不小于其父节点的值；\n- 堆总是一棵完全二叉树。\n\n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。\n\n堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。\n(ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：\n\n因为堆有序的特点，一般用来做数组中的排序，称为堆排序。\n\n# 图\n图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。\n\n按照顶点指向的方向可分为无向图和有向图：\n\n图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。\n","slug":"data-structure-overview","published":0,"updated":"2020-11-10T05:41:11.695Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz5r000nmxcdej19bm0l","content":"<h1 id=\"数据结构分类\"><a href=\"#数据结构分类\" class=\"headerlink\" title=\"数据结构分类\"></a>数据结构分类</h1><p>数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。<br>常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：</p>\n\n\n<p>常见数据结构大致可分为三大类，如下所示</p>\n<ul>\n<li>线性表：顺序表、链表、栈和队列；</li>\n<li>树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；</li>\n<li>图存储结构</li>\n</ul>\n<h2 id=\"优缺点对比表\"><a href=\"#优缺点对比表\" class=\"headerlink\" title=\"优缺点对比表\"></a>优缺点对比表</h2><p>每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。</p>\n<table>\n    <tr>\n        <td>数据结构</td>\n        <td>优点</td>\n        <td>缺点</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n<h1 id=\"数组（Array）\"><a href=\"#数组（Array）\" class=\"headerlink\" title=\"数组（Array）\"></a>数组（Array）</h1><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。</p>\n<pre><code>int[] data = new int[100]；\ndata[0]  = 1;</code></pre><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>按照索引查询元素速度快</li>\n<li>按照索引遍历数组方便</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>数组的大小固定后就无法扩容了</li>\n<li>数组只能存储一种类型的数据</li>\n<li>添加，删除的操作慢，因为要移动其他的元素。</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li>频繁查询，对存储空间要求不大，很少增加和删除的情况。</li>\n</ul>\n<h1 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h1><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p>\n\n<p>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。</p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：</p>\n\n<p>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p>\n\n<h2 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；</li>\n<li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</li>\n</ul>\n<h2 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>因为含有大量的指针域，占用空间较大；</li>\n<li>查找元素需要遍历链表来查找，非常耗时。</li>\n</ul>\n<h2 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>数据量较小，需要频繁增加，删除操作的场景</p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>\n\n<p>每个节点有零个或多个子节点；<br>没有父节点的节点称为根节点；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。</p>\n<p>二叉树是树的特殊一种，具有如下特点：</p>\n<ul>\n<li>每个结点最多有两颗子树，结点的度最大为2。</li>\n<li>左子树和右子树是有顺序的，次序不能颠倒。</li>\n<li>即使某结点只有一个子树，也要区分左右子树。</li>\n</ul>\n<p>二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</p>\n<p>扩展：<br>二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p>\n<h1 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h1><p>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p>\n\n<p>记录的存储位置=f(key)</p>\n<p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。</p>\n<p>哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：</p>\n<p>从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>\n<p>哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1>\n<p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p>\n<ul>\n<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>\n<li>堆总是一棵完全二叉树。</li>\n</ul>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>\n<p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：</p>\n<p>因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</p>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p>\n<p>按照顶点指向的方向可分为无向图和有向图：</p>\n<p>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。</p>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h1 id=\"数据结构分类\"><a href=\"#数据结构分类\" class=\"headerlink\" title=\"数据结构分类\"></a>数据结构分类</h1><p>数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。<br>常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：</p>\n\n\n<p>常见数据结构大致可分为三大类，如下所示</p>\n<ul>\n<li>线性表：顺序表、链表、栈和队列；</li>\n<li>树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；</li>\n<li>图存储结构</li>\n</ul>\n<h2 id=\"优缺点对比表\"><a href=\"#优缺点对比表\" class=\"headerlink\" title=\"优缺点对比表\"></a>优缺点对比表</h2><p>每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。</p>\n<table>\n    <tr>\n        <td>数据结构</td>\n        <td>优点</td>\n        <td>缺点</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n<h1 id=\"数组（Array）\"><a href=\"#数组（Array）\" class=\"headerlink\" title=\"数组（Array）\"></a>数组（Array）</h1><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。</p>\n<pre><code>int[] data = new int[100]；\ndata[0]  = 1;</code></pre><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>按照索引查询元素速度快</li>\n<li>按照索引遍历数组方便</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>数组的大小固定后就无法扩容了</li>\n<li>数组只能存储一种类型的数据</li>\n<li>添加，删除的操作慢，因为要移动其他的元素。</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li>频繁查询，对存储空间要求不大，很少增加和删除的情况。</li>\n</ul>\n<h1 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h1><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p>\n\n<p>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。</p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：</p>\n\n<p>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p>\n\n<h2 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；</li>\n<li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</li>\n</ul>\n<h2 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>因为含有大量的指针域，占用空间较大；</li>\n<li>查找元素需要遍历链表来查找，非常耗时。</li>\n</ul>\n<h2 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>数据量较小，需要频繁增加，删除操作的场景</p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>\n\n<p>每个节点有零个或多个子节点；<br>没有父节点的节点称为根节点；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。</p>\n<p>二叉树是树的特殊一种，具有如下特点：</p>\n<ul>\n<li>每个结点最多有两颗子树，结点的度最大为2。</li>\n<li>左子树和右子树是有顺序的，次序不能颠倒。</li>\n<li>即使某结点只有一个子树，也要区分左右子树。</li>\n</ul>\n<p>二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</p>\n<p>扩展：<br>二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p>\n<h1 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h1><p>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p>\n\n<p>记录的存储位置=f(key)</p>\n<p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。</p>\n<p>哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：</p>\n<p>从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>\n<p>哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1>\n<p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p>\n<ul>\n<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>\n<li>堆总是一棵完全二叉树。</li>\n</ul>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>\n<p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：</p>\n<p>因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</p>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p>\n<p>按照顶点指向的方向可分为无向图和有向图：</p>\n<p>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。</p>\n"},{"title":"【数据结构】八大数据结构简介","abbrlink":2827031203,"date":"2017-02-19T13:38:18.000Z","_content":"\n\n# 数据结构分类\n数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。\n常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：\n\n{% asset_img overview.png %}\n\n常见数据结构大致可分为三大类，如下所示\n- 线性表：顺序表、链表、栈和队列；\n- 树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；\n- 图存储结构\n\n## 优缺点对比表\n每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。\n\n<table>\n    <tr>\n        <td>数据结构</td>\n        <td>优点</td>\n        <td>缺点</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n# 数组（Array）\n\n数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。\n\n    int[] data = new int[100]；\n    data[0]  = 1;\n\n## 优点\n- 按照索引查询元素速度快\n- 按照索引遍历数组方便\n\n## 缺点\n- 数组的大小固定后就无法扩容了\n- 数组只能存储一种类型的数据\n- 添加，删除的操作慢，因为要移动其他的元素。\n\n## 适用场景\n- 频繁查询，对存储空间要求不大，很少增加和删除的情况。\n\n# 栈（Stack）\n栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。\n{% asset_img stack.png %}\n栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。\n\n# 队列\n队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：\n{% asset_img queue.png %}\n使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。\n\n# 链表\n链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。\n{% asset_img linekdlist.jpg %}\n## 优点\n- 链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；\n- 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；\n\n## 缺点\n- 因为含有大量的指针域，占用空间较大；\n- 查找元素需要遍历链表来查找，非常耗时。\n\n## 适用场景\n数据量较小，需要频繁增加，删除操作的场景\n\n# 树\n树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n{% asset_img tree.png %}\n每个节点有零个或多个子节点；\n没有父节点的节点称为根节点；\n每一个非根节点有且只有一个父节点；\n除了根节点外，每个子节点可以分为多个不相交的子树；\n在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。\n\n二叉树是树的特殊一种，具有如下特点：\n\n- 每个结点最多有两颗子树，结点的度最大为2。\n- 左子树和右子树是有顺序的，次序不能颠倒。\n- 即使某结点只有一个子树，也要区分左右子树。\n\n二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。\n\n扩展：\n二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。\n\n# 散列表\n散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。\n{% asset_img hashtable.jpg %}\n记录的存储位置=f(key)\n\n这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。\n\n哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：\n\n从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。\n\n哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。\n\n# 堆\n{% asset_img heap.jpg %}\n堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：\n\n- 堆中某个节点的值总是不大于或不小于其父节点的值；\n- 堆总是一棵完全二叉树。\n\n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。\n\n堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。\n(ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：\n\n因为堆有序的特点，一般用来做数组中的排序，称为堆排序。\n\n# 图\n图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。\n\n按照顶点指向的方向可分为无向图和有向图：\n\n图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。\n","source":"_posts/data-structure-overview.md","raw":"---\ntitle: 【数据结构】八大数据结构简介\ntags:\n  - 数据结构\n  - 算法\nabbrlink: 2827031203\ndate: 2017-02-19 21:38:18\n---\n\n\n# 数据结构分类\n数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。\n常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：\n\n{% asset_img overview.png %}\n\n常见数据结构大致可分为三大类，如下所示\n- 线性表：顺序表、链表、栈和队列；\n- 树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；\n- 图存储结构\n\n## 优缺点对比表\n每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。\n\n<table>\n    <tr>\n        <td>数据结构</td>\n        <td>优点</td>\n        <td>缺点</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n# 数组（Array）\n\n数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。\n\n    int[] data = new int[100]；\n    data[0]  = 1;\n\n## 优点\n- 按照索引查询元素速度快\n- 按照索引遍历数组方便\n\n## 缺点\n- 数组的大小固定后就无法扩容了\n- 数组只能存储一种类型的数据\n- 添加，删除的操作慢，因为要移动其他的元素。\n\n## 适用场景\n- 频繁查询，对存储空间要求不大，很少增加和删除的情况。\n\n# 栈（Stack）\n栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。\n{% asset_img stack.png %}\n栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。\n\n# 队列\n队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：\n{% asset_img queue.png %}\n使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。\n\n# 链表\n链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。\n{% asset_img linekdlist.jpg %}\n## 优点\n- 链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；\n- 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；\n\n## 缺点\n- 因为含有大量的指针域，占用空间较大；\n- 查找元素需要遍历链表来查找，非常耗时。\n\n## 适用场景\n数据量较小，需要频繁增加，删除操作的场景\n\n# 树\n树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n{% asset_img tree.png %}\n每个节点有零个或多个子节点；\n没有父节点的节点称为根节点；\n每一个非根节点有且只有一个父节点；\n除了根节点外，每个子节点可以分为多个不相交的子树；\n在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。\n\n二叉树是树的特殊一种，具有如下特点：\n\n- 每个结点最多有两颗子树，结点的度最大为2。\n- 左子树和右子树是有顺序的，次序不能颠倒。\n- 即使某结点只有一个子树，也要区分左右子树。\n\n二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。\n\n扩展：\n二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。\n\n# 散列表\n散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。\n{% asset_img hashtable.jpg %}\n记录的存储位置=f(key)\n\n这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。\n\n哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：\n\n从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。\n\n哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。\n\n# 堆\n{% asset_img heap.jpg %}\n堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：\n\n- 堆中某个节点的值总是不大于或不小于其父节点的值；\n- 堆总是一棵完全二叉树。\n\n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。\n\n堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。\n(ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：\n\n因为堆有序的特点，一般用来做数组中的排序，称为堆排序。\n\n# 图\n图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。\n\n按照顶点指向的方向可分为无向图和有向图：\n\n图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。\n","slug":"data-structure-overview","published":1,"updated":"2020-07-06T06:42:26.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz5t000pmxcd556qev6h","content":"<h1 id=\"数据结构分类\"><a href=\"#数据结构分类\" class=\"headerlink\" title=\"数据结构分类\"></a>数据结构分类</h1><p>数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。<br>常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：</p>\n<img src=\"/posts/2827031203/index/overview.png\" class=\"\">\n\n<p>常见数据结构大致可分为三大类，如下所示</p>\n<ul>\n<li>线性表：顺序表、链表、栈和队列；</li>\n<li>树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；</li>\n<li>图存储结构</li>\n</ul>\n<h2 id=\"优缺点对比表\"><a href=\"#优缺点对比表\" class=\"headerlink\" title=\"优缺点对比表\"></a>优缺点对比表</h2><p>每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。</p>\n<table>\n    <tr>\n        <td>数据结构</td>\n        <td>优点</td>\n        <td>缺点</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n<h1 id=\"数组（Array）\"><a href=\"#数组（Array）\" class=\"headerlink\" title=\"数组（Array）\"></a>数组（Array）</h1><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。</p>\n<pre><code>int[] data = new int[100]；\ndata[0]  = 1;</code></pre><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>按照索引查询元素速度快</li>\n<li>按照索引遍历数组方便</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>数组的大小固定后就无法扩容了</li>\n<li>数组只能存储一种类型的数据</li>\n<li>添加，删除的操作慢，因为要移动其他的元素。</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li>频繁查询，对存储空间要求不大，很少增加和删除的情况。</li>\n</ul>\n<h1 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h1><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p>\n<img src=\"/posts/2827031203/index/stack.png\" class=\"\">\n<p>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。</p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：</p>\n<img src=\"/posts/2827031203/index/queue.png\" class=\"\">\n<p>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p>\n\n<h2 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；</li>\n<li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</li>\n</ul>\n<h2 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>因为含有大量的指针域，占用空间较大；</li>\n<li>查找元素需要遍历链表来查找，非常耗时。</li>\n</ul>\n<h2 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>数据量较小，需要频繁增加，删除操作的场景</p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>\n<img src=\"/posts/2827031203/index/tree.png\" class=\"\">\n<p>每个节点有零个或多个子节点；<br>没有父节点的节点称为根节点；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。</p>\n<p>二叉树是树的特殊一种，具有如下特点：</p>\n<ul>\n<li>每个结点最多有两颗子树，结点的度最大为2。</li>\n<li>左子树和右子树是有顺序的，次序不能颠倒。</li>\n<li>即使某结点只有一个子树，也要区分左右子树。</li>\n</ul>\n<p>二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</p>\n<p>扩展：<br>二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p>\n<h1 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h1><p>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p>\n<img src=\"/posts/2827031203/index/hashtable.jpg\" class=\"\">\n<p>记录的存储位置=f(key)</p>\n<p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。</p>\n<p>哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：</p>\n<p>从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>\n<p>哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><img src=\"/posts/2827031203/index/heap.jpg\" class=\"\">\n<p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p>\n<ul>\n<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>\n<li>堆总是一棵完全二叉树。</li>\n</ul>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>\n<p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：</p>\n<p>因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</p>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p>\n<p>按照顶点指向的方向可分为无向图和有向图：</p>\n<p>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。</p>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h1 id=\"数据结构分类\"><a href=\"#数据结构分类\" class=\"headerlink\" title=\"数据结构分类\"></a>数据结构分类</h1><p>数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。<br>常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：</p>\n<img src=\"/posts/2827031203/index/overview.png\" class=\"\">\n\n<p>常见数据结构大致可分为三大类，如下所示</p>\n<ul>\n<li>线性表：顺序表、链表、栈和队列；</li>\n<li>树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；</li>\n<li>图存储结构</li>\n</ul>\n<h2 id=\"优缺点对比表\"><a href=\"#优缺点对比表\" class=\"headerlink\" title=\"优缺点对比表\"></a>优缺点对比表</h2><p>每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。</p>\n<table>\n    <tr>\n        <td>数据结构</td>\n        <td>优点</td>\n        <td>缺点</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n<h1 id=\"数组（Array）\"><a href=\"#数组（Array）\" class=\"headerlink\" title=\"数组（Array）\"></a>数组（Array）</h1><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。</p>\n<pre><code>int[] data = new int[100]；\ndata[0]  = 1;</code></pre><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>按照索引查询元素速度快</li>\n<li>按照索引遍历数组方便</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>数组的大小固定后就无法扩容了</li>\n<li>数组只能存储一种类型的数据</li>\n<li>添加，删除的操作慢，因为要移动其他的元素。</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li>频繁查询，对存储空间要求不大，很少增加和删除的情况。</li>\n</ul>\n<h1 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h1><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p>\n<img src=\"/posts/2827031203/index/stack.png\" class=\"\">\n<p>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。</p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：</p>\n<img src=\"/posts/2827031203/index/queue.png\" class=\"\">\n<p>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p>\n\n<h2 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；</li>\n<li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</li>\n</ul>\n<h2 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>因为含有大量的指针域，占用空间较大；</li>\n<li>查找元素需要遍历链表来查找，非常耗时。</li>\n</ul>\n<h2 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>数据量较小，需要频繁增加，删除操作的场景</p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>\n<img src=\"/posts/2827031203/index/tree.png\" class=\"\">\n<p>每个节点有零个或多个子节点；<br>没有父节点的节点称为根节点；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。</p>\n<p>二叉树是树的特殊一种，具有如下特点：</p>\n<ul>\n<li>每个结点最多有两颗子树，结点的度最大为2。</li>\n<li>左子树和右子树是有顺序的，次序不能颠倒。</li>\n<li>即使某结点只有一个子树，也要区分左右子树。</li>\n</ul>\n<p>二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</p>\n<p>扩展：<br>二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p>\n<h1 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h1><p>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p>\n<img src=\"/posts/2827031203/index/hashtable.jpg\" class=\"\">\n<p>记录的存储位置=f(key)</p>\n<p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。</p>\n<p>哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：</p>\n<p>从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>\n<p>哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><img src=\"/posts/2827031203/index/heap.jpg\" class=\"\">\n<p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p>\n<ul>\n<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>\n<li>堆总是一棵完全二叉树。</li>\n</ul>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>\n<p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：</p>\n<p>因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</p>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p>\n<p>按照顶点指向的方向可分为无向图和有向图：</p>\n<p>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。</p>\n"},{"title":"Hexo写作","index_img":"/img/hexo.jpeg","abbrlink":3878378061,"_content":"\n\n\n\n你可以执行下列命令来创建一篇新文章或者新的页面。\n\n```\n$ hexo new [layout] <title>\n```\n\n您可以在命令中指定文章的布局（layout），默认为 `post`，可以通过修改 `_config.yml` 中的 `default_layout` 参数来指定默认布局。\n\n### 布局（Layout）\n\nHexo 有三种默认布局：`post`、`page` 和 `draft`。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 `post` 相同，都将储存到 `source/_posts` 文件夹。\n\n| 布局    | 路径             |\n| :------ | :--------------- |\n| `post`  | `source/_posts`  |\n| `page`  | `source`         |\n| `draft` | `source/_drafts` |\n\n> Disabling layout\n>\n> If you don’t want an article (post/page) to be processed with a theme, set `layout: false` in its front-matter. Refer to [this section](https://hexo.io/zh-cn/docs/front-matter#布局) for more details.\n\n### 文件名称\n\nHexo 默认以标题做为文件名称，但您可编辑 `new_post_name` 参数来改变默认的文件名称，举例来说，设为 `:year-:month-:day-:title.md` 可让您更方便的通过日期来管理文章。\n\n| 变量       | 描述                                |\n| :--------- | :---------------------------------- |\n| `:title`   | 标题（小写，空格将会被替换为短杠）  |\n| `:year`    | 建立的年份，比如， `2015`           |\n| `:month`   | 建立的月份（有前导零），比如， `04` |\n| `:i_month` | 建立的月份（无前导零），比如， `4`  |\n| `:day`     | 建立的日期（有前导零），比如， `07` |\n| `:i_day`   | 建立的日期（无前导零），比如， `7`  |\n\n### 草稿\n\n刚刚提到了 Hexo 的一种特殊布局：`draft`，这种布局在建立时会被保存到 `source/_drafts` 文件夹，您可通过 `publish` 命令将草稿移动到 `source/_posts` 文件夹，该命令的使用方式与 `new` 十分类似，您也可在命令中指定 `layout` 来指定布局。\n\n```\n$ hexo publish [layout] <title>\n```\n\n草稿默认不会显示在页面中，您可在执行时加上 `--draft` 参数，或是把 `render_drafts` 参数设为 `true` 来预览草稿。\n\n## 模版（Scaffold）\n\n在新建文章时，Hexo 会根据 `scaffolds` 文件夹内相对应的文件来建立文件，例如：\n\n```\n$ hexo new photo \"My Gallery\"\n```\n\n在执行这行指令时，Hexo 会尝试在 `scaffolds` 文件夹中寻找 `photo.md`，并根据其内容建立文章，以下是您可以在模版中使用的变量：\n\n| 变量     | 描述         |\n| :------- | :----------- |\n| `layout` | 布局         |\n| `title`  | 标题         |\n| `date`   | 文件建立日期 |\n\n### 支持的格式\n\nHexo 支持以任何格式书写文章，只要安装了相应的渲染插件。\n\n例如，Hexo 默认安装了 `hexo-renderer-marked` 和 `hexo-renderer-ejs`，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 `hexo-renderer-pug`，你甚至可以用 Pug 模板语言书写文章。\n\n只需要将文章的扩展名从 `md` 改成 `ejs`，Hexo 就会使用 `hexo-renderer-ejs` 渲染这个文件，其他格式同理。","source":"_posts/hexo/hexo写作.md","raw":"---\ntitle: Hexo写作\ntags:\n  - Hexo\nindex_img: /img/hexo.jpeg\nabbrlink: 3878378061\n---\n\n\n\n\n你可以执行下列命令来创建一篇新文章或者新的页面。\n\n```\n$ hexo new [layout] <title>\n```\n\n您可以在命令中指定文章的布局（layout），默认为 `post`，可以通过修改 `_config.yml` 中的 `default_layout` 参数来指定默认布局。\n\n### 布局（Layout）\n\nHexo 有三种默认布局：`post`、`page` 和 `draft`。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 `post` 相同，都将储存到 `source/_posts` 文件夹。\n\n| 布局    | 路径             |\n| :------ | :--------------- |\n| `post`  | `source/_posts`  |\n| `page`  | `source`         |\n| `draft` | `source/_drafts` |\n\n> Disabling layout\n>\n> If you don’t want an article (post/page) to be processed with a theme, set `layout: false` in its front-matter. Refer to [this section](https://hexo.io/zh-cn/docs/front-matter#布局) for more details.\n\n### 文件名称\n\nHexo 默认以标题做为文件名称，但您可编辑 `new_post_name` 参数来改变默认的文件名称，举例来说，设为 `:year-:month-:day-:title.md` 可让您更方便的通过日期来管理文章。\n\n| 变量       | 描述                                |\n| :--------- | :---------------------------------- |\n| `:title`   | 标题（小写，空格将会被替换为短杠）  |\n| `:year`    | 建立的年份，比如， `2015`           |\n| `:month`   | 建立的月份（有前导零），比如， `04` |\n| `:i_month` | 建立的月份（无前导零），比如， `4`  |\n| `:day`     | 建立的日期（有前导零），比如， `07` |\n| `:i_day`   | 建立的日期（无前导零），比如， `7`  |\n\n### 草稿\n\n刚刚提到了 Hexo 的一种特殊布局：`draft`，这种布局在建立时会被保存到 `source/_drafts` 文件夹，您可通过 `publish` 命令将草稿移动到 `source/_posts` 文件夹，该命令的使用方式与 `new` 十分类似，您也可在命令中指定 `layout` 来指定布局。\n\n```\n$ hexo publish [layout] <title>\n```\n\n草稿默认不会显示在页面中，您可在执行时加上 `--draft` 参数，或是把 `render_drafts` 参数设为 `true` 来预览草稿。\n\n## 模版（Scaffold）\n\n在新建文章时，Hexo 会根据 `scaffolds` 文件夹内相对应的文件来建立文件，例如：\n\n```\n$ hexo new photo \"My Gallery\"\n```\n\n在执行这行指令时，Hexo 会尝试在 `scaffolds` 文件夹中寻找 `photo.md`，并根据其内容建立文章，以下是您可以在模版中使用的变量：\n\n| 变量     | 描述         |\n| :------- | :----------- |\n| `layout` | 布局         |\n| `title`  | 标题         |\n| `date`   | 文件建立日期 |\n\n### 支持的格式\n\nHexo 支持以任何格式书写文章，只要安装了相应的渲染插件。\n\n例如，Hexo 默认安装了 `hexo-renderer-marked` 和 `hexo-renderer-ejs`，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 `hexo-renderer-pug`，你甚至可以用 Pug 模板语言书写文章。\n\n只需要将文章的扩展名从 `md` 改成 `ejs`，Hexo 就会使用 `hexo-renderer-ejs` 渲染这个文件，其他格式同理。","slug":"hexo/hexo写作","published":1,"date":"2020-12-15T01:04:34.082Z","updated":"2020-12-15T01:04:34.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz74000wmxcd6qlf6w2l","content":"<p>你可以执行下列命令来创建一篇新文章或者新的页面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>\n<h3 id=\"布局（Layout）\"><a href=\"#布局（Layout）\" class=\"headerlink\" title=\"布局（Layout）\"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">布局</th>\n<th align=\"left\">路径</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>post</code></td>\n<td align=\"left\"><code>source/_posts</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>page</code></td>\n<td align=\"left\"><code>source</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>draft</code></td>\n<td align=\"left\"><code>source/_drafts</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>Disabling layout</p>\n<p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href=\"https://hexo.io/zh-cn/docs/front-matter#布局\" target=\"_blank\" rel=\"noopener\">this section</a> for more details.</p>\n</blockquote>\n<h3 id=\"文件名称\"><a href=\"#文件名称\" class=\"headerlink\" title=\"文件名称\"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>:title</code></td>\n<td align=\"left\">标题（小写，空格将会被替换为短杠）</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:year</code></td>\n<td align=\"left\">建立的年份，比如， <code>2015</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:month</code></td>\n<td align=\"left\">建立的月份（有前导零），比如， <code>04</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:i_month</code></td>\n<td align=\"left\">建立的月份（无前导零），比如， <code>4</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:day</code></td>\n<td align=\"left\">建立的日期（有前导零），比如， <code>07</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:i_day</code></td>\n<td align=\"left\">建立的日期（无前导零），比如， <code>7</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p>\n<h2 id=\"模版（Scaffold）\"><a href=\"#模版（Scaffold）\" class=\"headerlink\" title=\"模版（Scaffold）\"></a>模版（Scaffold）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure>\n\n<p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>layout</code></td>\n<td align=\"left\">布局</td>\n</tr>\n<tr>\n<td align=\"left\"><code>title</code></td>\n<td align=\"left\">标题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>date</code></td>\n<td align=\"left\">文件建立日期</td>\n</tr>\n</tbody></table>\n<h3 id=\"支持的格式\"><a href=\"#支持的格式\" class=\"headerlink\" title=\"支持的格式\"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p>\n<p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p>\n<p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>你可以执行下列命令来创建一篇新文章或者新的页面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>\n<h3 id=\"布局（Layout）\"><a href=\"#布局（Layout）\" class=\"headerlink\" title=\"布局（Layout）\"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">布局</th>\n<th align=\"left\">路径</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>post</code></td>\n<td align=\"left\"><code>source/_posts</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>page</code></td>\n<td align=\"left\"><code>source</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>draft</code></td>\n<td align=\"left\"><code>source/_drafts</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>Disabling layout</p>\n<p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href=\"https://hexo.io/zh-cn/docs/front-matter#布局\" target=\"_blank\" rel=\"noopener\">this section</a> for more details.</p>\n</blockquote>\n<h3 id=\"文件名称\"><a href=\"#文件名称\" class=\"headerlink\" title=\"文件名称\"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>:title</code></td>\n<td align=\"left\">标题（小写，空格将会被替换为短杠）</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:year</code></td>\n<td align=\"left\">建立的年份，比如， <code>2015</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:month</code></td>\n<td align=\"left\">建立的月份（有前导零），比如， <code>04</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:i_month</code></td>\n<td align=\"left\">建立的月份（无前导零），比如， <code>4</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:day</code></td>\n<td align=\"left\">建立的日期（有前导零），比如， <code>07</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:i_day</code></td>\n<td align=\"left\">建立的日期（无前导零），比如， <code>7</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p>\n<h2 id=\"模版（Scaffold）\"><a href=\"#模版（Scaffold）\" class=\"headerlink\" title=\"模版（Scaffold）\"></a>模版（Scaffold）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure>\n\n<p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>layout</code></td>\n<td align=\"left\">布局</td>\n</tr>\n<tr>\n<td align=\"left\"><code>title</code></td>\n<td align=\"left\">标题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>date</code></td>\n<td align=\"left\">文件建立日期</td>\n</tr>\n</tbody></table>\n<h3 id=\"支持的格式\"><a href=\"#支持的格式\" class=\"headerlink\" title=\"支持的格式\"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p>\n<p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p>\n<p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p>\n"},{"title":"基于Github Action工作流自动部署Hexo","index_img":"/img/hexo-github-action.jpg","abbrlink":2231850037,"date":"2020-04-16T03:54:14.000Z","_content":"\n# Hexo搭建\n这段就pass了，只要这篇主要讲解Github Action部署\n\n# 创建github ssh 私钥和公钥\n在本地运行如下命令生成id_rsa和id_rsa.pub文件，一路回车，不要输入密码！！！不要输入密码！！！不要输入密码！！！（被这个坑的我想哭T_T，一直验证不通过）\n```cmd\n$ ssh-keygen -t rsa -C \"tanxinzheng@139.com\" #此处修改为你github的注册邮箱\n```\n\n# Github设置\n- 将id_rsa私钥放入项目的settings/secures配置中\n- 将id_rsa.pub公钥填入账号的settings/SSH keys配置中\n\n# 创建Github Action工作流脚本\n\n在项目该目录下创建~./.github/workflows/main.yml文件，将下面的配置信息填入，并修改自己的信息即可\n\n```yml\nname: CI\non:\n  push:\n    branches:\n      - generate-source\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout source\n        uses: actions/checkout@v1\n        with:\n          ref: generate-source\n      - name: Use Node.js ${{ matrix.node_version }}\n        uses: actions/setup-node@v1\n        with:\n          version: ${{ matrix.node_version }}\n      - name: Setup hexo\n        env:\n          ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_PRI }}\n        run: |\n          mkdir -p ~/.ssh/\n          echo \"$ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n          git config --global user.email \"tanxinzheng@139.com\"\n          git config --global user.name \"tanxinzheng\"\n          npm install hexo-cli -g\n          npm install\n      - name: Hexo deploy\n        run: |\n          hexo clean\n          hexo d\n```\n\n# Github Action执行部署\n在Github Action页面执行即可，push之后会自动部署。","source":"_posts/hexo/hexo-github-action.md","raw":"---\ntitle: 基于Github Action工作流自动部署Hexo\ntags:\n  - Hexo\n  - Github\nindex_img: /img/hexo-github-action.jpg\nabbrlink: 2231850037\ndate: 2020-04-16 11:54:14\n---\n\n# Hexo搭建\n这段就pass了，只要这篇主要讲解Github Action部署\n\n# 创建github ssh 私钥和公钥\n在本地运行如下命令生成id_rsa和id_rsa.pub文件，一路回车，不要输入密码！！！不要输入密码！！！不要输入密码！！！（被这个坑的我想哭T_T，一直验证不通过）\n```cmd\n$ ssh-keygen -t rsa -C \"tanxinzheng@139.com\" #此处修改为你github的注册邮箱\n```\n\n# Github设置\n- 将id_rsa私钥放入项目的settings/secures配置中\n- 将id_rsa.pub公钥填入账号的settings/SSH keys配置中\n\n# 创建Github Action工作流脚本\n\n在项目该目录下创建~./.github/workflows/main.yml文件，将下面的配置信息填入，并修改自己的信息即可\n\n```yml\nname: CI\non:\n  push:\n    branches:\n      - generate-source\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout source\n        uses: actions/checkout@v1\n        with:\n          ref: generate-source\n      - name: Use Node.js ${{ matrix.node_version }}\n        uses: actions/setup-node@v1\n        with:\n          version: ${{ matrix.node_version }}\n      - name: Setup hexo\n        env:\n          ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_PRI }}\n        run: |\n          mkdir -p ~/.ssh/\n          echo \"$ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n          git config --global user.email \"tanxinzheng@139.com\"\n          git config --global user.name \"tanxinzheng\"\n          npm install hexo-cli -g\n          npm install\n      - name: Hexo deploy\n        run: |\n          hexo clean\n          hexo d\n```\n\n# Github Action执行部署\n在Github Action页面执行即可，push之后会自动部署。","slug":"hexo/hexo-github-action","published":1,"updated":"2020-12-15T01:04:34.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz75000xmxcdeftp4t4a","content":"<h1 id=\"Hexo搭建\"><a href=\"#Hexo搭建\" class=\"headerlink\" title=\"Hexo搭建\"></a>Hexo搭建</h1><p>这段就pass了，只要这篇主要讲解Github Action部署</p>\n<h1 id=\"创建github-ssh-私钥和公钥\"><a href=\"#创建github-ssh-私钥和公钥\" class=\"headerlink\" title=\"创建github ssh 私钥和公钥\"></a>创建github ssh 私钥和公钥</h1><p>在本地运行如下命令生成id_rsa和id_rsa.pub文件，一路回车，不要输入密码！！！不要输入密码！！！不要输入密码！！！（被这个坑的我想哭T_T，一直验证不通过）</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C \"tanxinzheng@<span class=\"number\">139</span>.com\" #此处修改为你github的注册邮箱</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Github设置\"><a href=\"#Github设置\" class=\"headerlink\" title=\"Github设置\"></a>Github设置</h1><ul>\n<li>将id_rsa私钥放入项目的settings/secures配置中</li>\n<li>将id_rsa.pub公钥填入账号的settings/SSH keys配置中</li>\n</ul>\n<h1 id=\"创建Github-Action工作流脚本\"><a href=\"#创建Github-Action工作流脚本\" class=\"headerlink\" title=\"创建Github Action工作流脚本\"></a>创建Github Action工作流脚本</h1><p>在项目该目录下创建~./.github/workflows/main.yml文件，将下面的配置信息填入，并修改自己的信息即可</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">CI</span></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"attr\">branches:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">generate-source</span></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">source</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">ref:</span> <span class=\"string\">generate-source</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Use</span> <span class=\"string\">Node.js</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">matrix.node_version</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">version:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">matrix.node_version</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Setup</span> <span class=\"string\">hexo</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">ACTION_DEPLOY_KEY:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.HEXO_DEPLOY_PRI</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">mkdir</span> <span class=\"string\">-p</span> <span class=\"string\">~/.ssh/</span></span><br><span class=\"line\">          <span class=\"string\">echo</span> <span class=\"string\">\"$ACTION_DEPLOY_KEY\"</span> <span class=\"string\">&gt;</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">          <span class=\"string\">chmod</span> <span class=\"number\">600</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">          <span class=\"string\">ssh-keyscan</span> <span class=\"string\">github.com</span> <span class=\"string\">&gt;&gt;</span> <span class=\"string\">~/.ssh/known_hosts</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.email</span> <span class=\"string\">\"tanxinzheng@139.com\"</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.name</span> <span class=\"string\">\"tanxinzheng\"</span></span><br><span class=\"line\">          <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-cli</span> <span class=\"string\">-g</span></span><br><span class=\"line\">          <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Hexo</span> <span class=\"string\">deploy</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\">          <span class=\"string\">hexo</span> <span class=\"string\">d</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Github-Action执行部署\"><a href=\"#Github-Action执行部署\" class=\"headerlink\" title=\"Github Action执行部署\"></a>Github Action执行部署</h1><p>在Github Action页面执行即可，push之后会自动部署。</p>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h1 id=\"Hexo搭建\"><a href=\"#Hexo搭建\" class=\"headerlink\" title=\"Hexo搭建\"></a>Hexo搭建</h1><p>这段就pass了，只要这篇主要讲解Github Action部署</p>\n<h1 id=\"创建github-ssh-私钥和公钥\"><a href=\"#创建github-ssh-私钥和公钥\" class=\"headerlink\" title=\"创建github ssh 私钥和公钥\"></a>创建github ssh 私钥和公钥</h1><p>在本地运行如下命令生成id_rsa和id_rsa.pub文件，一路回车，不要输入密码！！！不要输入密码！！！不要输入密码！！！（被这个坑的我想哭T_T，一直验证不通过）</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C \"tanxinzheng@<span class=\"number\">139</span>.com\" #此处修改为你github的注册邮箱</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Github设置\"><a href=\"#Github设置\" class=\"headerlink\" title=\"Github设置\"></a>Github设置</h1><ul>\n<li>将id_rsa私钥放入项目的settings/secures配置中</li>\n<li>将id_rsa.pub公钥填入账号的settings/SSH keys配置中</li>\n</ul>\n<h1 id=\"创建Github-Action工作流脚本\"><a href=\"#创建Github-Action工作流脚本\" class=\"headerlink\" title=\"创建Github Action工作流脚本\"></a>创建Github Action工作流脚本</h1><p>在项目该目录下创建~./.github/workflows/main.yml文件，将下面的配置信息填入，并修改自己的信息即可</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">CI</span></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"attr\">branches:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">generate-source</span></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span> <span class=\"string\">source</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">ref:</span> <span class=\"string\">generate-source</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Use</span> <span class=\"string\">Node.js</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">matrix.node_version</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v1</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">version:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">matrix.node_version</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Setup</span> <span class=\"string\">hexo</span></span><br><span class=\"line\">        <span class=\"attr\">env:</span></span><br><span class=\"line\">          <span class=\"attr\">ACTION_DEPLOY_KEY:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.HEXO_DEPLOY_PRI</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">mkdir</span> <span class=\"string\">-p</span> <span class=\"string\">~/.ssh/</span></span><br><span class=\"line\">          <span class=\"string\">echo</span> <span class=\"string\">\"$ACTION_DEPLOY_KEY\"</span> <span class=\"string\">&gt;</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">          <span class=\"string\">chmod</span> <span class=\"number\">600</span> <span class=\"string\">~/.ssh/id_rsa</span></span><br><span class=\"line\">          <span class=\"string\">ssh-keyscan</span> <span class=\"string\">github.com</span> <span class=\"string\">&gt;&gt;</span> <span class=\"string\">~/.ssh/known_hosts</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.email</span> <span class=\"string\">\"tanxinzheng@139.com\"</span></span><br><span class=\"line\">          <span class=\"string\">git</span> <span class=\"string\">config</span> <span class=\"string\">--global</span> <span class=\"string\">user.name</span> <span class=\"string\">\"tanxinzheng\"</span></span><br><span class=\"line\">          <span class=\"string\">npm</span> <span class=\"string\">install</span> <span class=\"string\">hexo-cli</span> <span class=\"string\">-g</span></span><br><span class=\"line\">          <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Hexo</span> <span class=\"string\">deploy</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\">          <span class=\"string\">hexo</span> <span class=\"string\">clean</span></span><br><span class=\"line\">          <span class=\"string\">hexo</span> <span class=\"string\">d</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Github-Action执行部署\"><a href=\"#Github-Action执行部署\" class=\"headerlink\" title=\"Github Action执行部署\"></a>Github Action执行部署</h1><p>在Github Action页面执行即可，push之后会自动部署。</p>\n"},{"title":"Hexo命令","index_img":"/img/hexo.jpeg","abbrlink":2628717197,"_content":"\n\n## init\n\n```\n$ hexo init [folder]\n```\n\n新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\nThis command is a shortcut that runs the following steps:\n\n1. Git clone [hexo-starter](https://github.com/hexojs/hexo-starter) including [hexo-theme-landscape](https://github.com/hexojs/hexo-theme-landscape) into the current directory or a target folder if specified.\n2. Install dependencies using a package manager: [Yarn 1](https://classic.yarnpkg.com/lang/en/), [pnpm](https://pnpm.js.org/) or [npm](https://docs.npmjs.com/cli/install), whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with [Node.js](https://hexo.io/docs/#Install-Node-js) by default.\n\n## new\n\n```\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n```\n$ hexo new \"post title with whitespace\"\n```\n\n| 参数              | 描述                                          |\n| :---------------- | :-------------------------------------------- |\n| `-p`, `--path`    | 自定义新文章的路径                            |\n| `-r`, `--replace` | 如果存在同名文章，将其替换                    |\n| `-s`, `--slug`    | 文章的 Slug，作为新文章的文件名和发布后的 URL |\n\n默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 `index.md` 文件。你可以使用 `--path` 参数来覆盖上述行为、自行决定文件的目录：\n\n```\nhexo new page --path about/me \"About me\"\n```\n\n以上命令会创建一个 `source/about/me.md` 文件，同时 Front Matter 中的 title 为 `\"About me\"`\n\n注意！title 是必须指定的！如果你这么做并不能达到你的目的：\n\n```\nhexo new page --path about/me\n```\n\n此时 Hexo 会创建 `source/_posts/about/me.md`，同时 `me.md` 的 Front Matter 中的 title 为 `\"page\"`。这是因为在上述命令中，hexo-cli 将 `page` 视为指定文章的标题、并采用默认的 `layout`。\n\n## generate\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项                  | 描述                                                         |\n| :-------------------- | :----------------------------------------------------------- |\n| `-d`, `--deploy`      | 文件生成后立即部署网站                                       |\n| `-w`, `--watch`       | 监视文件变动                                                 |\n| `-b`, `--bail`        | 生成过程中如果发生任何未处理的异常则抛出异常                 |\n| `-f`, `--force`       | 强制重新生成文件 Hexo 引入了差分机制，如果 `public` 目录存在，那么 `hexo g` 只会重新生成改动的文件。 使用该参数的效果接近 `hexo clean && hexo generate` |\n| `-c`, `--concurrency` | 最大同时生成文件的数量，默认无限制                           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n## publish\n\n```\n$ hexo publish [layout] <filename>\n```\n\n发表草稿。\n\n## server\n\n```\n$ hexo server\n```\n\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n| 选项             | 描述                           |\n| :--------------- | :----------------------------- |\n| `-p`, `--port`   | 重设端口                       |\n| `-s`, `--static` | 只使用静态文件                 |\n| `-l`, `--log`    | 启动日记记录，使用覆盖记录格式 |\n\n## deploy\n\n```\n$ hexo deploy\n```\n\n部署网站。\n\n| 参数               | 描述                     |\n| :----------------- | :----------------------- |\n| `-g`, `--generate` | 部署之前预先生成静态文件 |\n\n该命令可以简写为：\n\n```\n$ hexo d\n```\n\n## render\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n渲染文件。\n\n| 参数             | 描述         |\n| :--------------- | :----------- |\n| `-o`, `--output` | 设置输出路径 |\n\n## migrate\n\n```\n$ hexo migrate <type>\n```\n\n从其他博客系统 [迁移内容](https://hexo.io/zh-cn/docs/migration)。\n\n## clean\n\n```\n$ hexo clean\n```\n\n清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n## list\n\n```\n$ hexo list <type>\n```\n\n列出网站资料。\n\n## version\n\n```\n$ hexo version\n```\n\n显示 Hexo 版本。\n\n## 选项\n\n### 安全模式\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n### 调试模式\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 `debug.log`。当您碰到问题时，可以尝试用调试模式重新执行一次，并 [提交调试信息到 GitHub](https://github.com/hexojs/hexo/issues/new)。\n\n### 简洁模式\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n### 自定义配置文件的路径\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n自定义配置文件的路径，指定这个参数后将不再使用默认的 `_config.yml`。\n你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 `_multiconfig.yml`。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。\n\n### 显示草稿\n\n```\n$ hexo --draft\n```\n\n显示 `source/_drafts` 文件夹中的草稿文章。\n\n### 自定义 CWD\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。","source":"_posts/hexo/hexo命令.md","raw":"---\ntitle: Hexo命令\ntags:\n  - Hexo\nindex_img: /img/hexo.jpeg\nabbrlink: 2628717197\n---\n\n\n## init\n\n```\n$ hexo init [folder]\n```\n\n新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\nThis command is a shortcut that runs the following steps:\n\n1. Git clone [hexo-starter](https://github.com/hexojs/hexo-starter) including [hexo-theme-landscape](https://github.com/hexojs/hexo-theme-landscape) into the current directory or a target folder if specified.\n2. Install dependencies using a package manager: [Yarn 1](https://classic.yarnpkg.com/lang/en/), [pnpm](https://pnpm.js.org/) or [npm](https://docs.npmjs.com/cli/install), whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with [Node.js](https://hexo.io/docs/#Install-Node-js) by default.\n\n## new\n\n```\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n```\n$ hexo new \"post title with whitespace\"\n```\n\n| 参数              | 描述                                          |\n| :---------------- | :-------------------------------------------- |\n| `-p`, `--path`    | 自定义新文章的路径                            |\n| `-r`, `--replace` | 如果存在同名文章，将其替换                    |\n| `-s`, `--slug`    | 文章的 Slug，作为新文章的文件名和发布后的 URL |\n\n默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 `index.md` 文件。你可以使用 `--path` 参数来覆盖上述行为、自行决定文件的目录：\n\n```\nhexo new page --path about/me \"About me\"\n```\n\n以上命令会创建一个 `source/about/me.md` 文件，同时 Front Matter 中的 title 为 `\"About me\"`\n\n注意！title 是必须指定的！如果你这么做并不能达到你的目的：\n\n```\nhexo new page --path about/me\n```\n\n此时 Hexo 会创建 `source/_posts/about/me.md`，同时 `me.md` 的 Front Matter 中的 title 为 `\"page\"`。这是因为在上述命令中，hexo-cli 将 `page` 视为指定文章的标题、并采用默认的 `layout`。\n\n## generate\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项                  | 描述                                                         |\n| :-------------------- | :----------------------------------------------------------- |\n| `-d`, `--deploy`      | 文件生成后立即部署网站                                       |\n| `-w`, `--watch`       | 监视文件变动                                                 |\n| `-b`, `--bail`        | 生成过程中如果发生任何未处理的异常则抛出异常                 |\n| `-f`, `--force`       | 强制重新生成文件 Hexo 引入了差分机制，如果 `public` 目录存在，那么 `hexo g` 只会重新生成改动的文件。 使用该参数的效果接近 `hexo clean && hexo generate` |\n| `-c`, `--concurrency` | 最大同时生成文件的数量，默认无限制                           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n## publish\n\n```\n$ hexo publish [layout] <filename>\n```\n\n发表草稿。\n\n## server\n\n```\n$ hexo server\n```\n\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n| 选项             | 描述                           |\n| :--------------- | :----------------------------- |\n| `-p`, `--port`   | 重设端口                       |\n| `-s`, `--static` | 只使用静态文件                 |\n| `-l`, `--log`    | 启动日记记录，使用覆盖记录格式 |\n\n## deploy\n\n```\n$ hexo deploy\n```\n\n部署网站。\n\n| 参数               | 描述                     |\n| :----------------- | :----------------------- |\n| `-g`, `--generate` | 部署之前预先生成静态文件 |\n\n该命令可以简写为：\n\n```\n$ hexo d\n```\n\n## render\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n渲染文件。\n\n| 参数             | 描述         |\n| :--------------- | :----------- |\n| `-o`, `--output` | 设置输出路径 |\n\n## migrate\n\n```\n$ hexo migrate <type>\n```\n\n从其他博客系统 [迁移内容](https://hexo.io/zh-cn/docs/migration)。\n\n## clean\n\n```\n$ hexo clean\n```\n\n清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n## list\n\n```\n$ hexo list <type>\n```\n\n列出网站资料。\n\n## version\n\n```\n$ hexo version\n```\n\n显示 Hexo 版本。\n\n## 选项\n\n### 安全模式\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n### 调试模式\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 `debug.log`。当您碰到问题时，可以尝试用调试模式重新执行一次，并 [提交调试信息到 GitHub](https://github.com/hexojs/hexo/issues/new)。\n\n### 简洁模式\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n### 自定义配置文件的路径\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n自定义配置文件的路径，指定这个参数后将不再使用默认的 `_config.yml`。\n你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 `_multiconfig.yml`。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。\n\n### 显示草稿\n\n```\n$ hexo --draft\n```\n\n显示 `source/_drafts` 文件夹中的草稿文章。\n\n### 自定义 CWD\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。","slug":"hexo/hexo命令","published":1,"date":"2020-12-15T01:04:34.082Z","updated":"2020-12-15T01:04:34.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz76000zmxcd1o4174cy","content":"<h2 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init [folder]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>\n<p>This command is a shortcut that runs the following steps:</p>\n<ol>\n<li>Git clone <a href=\"https://github.com/hexojs/hexo-starter\" target=\"_blank\" rel=\"noopener\">hexo-starter</a> including <a href=\"https://github.com/hexojs/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">hexo-theme-landscape</a> into the current directory or a target folder if specified.</li>\n<li>Install dependencies using a package manager: <a href=\"https://classic.yarnpkg.com/lang/en/\" target=\"_blank\" rel=\"noopener\">Yarn 1</a>, <a href=\"https://pnpm.js.org/\" target=\"_blank\" rel=\"noopener\">pnpm</a> or <a href=\"https://docs.npmjs.com/cli/install\" target=\"_blank\" rel=\"noopener\">npm</a>, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with <a href=\"https://hexo.io/docs/#Install-Node-js\" target=\"_blank\" rel=\"noopener\">Node.js</a> by default.</li>\n</ol>\n<h2 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--path</code></td>\n<td align=\"left\">自定义新文章的路径</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-r</code>, <code>--replace</code></td>\n<td align=\"left\">如果存在同名文章，将其替换</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--slug</code></td>\n<td align=\"left\">文章的 Slug，作为新文章的文件名和发布后的 URL</td>\n</tr>\n</tbody></table>\n<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p>\n<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure>\n\n<p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p>\n<h2 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>生成静态文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-d</code>, <code>--deploy</code></td>\n<td align=\"left\">文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-w</code>, <code>--watch</code></td>\n<td align=\"left\">监视文件变动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-b</code>, <code>--bail</code></td>\n<td align=\"left\">生成过程中如果发生任何未处理的异常则抛出异常</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-f</code>, <code>--force</code></td>\n<td align=\"left\">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>-c</code>, <code>--concurrency</code></td>\n<td align=\"left\">最大同时生成文件的数量，默认无限制</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"publish\"><a href=\"#publish\" class=\"headerlink\" title=\"publish\"></a>publish</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n\n<p>发表草稿。</p>\n<h2 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--port</code></td>\n<td align=\"left\">重设端口</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--static</code></td>\n<td align=\"left\">只使用静态文件</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-l</code>, <code>--log</code></td>\n<td align=\"left\">启动日记记录，使用覆盖记录格式</td>\n</tr>\n</tbody></table>\n<h2 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>部署网站。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-g</code>, <code>--generate</code></td>\n<td align=\"left\">部署之前预先生成静态文件</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>渲染文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-o</code>, <code>--output</code></td>\n<td align=\"left\">设置输出路径</td>\n</tr>\n</tbody></table>\n<h2 id=\"migrate\"><a href=\"#migrate\" class=\"headerlink\" title=\"migrate\"></a>migrate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>\n\n<p>从其他博客系统 <a href=\"https://hexo.io/zh-cn/docs/migration\" target=\"_blank\" rel=\"noopener\">迁移内容</a>。</p>\n<h2 id=\"clean\"><a href=\"#clean\" class=\"headerlink\" title=\"clean\"></a>clean</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n\n<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>\n<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>\n<h2 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>\n\n<p>列出网站资料。</p>\n<h2 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo version</span><br></pre></td></tr></table></figure>\n\n<p>显示 Hexo 版本。</p>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><h3 id=\"安全模式\"><a href=\"#安全模式\" class=\"headerlink\" title=\"安全模式\"></a>安全模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --safe</span><br></pre></td></tr></table></figure>\n\n<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>\n<h3 id=\"调试模式\"><a href=\"#调试模式\" class=\"headerlink\" title=\"调试模式\"></a>调试模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --debug</span><br></pre></td></tr></table></figure>\n\n<p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href=\"https://github.com/hexojs/hexo/issues/new\" target=\"_blank\" rel=\"noopener\">提交调试信息到 GitHub</a>。</p>\n<h3 id=\"简洁模式\"><a href=\"#简洁模式\" class=\"headerlink\" title=\"简洁模式\"></a>简洁模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --silent</span><br></pre></td></tr></table></figure>\n\n<p>隐藏终端信息。</p>\n<h3 id=\"自定义配置文件的路径\"><a href=\"#自定义配置文件的路径\" class=\"headerlink\" title=\"自定义配置文件的路径\"></a>自定义配置文件的路径</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class=\"line\">$ hexo server --config custom.yml</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span><br><span class=\"line\">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>\n\n<p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class=\"line\">$ hexo server --config custom.yml</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span><br><span class=\"line\">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>\n\n<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>\n<h3 id=\"显示草稿\"><a href=\"#显示草稿\" class=\"headerlink\" title=\"显示草稿\"></a>显示草稿</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --draft</span><br></pre></td></tr></table></figure>\n\n<p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>\n<h3 id=\"自定义-CWD\"><a href=\"#自定义-CWD\" class=\"headerlink\" title=\"自定义 CWD\"></a>自定义 CWD</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure>\n\n<p>自定义当前工作目录（Current working directory）的路径。</p>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h2 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init [folder]</span><br></pre></td></tr></table></figure>\n\n<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>\n<p>This command is a shortcut that runs the following steps:</p>\n<ol>\n<li>Git clone <a href=\"https://github.com/hexojs/hexo-starter\" target=\"_blank\" rel=\"noopener\">hexo-starter</a> including <a href=\"https://github.com/hexojs/hexo-theme-landscape\" target=\"_blank\" rel=\"noopener\">hexo-theme-landscape</a> into the current directory or a target folder if specified.</li>\n<li>Install dependencies using a package manager: <a href=\"https://classic.yarnpkg.com/lang/en/\" target=\"_blank\" rel=\"noopener\">Yarn 1</a>, <a href=\"https://pnpm.js.org/\" target=\"_blank\" rel=\"noopener\">pnpm</a> or <a href=\"https://docs.npmjs.com/cli/install\" target=\"_blank\" rel=\"noopener\">npm</a>, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with <a href=\"https://hexo.io/docs/#Install-Node-js\" target=\"_blank\" rel=\"noopener\">Node.js</a> by default.</li>\n</ol>\n<h2 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\" rel=\"noopener\">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--path</code></td>\n<td align=\"left\">自定义新文章的路径</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-r</code>, <code>--replace</code></td>\n<td align=\"left\">如果存在同名文章，将其替换</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--slug</code></td>\n<td align=\"left\">文章的 Slug，作为新文章的文件名和发布后的 URL</td>\n</tr>\n</tbody></table>\n<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure>\n\n<p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p>\n<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure>\n\n<p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p>\n<h2 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>生成静态文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-d</code>, <code>--deploy</code></td>\n<td align=\"left\">文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-w</code>, <code>--watch</code></td>\n<td align=\"left\">监视文件变动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-b</code>, <code>--bail</code></td>\n<td align=\"left\">生成过程中如果发生任何未处理的异常则抛出异常</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-f</code>, <code>--force</code></td>\n<td align=\"left\">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>-c</code>, <code>--concurrency</code></td>\n<td align=\"left\">最大同时生成文件的数量，默认无限制</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"publish\"><a href=\"#publish\" class=\"headerlink\" title=\"publish\"></a>publish</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n\n<p>发表草稿。</p>\n<h2 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--port</code></td>\n<td align=\"left\">重设端口</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--static</code></td>\n<td align=\"left\">只使用静态文件</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-l</code>, <code>--log</code></td>\n<td align=\"left\">启动日记记录，使用覆盖记录格式</td>\n</tr>\n</tbody></table>\n<h2 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>部署网站。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-g</code>, <code>--generate</code></td>\n<td align=\"left\">部署之前预先生成静态文件</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>\n\n<p>渲染文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-o</code>, <code>--output</code></td>\n<td align=\"left\">设置输出路径</td>\n</tr>\n</tbody></table>\n<h2 id=\"migrate\"><a href=\"#migrate\" class=\"headerlink\" title=\"migrate\"></a>migrate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>\n\n<p>从其他博客系统 <a href=\"https://hexo.io/zh-cn/docs/migration\" target=\"_blank\" rel=\"noopener\">迁移内容</a>。</p>\n<h2 id=\"clean\"><a href=\"#clean\" class=\"headerlink\" title=\"clean\"></a>clean</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n\n<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>\n<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>\n<h2 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>\n\n<p>列出网站资料。</p>\n<h2 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo version</span><br></pre></td></tr></table></figure>\n\n<p>显示 Hexo 版本。</p>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><h3 id=\"安全模式\"><a href=\"#安全模式\" class=\"headerlink\" title=\"安全模式\"></a>安全模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --safe</span><br></pre></td></tr></table></figure>\n\n<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>\n<h3 id=\"调试模式\"><a href=\"#调试模式\" class=\"headerlink\" title=\"调试模式\"></a>调试模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --debug</span><br></pre></td></tr></table></figure>\n\n<p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href=\"https://github.com/hexojs/hexo/issues/new\" target=\"_blank\" rel=\"noopener\">提交调试信息到 GitHub</a>。</p>\n<h3 id=\"简洁模式\"><a href=\"#简洁模式\" class=\"headerlink\" title=\"简洁模式\"></a>简洁模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --silent</span><br></pre></td></tr></table></figure>\n\n<p>隐藏终端信息。</p>\n<h3 id=\"自定义配置文件的路径\"><a href=\"#自定义配置文件的路径\" class=\"headerlink\" title=\"自定义配置文件的路径\"></a>自定义配置文件的路径</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class=\"line\">$ hexo server --config custom.yml</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span><br><span class=\"line\">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>\n\n<p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class=\"line\">$ hexo server --config custom.yml</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span><br><span class=\"line\">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>\n\n<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>\n<h3 id=\"显示草稿\"><a href=\"#显示草稿\" class=\"headerlink\" title=\"显示草稿\"></a>显示草稿</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --draft</span><br></pre></td></tr></table></figure>\n\n<p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>\n<h3 id=\"自定义-CWD\"><a href=\"#自定义-CWD\" class=\"headerlink\" title=\"自定义 CWD\"></a>自定义 CWD</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure>\n\n<p>自定义当前工作目录（Current working directory）的路径。</p>\n"},{"title":"Linux之SSH免密登录","abbrlink":2578104319,"date":"2017-08-18T09:59:25.000Z","index_img":"/img/linux.jpeg","_content":"\n\n\n安装Linux/Ubuntu的阿里云ECS默认情况下是使用账号+密码通过SSH登录的，并且默认账户是root，所以这里难免会有安全隐患。\n因此这里记录一下：Linux/Ubuntu系统怎么设置普通用户（非root用户），本教程以admin用户为例，使用秘钥登录通过SSH登录远程服务器。\n\n# 本地端流程\n## 检查本地SSH Key\n检查本地是否已经存在SSH Key秘钥，输入下面的命令来检查本地是否已经存在秘钥，如果有下面结果则跳过该步，若没有那么接下来的步骤生成秘钥\n\n    $ ls -a ~/.ssh\n    .\t\t..\t\tauthorized_keys\tid_rsa\t\tid_rsa.pub\tknown_hosts\n\n## 生成本地SSH Key秘钥\n输入以下命令，默认会在相应路径下（~/.ssh）生成id_rsa和id_rsa.pub两个文件，如下面代码所示\n\n     # 注：若需要免密码登录则直接回车\n     ~$ ssh-keygen -t rsa -C \"your_email@example.com\"   \n     Enter file in which to save the key (/your_home_path/.ssh/id_rsa): \n     Enter passphrase (empty for no passphrase): \n     Enter same passphrase again: \n     Your identification has been saved in /your_home_path/.ssh/id_rsa.\n     Your public key has been saved in /your_home_path/.ssh/id_rsa.pub.\n     The key fingerprint is:\n     SHA256:YgZkAauw6YCWAWwvfiMgJ7zBGkVbFqgRxQ7hdet5nGY your_email@example.com\n     The key's randomart image is:\n     +---[RSA 2048]----+\n     |BO=++o           |\n     |Bo++. .          |\n     |oOo ..           |\n     |+==...o .        |\n     |X+.  o+ES        |\n     |=X + o+.         |\n     |.oX .            |\n     |..               |\n     |                 |\n     +----[SHA256]-----+\n\n# 服务器端流程\n创建普通用户\n使用root用户操作以下命令创建普通用户：\n## 创建用户并修改密码\n\n    useradd admin\n    passwd admin\n    vi /etc/sudoers                                 # 增加用户su身份，编辑sudoers文件\n    admin ALL=(ALL:ALL) ALL                         # 在最底部加入这一行，保存退出\n\n## 添加ssh key公钥配置\n使用root用户操作以下命令创建存储密钥的文件夹及文件\n> <font color=red>**注意：第三步是最重要的一步！！！**</font>\n\n     mkdir /home/admin/.ssh\n     chmod 700 /home/admin/.ssh                       \n     vi /home/admin/.ssh/authorized_keys            #创建authorized_keys文件，并将本地生成的id_rsa.pub的内容填入authorized_keys\n     chmod 600 /home/admin/.ssh/authorized_keys     #设置authorized_keys权限\n     chown -R admin:admin /home/admin/.ssh/         #修改用户组和用户所有权\n     systemctl stop sshd                            #暂停ssh服务\n     systemctl start sshd                           #启动ssh服务\n\n## 设置SSH登录安全配置（可选步骤）\n> **温馨提示：SSH登录安全配置建议，使用root用户操作以下命令**\n\n     # 编辑SSH配置文件 \n     vi /etc/ssh/sshd_config\n     PermitRootLogin no                             # 禁用root账号登录，该配置可不修改，避免特殊情况下需要用到root\n     PasswordAuthentication no                      # 禁用账号+密码登录\n     # 保存退出后，重启ssh服务\n     systemctl stop sshd\n     systemctl start sshd\n\n# 本地验证登录\n因为每次记ip很麻烦，推荐使用hosts映射ip，使用别名登录。\n## 添加远端ip别名\n\n    vi /etc/hosts\n    xxx.xxx.xxx.xxx   my-remote-server              # 添加远端ip及映射的别名：ip  别名\n\n## 验证ssh免密登录\n\n    ssh admin@xxx.xxx.xxx.xxx                       # ip远程登录\n    ssh admin@my-remote-server                      # 别名远程登录\n\n   \n\n\n","source":"_posts/linux/Linux之SSH免密登录.md","raw":"---\ntitle: Linux之SSH免密登录\nabbrlink: 2578104319\ndate: 2017-08-18 17:59:25\nindex_img: /img/linux.jpeg\ntags: \n  - Linux\n---\n\n\n\n安装Linux/Ubuntu的阿里云ECS默认情况下是使用账号+密码通过SSH登录的，并且默认账户是root，所以这里难免会有安全隐患。\n因此这里记录一下：Linux/Ubuntu系统怎么设置普通用户（非root用户），本教程以admin用户为例，使用秘钥登录通过SSH登录远程服务器。\n\n# 本地端流程\n## 检查本地SSH Key\n检查本地是否已经存在SSH Key秘钥，输入下面的命令来检查本地是否已经存在秘钥，如果有下面结果则跳过该步，若没有那么接下来的步骤生成秘钥\n\n    $ ls -a ~/.ssh\n    .\t\t..\t\tauthorized_keys\tid_rsa\t\tid_rsa.pub\tknown_hosts\n\n## 生成本地SSH Key秘钥\n输入以下命令，默认会在相应路径下（~/.ssh）生成id_rsa和id_rsa.pub两个文件，如下面代码所示\n\n     # 注：若需要免密码登录则直接回车\n     ~$ ssh-keygen -t rsa -C \"your_email@example.com\"   \n     Enter file in which to save the key (/your_home_path/.ssh/id_rsa): \n     Enter passphrase (empty for no passphrase): \n     Enter same passphrase again: \n     Your identification has been saved in /your_home_path/.ssh/id_rsa.\n     Your public key has been saved in /your_home_path/.ssh/id_rsa.pub.\n     The key fingerprint is:\n     SHA256:YgZkAauw6YCWAWwvfiMgJ7zBGkVbFqgRxQ7hdet5nGY your_email@example.com\n     The key's randomart image is:\n     +---[RSA 2048]----+\n     |BO=++o           |\n     |Bo++. .          |\n     |oOo ..           |\n     |+==...o .        |\n     |X+.  o+ES        |\n     |=X + o+.         |\n     |.oX .            |\n     |..               |\n     |                 |\n     +----[SHA256]-----+\n\n# 服务器端流程\n创建普通用户\n使用root用户操作以下命令创建普通用户：\n## 创建用户并修改密码\n\n    useradd admin\n    passwd admin\n    vi /etc/sudoers                                 # 增加用户su身份，编辑sudoers文件\n    admin ALL=(ALL:ALL) ALL                         # 在最底部加入这一行，保存退出\n\n## 添加ssh key公钥配置\n使用root用户操作以下命令创建存储密钥的文件夹及文件\n> <font color=red>**注意：第三步是最重要的一步！！！**</font>\n\n     mkdir /home/admin/.ssh\n     chmod 700 /home/admin/.ssh                       \n     vi /home/admin/.ssh/authorized_keys            #创建authorized_keys文件，并将本地生成的id_rsa.pub的内容填入authorized_keys\n     chmod 600 /home/admin/.ssh/authorized_keys     #设置authorized_keys权限\n     chown -R admin:admin /home/admin/.ssh/         #修改用户组和用户所有权\n     systemctl stop sshd                            #暂停ssh服务\n     systemctl start sshd                           #启动ssh服务\n\n## 设置SSH登录安全配置（可选步骤）\n> **温馨提示：SSH登录安全配置建议，使用root用户操作以下命令**\n\n     # 编辑SSH配置文件 \n     vi /etc/ssh/sshd_config\n     PermitRootLogin no                             # 禁用root账号登录，该配置可不修改，避免特殊情况下需要用到root\n     PasswordAuthentication no                      # 禁用账号+密码登录\n     # 保存退出后，重启ssh服务\n     systemctl stop sshd\n     systemctl start sshd\n\n# 本地验证登录\n因为每次记ip很麻烦，推荐使用hosts映射ip，使用别名登录。\n## 添加远端ip别名\n\n    vi /etc/hosts\n    xxx.xxx.xxx.xxx   my-remote-server              # 添加远端ip及映射的别名：ip  别名\n\n## 验证ssh免密登录\n\n    ssh admin@xxx.xxx.xxx.xxx                       # ip远程登录\n    ssh admin@my-remote-server                      # 别名远程登录\n\n   \n\n\n","slug":"linux/Linux之SSH免密登录","published":1,"updated":"2020-12-15T01:04:34.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz790010mxcdcwgd6ogz","content":"<p>安装Linux/Ubuntu的阿里云ECS默认情况下是使用账号+密码通过SSH登录的，并且默认账户是root，所以这里难免会有安全隐患。<br>因此这里记录一下：Linux/Ubuntu系统怎么设置普通用户（非root用户），本教程以admin用户为例，使用秘钥登录通过SSH登录远程服务器。</p>\n<h1 id=\"本地端流程\"><a href=\"#本地端流程\" class=\"headerlink\" title=\"本地端流程\"></a>本地端流程</h1><h2 id=\"检查本地SSH-Key\"><a href=\"#检查本地SSH-Key\" class=\"headerlink\" title=\"检查本地SSH Key\"></a>检查本地SSH Key</h2><p>检查本地是否已经存在SSH Key秘钥，输入下面的命令来检查本地是否已经存在秘钥，如果有下面结果则跳过该步，若没有那么接下来的步骤生成秘钥</p>\n<pre><code>$ ls -a ~/.ssh\n.        ..        authorized_keys    id_rsa        id_rsa.pub    known_hosts</code></pre><h2 id=\"生成本地SSH-Key秘钥\"><a href=\"#生成本地SSH-Key秘钥\" class=\"headerlink\" title=\"生成本地SSH Key秘钥\"></a>生成本地SSH Key秘钥</h2><p>输入以下命令，默认会在相应路径下（~/.ssh）生成id_rsa和id_rsa.pub两个文件，如下面代码所示</p>\n<pre><code># 注：若需要免密码登录则直接回车\n~$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;   \nEnter file in which to save the key (/your_home_path/.ssh/id_rsa): \nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /your_home_path/.ssh/id_rsa.\nYour public key has been saved in /your_home_path/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:YgZkAauw6YCWAWwvfiMgJ7zBGkVbFqgRxQ7hdet5nGY your_email@example.com\nThe key&apos;s randomart image is:\n+---[RSA 2048]----+\n|BO=++o           |\n|Bo++. .          |\n|oOo ..           |\n|+==...o .        |\n|X+.  o+ES        |\n|=X + o+.         |\n|.oX .            |\n|..               |\n|                 |\n+----[SHA256]-----+</code></pre><h1 id=\"服务器端流程\"><a href=\"#服务器端流程\" class=\"headerlink\" title=\"服务器端流程\"></a>服务器端流程</h1><p>创建普通用户<br>使用root用户操作以下命令创建普通用户：</p>\n<h2 id=\"创建用户并修改密码\"><a href=\"#创建用户并修改密码\" class=\"headerlink\" title=\"创建用户并修改密码\"></a>创建用户并修改密码</h2><pre><code>useradd admin\npasswd admin\nvi /etc/sudoers                                 # 增加用户su身份，编辑sudoers文件\nadmin ALL=(ALL:ALL) ALL                         # 在最底部加入这一行，保存退出</code></pre><h2 id=\"添加ssh-key公钥配置\"><a href=\"#添加ssh-key公钥配置\" class=\"headerlink\" title=\"添加ssh key公钥配置\"></a>添加ssh key公钥配置</h2><p>使用root用户操作以下命令创建存储密钥的文件夹及文件</p>\n<blockquote>\n<p><font color=red><strong>注意：第三步是最重要的一步！！！</strong></font></p>\n</blockquote>\n<pre><code>mkdir /home/admin/.ssh\nchmod 700 /home/admin/.ssh                       \nvi /home/admin/.ssh/authorized_keys            #创建authorized_keys文件，并将本地生成的id_rsa.pub的内容填入authorized_keys\nchmod 600 /home/admin/.ssh/authorized_keys     #设置authorized_keys权限\nchown -R admin:admin /home/admin/.ssh/         #修改用户组和用户所有权\nsystemctl stop sshd                            #暂停ssh服务\nsystemctl start sshd                           #启动ssh服务</code></pre><h2 id=\"设置SSH登录安全配置（可选步骤）\"><a href=\"#设置SSH登录安全配置（可选步骤）\" class=\"headerlink\" title=\"设置SSH登录安全配置（可选步骤）\"></a>设置SSH登录安全配置（可选步骤）</h2><blockquote>\n<p><strong>温馨提示：SSH登录安全配置建议，使用root用户操作以下命令</strong></p>\n</blockquote>\n<pre><code># 编辑SSH配置文件 \nvi /etc/ssh/sshd_config\nPermitRootLogin no                             # 禁用root账号登录，该配置可不修改，避免特殊情况下需要用到root\nPasswordAuthentication no                      # 禁用账号+密码登录\n# 保存退出后，重启ssh服务\nsystemctl stop sshd\nsystemctl start sshd</code></pre><h1 id=\"本地验证登录\"><a href=\"#本地验证登录\" class=\"headerlink\" title=\"本地验证登录\"></a>本地验证登录</h1><p>因为每次记ip很麻烦，推荐使用hosts映射ip，使用别名登录。</p>\n<h2 id=\"添加远端ip别名\"><a href=\"#添加远端ip别名\" class=\"headerlink\" title=\"添加远端ip别名\"></a>添加远端ip别名</h2><pre><code>vi /etc/hosts\nxxx.xxx.xxx.xxx   my-remote-server              # 添加远端ip及映射的别名：ip  别名</code></pre><h2 id=\"验证ssh免密登录\"><a href=\"#验证ssh免密登录\" class=\"headerlink\" title=\"验证ssh免密登录\"></a>验证ssh免密登录</h2><pre><code>ssh admin@xxx.xxx.xxx.xxx                       # ip远程登录\nssh admin@my-remote-server                      # 别名远程登录</code></pre>","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>安装Linux/Ubuntu的阿里云ECS默认情况下是使用账号+密码通过SSH登录的，并且默认账户是root，所以这里难免会有安全隐患。<br>因此这里记录一下：Linux/Ubuntu系统怎么设置普通用户（非root用户），本教程以admin用户为例，使用秘钥登录通过SSH登录远程服务器。</p>\n<h1 id=\"本地端流程\"><a href=\"#本地端流程\" class=\"headerlink\" title=\"本地端流程\"></a>本地端流程</h1><h2 id=\"检查本地SSH-Key\"><a href=\"#检查本地SSH-Key\" class=\"headerlink\" title=\"检查本地SSH Key\"></a>检查本地SSH Key</h2><p>检查本地是否已经存在SSH Key秘钥，输入下面的命令来检查本地是否已经存在秘钥，如果有下面结果则跳过该步，若没有那么接下来的步骤生成秘钥</p>\n<pre><code>$ ls -a ~/.ssh\n.        ..        authorized_keys    id_rsa        id_rsa.pub    known_hosts</code></pre><h2 id=\"生成本地SSH-Key秘钥\"><a href=\"#生成本地SSH-Key秘钥\" class=\"headerlink\" title=\"生成本地SSH Key秘钥\"></a>生成本地SSH Key秘钥</h2><p>输入以下命令，默认会在相应路径下（~/.ssh）生成id_rsa和id_rsa.pub两个文件，如下面代码所示</p>\n<pre><code># 注：若需要免密码登录则直接回车\n~$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;   \nEnter file in which to save the key (/your_home_path/.ssh/id_rsa): \nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /your_home_path/.ssh/id_rsa.\nYour public key has been saved in /your_home_path/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:YgZkAauw6YCWAWwvfiMgJ7zBGkVbFqgRxQ7hdet5nGY your_email@example.com\nThe key&apos;s randomart image is:\n+---[RSA 2048]----+\n|BO=++o           |\n|Bo++. .          |\n|oOo ..           |\n|+==...o .        |\n|X+.  o+ES        |\n|=X + o+.         |\n|.oX .            |\n|..               |\n|                 |\n+----[SHA256]-----+</code></pre><h1 id=\"服务器端流程\"><a href=\"#服务器端流程\" class=\"headerlink\" title=\"服务器端流程\"></a>服务器端流程</h1><p>创建普通用户<br>使用root用户操作以下命令创建普通用户：</p>\n<h2 id=\"创建用户并修改密码\"><a href=\"#创建用户并修改密码\" class=\"headerlink\" title=\"创建用户并修改密码\"></a>创建用户并修改密码</h2><pre><code>useradd admin\npasswd admin\nvi /etc/sudoers                                 # 增加用户su身份，编辑sudoers文件\nadmin ALL=(ALL:ALL) ALL                         # 在最底部加入这一行，保存退出</code></pre><h2 id=\"添加ssh-key公钥配置\"><a href=\"#添加ssh-key公钥配置\" class=\"headerlink\" title=\"添加ssh key公钥配置\"></a>添加ssh key公钥配置</h2><p>使用root用户操作以下命令创建存储密钥的文件夹及文件</p>\n<blockquote>\n<p><font color=red><strong>注意：第三步是最重要的一步！！！</strong></font></p>\n</blockquote>\n<pre><code>mkdir /home/admin/.ssh\nchmod 700 /home/admin/.ssh                       \nvi /home/admin/.ssh/authorized_keys            #创建authorized_keys文件，并将本地生成的id_rsa.pub的内容填入authorized_keys\nchmod 600 /home/admin/.ssh/authorized_keys     #设置authorized_keys权限\nchown -R admin:admin /home/admin/.ssh/         #修改用户组和用户所有权\nsystemctl stop sshd                            #暂停ssh服务\nsystemctl start sshd                           #启动ssh服务</code></pre><h2 id=\"设置SSH登录安全配置（可选步骤）\"><a href=\"#设置SSH登录安全配置（可选步骤）\" class=\"headerlink\" title=\"设置SSH登录安全配置（可选步骤）\"></a>设置SSH登录安全配置（可选步骤）</h2><blockquote>\n<p><strong>温馨提示：SSH登录安全配置建议，使用root用户操作以下命令</strong></p>\n</blockquote>\n<pre><code># 编辑SSH配置文件 \nvi /etc/ssh/sshd_config\nPermitRootLogin no                             # 禁用root账号登录，该配置可不修改，避免特殊情况下需要用到root\nPasswordAuthentication no                      # 禁用账号+密码登录\n# 保存退出后，重启ssh服务\nsystemctl stop sshd\nsystemctl start sshd</code></pre><h1 id=\"本地验证登录\"><a href=\"#本地验证登录\" class=\"headerlink\" title=\"本地验证登录\"></a>本地验证登录</h1><p>因为每次记ip很麻烦，推荐使用hosts映射ip，使用别名登录。</p>\n<h2 id=\"添加远端ip别名\"><a href=\"#添加远端ip别名\" class=\"headerlink\" title=\"添加远端ip别名\"></a>添加远端ip别名</h2><pre><code>vi /etc/hosts\nxxx.xxx.xxx.xxx   my-remote-server              # 添加远端ip及映射的别名：ip  别名</code></pre><h2 id=\"验证ssh免密登录\"><a href=\"#验证ssh免密登录\" class=\"headerlink\" title=\"验证ssh免密登录\"></a>验证ssh免密登录</h2><pre><code>ssh admin@xxx.xxx.xxx.xxx                       # ip远程登录\nssh admin@my-remote-server                      # 别名远程登录</code></pre>"},{"title":"Mac系统下升级node版本","abbrlink":1345941684,"_content":"\n[TOC]\n\n#### 第一步：使用npm安装n模块\n\nn模块是专门用来管理nodejs版本的，名字就叫n执行命令\n\n`npm install -g n`  **（注意不带sudo，我按照网上带sudo提示错误）**\n\n\n\n出现此日志表示添加n包成功\n\n#### 第二步：使用n模块升级node\n\n*第一种是升级到最新版本*\n\n```\nsudo n latest\n```\n\n*第二种是升级到稳定版本（建议用稳定版本）*\n\n`sudo n stable`\n\n安装成功！（若版本未切换成功则进入第三步手动修改环境变量）\n\n```\nnode -v\nv11.10.1\n```\n\n最后升级npm到最新版本：\n\n```\nsudo npm install npm@latest -g\n```\n\n#### 第三步：修改NODE_HOME环境变量\n\n```shell\nsudo vi /etc/profile\n+\nexport NODE_HOME=/usr/local/n/versions/node/12.0.0\nexport PATH=$NODE_HOME/bin:$PATH\n```\n\n激活环境变量\n\n```\nsource /etc/profile\n```","source":"_posts/mac/Mac系统下升级node版本.md","raw":"---\ntitle: Mac系统下升级node版本\nabbrlink: 1345941684\ntags:\n\t- mac\n\t- node\n---\n\n[TOC]\n\n#### 第一步：使用npm安装n模块\n\nn模块是专门用来管理nodejs版本的，名字就叫n执行命令\n\n`npm install -g n`  **（注意不带sudo，我按照网上带sudo提示错误）**\n\n\n\n出现此日志表示添加n包成功\n\n#### 第二步：使用n模块升级node\n\n*第一种是升级到最新版本*\n\n```\nsudo n latest\n```\n\n*第二种是升级到稳定版本（建议用稳定版本）*\n\n`sudo n stable`\n\n安装成功！（若版本未切换成功则进入第三步手动修改环境变量）\n\n```\nnode -v\nv11.10.1\n```\n\n最后升级npm到最新版本：\n\n```\nsudo npm install npm@latest -g\n```\n\n#### 第三步：修改NODE_HOME环境变量\n\n```shell\nsudo vi /etc/profile\n+\nexport NODE_HOME=/usr/local/n/versions/node/12.0.0\nexport PATH=$NODE_HOME/bin:$PATH\n```\n\n激活环境变量\n\n```\nsource /etc/profile\n```","slug":"mac/Mac系统下升级node版本","published":1,"date":"2020-12-15T01:11:27.412Z","updated":"2020-12-15T01:12:49.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz7c0011mxcdec14ffwy","content":"<p>[TOC]</p>\n<h4 id=\"第一步：使用npm安装n模块\"><a href=\"#第一步：使用npm安装n模块\" class=\"headerlink\" title=\"第一步：使用npm安装n模块\"></a>第一步：使用npm安装n模块</h4><p>n模块是专门用来管理nodejs版本的，名字就叫n执行命令</p>\n<p><code>npm install -g n</code>  <strong>（注意不带sudo，我按照网上带sudo提示错误）</strong></p>\n<p>出现此日志表示添加n包成功</p>\n<h4 id=\"第二步：使用n模块升级node\"><a href=\"#第二步：使用n模块升级node\" class=\"headerlink\" title=\"第二步：使用n模块升级node\"></a>第二步：使用n模块升级node</h4><p><em>第一种是升级到最新版本</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo n latest</span><br></pre></td></tr></table></figure>\n\n<p><em>第二种是升级到稳定版本（建议用稳定版本）</em></p>\n<p><code>sudo n stable</code></p>\n<p>安装成功！（若版本未切换成功则进入第三步手动修改环境变量）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">v11.10.1</span><br></pre></td></tr></table></figure>\n\n<p>最后升级npm到最新版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install npm@latest -g</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"第三步：修改NODE-HOME环境变量\"><a href=\"#第三步：修改NODE-HOME环境变量\" class=\"headerlink\" title=\"第三步：修改NODE_HOME环境变量\"></a>第三步：修改NODE_HOME环境变量</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vi /etc/profile</span><br><span class=\"line\">+</span><br><span class=\"line\">export NODE_HOME=/usr/local/n/versions/node/12.0.0</span><br><span class=\"line\">export PATH=$NODE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<p>激活环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>[TOC]</p>\n<h4 id=\"第一步：使用npm安装n模块\"><a href=\"#第一步：使用npm安装n模块\" class=\"headerlink\" title=\"第一步：使用npm安装n模块\"></a>第一步：使用npm安装n模块</h4><p>n模块是专门用来管理nodejs版本的，名字就叫n执行命令</p>\n<p><code>npm install -g n</code>  <strong>（注意不带sudo，我按照网上带sudo提示错误）</strong></p>\n<p>出现此日志表示添加n包成功</p>\n<h4 id=\"第二步：使用n模块升级node\"><a href=\"#第二步：使用n模块升级node\" class=\"headerlink\" title=\"第二步：使用n模块升级node\"></a>第二步：使用n模块升级node</h4><p><em>第一种是升级到最新版本</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo n latest</span><br></pre></td></tr></table></figure>\n\n<p><em>第二种是升级到稳定版本（建议用稳定版本）</em></p>\n<p><code>sudo n stable</code></p>\n<p>安装成功！（若版本未切换成功则进入第三步手动修改环境变量）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node -v</span><br><span class=\"line\">v11.10.1</span><br></pre></td></tr></table></figure>\n\n<p>最后升级npm到最新版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo npm install npm@latest -g</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"第三步：修改NODE-HOME环境变量\"><a href=\"#第三步：修改NODE-HOME环境变量\" class=\"headerlink\" title=\"第三步：修改NODE_HOME环境变量\"></a>第三步：修改NODE_HOME环境变量</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vi /etc/profile</span><br><span class=\"line\">+</span><br><span class=\"line\">export NODE_HOME=/usr/local/n/versions/node/12.0.0</span><br><span class=\"line\">export PATH=$NODE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>\n\n<p>激活环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>"},{"title":"Java【基础篇之HashMap及hashcode】","abbrlink":2936205123,"date":"2019-10-10T02:12:00.000Z","index_img":"/img/java.jpeg","_content":"## 一、hashcode是什么\n要理解hashcode首先要理解hash表这个概念\n\n1. 哈希表\nhash表也称散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的hashcode是什么记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。\n简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。\n具有快速查找和插入操作的优点\n2. hashcode\nhashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置\n每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode\n## 二、hashcode的作用\n    HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的\n\n    对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。\n\n   在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题\n\n   如何判别在集合中是否已经存在该对象了？\n\n   首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。    此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了。\n\n    这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。\n\n            所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。\n\n## 三、 hashCode()和equals()\nJava的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)\n\n1. equals方法\nObject类中equals()方法实现如下\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。\n\n虽然可以重写equals()方法，但是有一些注意事项；JDK中说明了实现equals()方法应该遵守的约定\n\n自反性：x.equals(x)必须返回true。\n对称性：x.equals(y)与y.equals(x)的返回值必须相等。\n传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。\n一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。\n非null：x不是null，y为null，则x.equals(y)必须为false。\n2. hashCode 方法\nObject类中hashCode()方法的声明如下：\n\npublic native int hashCode();\n可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。\n\n与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：\n\n（1）hashCode()在哈希表中起作用，如java.util.HashMap。\n（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。\n（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。\n（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。\n重写hashcode()的原则\n\n（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。\n（2）hashCode()方法不能太过简单，否则哈希冲突过多。\n（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能\nhashCode()重写方法\n\n《Effective Java》中提出了一种简单通用的hashCode算法：\n\n初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;\n\n选取equals方法中用于比较的所有域（之所以只选择equals()中使用的域，是为了保证上述原则的第1条），然后针对每个域的属性进行计算：\n\n复制代码\n(1) 如果是boolean值，则计算f ? 1:0\n(2) 如果是bytecharshortint,则计算(int)f\n(3) 如果是long值，则计算(int)(f ^ (f >>> 32))\n(4) 如果是float值，则计算Float.floatToIntBits(f)\n(5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int\n(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0\n(7) 如果是数组，那么需要为每个元素当做单独的域来处理。java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上。 \n复制代码\n最后，把每个域的散列码合并到对象的哈希码中。\n\n## 四、HashMap中的hash()函数\nHashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n这段代码类似作用是为了增加hashcode的随机性\n\nkey.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。\n\nhashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个\"与\"操作\n\nstatic int indexFor(int h, int length) { return h & (length-1);}\n这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h & (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。\n  01111010 00111100 00100101\n& 00000000 00000000 00001111\n----------------------------------\n  00000000 00000000 00000101\n  //高位全部归零，只保留末四位 \nbut 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上成个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。\n\n这时候 “hash”函数作用就出来了\n\n右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。\n设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。\n根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。\nhashMap中 MAXIMUM_CAPACITY = 1 << 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）","source":"_posts/java/hashcode.md","raw":"---\ntitle: Java【基础篇之HashMap及hashcode】\ntags:\n  - Java\nabbrlink: 2936205123\ndate: 2019-10-10 10:12:00\nindex_img: /img/java.jpeg\n---\n## 一、hashcode是什么\n要理解hashcode首先要理解hash表这个概念\n\n1. 哈希表\nhash表也称散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的hashcode是什么记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。\n简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。\n具有快速查找和插入操作的优点\n2. hashcode\nhashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置\n每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode\n## 二、hashcode的作用\n    HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的\n\n    对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。\n\n   在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题\n\n   如何判别在集合中是否已经存在该对象了？\n\n   首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。    此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了。\n\n    这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。\n\n            所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。\n\n## 三、 hashCode()和equals()\nJava的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)\n\n1. equals方法\nObject类中equals()方法实现如下\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。\n\n虽然可以重写equals()方法，但是有一些注意事项；JDK中说明了实现equals()方法应该遵守的约定\n\n自反性：x.equals(x)必须返回true。\n对称性：x.equals(y)与y.equals(x)的返回值必须相等。\n传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。\n一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。\n非null：x不是null，y为null，则x.equals(y)必须为false。\n2. hashCode 方法\nObject类中hashCode()方法的声明如下：\n\npublic native int hashCode();\n可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。\n\n与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：\n\n（1）hashCode()在哈希表中起作用，如java.util.HashMap。\n（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。\n（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。\n（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。\n重写hashcode()的原则\n\n（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。\n（2）hashCode()方法不能太过简单，否则哈希冲突过多。\n（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能\nhashCode()重写方法\n\n《Effective Java》中提出了一种简单通用的hashCode算法：\n\n初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;\n\n选取equals方法中用于比较的所有域（之所以只选择equals()中使用的域，是为了保证上述原则的第1条），然后针对每个域的属性进行计算：\n\n复制代码\n(1) 如果是boolean值，则计算f ? 1:0\n(2) 如果是bytecharshortint,则计算(int)f\n(3) 如果是long值，则计算(int)(f ^ (f >>> 32))\n(4) 如果是float值，则计算Float.floatToIntBits(f)\n(5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int\n(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0\n(7) 如果是数组，那么需要为每个元素当做单独的域来处理。java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上。 \n复制代码\n最后，把每个域的散列码合并到对象的哈希码中。\n\n## 四、HashMap中的hash()函数\nHashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n这段代码类似作用是为了增加hashcode的随机性\n\nkey.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。\n\nhashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个\"与\"操作\n\nstatic int indexFor(int h, int length) { return h & (length-1);}\n这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h & (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。\n  01111010 00111100 00100101\n& 00000000 00000000 00001111\n----------------------------------\n  00000000 00000000 00000101\n  //高位全部归零，只保留末四位 \nbut 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上成个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。\n\n这时候 “hash”函数作用就出来了\n\n右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。\n设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。\n根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。\nhashMap中 MAXIMUM_CAPACITY = 1 << 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）","slug":"java/hashcode","published":1,"updated":"2020-12-15T01:04:34.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz85001emxcdcdqp70jg","content":"<h2 id=\"一、hashcode是什么\"><a href=\"#一、hashcode是什么\" class=\"headerlink\" title=\"一、hashcode是什么\"></a>一、hashcode是什么</h2><p>要理解hashcode首先要理解hash表这个概念</p>\n<ol>\n<li><p>哈希表<br>hash表也称散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的hashcode是什么记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。<br>简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。<br>具有快速查找和插入操作的优点</p>\n</li>\n<li><p>hashcode<br>hashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置<br>每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode</p>\n<h2 id=\"二、hashcode的作用\"><a href=\"#二、hashcode的作用\" class=\"headerlink\" title=\"二、hashcode的作用\"></a>二、hashcode的作用</h2><p> HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p>\n<p> 对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p>\n<p>在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题</p>\n<p>如何判别在集合中是否已经存在该对象了？</p>\n<p>首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。    此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了。</p>\n<p> 这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。</p>\n<pre><code>所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</code></pre></li>\n</ol>\n<h2 id=\"三、-hashCode-和equals\"><a href=\"#三、-hashCode-和equals\" class=\"headerlink\" title=\"三、 hashCode()和equals()\"></a>三、 hashCode()和equals()</h2><p>Java的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)</p>\n<ol>\n<li>equals方法<br>Object类中equals()方法实现如下</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。</p>\n<p>虽然可以重写equals()方法，但是有一些注意事项；JDK中说明了实现equals()方法应该遵守的约定</p>\n<p>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。<br>2. hashCode 方法<br>Object类中hashCode()方法的声明如下：</p>\n<p>public native int hashCode();<br>可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。</p>\n<p>与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：</p>\n<p>（1）hashCode()在哈希表中起作用，如java.util.HashMap。<br>（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。<br>（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。<br>（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。<br>重写hashcode()的原则</p>\n<p>（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。<br>（2）hashCode()方法不能太过简单，否则哈希冲突过多。<br>（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能<br>hashCode()重写方法</p>\n<p>《Effective Java》中提出了一种简单通用的hashCode算法：</p>\n<p>初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;</p>\n<p>选取equals方法中用于比较的所有域（之所以只选择equals()中使用的域，是为了保证上述原则的第1条），然后针对每个域的属性进行计算：</p>\n<p>复制代码<br>(1) 如果是boolean值，则计算f ? 1:0<br>(2) 如果是bytecharshortint,则计算(int)f<br>(3) 如果是long值，则计算(int)(f ^ (f &gt;&gt;&gt; 32))<br>(4) 如果是float值，则计算Float.floatToIntBits(f)<br>(5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int<br>(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0<br>(7) 如果是数组，那么需要为每个元素当做单独的域来处理。java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上。<br>复制代码<br>最后，把每个域的散列码合并到对象的哈希码中。</p>\n<h2 id=\"四、HashMap中的hash-函数\"><a href=\"#四、HashMap中的hash-函数\" class=\"headerlink\" title=\"四、HashMap中的hash()函数\"></a>四、HashMap中的hash()函数</h2><p>HashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int hash(Object key) &#123;</span><br><span class=\"line\">    int h;</span><br><span class=\"line\">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码类似作用是为了增加hashcode的随机性</p>\n<p>key.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>\n<p>hashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个”与”操作</p>\n<p>static int indexFor(int h, int length) { return h &amp; (length-1);}<br>这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h &amp; (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。<br>  01111010 00111100 00100101<br>&amp; 00000000 00000000 00001111</p>\n<hr>\n<p>  00000000 00000000 00000101<br>  //高位全部归零，只保留末四位<br>but 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上成个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。</p>\n<p>这时候 “hash”函数作用就出来了</p>\n<p>右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。<br>设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。<br>根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。<br>hashMap中 MAXIMUM_CAPACITY = 1 &lt;&lt; 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）</p>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h2 id=\"一、hashcode是什么\"><a href=\"#一、hashcode是什么\" class=\"headerlink\" title=\"一、hashcode是什么\"></a>一、hashcode是什么</h2><p>要理解hashcode首先要理解hash表这个概念</p>\n<ol>\n<li><p>哈希表<br>hash表也称散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的hashcode是什么记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。<br>简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。<br>具有快速查找和插入操作的优点</p>\n</li>\n<li><p>hashcode<br>hashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置<br>每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode</p>\n<h2 id=\"二、hashcode的作用\"><a href=\"#二、hashcode的作用\" class=\"headerlink\" title=\"二、hashcode的作用\"></a>二、hashcode的作用</h2><p> HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p>\n<p> 对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p>\n<p>在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题</p>\n<p>如何判别在集合中是否已经存在该对象了？</p>\n<p>首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。    此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了。</p>\n<p> 这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。</p>\n<pre><code>所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</code></pre></li>\n</ol>\n<h2 id=\"三、-hashCode-和equals\"><a href=\"#三、-hashCode-和equals\" class=\"headerlink\" title=\"三、 hashCode()和equals()\"></a>三、 hashCode()和equals()</h2><p>Java的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)</p>\n<ol>\n<li>equals方法<br>Object类中equals()方法实现如下</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。</p>\n<p>虽然可以重写equals()方法，但是有一些注意事项；JDK中说明了实现equals()方法应该遵守的约定</p>\n<p>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。<br>2. hashCode 方法<br>Object类中hashCode()方法的声明如下：</p>\n<p>public native int hashCode();<br>可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。</p>\n<p>与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：</p>\n<p>（1）hashCode()在哈希表中起作用，如java.util.HashMap。<br>（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。<br>（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。<br>（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。<br>重写hashcode()的原则</p>\n<p>（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。<br>（2）hashCode()方法不能太过简单，否则哈希冲突过多。<br>（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能<br>hashCode()重写方法</p>\n<p>《Effective Java》中提出了一种简单通用的hashCode算法：</p>\n<p>初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;</p>\n<p>选取equals方法中用于比较的所有域（之所以只选择equals()中使用的域，是为了保证上述原则的第1条），然后针对每个域的属性进行计算：</p>\n<p>复制代码<br>(1) 如果是boolean值，则计算f ? 1:0<br>(2) 如果是bytecharshortint,则计算(int)f<br>(3) 如果是long值，则计算(int)(f ^ (f &gt;&gt;&gt; 32))<br>(4) 如果是float值，则计算Float.floatToIntBits(f)<br>(5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int<br>(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0<br>(7) 如果是数组，那么需要为每个元素当做单独的域来处理。java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上。<br>复制代码<br>最后，把每个域的散列码合并到对象的哈希码中。</p>\n<h2 id=\"四、HashMap中的hash-函数\"><a href=\"#四、HashMap中的hash-函数\" class=\"headerlink\" title=\"四、HashMap中的hash()函数\"></a>四、HashMap中的hash()函数</h2><p>HashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int hash(Object key) &#123;</span><br><span class=\"line\">    int h;</span><br><span class=\"line\">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码类似作用是为了增加hashcode的随机性</p>\n<p>key.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>\n<p>hashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个”与”操作</p>\n<p>static int indexFor(int h, int length) { return h &amp; (length-1);}<br>这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h &amp; (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。<br>  01111010 00111100 00100101<br>&amp; 00000000 00000000 00001111</p>\n<hr>\n<p>  00000000 00000000 00000101<br>  //高位全部归零，只保留末四位<br>but 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上成个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。</p>\n<p>这时候 “hash”函数作用就出来了</p>\n<p>右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。<br>设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。<br>根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。<br>hashMap中 MAXIMUM_CAPACITY = 1 &lt;&lt; 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）</p>\n"},{"title":"JVM【性能调优篇】","index_img":"/img/java.jpeg","abbrlink":3097382278,"date":"2016-10-16T03:54:14.000Z","_content":"\n前面我们学习了整个JVM系列，最终目标的不仅仅是了解JVM的基础知识，也是为了进行JVM性能调优做准备。这篇文章带领大家学习JVM性能调优的知识。\n\n### 性能调优\n性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。\n\n架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。\n\n性能调优基本上按照以下步骤进行：明确优化目标、发现性能瓶颈、性能调优、通过监控及数据统计工具获得数据、确认是否达到目标。\n\n### 何时进行JVM调优\n遇到以下情况，就需要考虑进行JVM调优了：\n- Heap内存（老年代）持续上涨达到设置的最大内存值；\n- Full GC 次数频繁；\n- GC 停顿时间过长（超过1秒）；\n- 应用出现OutOfMemory 等内存异常；\n- 应用中有使用本地缓存且占用大量内存空间；\n- 系统吞吐量与响应性能不高或下降。\n\n### JVM调优的基本原则\nJVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：\n\n- 大多数的Java应用不需要进行JVM优化；\n- 大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；\n- 上线之前，应先考虑将机器的JVM参数设置到最优；\n- 减少创建对象的数量（代码层面）；\n- 减少使用全局变量和大对象（代码层面）；\n- 优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；\n- 分析GC情况优化代码比优化JVM参数更好（代码层面）；\n\n通过以上原则，我们发现，其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。\n\n### JVM调优目标\n调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。\njvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。\n\n- 延迟：GC低停顿和GC低频率；\n- 低内存占用；\n- 高吞吐量;\n\n其中，任何一个属性性能的提高，几乎都是以牺牲其他属性性能的损为代价的，不可兼得。具体根据在业务中的重要性确定。\n\n### JVM调优量化目标\n下面展示了一些JVM调优的量化目标参考实例：\n\n- Heap 内存使用率 <= 70%;\n- Old generation内存使用率<= 70%;\n- avgpause <= 1秒;\n- Full gc 次数0 或 avg pause interval >= 24小时 ;\n\n注意：不同应用的JVM调优量化目标是不一样的。\n\n### JVM调优的步骤\n一般情况下，JVM调优可通过以下步骤进行：\n\n- 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；\n- 确定JVM调优量化目标；\n- 确定JVM调优参数（根据历史JVM参数来调整）；\n- 依次调优内存、延迟、吞吐量等指标；\n- 对比观察调优前后的差异；\n- 不断的分析和调整，直到找到合适的JVM参数配置；\n- 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。\n\n### JVM参数\nJVM调优最重要的工具就是JVM参数了。先来了解一下JVM参数相关内容。\n\n-XX 参数被称为不稳定参数，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。如果此类参数设置合理将大大提高JVM的性能及稳定性。\n\n不稳定参数语法规则包含以下内容。\n\n    布尔类型参数值：\n    -XX:+<option> '+'表示启用该选项\n    -XX:-<option> '-'表示关闭该选项\n    数字类型参数值：\n    -XX:<option>=<number>给选项设置一个数字类型值，可跟随单位，例如：'m'或'M'表示兆字节;'k'或'K'千字节;'g'或'G'千兆字节。32K与32768是相同大小的。\n    字符串类型参数值\n    -XX:<option>=<string>给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core\n\n\n### JVM参数解析及调优\n比如以下参数示例：\n\n    -Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15\n\n上面为Java7及以前版本的示例，在Java8中永久代的参数-XX:PermSize和-XX：MaxPermSize已经失效。这在前面章节中已经讲到。\n\n参数解析：\n```\n-Xmx4g：堆内存最大值为4GB。\n-Xms4g：初始化堆内存大小为4GB。\n-Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。\n-Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n-XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n-XX:SurvivorRatio=8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10\n-XX:PermSize=100m：初始化永久代大小为100MB。\n-XX:MaxPermSize=256m：设置持久代大小为256MB。\n-XX:MaxTenuringThreshold=15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n```\n新生代、老生代、永久代的参数，如果不进行指定，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。\n\n可调优参数：\n```\n-Xms：初始化堆内存大小，默认为物理内存的1/64(小于1GB)。\n-Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。\n-Xmn：新生代大小，包括Eden区与2个Survivor区。\n-XX:SurvivorRatio=1：Eden区与一个Survivor区比值为1:1。\n-XX:MaxDirectMemorySize=1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。\n-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。\n-XX:CMSInitiatingOccupancyFraction=60：老年代内存回收阈值，默认值为68。\n-XX:ConcGCThreads=4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。\n-XX:ParallelGCThreads=8：新生代并行收集器的线程数。\n-XX:MaxTenuringThreshold=10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n-XX:CMSFullGCsBeforeCompaction=4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。\n-XX:CMSMaxAbortablePrecleanTime=500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。\n```\n> 注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。\n\n在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。\n\n### 内存优化示例\n当JVM运行稳定之后，触发了FullGC我们一般会拿到如下信息:\n\nimage\n以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。\n\n    java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n    永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。\n    新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n    老年代：2-3倍FullGC后的老年代空间占用。\n\n基于以上规则，则对参数定义如下：\n```\njava -Xms373m -Xmx373m -Xmn140m -XX:PermSize=5m -XX:MaxPermSize=5m\n```\n\n### 延迟优化示例\n对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。\n\n- 应用程序可接受的平均停滞时间: 此时间与测量的Minor\n- GC持续时间进行比较。可接受的Minor GC频率：Minor\n- GC的频率与可容忍的值进行比较。\n- 可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。\n- 可接受的最大停顿发生的频率：基本就是FullGC的频率。\n\n其中，平均停滞时间和最大停顿时间，对用户体验最为重要。对于上面的指标，相关数据采集包括：MinorGC的持续时间、统计MinorGC的次数、FullGC的最差持续时间、最差情况下，FullGC的频率。\n\nimage\n如上图，Minor GC的平均持续时间0.069秒，MinorGC的频率为0.389秒一次。\n\n新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。\n\n这里以减少了新生代空间10%的大小，来减小延迟时间。在此过程中，应该保持老年代和持代的大小不变化。调优后的参数如下变化:\n```\njava -Xms359m -Xmx359m -Xmn126m -XX:PermSize=5m -XX:MaxPermSize=5m\n```\n### 吞吐量调优\n吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于整个应用的需求和测试而衍生出来的。\n\n评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。\n\n> 对于垃圾收集器来说，提升吞吐量的性能调优的目标就是尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。\n\n### 调优工具\n借助GCViewer日志分析工具，可以非常直观地分析出待调优点。可从以下几方面来分析：\n- Memory,分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；\n- Pause，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；","source":"_posts/java/jvm.md","raw":"---\ntitle: JVM【性能调优篇】\ntags:\n  - Java\nindex_img: /img/java.jpeg\nabbrlink: 3097382278\ndate: 2016-10-16 11:54:14\n\n---\n\n前面我们学习了整个JVM系列，最终目标的不仅仅是了解JVM的基础知识，也是为了进行JVM性能调优做准备。这篇文章带领大家学习JVM性能调优的知识。\n\n### 性能调优\n性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。\n\n架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。\n\n性能调优基本上按照以下步骤进行：明确优化目标、发现性能瓶颈、性能调优、通过监控及数据统计工具获得数据、确认是否达到目标。\n\n### 何时进行JVM调优\n遇到以下情况，就需要考虑进行JVM调优了：\n- Heap内存（老年代）持续上涨达到设置的最大内存值；\n- Full GC 次数频繁；\n- GC 停顿时间过长（超过1秒）；\n- 应用出现OutOfMemory 等内存异常；\n- 应用中有使用本地缓存且占用大量内存空间；\n- 系统吞吐量与响应性能不高或下降。\n\n### JVM调优的基本原则\nJVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：\n\n- 大多数的Java应用不需要进行JVM优化；\n- 大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；\n- 上线之前，应先考虑将机器的JVM参数设置到最优；\n- 减少创建对象的数量（代码层面）；\n- 减少使用全局变量和大对象（代码层面）；\n- 优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；\n- 分析GC情况优化代码比优化JVM参数更好（代码层面）；\n\n通过以上原则，我们发现，其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。\n\n### JVM调优目标\n调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。\njvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。\n\n- 延迟：GC低停顿和GC低频率；\n- 低内存占用；\n- 高吞吐量;\n\n其中，任何一个属性性能的提高，几乎都是以牺牲其他属性性能的损为代价的，不可兼得。具体根据在业务中的重要性确定。\n\n### JVM调优量化目标\n下面展示了一些JVM调优的量化目标参考实例：\n\n- Heap 内存使用率 <= 70%;\n- Old generation内存使用率<= 70%;\n- avgpause <= 1秒;\n- Full gc 次数0 或 avg pause interval >= 24小时 ;\n\n注意：不同应用的JVM调优量化目标是不一样的。\n\n### JVM调优的步骤\n一般情况下，JVM调优可通过以下步骤进行：\n\n- 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；\n- 确定JVM调优量化目标；\n- 确定JVM调优参数（根据历史JVM参数来调整）；\n- 依次调优内存、延迟、吞吐量等指标；\n- 对比观察调优前后的差异；\n- 不断的分析和调整，直到找到合适的JVM参数配置；\n- 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。\n\n### JVM参数\nJVM调优最重要的工具就是JVM参数了。先来了解一下JVM参数相关内容。\n\n-XX 参数被称为不稳定参数，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。如果此类参数设置合理将大大提高JVM的性能及稳定性。\n\n不稳定参数语法规则包含以下内容。\n\n    布尔类型参数值：\n    -XX:+<option> '+'表示启用该选项\n    -XX:-<option> '-'表示关闭该选项\n    数字类型参数值：\n    -XX:<option>=<number>给选项设置一个数字类型值，可跟随单位，例如：'m'或'M'表示兆字节;'k'或'K'千字节;'g'或'G'千兆字节。32K与32768是相同大小的。\n    字符串类型参数值\n    -XX:<option>=<string>给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core\n\n\n### JVM参数解析及调优\n比如以下参数示例：\n\n    -Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15\n\n上面为Java7及以前版本的示例，在Java8中永久代的参数-XX:PermSize和-XX：MaxPermSize已经失效。这在前面章节中已经讲到。\n\n参数解析：\n```\n-Xmx4g：堆内存最大值为4GB。\n-Xms4g：初始化堆内存大小为4GB。\n-Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。\n-Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n-XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n-XX:SurvivorRatio=8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10\n-XX:PermSize=100m：初始化永久代大小为100MB。\n-XX:MaxPermSize=256m：设置持久代大小为256MB。\n-XX:MaxTenuringThreshold=15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n```\n新生代、老生代、永久代的参数，如果不进行指定，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。\n\n可调优参数：\n```\n-Xms：初始化堆内存大小，默认为物理内存的1/64(小于1GB)。\n-Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。\n-Xmn：新生代大小，包括Eden区与2个Survivor区。\n-XX:SurvivorRatio=1：Eden区与一个Survivor区比值为1:1。\n-XX:MaxDirectMemorySize=1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。\n-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。\n-XX:CMSInitiatingOccupancyFraction=60：老年代内存回收阈值，默认值为68。\n-XX:ConcGCThreads=4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。\n-XX:ParallelGCThreads=8：新生代并行收集器的线程数。\n-XX:MaxTenuringThreshold=10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n-XX:CMSFullGCsBeforeCompaction=4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。\n-XX:CMSMaxAbortablePrecleanTime=500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。\n```\n> 注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。\n\n在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。\n\n### 内存优化示例\n当JVM运行稳定之后，触发了FullGC我们一般会拿到如下信息:\n\nimage\n以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。\n\n    java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n    永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。\n    新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n    老年代：2-3倍FullGC后的老年代空间占用。\n\n基于以上规则，则对参数定义如下：\n```\njava -Xms373m -Xmx373m -Xmn140m -XX:PermSize=5m -XX:MaxPermSize=5m\n```\n\n### 延迟优化示例\n对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。\n\n- 应用程序可接受的平均停滞时间: 此时间与测量的Minor\n- GC持续时间进行比较。可接受的Minor GC频率：Minor\n- GC的频率与可容忍的值进行比较。\n- 可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。\n- 可接受的最大停顿发生的频率：基本就是FullGC的频率。\n\n其中，平均停滞时间和最大停顿时间，对用户体验最为重要。对于上面的指标，相关数据采集包括：MinorGC的持续时间、统计MinorGC的次数、FullGC的最差持续时间、最差情况下，FullGC的频率。\n\nimage\n如上图，Minor GC的平均持续时间0.069秒，MinorGC的频率为0.389秒一次。\n\n新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。\n\n这里以减少了新生代空间10%的大小，来减小延迟时间。在此过程中，应该保持老年代和持代的大小不变化。调优后的参数如下变化:\n```\njava -Xms359m -Xmx359m -Xmn126m -XX:PermSize=5m -XX:MaxPermSize=5m\n```\n### 吞吐量调优\n吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于整个应用的需求和测试而衍生出来的。\n\n评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。\n\n> 对于垃圾收集器来说，提升吞吐量的性能调优的目标就是尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。\n\n### 调优工具\n借助GCViewer日志分析工具，可以非常直观地分析出待调优点。可从以下几方面来分析：\n- Memory,分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；\n- Pause，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；","slug":"java/jvm","published":1,"updated":"2020-12-15T01:04:34.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz86001fmxcd144h5sya","content":"<p>前面我们学习了整个JVM系列，最终目标的不仅仅是了解JVM的基础知识，也是为了进行JVM性能调优做准备。这篇文章带领大家学习JVM性能调优的知识。</p>\n<h3 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h3><p>性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。</p>\n<p>架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。</p>\n<p>性能调优基本上按照以下步骤进行：明确优化目标、发现性能瓶颈、性能调优、通过监控及数据统计工具获得数据、确认是否达到目标。</p>\n<h3 id=\"何时进行JVM调优\"><a href=\"#何时进行JVM调优\" class=\"headerlink\" title=\"何时进行JVM调优\"></a>何时进行JVM调优</h3><p>遇到以下情况，就需要考虑进行JVM调优了：</p>\n<ul>\n<li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li>\n<li>Full GC 次数频繁；</li>\n<li>GC 停顿时间过长（超过1秒）；</li>\n<li>应用出现OutOfMemory 等内存异常；</li>\n<li>应用中有使用本地缓存且占用大量内存空间；</li>\n<li>系统吞吐量与响应性能不高或下降。</li>\n</ul>\n<h3 id=\"JVM调优的基本原则\"><a href=\"#JVM调优的基本原则\" class=\"headerlink\" title=\"JVM调优的基本原则\"></a>JVM调优的基本原则</h3><p>JVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：</p>\n<ul>\n<li>大多数的Java应用不需要进行JVM优化；</li>\n<li>大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；</li>\n<li>上线之前，应先考虑将机器的JVM参数设置到最优；</li>\n<li>减少创建对象的数量（代码层面）；</li>\n<li>减少使用全局变量和大对象（代码层面）；</li>\n<li>优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；</li>\n<li>分析GC情况优化代码比优化JVM参数更好（代码层面）；</li>\n</ul>\n<p>通过以上原则，我们发现，其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。</p>\n<h3 id=\"JVM调优目标\"><a href=\"#JVM调优目标\" class=\"headerlink\" title=\"JVM调优目标\"></a>JVM调优目标</h3><p>调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。<br>jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。</p>\n<ul>\n<li>延迟：GC低停顿和GC低频率；</li>\n<li>低内存占用；</li>\n<li>高吞吐量;</li>\n</ul>\n<p>其中，任何一个属性性能的提高，几乎都是以牺牲其他属性性能的损为代价的，不可兼得。具体根据在业务中的重要性确定。</p>\n<h3 id=\"JVM调优量化目标\"><a href=\"#JVM调优量化目标\" class=\"headerlink\" title=\"JVM调优量化目标\"></a>JVM调优量化目标</h3><p>下面展示了一些JVM调优的量化目标参考实例：</p>\n<ul>\n<li>Heap 内存使用率 &lt;= 70%;</li>\n<li>Old generation内存使用率&lt;= 70%;</li>\n<li>avgpause &lt;= 1秒;</li>\n<li>Full gc 次数0 或 avg pause interval &gt;= 24小时 ;</li>\n</ul>\n<p>注意：不同应用的JVM调优量化目标是不一样的。</p>\n<h3 id=\"JVM调优的步骤\"><a href=\"#JVM调优的步骤\" class=\"headerlink\" title=\"JVM调优的步骤\"></a>JVM调优的步骤</h3><p>一般情况下，JVM调优可通过以下步骤进行：</p>\n<ul>\n<li>分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li>\n<li>确定JVM调优量化目标；</li>\n<li>确定JVM调优参数（根据历史JVM参数来调整）；</li>\n<li>依次调优内存、延迟、吞吐量等指标；</li>\n<li>对比观察调优前后的差异；</li>\n<li>不断的分析和调整，直到找到合适的JVM参数配置；</li>\n<li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li>\n</ul>\n<p>以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。</p>\n<h3 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h3><p>JVM调优最重要的工具就是JVM参数了。先来了解一下JVM参数相关内容。</p>\n<p>-XX 参数被称为不稳定参数，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。如果此类参数设置合理将大大提高JVM的性能及稳定性。</p>\n<p>不稳定参数语法规则包含以下内容。</p>\n<pre><code>布尔类型参数值：\n-XX:+&lt;option&gt; &apos;+&apos;表示启用该选项\n-XX:-&lt;option&gt; &apos;-&apos;表示关闭该选项\n数字类型参数值：\n-XX:&lt;option&gt;=&lt;number&gt;给选项设置一个数字类型值，可跟随单位，例如：&apos;m&apos;或&apos;M&apos;表示兆字节;&apos;k&apos;或&apos;K&apos;千字节;&apos;g&apos;或&apos;G&apos;千兆字节。32K与32768是相同大小的。\n字符串类型参数值\n-XX:&lt;option&gt;=&lt;string&gt;给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core</code></pre><h3 id=\"JVM参数解析及调优\"><a href=\"#JVM参数解析及调优\" class=\"headerlink\" title=\"JVM参数解析及调优\"></a>JVM参数解析及调优</h3><p>比如以下参数示例：</p>\n<pre><code>-Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15</code></pre><p>上面为Java7及以前版本的示例，在Java8中永久代的参数-XX:PermSize和-XX：MaxPermSize已经失效。这在前面章节中已经讲到。</p>\n<p>参数解析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx4g：堆内存最大值为4GB。</span><br><span class=\"line\">-Xms4g：初始化堆内存大小为4GB。</span><br><span class=\"line\">-Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。</span><br><span class=\"line\">-Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</span><br><span class=\"line\">-XX:NewRatio&#x3D;4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5</span><br><span class=\"line\">-XX:SurvivorRatio&#x3D;8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1&#x2F;10</span><br><span class=\"line\">-XX:PermSize&#x3D;100m：初始化永久代大小为100MB。</span><br><span class=\"line\">-XX:MaxPermSize&#x3D;256m：设置持久代大小为256MB。</span><br><span class=\"line\">-XX:MaxTenuringThreshold&#x3D;15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</span><br></pre></td></tr></table></figure>\n<p>新生代、老生代、永久代的参数，如果不进行指定，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。</p>\n<p>可调优参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms：初始化堆内存大小，默认为物理内存的1&#x2F;64(小于1GB)。</span><br><span class=\"line\">-Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。</span><br><span class=\"line\">-Xmn：新生代大小，包括Eden区与2个Survivor区。</span><br><span class=\"line\">-XX:SurvivorRatio&#x3D;1：Eden区与一个Survivor区比值为1:1。</span><br><span class=\"line\">-XX:MaxDirectMemorySize&#x3D;1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。</span><br><span class=\"line\">-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。</span><br><span class=\"line\">-XX:CMSInitiatingOccupancyFraction&#x3D;60：老年代内存回收阈值，默认值为68。</span><br><span class=\"line\">-XX:ConcGCThreads&#x3D;4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。</span><br><span class=\"line\">-XX:ParallelGCThreads&#x3D;8：新生代并行收集器的线程数。</span><br><span class=\"line\">-XX:MaxTenuringThreshold&#x3D;10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</span><br><span class=\"line\">-XX:CMSFullGCsBeforeCompaction&#x3D;4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。</span><br><span class=\"line\">-XX:CMSMaxAbortablePrecleanTime&#x3D;500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。</p>\n</blockquote>\n<p>在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。</p>\n<h3 id=\"内存优化示例\"><a href=\"#内存优化示例\" class=\"headerlink\" title=\"内存优化示例\"></a>内存优化示例</h3><p>当JVM运行稳定之后，触发了FullGC我们一般会拿到如下信息:</p>\n<p>image<br>以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。</p>\n<pre><code>java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。\n新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n老年代：2-3倍FullGC后的老年代空间占用。</code></pre><p>基于以上规则，则对参数定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xms373m -Xmx373m -Xmn140m -XX:PermSize&#x3D;5m -XX:MaxPermSize&#x3D;5m</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延迟优化示例\"><a href=\"#延迟优化示例\" class=\"headerlink\" title=\"延迟优化示例\"></a>延迟优化示例</h3><p>对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。</p>\n<ul>\n<li>应用程序可接受的平均停滞时间: 此时间与测量的Minor</li>\n<li>GC持续时间进行比较。可接受的Minor GC频率：Minor</li>\n<li>GC的频率与可容忍的值进行比较。</li>\n<li>可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。</li>\n<li>可接受的最大停顿发生的频率：基本就是FullGC的频率。</li>\n</ul>\n<p>其中，平均停滞时间和最大停顿时间，对用户体验最为重要。对于上面的指标，相关数据采集包括：MinorGC的持续时间、统计MinorGC的次数、FullGC的最差持续时间、最差情况下，FullGC的频率。</p>\n<p>image<br>如上图，Minor GC的平均持续时间0.069秒，MinorGC的频率为0.389秒一次。</p>\n<p>新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。</p>\n<p>这里以减少了新生代空间10%的大小，来减小延迟时间。在此过程中，应该保持老年代和持代的大小不变化。调优后的参数如下变化:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xms359m -Xmx359m -Xmn126m -XX:PermSize&#x3D;5m -XX:MaxPermSize&#x3D;5m</span><br></pre></td></tr></table></figure>\n<h3 id=\"吞吐量调优\"><a href=\"#吞吐量调优\" class=\"headerlink\" title=\"吞吐量调优\"></a>吞吐量调优</h3><p>吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于整个应用的需求和测试而衍生出来的。</p>\n<p>评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。</p>\n<blockquote>\n<p>对于垃圾收集器来说，提升吞吐量的性能调优的目标就是尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。</p>\n</blockquote>\n<h3 id=\"调优工具\"><a href=\"#调优工具\" class=\"headerlink\" title=\"调优工具\"></a>调优工具</h3><p>借助GCViewer日志分析工具，可以非常直观地分析出待调优点。可从以下几方面来分析：</p>\n<ul>\n<li>Memory,分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；</li>\n<li>Pause，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；</li>\n</ul>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>前面我们学习了整个JVM系列，最终目标的不仅仅是了解JVM的基础知识，也是为了进行JVM性能调优做准备。这篇文章带领大家学习JVM性能调优的知识。</p>\n<h3 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h3><p>性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。</p>\n<p>架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。</p>\n<p>性能调优基本上按照以下步骤进行：明确优化目标、发现性能瓶颈、性能调优、通过监控及数据统计工具获得数据、确认是否达到目标。</p>\n<h3 id=\"何时进行JVM调优\"><a href=\"#何时进行JVM调优\" class=\"headerlink\" title=\"何时进行JVM调优\"></a>何时进行JVM调优</h3><p>遇到以下情况，就需要考虑进行JVM调优了：</p>\n<ul>\n<li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li>\n<li>Full GC 次数频繁；</li>\n<li>GC 停顿时间过长（超过1秒）；</li>\n<li>应用出现OutOfMemory 等内存异常；</li>\n<li>应用中有使用本地缓存且占用大量内存空间；</li>\n<li>系统吞吐量与响应性能不高或下降。</li>\n</ul>\n<h3 id=\"JVM调优的基本原则\"><a href=\"#JVM调优的基本原则\" class=\"headerlink\" title=\"JVM调优的基本原则\"></a>JVM调优的基本原则</h3><p>JVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：</p>\n<ul>\n<li>大多数的Java应用不需要进行JVM优化；</li>\n<li>大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；</li>\n<li>上线之前，应先考虑将机器的JVM参数设置到最优；</li>\n<li>减少创建对象的数量（代码层面）；</li>\n<li>减少使用全局变量和大对象（代码层面）；</li>\n<li>优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；</li>\n<li>分析GC情况优化代码比优化JVM参数更好（代码层面）；</li>\n</ul>\n<p>通过以上原则，我们发现，其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。</p>\n<h3 id=\"JVM调优目标\"><a href=\"#JVM调优目标\" class=\"headerlink\" title=\"JVM调优目标\"></a>JVM调优目标</h3><p>调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。<br>jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。</p>\n<ul>\n<li>延迟：GC低停顿和GC低频率；</li>\n<li>低内存占用；</li>\n<li>高吞吐量;</li>\n</ul>\n<p>其中，任何一个属性性能的提高，几乎都是以牺牲其他属性性能的损为代价的，不可兼得。具体根据在业务中的重要性确定。</p>\n<h3 id=\"JVM调优量化目标\"><a href=\"#JVM调优量化目标\" class=\"headerlink\" title=\"JVM调优量化目标\"></a>JVM调优量化目标</h3><p>下面展示了一些JVM调优的量化目标参考实例：</p>\n<ul>\n<li>Heap 内存使用率 &lt;= 70%;</li>\n<li>Old generation内存使用率&lt;= 70%;</li>\n<li>avgpause &lt;= 1秒;</li>\n<li>Full gc 次数0 或 avg pause interval &gt;= 24小时 ;</li>\n</ul>\n<p>注意：不同应用的JVM调优量化目标是不一样的。</p>\n<h3 id=\"JVM调优的步骤\"><a href=\"#JVM调优的步骤\" class=\"headerlink\" title=\"JVM调优的步骤\"></a>JVM调优的步骤</h3><p>一般情况下，JVM调优可通过以下步骤进行：</p>\n<ul>\n<li>分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li>\n<li>确定JVM调优量化目标；</li>\n<li>确定JVM调优参数（根据历史JVM参数来调整）；</li>\n<li>依次调优内存、延迟、吞吐量等指标；</li>\n<li>对比观察调优前后的差异；</li>\n<li>不断的分析和调整，直到找到合适的JVM参数配置；</li>\n<li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li>\n</ul>\n<p>以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。</p>\n<h3 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h3><p>JVM调优最重要的工具就是JVM参数了。先来了解一下JVM参数相关内容。</p>\n<p>-XX 参数被称为不稳定参数，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。如果此类参数设置合理将大大提高JVM的性能及稳定性。</p>\n<p>不稳定参数语法规则包含以下内容。</p>\n<pre><code>布尔类型参数值：\n-XX:+&lt;option&gt; &apos;+&apos;表示启用该选项\n-XX:-&lt;option&gt; &apos;-&apos;表示关闭该选项\n数字类型参数值：\n-XX:&lt;option&gt;=&lt;number&gt;给选项设置一个数字类型值，可跟随单位，例如：&apos;m&apos;或&apos;M&apos;表示兆字节;&apos;k&apos;或&apos;K&apos;千字节;&apos;g&apos;或&apos;G&apos;千兆字节。32K与32768是相同大小的。\n字符串类型参数值\n-XX:&lt;option&gt;=&lt;string&gt;给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core</code></pre><h3 id=\"JVM参数解析及调优\"><a href=\"#JVM参数解析及调优\" class=\"headerlink\" title=\"JVM参数解析及调优\"></a>JVM参数解析及调优</h3><p>比如以下参数示例：</p>\n<pre><code>-Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15</code></pre><p>上面为Java7及以前版本的示例，在Java8中永久代的参数-XX:PermSize和-XX：MaxPermSize已经失效。这在前面章节中已经讲到。</p>\n<p>参数解析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx4g：堆内存最大值为4GB。</span><br><span class=\"line\">-Xms4g：初始化堆内存大小为4GB。</span><br><span class=\"line\">-Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。</span><br><span class=\"line\">-Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</span><br><span class=\"line\">-XX:NewRatio&#x3D;4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5</span><br><span class=\"line\">-XX:SurvivorRatio&#x3D;8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1&#x2F;10</span><br><span class=\"line\">-XX:PermSize&#x3D;100m：初始化永久代大小为100MB。</span><br><span class=\"line\">-XX:MaxPermSize&#x3D;256m：设置持久代大小为256MB。</span><br><span class=\"line\">-XX:MaxTenuringThreshold&#x3D;15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</span><br></pre></td></tr></table></figure>\n<p>新生代、老生代、永久代的参数，如果不进行指定，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。</p>\n<p>可调优参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xms：初始化堆内存大小，默认为物理内存的1&#x2F;64(小于1GB)。</span><br><span class=\"line\">-Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。</span><br><span class=\"line\">-Xmn：新生代大小，包括Eden区与2个Survivor区。</span><br><span class=\"line\">-XX:SurvivorRatio&#x3D;1：Eden区与一个Survivor区比值为1:1。</span><br><span class=\"line\">-XX:MaxDirectMemorySize&#x3D;1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。</span><br><span class=\"line\">-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。</span><br><span class=\"line\">-XX:CMSInitiatingOccupancyFraction&#x3D;60：老年代内存回收阈值，默认值为68。</span><br><span class=\"line\">-XX:ConcGCThreads&#x3D;4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。</span><br><span class=\"line\">-XX:ParallelGCThreads&#x3D;8：新生代并行收集器的线程数。</span><br><span class=\"line\">-XX:MaxTenuringThreshold&#x3D;10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</span><br><span class=\"line\">-XX:CMSFullGCsBeforeCompaction&#x3D;4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。</span><br><span class=\"line\">-XX:CMSMaxAbortablePrecleanTime&#x3D;500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。</p>\n</blockquote>\n<p>在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。</p>\n<h3 id=\"内存优化示例\"><a href=\"#内存优化示例\" class=\"headerlink\" title=\"内存优化示例\"></a>内存优化示例</h3><p>当JVM运行稳定之后，触发了FullGC我们一般会拿到如下信息:</p>\n<p>image<br>以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。</p>\n<pre><code>java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。\n新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n老年代：2-3倍FullGC后的老年代空间占用。</code></pre><p>基于以上规则，则对参数定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xms373m -Xmx373m -Xmn140m -XX:PermSize&#x3D;5m -XX:MaxPermSize&#x3D;5m</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延迟优化示例\"><a href=\"#延迟优化示例\" class=\"headerlink\" title=\"延迟优化示例\"></a>延迟优化示例</h3><p>对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。</p>\n<ul>\n<li>应用程序可接受的平均停滞时间: 此时间与测量的Minor</li>\n<li>GC持续时间进行比较。可接受的Minor GC频率：Minor</li>\n<li>GC的频率与可容忍的值进行比较。</li>\n<li>可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。</li>\n<li>可接受的最大停顿发生的频率：基本就是FullGC的频率。</li>\n</ul>\n<p>其中，平均停滞时间和最大停顿时间，对用户体验最为重要。对于上面的指标，相关数据采集包括：MinorGC的持续时间、统计MinorGC的次数、FullGC的最差持续时间、最差情况下，FullGC的频率。</p>\n<p>image<br>如上图，Minor GC的平均持续时间0.069秒，MinorGC的频率为0.389秒一次。</p>\n<p>新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。</p>\n<p>这里以减少了新生代空间10%的大小，来减小延迟时间。在此过程中，应该保持老年代和持代的大小不变化。调优后的参数如下变化:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -Xms359m -Xmx359m -Xmn126m -XX:PermSize&#x3D;5m -XX:MaxPermSize&#x3D;5m</span><br></pre></td></tr></table></figure>\n<h3 id=\"吞吐量调优\"><a href=\"#吞吐量调优\" class=\"headerlink\" title=\"吞吐量调优\"></a>吞吐量调优</h3><p>吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于整个应用的需求和测试而衍生出来的。</p>\n<p>评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。</p>\n<blockquote>\n<p>对于垃圾收集器来说，提升吞吐量的性能调优的目标就是尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。</p>\n</blockquote>\n<h3 id=\"调优工具\"><a href=\"#调优工具\" class=\"headerlink\" title=\"调优工具\"></a>调优工具</h3><p>借助GCViewer日志分析工具，可以非常直观地分析出待调优点。可从以下几方面来分析：</p>\n<ul>\n<li>Memory,分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；</li>\n<li>Pause，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；</li>\n</ul>\n"},{"title":"Spring Cloud 微服务架构全链路实践","index_img":"/img/spring-cloud.jpeg","abbrlink":1879991184,"date":"2016-08-15T16:04:12.000Z","_content":"\nJava 微服务框架选型（Dubbo 和 Spring Cloud）\n\n{% asset_img 1.png %}\n\n目前公司使用的 Spring Cloud 整个技术组件，基本包含了上面图中所包含的，不得不说，Spring Cloud 整个生态真的很强大，使用起来也很方便有效。\n\n后面有时间再针对每个组件进行使用解读，这篇文章主要说下 Spring Cloud 架构的链路图，顺便把自己的思路整理下来，以备查阅。\n\n{% asset_img 2.png %}\n\n# 网关请求流程\n\n在 Spring Cloud 整个组件库中，Spring Cloud Zuul 是最容易被忽视，但也是最重要的，Spring Cloud Zuul 可以和 Eureka 注册中心集成，我们目前使用 Spring Cloud Zuul 的功能如下：\n- Filter 过滤器\n- Router 路由\n- Ribbon 负载均衡\n- Hystrix 熔断\n- Retry 重试\n有些功能是 Spring Cloud Zuul 自带的，比如 Filter 和 Router，有些是结合 Spring Cloud 其他组件，比如 Ribbon 和 Hystrix。\n\n这里重点介绍下 Filter 过滤器，分为四个过滤类型：\n- pre：Zuul 转发请求之前执行，我们目前的实现是AccessTokenFilter，用于 oAuth2.0 JWT 的授权验证。\n- route：Zuul 路由时执行，目前项目没用到。\n- post：Zuul 路由转发后执行，也就是已经请求成功了后端服务，我们目前的实现是CustomResponseFilter，用于统一请求格式的封装，比如 code/msg/data 等。\n- error：以上过滤器发生错误时执行，我们目前的实现是CustomErrorFilter，用于拦截过滤器执行的出现的错误，然后统一格式封装返回，另外，error 过滤器好像并不能捕获后端服务执行出现的错误。\n\n另外，关于 oAuth2.0 JWT 的授权验证，实现的方式有两种：\n- 授权的配置在后端服务中（每个服务都需要当作 Resource Server 进行配置，需要配置公钥，接口的授权具体配置在注解中），Zuul 只做转发，并不进行授权的验证。\n- 授权的配置在 Zuul 中，也就是把 Zuul 当作 Resource Server，后端服务不需要进行任何处理，Zuul 中具体的实现就是AccessTokenFilter，里面的逻辑是手动解析 JWT，然后判断是否正确，以及解析出用户信息/Scope/Role，然后根据当前的请求 API，对授权 Map 中的配置进行匹配，如果匹配错误，直接抛出 401 授权错误。\n我们目前采用的是第二种方式，这两种方式都有利有弊，关键在于自己的取舍，为什么采用第二种方式？目的就是发挥 Zuul 的作用，对外网关进行统一授权验证。\n\n关于授权 Map，里面存储了所有服务接口的配置，示例配置：\n```\nprivate static final Map ROUTE_MAPS;\nstatic {\n    ROUTE_MAPS = new HashMap();\n    ROUTE_MAPS.put(\"eureka-client/home\", \"read:ROLE_ADMIN\");\n    ROUTE_MAPS.put(\"eureka-client/user\", \"read:ROLE_ADMIN\");\n    ROUTE_MAPS.put(\"eureka-client/error\", \"read:ROLE_ADMIN\");\n}\n```\n\n\n这是我们目前的配置，是一个静态的 Map，后面会存储在 Spring Cloud Config 配置中心，Zuul 启动时进行加载，利用 Spring Cloud Bus 动态刷新。\n\n关于 Zuul 网关，其实还有很多需要说的，后面有机会再进行针对说明。\n\n# Eureka 服务治理\n\n{% asset_img 3.png %}\n\nEureka 遵循的是 AP 原则（服务可用性和分区容错性），是服务治理最理想的遵循 CAP 分布式原则。\n\nEureka 集群中的节点是彼此平级，不像 Consul 有 master/worker 之分，集群中的 Eureka 节点彼此两两注册，所以，Eureka 集群最好部署三个节点，这也是我们目前的部署方式。\n\n另外，Eureka 的自我保护机制，可以参考这篇文章。\n\n服务之间的相互调用，负载有两种使用方式：\n- Feign：基于声明式，顾名思义，就是需要定义接口，就像我们平常使用对象调用一样。\n- Ribbon：软负载，通过往 RestTemplate 中注入负载 Handler，然后通过负载算法选取调用（通过 Eureka 获取服务注册信息）。\n我们目前打算使用 Ribbon 负载方式，为什么？看下面代码就知道了：\n\n```\nrestTemplate.getForObject(\"http://eureka-client/hello\", String.class);\n```\n\n# Config 配置中心\n\n{% asset_img 4.png %}\n\n我们目前配置中心使用的是 Spring Cloud Config，当然你也可以使用功能更强大的 Polly（携程开源），但 Config 目前也能满足我们的需求，存储仓库我们现在使用的是 Git。\n\nConfig 配置中心提供了数据加密功能，你可以使用 RSA 的加密方式，这样存储在 Git 中的配置都是密文形式，Config Client 获取加密配置的时候，Config Server 会自动进行解密返回。\n\n配置中心的使用场景，我们目前主要是两个地方：\n\n- 项目启动的配置信息，比如数据库的连接字符串等。\n- 业务服务的配置信息，也就是业务相关的配置。\n\n另外，需要说明的是，默认情况下，如果 Git 中的配置更新了，Config Client 不会进行更新配置，我们目前的解决方式是，使用 Spring Cloud Bus 进行动态刷新配置（Config Server 中配置），具体的流程：\n1. Git 中添加 WebHooks 脚本，比如curl -X POST http://manager1:8180/bus/refresh，当 Git 仓库中的配置更新后，自动执行。\n2. Config Server 中配置 Spring Cloud Bus，接受 Git 的配置刷新请求，然后利用 RabbitMQ 广播通知所有的 Config Client 订阅方，刷新配置信息。\n\n# Hystrix 监控\n\n{% asset_img 5.png %}\n\nHystrix 主要是用于服务熔断/降级/隔离处理，Hystrix 配置在调用方，当被调用方服务不可用时，触发 Hystrix 熔断，会执行指定的 Fallback 方法，进行特殊处理。\n\n我之前以为，Hystrix 熔断的触发条件是服务不可用，也就是服务请求超时（比如服务挂掉了），但我自己测试了下，服务出现 500 错误，也会触发 Hystrix 熔断，而且会自动忽略 Hystrix 的超时时间设置。\n\n我们目前使用 Hystrix，主要有两个地方：\n- 内部服务调用：可以对某个 API 接口进行熔断处理。\n- Zuul 网关使用：就是当 Zuul 路由转发调用时，但有个局限性，就是只能对服务进行熔断，并不能针对某个 API 接口熔断。\n\n上面图中，主要画的是 Hystrix 的监控流程，我们目前主要使用 RabbitMQ 进行采集传输，turbine-server 进行数据流的聚合，hystrix-dashboard 进行图形化的展示。\n\n# 服务调用链路\n\n{% asset_img 6.png %}\n\n服务调用链路的概念，就是当服务请求发起时，记录整个请求链路的数据，以备查询。\n\n目前市面上，几乎所有服务调用链路的实现，理论基础都是基于 Google Dapper 的那篇论文，其中最重要的概念就是 traceId 和 spanId。\ntraceId 记录整个服务链路的 ID，由首次请求方创建，服务链路中唯一。\nspanId 记录当前服务块的 ID，由当前服务方创建。\nparentId 记录上一个请求服务的 spanId。\n下面我描述下，我们目前的服务调用链路过程：\nH5 发起请求，到 Zuul 网关，Zuul 创建全局的 traceId 和自己的 spanId，然后携带这些数据到业务服务 A，并利用 Spring Cloud Sluth 传输到 RabbitMQ。\n业务服务 A，接收到 Zuul 传输的 traceId 和 spanId，然后把 Zuul 的 spanId 设置成 parentId，并生成自己的 spanId，然后携带这些数据到业务服务 B，并利用 Spring Cloud Sluth 传输到 RabbitMQ。\n....\n上面图中，详细说明了整个服务调用链路的过程，这边再说下使用的技术栈：\nSpring Cloud Sluth：和 SkyWalking 的探针概念比较类似，每个服务都进行配置，收集当然服务的请求数据（traceId 和 spanId），然后利用stream-sluth和binder-rabbit组件，将请求数据传输到 RabbitMQ。\nSpring Cloud Zipkin：主要用于请求链路的 UI 展示，Zipkin 会从 RabbitMQ 读取请求数据，然后存储到 ElasticSearch 中，然后下次显示直接从 ElasticSearch 中读取。\nKibana：Kibana 也可以显示 ElasticSearch 中的请求数据，只不过不是图形化的，需要索引配置创建。\n\n# ELK 日志链路\n\n{% asset_img 7.png  %}\n\nELK 可以参考下之前的几篇文章：\nELK 架构之 Elasticsearch 和 Kibana 安装配置\nELK 架构之 Logstash 和 Filebeat 安装配置\nELK 架构之 Logstash 和 Filebeat 配置使用（采集过滤）\nELK 架构之 Elasticsearch、Kibana、Logstash 和 Filebeat 安装配置汇总（6.2.4 版本）\n上面图中已经很详细介绍了下 ELK 的流程，ELK 默认技术栈里是没有 Filebeat 的，Logstash 用作日志收集的时候，CPU 和内存会占用资源比较大，所以我们使用轻量化的 Filebeat 进行日志的收集，Filebeat 部署在每个业务服务所在的服务器，然后将收集到的日志数据传输到 Logstash，Logstash 可以部署两到三台服务器上，用作日志的过滤和分析工作，然后再将处理后的日志数据，传输到 ElasticSearch 存储。\n\n# 统一格式返回\n\n{% asset_img 8.png %}\n\n","source":"_posts/spring/spring-cloud-learning.md","raw":"---\ntitle: Spring Cloud 微服务架构全链路实践\ntags:\n  - Spring\n  - Java\nindex_img: /img/spring-cloud.jpeg\nabbrlink: 1879991184\ndate: 2016-08-16 00:04:12\n---\n\nJava 微服务框架选型（Dubbo 和 Spring Cloud）\n\n{% asset_img 1.png %}\n\n目前公司使用的 Spring Cloud 整个技术组件，基本包含了上面图中所包含的，不得不说，Spring Cloud 整个生态真的很强大，使用起来也很方便有效。\n\n后面有时间再针对每个组件进行使用解读，这篇文章主要说下 Spring Cloud 架构的链路图，顺便把自己的思路整理下来，以备查阅。\n\n{% asset_img 2.png %}\n\n# 网关请求流程\n\n在 Spring Cloud 整个组件库中，Spring Cloud Zuul 是最容易被忽视，但也是最重要的，Spring Cloud Zuul 可以和 Eureka 注册中心集成，我们目前使用 Spring Cloud Zuul 的功能如下：\n- Filter 过滤器\n- Router 路由\n- Ribbon 负载均衡\n- Hystrix 熔断\n- Retry 重试\n有些功能是 Spring Cloud Zuul 自带的，比如 Filter 和 Router，有些是结合 Spring Cloud 其他组件，比如 Ribbon 和 Hystrix。\n\n这里重点介绍下 Filter 过滤器，分为四个过滤类型：\n- pre：Zuul 转发请求之前执行，我们目前的实现是AccessTokenFilter，用于 oAuth2.0 JWT 的授权验证。\n- route：Zuul 路由时执行，目前项目没用到。\n- post：Zuul 路由转发后执行，也就是已经请求成功了后端服务，我们目前的实现是CustomResponseFilter，用于统一请求格式的封装，比如 code/msg/data 等。\n- error：以上过滤器发生错误时执行，我们目前的实现是CustomErrorFilter，用于拦截过滤器执行的出现的错误，然后统一格式封装返回，另外，error 过滤器好像并不能捕获后端服务执行出现的错误。\n\n另外，关于 oAuth2.0 JWT 的授权验证，实现的方式有两种：\n- 授权的配置在后端服务中（每个服务都需要当作 Resource Server 进行配置，需要配置公钥，接口的授权具体配置在注解中），Zuul 只做转发，并不进行授权的验证。\n- 授权的配置在 Zuul 中，也就是把 Zuul 当作 Resource Server，后端服务不需要进行任何处理，Zuul 中具体的实现就是AccessTokenFilter，里面的逻辑是手动解析 JWT，然后判断是否正确，以及解析出用户信息/Scope/Role，然后根据当前的请求 API，对授权 Map 中的配置进行匹配，如果匹配错误，直接抛出 401 授权错误。\n我们目前采用的是第二种方式，这两种方式都有利有弊，关键在于自己的取舍，为什么采用第二种方式？目的就是发挥 Zuul 的作用，对外网关进行统一授权验证。\n\n关于授权 Map，里面存储了所有服务接口的配置，示例配置：\n```\nprivate static final Map ROUTE_MAPS;\nstatic {\n    ROUTE_MAPS = new HashMap();\n    ROUTE_MAPS.put(\"eureka-client/home\", \"read:ROLE_ADMIN\");\n    ROUTE_MAPS.put(\"eureka-client/user\", \"read:ROLE_ADMIN\");\n    ROUTE_MAPS.put(\"eureka-client/error\", \"read:ROLE_ADMIN\");\n}\n```\n\n\n这是我们目前的配置，是一个静态的 Map，后面会存储在 Spring Cloud Config 配置中心，Zuul 启动时进行加载，利用 Spring Cloud Bus 动态刷新。\n\n关于 Zuul 网关，其实还有很多需要说的，后面有机会再进行针对说明。\n\n# Eureka 服务治理\n\n{% asset_img 3.png %}\n\nEureka 遵循的是 AP 原则（服务可用性和分区容错性），是服务治理最理想的遵循 CAP 分布式原则。\n\nEureka 集群中的节点是彼此平级，不像 Consul 有 master/worker 之分，集群中的 Eureka 节点彼此两两注册，所以，Eureka 集群最好部署三个节点，这也是我们目前的部署方式。\n\n另外，Eureka 的自我保护机制，可以参考这篇文章。\n\n服务之间的相互调用，负载有两种使用方式：\n- Feign：基于声明式，顾名思义，就是需要定义接口，就像我们平常使用对象调用一样。\n- Ribbon：软负载，通过往 RestTemplate 中注入负载 Handler，然后通过负载算法选取调用（通过 Eureka 获取服务注册信息）。\n我们目前打算使用 Ribbon 负载方式，为什么？看下面代码就知道了：\n\n```\nrestTemplate.getForObject(\"http://eureka-client/hello\", String.class);\n```\n\n# Config 配置中心\n\n{% asset_img 4.png %}\n\n我们目前配置中心使用的是 Spring Cloud Config，当然你也可以使用功能更强大的 Polly（携程开源），但 Config 目前也能满足我们的需求，存储仓库我们现在使用的是 Git。\n\nConfig 配置中心提供了数据加密功能，你可以使用 RSA 的加密方式，这样存储在 Git 中的配置都是密文形式，Config Client 获取加密配置的时候，Config Server 会自动进行解密返回。\n\n配置中心的使用场景，我们目前主要是两个地方：\n\n- 项目启动的配置信息，比如数据库的连接字符串等。\n- 业务服务的配置信息，也就是业务相关的配置。\n\n另外，需要说明的是，默认情况下，如果 Git 中的配置更新了，Config Client 不会进行更新配置，我们目前的解决方式是，使用 Spring Cloud Bus 进行动态刷新配置（Config Server 中配置），具体的流程：\n1. Git 中添加 WebHooks 脚本，比如curl -X POST http://manager1:8180/bus/refresh，当 Git 仓库中的配置更新后，自动执行。\n2. Config Server 中配置 Spring Cloud Bus，接受 Git 的配置刷新请求，然后利用 RabbitMQ 广播通知所有的 Config Client 订阅方，刷新配置信息。\n\n# Hystrix 监控\n\n{% asset_img 5.png %}\n\nHystrix 主要是用于服务熔断/降级/隔离处理，Hystrix 配置在调用方，当被调用方服务不可用时，触发 Hystrix 熔断，会执行指定的 Fallback 方法，进行特殊处理。\n\n我之前以为，Hystrix 熔断的触发条件是服务不可用，也就是服务请求超时（比如服务挂掉了），但我自己测试了下，服务出现 500 错误，也会触发 Hystrix 熔断，而且会自动忽略 Hystrix 的超时时间设置。\n\n我们目前使用 Hystrix，主要有两个地方：\n- 内部服务调用：可以对某个 API 接口进行熔断处理。\n- Zuul 网关使用：就是当 Zuul 路由转发调用时，但有个局限性，就是只能对服务进行熔断，并不能针对某个 API 接口熔断。\n\n上面图中，主要画的是 Hystrix 的监控流程，我们目前主要使用 RabbitMQ 进行采集传输，turbine-server 进行数据流的聚合，hystrix-dashboard 进行图形化的展示。\n\n# 服务调用链路\n\n{% asset_img 6.png %}\n\n服务调用链路的概念，就是当服务请求发起时，记录整个请求链路的数据，以备查询。\n\n目前市面上，几乎所有服务调用链路的实现，理论基础都是基于 Google Dapper 的那篇论文，其中最重要的概念就是 traceId 和 spanId。\ntraceId 记录整个服务链路的 ID，由首次请求方创建，服务链路中唯一。\nspanId 记录当前服务块的 ID，由当前服务方创建。\nparentId 记录上一个请求服务的 spanId。\n下面我描述下，我们目前的服务调用链路过程：\nH5 发起请求，到 Zuul 网关，Zuul 创建全局的 traceId 和自己的 spanId，然后携带这些数据到业务服务 A，并利用 Spring Cloud Sluth 传输到 RabbitMQ。\n业务服务 A，接收到 Zuul 传输的 traceId 和 spanId，然后把 Zuul 的 spanId 设置成 parentId，并生成自己的 spanId，然后携带这些数据到业务服务 B，并利用 Spring Cloud Sluth 传输到 RabbitMQ。\n....\n上面图中，详细说明了整个服务调用链路的过程，这边再说下使用的技术栈：\nSpring Cloud Sluth：和 SkyWalking 的探针概念比较类似，每个服务都进行配置，收集当然服务的请求数据（traceId 和 spanId），然后利用stream-sluth和binder-rabbit组件，将请求数据传输到 RabbitMQ。\nSpring Cloud Zipkin：主要用于请求链路的 UI 展示，Zipkin 会从 RabbitMQ 读取请求数据，然后存储到 ElasticSearch 中，然后下次显示直接从 ElasticSearch 中读取。\nKibana：Kibana 也可以显示 ElasticSearch 中的请求数据，只不过不是图形化的，需要索引配置创建。\n\n# ELK 日志链路\n\n{% asset_img 7.png  %}\n\nELK 可以参考下之前的几篇文章：\nELK 架构之 Elasticsearch 和 Kibana 安装配置\nELK 架构之 Logstash 和 Filebeat 安装配置\nELK 架构之 Logstash 和 Filebeat 配置使用（采集过滤）\nELK 架构之 Elasticsearch、Kibana、Logstash 和 Filebeat 安装配置汇总（6.2.4 版本）\n上面图中已经很详细介绍了下 ELK 的流程，ELK 默认技术栈里是没有 Filebeat 的，Logstash 用作日志收集的时候，CPU 和内存会占用资源比较大，所以我们使用轻量化的 Filebeat 进行日志的收集，Filebeat 部署在每个业务服务所在的服务器，然后将收集到的日志数据传输到 Logstash，Logstash 可以部署两到三台服务器上，用作日志的过滤和分析工作，然后再将处理后的日志数据，传输到 ElasticSearch 存储。\n\n# 统一格式返回\n\n{% asset_img 8.png %}\n\n","slug":"spring/spring-cloud-learning","published":1,"updated":"2020-12-15T01:04:34.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz87001hmxcd1our15vm","content":"<p>Java 微服务框架选型（Dubbo 和 Spring Cloud）</p>\n<img src=\"/posts/1879991184/index/1.png\" class=\"\">\n\n<p>目前公司使用的 Spring Cloud 整个技术组件，基本包含了上面图中所包含的，不得不说，Spring Cloud 整个生态真的很强大，使用起来也很方便有效。</p>\n<p>后面有时间再针对每个组件进行使用解读，这篇文章主要说下 Spring Cloud 架构的链路图，顺便把自己的思路整理下来，以备查阅。</p>\n<img src=\"/posts/1879991184/index/2.png\" class=\"\">\n\n<h1 id=\"网关请求流程\"><a href=\"#网关请求流程\" class=\"headerlink\" title=\"网关请求流程\"></a>网关请求流程</h1><p>在 Spring Cloud 整个组件库中，Spring Cloud Zuul 是最容易被忽视，但也是最重要的，Spring Cloud Zuul 可以和 Eureka 注册中心集成，我们目前使用 Spring Cloud Zuul 的功能如下：</p>\n<ul>\n<li>Filter 过滤器</li>\n<li>Router 路由</li>\n<li>Ribbon 负载均衡</li>\n<li>Hystrix 熔断</li>\n<li>Retry 重试<br>有些功能是 Spring Cloud Zuul 自带的，比如 Filter 和 Router，有些是结合 Spring Cloud 其他组件，比如 Ribbon 和 Hystrix。</li>\n</ul>\n<p>这里重点介绍下 Filter 过滤器，分为四个过滤类型：</p>\n<ul>\n<li>pre：Zuul 转发请求之前执行，我们目前的实现是AccessTokenFilter，用于 oAuth2.0 JWT 的授权验证。</li>\n<li>route：Zuul 路由时执行，目前项目没用到。</li>\n<li>post：Zuul 路由转发后执行，也就是已经请求成功了后端服务，我们目前的实现是CustomResponseFilter，用于统一请求格式的封装，比如 code/msg/data 等。</li>\n<li>error：以上过滤器发生错误时执行，我们目前的实现是CustomErrorFilter，用于拦截过滤器执行的出现的错误，然后统一格式封装返回，另外，error 过滤器好像并不能捕获后端服务执行出现的错误。</li>\n</ul>\n<p>另外，关于 oAuth2.0 JWT 的授权验证，实现的方式有两种：</p>\n<ul>\n<li>授权的配置在后端服务中（每个服务都需要当作 Resource Server 进行配置，需要配置公钥，接口的授权具体配置在注解中），Zuul 只做转发，并不进行授权的验证。</li>\n<li>授权的配置在 Zuul 中，也就是把 Zuul 当作 Resource Server，后端服务不需要进行任何处理，Zuul 中具体的实现就是AccessTokenFilter，里面的逻辑是手动解析 JWT，然后判断是否正确，以及解析出用户信息/Scope/Role，然后根据当前的请求 API，对授权 Map 中的配置进行匹配，如果匹配错误，直接抛出 401 授权错误。<br>我们目前采用的是第二种方式，这两种方式都有利有弊，关键在于自己的取舍，为什么采用第二种方式？目的就是发挥 Zuul 的作用，对外网关进行统一授权验证。</li>\n</ul>\n<p>关于授权 Map，里面存储了所有服务接口的配置，示例配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final Map ROUTE_MAPS;</span><br><span class=\"line\">static &#123;</span><br><span class=\"line\">    ROUTE_MAPS &#x3D; new HashMap();</span><br><span class=\"line\">    ROUTE_MAPS.put(&quot;eureka-client&#x2F;home&quot;, &quot;read:ROLE_ADMIN&quot;);</span><br><span class=\"line\">    ROUTE_MAPS.put(&quot;eureka-client&#x2F;user&quot;, &quot;read:ROLE_ADMIN&quot;);</span><br><span class=\"line\">    ROUTE_MAPS.put(&quot;eureka-client&#x2F;error&quot;, &quot;read:ROLE_ADMIN&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>这是我们目前的配置，是一个静态的 Map，后面会存储在 Spring Cloud Config 配置中心，Zuul 启动时进行加载，利用 Spring Cloud Bus 动态刷新。</p>\n<p>关于 Zuul 网关，其实还有很多需要说的，后面有机会再进行针对说明。</p>\n<h1 id=\"Eureka-服务治理\"><a href=\"#Eureka-服务治理\" class=\"headerlink\" title=\"Eureka 服务治理\"></a>Eureka 服务治理</h1><img src=\"/posts/1879991184/index/3.png\" class=\"\">\n\n<p>Eureka 遵循的是 AP 原则（服务可用性和分区容错性），是服务治理最理想的遵循 CAP 分布式原则。</p>\n<p>Eureka 集群中的节点是彼此平级，不像 Consul 有 master/worker 之分，集群中的 Eureka 节点彼此两两注册，所以，Eureka 集群最好部署三个节点，这也是我们目前的部署方式。</p>\n<p>另外，Eureka 的自我保护机制，可以参考这篇文章。</p>\n<p>服务之间的相互调用，负载有两种使用方式：</p>\n<ul>\n<li>Feign：基于声明式，顾名思义，就是需要定义接口，就像我们平常使用对象调用一样。</li>\n<li>Ribbon：软负载，通过往 RestTemplate 中注入负载 Handler，然后通过负载算法选取调用（通过 Eureka 获取服务注册信息）。<br>我们目前打算使用 Ribbon 负载方式，为什么？看下面代码就知道了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">restTemplate.getForObject(&quot;http:&#x2F;&#x2F;eureka-client&#x2F;hello&quot;, String.class);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Config-配置中心\"><a href=\"#Config-配置中心\" class=\"headerlink\" title=\"Config 配置中心\"></a>Config 配置中心</h1><img src=\"/posts/1879991184/index/4.png\" class=\"\">\n\n<p>我们目前配置中心使用的是 Spring Cloud Config，当然你也可以使用功能更强大的 Polly（携程开源），但 Config 目前也能满足我们的需求，存储仓库我们现在使用的是 Git。</p>\n<p>Config 配置中心提供了数据加密功能，你可以使用 RSA 的加密方式，这样存储在 Git 中的配置都是密文形式，Config Client 获取加密配置的时候，Config Server 会自动进行解密返回。</p>\n<p>配置中心的使用场景，我们目前主要是两个地方：</p>\n<ul>\n<li>项目启动的配置信息，比如数据库的连接字符串等。</li>\n<li>业务服务的配置信息，也就是业务相关的配置。</li>\n</ul>\n<p>另外，需要说明的是，默认情况下，如果 Git 中的配置更新了，Config Client 不会进行更新配置，我们目前的解决方式是，使用 Spring Cloud Bus 进行动态刷新配置（Config Server 中配置），具体的流程：</p>\n<ol>\n<li>Git 中添加 WebHooks 脚本，比如curl -X POST <a href=\"http://manager1:8180/bus/refresh，当\" target=\"_blank\" rel=\"noopener\">http://manager1:8180/bus/refresh，当</a> Git 仓库中的配置更新后，自动执行。</li>\n<li>Config Server 中配置 Spring Cloud Bus，接受 Git 的配置刷新请求，然后利用 RabbitMQ 广播通知所有的 Config Client 订阅方，刷新配置信息。</li>\n</ol>\n<h1 id=\"Hystrix-监控\"><a href=\"#Hystrix-监控\" class=\"headerlink\" title=\"Hystrix 监控\"></a>Hystrix 监控</h1><img src=\"/posts/1879991184/index/5.png\" class=\"\">\n\n<p>Hystrix 主要是用于服务熔断/降级/隔离处理，Hystrix 配置在调用方，当被调用方服务不可用时，触发 Hystrix 熔断，会执行指定的 Fallback 方法，进行特殊处理。</p>\n<p>我之前以为，Hystrix 熔断的触发条件是服务不可用，也就是服务请求超时（比如服务挂掉了），但我自己测试了下，服务出现 500 错误，也会触发 Hystrix 熔断，而且会自动忽略 Hystrix 的超时时间设置。</p>\n<p>我们目前使用 Hystrix，主要有两个地方：</p>\n<ul>\n<li>内部服务调用：可以对某个 API 接口进行熔断处理。</li>\n<li>Zuul 网关使用：就是当 Zuul 路由转发调用时，但有个局限性，就是只能对服务进行熔断，并不能针对某个 API 接口熔断。</li>\n</ul>\n<p>上面图中，主要画的是 Hystrix 的监控流程，我们目前主要使用 RabbitMQ 进行采集传输，turbine-server 进行数据流的聚合，hystrix-dashboard 进行图形化的展示。</p>\n<h1 id=\"服务调用链路\"><a href=\"#服务调用链路\" class=\"headerlink\" title=\"服务调用链路\"></a>服务调用链路</h1><img src=\"/posts/1879991184/index/6.png\" class=\"\">\n\n<p>服务调用链路的概念，就是当服务请求发起时，记录整个请求链路的数据，以备查询。</p>\n<p>目前市面上，几乎所有服务调用链路的实现，理论基础都是基于 Google Dapper 的那篇论文，其中最重要的概念就是 traceId 和 spanId。<br>traceId 记录整个服务链路的 ID，由首次请求方创建，服务链路中唯一。<br>spanId 记录当前服务块的 ID，由当前服务方创建。<br>parentId 记录上一个请求服务的 spanId。<br>下面我描述下，我们目前的服务调用链路过程：<br>H5 发起请求，到 Zuul 网关，Zuul 创建全局的 traceId 和自己的 spanId，然后携带这些数据到业务服务 A，并利用 Spring Cloud Sluth 传输到 RabbitMQ。<br>业务服务 A，接收到 Zuul 传输的 traceId 和 spanId，然后把 Zuul 的 spanId 设置成 parentId，并生成自己的 spanId，然后携带这些数据到业务服务 B，并利用 Spring Cloud Sluth 传输到 RabbitMQ。<br>….<br>上面图中，详细说明了整个服务调用链路的过程，这边再说下使用的技术栈：<br>Spring Cloud Sluth：和 SkyWalking 的探针概念比较类似，每个服务都进行配置，收集当然服务的请求数据（traceId 和 spanId），然后利用stream-sluth和binder-rabbit组件，将请求数据传输到 RabbitMQ。<br>Spring Cloud Zipkin：主要用于请求链路的 UI 展示，Zipkin 会从 RabbitMQ 读取请求数据，然后存储到 ElasticSearch 中，然后下次显示直接从 ElasticSearch 中读取。<br>Kibana：Kibana 也可以显示 ElasticSearch 中的请求数据，只不过不是图形化的，需要索引配置创建。</p>\n<h1 id=\"ELK-日志链路\"><a href=\"#ELK-日志链路\" class=\"headerlink\" title=\"ELK 日志链路\"></a>ELK 日志链路</h1><img src=\"/posts/1879991184/index/7.png\" class=\"\">\n\n<p>ELK 可以参考下之前的几篇文章：<br>ELK 架构之 Elasticsearch 和 Kibana 安装配置<br>ELK 架构之 Logstash 和 Filebeat 安装配置<br>ELK 架构之 Logstash 和 Filebeat 配置使用（采集过滤）<br>ELK 架构之 Elasticsearch、Kibana、Logstash 和 Filebeat 安装配置汇总（6.2.4 版本）<br>上面图中已经很详细介绍了下 ELK 的流程，ELK 默认技术栈里是没有 Filebeat 的，Logstash 用作日志收集的时候，CPU 和内存会占用资源比较大，所以我们使用轻量化的 Filebeat 进行日志的收集，Filebeat 部署在每个业务服务所在的服务器，然后将收集到的日志数据传输到 Logstash，Logstash 可以部署两到三台服务器上，用作日志的过滤和分析工作，然后再将处理后的日志数据，传输到 ElasticSearch 存储。</p>\n<h1 id=\"统一格式返回\"><a href=\"#统一格式返回\" class=\"headerlink\" title=\"统一格式返回\"></a>统一格式返回</h1><img src=\"/posts/1879991184/index/8.png\" class=\"\">\n\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>Java 微服务框架选型（Dubbo 和 Spring Cloud）</p>\n<img src=\"/posts/1879991184/index/1.png\" class=\"\">\n\n<p>目前公司使用的 Spring Cloud 整个技术组件，基本包含了上面图中所包含的，不得不说，Spring Cloud 整个生态真的很强大，使用起来也很方便有效。</p>\n<p>后面有时间再针对每个组件进行使用解读，这篇文章主要说下 Spring Cloud 架构的链路图，顺便把自己的思路整理下来，以备查阅。</p>\n<img src=\"/posts/1879991184/index/2.png\" class=\"\">\n\n<h1 id=\"网关请求流程\"><a href=\"#网关请求流程\" class=\"headerlink\" title=\"网关请求流程\"></a>网关请求流程</h1><p>在 Spring Cloud 整个组件库中，Spring Cloud Zuul 是最容易被忽视，但也是最重要的，Spring Cloud Zuul 可以和 Eureka 注册中心集成，我们目前使用 Spring Cloud Zuul 的功能如下：</p>\n<ul>\n<li>Filter 过滤器</li>\n<li>Router 路由</li>\n<li>Ribbon 负载均衡</li>\n<li>Hystrix 熔断</li>\n<li>Retry 重试<br>有些功能是 Spring Cloud Zuul 自带的，比如 Filter 和 Router，有些是结合 Spring Cloud 其他组件，比如 Ribbon 和 Hystrix。</li>\n</ul>\n<p>这里重点介绍下 Filter 过滤器，分为四个过滤类型：</p>\n<ul>\n<li>pre：Zuul 转发请求之前执行，我们目前的实现是AccessTokenFilter，用于 oAuth2.0 JWT 的授权验证。</li>\n<li>route：Zuul 路由时执行，目前项目没用到。</li>\n<li>post：Zuul 路由转发后执行，也就是已经请求成功了后端服务，我们目前的实现是CustomResponseFilter，用于统一请求格式的封装，比如 code/msg/data 等。</li>\n<li>error：以上过滤器发生错误时执行，我们目前的实现是CustomErrorFilter，用于拦截过滤器执行的出现的错误，然后统一格式封装返回，另外，error 过滤器好像并不能捕获后端服务执行出现的错误。</li>\n</ul>\n<p>另外，关于 oAuth2.0 JWT 的授权验证，实现的方式有两种：</p>\n<ul>\n<li>授权的配置在后端服务中（每个服务都需要当作 Resource Server 进行配置，需要配置公钥，接口的授权具体配置在注解中），Zuul 只做转发，并不进行授权的验证。</li>\n<li>授权的配置在 Zuul 中，也就是把 Zuul 当作 Resource Server，后端服务不需要进行任何处理，Zuul 中具体的实现就是AccessTokenFilter，里面的逻辑是手动解析 JWT，然后判断是否正确，以及解析出用户信息/Scope/Role，然后根据当前的请求 API，对授权 Map 中的配置进行匹配，如果匹配错误，直接抛出 401 授权错误。<br>我们目前采用的是第二种方式，这两种方式都有利有弊，关键在于自己的取舍，为什么采用第二种方式？目的就是发挥 Zuul 的作用，对外网关进行统一授权验证。</li>\n</ul>\n<p>关于授权 Map，里面存储了所有服务接口的配置，示例配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static final Map ROUTE_MAPS;</span><br><span class=\"line\">static &#123;</span><br><span class=\"line\">    ROUTE_MAPS &#x3D; new HashMap();</span><br><span class=\"line\">    ROUTE_MAPS.put(&quot;eureka-client&#x2F;home&quot;, &quot;read:ROLE_ADMIN&quot;);</span><br><span class=\"line\">    ROUTE_MAPS.put(&quot;eureka-client&#x2F;user&quot;, &quot;read:ROLE_ADMIN&quot;);</span><br><span class=\"line\">    ROUTE_MAPS.put(&quot;eureka-client&#x2F;error&quot;, &quot;read:ROLE_ADMIN&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>这是我们目前的配置，是一个静态的 Map，后面会存储在 Spring Cloud Config 配置中心，Zuul 启动时进行加载，利用 Spring Cloud Bus 动态刷新。</p>\n<p>关于 Zuul 网关，其实还有很多需要说的，后面有机会再进行针对说明。</p>\n<h1 id=\"Eureka-服务治理\"><a href=\"#Eureka-服务治理\" class=\"headerlink\" title=\"Eureka 服务治理\"></a>Eureka 服务治理</h1><img src=\"/posts/1879991184/index/3.png\" class=\"\">\n\n<p>Eureka 遵循的是 AP 原则（服务可用性和分区容错性），是服务治理最理想的遵循 CAP 分布式原则。</p>\n<p>Eureka 集群中的节点是彼此平级，不像 Consul 有 master/worker 之分，集群中的 Eureka 节点彼此两两注册，所以，Eureka 集群最好部署三个节点，这也是我们目前的部署方式。</p>\n<p>另外，Eureka 的自我保护机制，可以参考这篇文章。</p>\n<p>服务之间的相互调用，负载有两种使用方式：</p>\n<ul>\n<li>Feign：基于声明式，顾名思义，就是需要定义接口，就像我们平常使用对象调用一样。</li>\n<li>Ribbon：软负载，通过往 RestTemplate 中注入负载 Handler，然后通过负载算法选取调用（通过 Eureka 获取服务注册信息）。<br>我们目前打算使用 Ribbon 负载方式，为什么？看下面代码就知道了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">restTemplate.getForObject(&quot;http:&#x2F;&#x2F;eureka-client&#x2F;hello&quot;, String.class);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Config-配置中心\"><a href=\"#Config-配置中心\" class=\"headerlink\" title=\"Config 配置中心\"></a>Config 配置中心</h1><img src=\"/posts/1879991184/index/4.png\" class=\"\">\n\n<p>我们目前配置中心使用的是 Spring Cloud Config，当然你也可以使用功能更强大的 Polly（携程开源），但 Config 目前也能满足我们的需求，存储仓库我们现在使用的是 Git。</p>\n<p>Config 配置中心提供了数据加密功能，你可以使用 RSA 的加密方式，这样存储在 Git 中的配置都是密文形式，Config Client 获取加密配置的时候，Config Server 会自动进行解密返回。</p>\n<p>配置中心的使用场景，我们目前主要是两个地方：</p>\n<ul>\n<li>项目启动的配置信息，比如数据库的连接字符串等。</li>\n<li>业务服务的配置信息，也就是业务相关的配置。</li>\n</ul>\n<p>另外，需要说明的是，默认情况下，如果 Git 中的配置更新了，Config Client 不会进行更新配置，我们目前的解决方式是，使用 Spring Cloud Bus 进行动态刷新配置（Config Server 中配置），具体的流程：</p>\n<ol>\n<li>Git 中添加 WebHooks 脚本，比如curl -X POST <a href=\"http://manager1:8180/bus/refresh，当\" target=\"_blank\" rel=\"noopener\">http://manager1:8180/bus/refresh，当</a> Git 仓库中的配置更新后，自动执行。</li>\n<li>Config Server 中配置 Spring Cloud Bus，接受 Git 的配置刷新请求，然后利用 RabbitMQ 广播通知所有的 Config Client 订阅方，刷新配置信息。</li>\n</ol>\n<h1 id=\"Hystrix-监控\"><a href=\"#Hystrix-监控\" class=\"headerlink\" title=\"Hystrix 监控\"></a>Hystrix 监控</h1><img src=\"/posts/1879991184/index/5.png\" class=\"\">\n\n<p>Hystrix 主要是用于服务熔断/降级/隔离处理，Hystrix 配置在调用方，当被调用方服务不可用时，触发 Hystrix 熔断，会执行指定的 Fallback 方法，进行特殊处理。</p>\n<p>我之前以为，Hystrix 熔断的触发条件是服务不可用，也就是服务请求超时（比如服务挂掉了），但我自己测试了下，服务出现 500 错误，也会触发 Hystrix 熔断，而且会自动忽略 Hystrix 的超时时间设置。</p>\n<p>我们目前使用 Hystrix，主要有两个地方：</p>\n<ul>\n<li>内部服务调用：可以对某个 API 接口进行熔断处理。</li>\n<li>Zuul 网关使用：就是当 Zuul 路由转发调用时，但有个局限性，就是只能对服务进行熔断，并不能针对某个 API 接口熔断。</li>\n</ul>\n<p>上面图中，主要画的是 Hystrix 的监控流程，我们目前主要使用 RabbitMQ 进行采集传输，turbine-server 进行数据流的聚合，hystrix-dashboard 进行图形化的展示。</p>\n<h1 id=\"服务调用链路\"><a href=\"#服务调用链路\" class=\"headerlink\" title=\"服务调用链路\"></a>服务调用链路</h1><img src=\"/posts/1879991184/index/6.png\" class=\"\">\n\n<p>服务调用链路的概念，就是当服务请求发起时，记录整个请求链路的数据，以备查询。</p>\n<p>目前市面上，几乎所有服务调用链路的实现，理论基础都是基于 Google Dapper 的那篇论文，其中最重要的概念就是 traceId 和 spanId。<br>traceId 记录整个服务链路的 ID，由首次请求方创建，服务链路中唯一。<br>spanId 记录当前服务块的 ID，由当前服务方创建。<br>parentId 记录上一个请求服务的 spanId。<br>下面我描述下，我们目前的服务调用链路过程：<br>H5 发起请求，到 Zuul 网关，Zuul 创建全局的 traceId 和自己的 spanId，然后携带这些数据到业务服务 A，并利用 Spring Cloud Sluth 传输到 RabbitMQ。<br>业务服务 A，接收到 Zuul 传输的 traceId 和 spanId，然后把 Zuul 的 spanId 设置成 parentId，并生成自己的 spanId，然后携带这些数据到业务服务 B，并利用 Spring Cloud Sluth 传输到 RabbitMQ。<br>….<br>上面图中，详细说明了整个服务调用链路的过程，这边再说下使用的技术栈：<br>Spring Cloud Sluth：和 SkyWalking 的探针概念比较类似，每个服务都进行配置，收集当然服务的请求数据（traceId 和 spanId），然后利用stream-sluth和binder-rabbit组件，将请求数据传输到 RabbitMQ。<br>Spring Cloud Zipkin：主要用于请求链路的 UI 展示，Zipkin 会从 RabbitMQ 读取请求数据，然后存储到 ElasticSearch 中，然后下次显示直接从 ElasticSearch 中读取。<br>Kibana：Kibana 也可以显示 ElasticSearch 中的请求数据，只不过不是图形化的，需要索引配置创建。</p>\n<h1 id=\"ELK-日志链路\"><a href=\"#ELK-日志链路\" class=\"headerlink\" title=\"ELK 日志链路\"></a>ELK 日志链路</h1><img src=\"/posts/1879991184/index/7.png\" class=\"\">\n\n<p>ELK 可以参考下之前的几篇文章：<br>ELK 架构之 Elasticsearch 和 Kibana 安装配置<br>ELK 架构之 Logstash 和 Filebeat 安装配置<br>ELK 架构之 Logstash 和 Filebeat 配置使用（采集过滤）<br>ELK 架构之 Elasticsearch、Kibana、Logstash 和 Filebeat 安装配置汇总（6.2.4 版本）<br>上面图中已经很详细介绍了下 ELK 的流程，ELK 默认技术栈里是没有 Filebeat 的，Logstash 用作日志收集的时候，CPU 和内存会占用资源比较大，所以我们使用轻量化的 Filebeat 进行日志的收集，Filebeat 部署在每个业务服务所在的服务器，然后将收集到的日志数据传输到 Logstash，Logstash 可以部署两到三台服务器上，用作日志的过滤和分析工作，然后再将处理后的日志数据，传输到 ElasticSearch 存储。</p>\n<h1 id=\"统一格式返回\"><a href=\"#统一格式返回\" class=\"headerlink\" title=\"统一格式返回\"></a>统一格式返回</h1><img src=\"/posts/1879991184/index/8.png\" class=\"\">\n\n"},{"title":"linux与k8s的区别","abbrlink":2578104314,"date":"2017-08-18T09:59:25.000Z","index_img":"./img/docker.png","_content":"\n# [10分钟看懂Docker和K8S](https://www.cnblogs.com/itbsl/p/10178698.html)\n\n**本文来源：鲜枣课堂**\n\n2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。\n\n![img](../../img/720430-20181226134250810-1685533200.png)\n\n这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。\n\n![img](../../img/720430-20181226134259735-1931086473.png)\n\nLXC，就是Linux容器虚拟技术（Linux container）\n\n后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。\n\n![img](../../img/720430-20181226134308841-1109691453.png)\n\nDocker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。\n\n正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。\n\n什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。\n\n![img](../../img/720430-20181226134321094-1025894099.png)\n\nOpen Source，开源\n\n有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。\n\n2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134409452-99479785.png)\n\nSolomon Hykes（今年刚从Docker离职）\n\n不开则已，一开惊人。\n\n越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。\n\nDocker的人气迅速攀升，速度之快，令人瞠目结舌。\n\n开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。\n\n此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。\n\nDocker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。\n\nDocker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。\n\n在容器技术之前，业界的网红是虚拟机。**虚拟机**技术的代表，是**VMWare**和**OpenStack**。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134345971-148194642.png)\n\n相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134357583-1178315643.png)\n\n虚拟机，类似于“子电脑”\n\n在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是**相互隔离**的，互不影响。\n\n虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于**轻量级的虚拟化**。\n\n虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。\n\n而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134422660-219996811.png)\n\n沙箱\n\n它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134430830-648875754.png)\n\n容器和虚拟机的对比\n\n正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。\n\n我们具体来看看Docker。\n\n大家需要注意，**Docker本身并不是容器**，它是创建容器的工具，是应用容器引擎。\n\n想要搞懂Docker，其实看它的两句口号就行。\n\n第一句，是“**Build, Ship and Run**”。\n\n![img](linux%E4%B8%8Ek8s%E7%9A%84%E5%8C%BA%E5%88%AB.assets/720430-20181226134440039-355719052.png)\n\n也就是，“搭建、发送、运行”，三板斧。\n\n举个例子：\n\n我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134448189-1614413776.png)\n\n结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。\n\n但是，跑来一个老巫婆，教会我一种魔法。\n\n这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134458048-1632935313.png)\n\n等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134507695-502496013.png)\n\n怎么样？是不是很神奇？\n\n所以，Docker的第二句口号就是：“**Build once，Run anywhere（搭建一次，到处能用）**”。\n\nDocker技术的三大核心概念，分别是：\n\n- **镜像（Image）**\n- **容器（Container）**\n- **仓库（Repository）**\n\n我刚才例子里面，那个放在包里的“镜像”，就是**Docker镜像**。而我的背包，就是**Docker仓库**。我在空地上，用魔法造好的房子，就是一个**Docker容器**。\n\n说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。\n\n每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！\n\n也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。\n\n这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134517561-1517184540.png)\n\n于是乎，就变成了一个大的公共仓库。\n\n负责对Docker镜像进行管理的，是**Docker Registry服务**（类似仓库管理员）。\n\n不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？\n\n所以，Docker Registry服务对镜像的管理是非常严格的。\n\n最常使用的Registry公开服务，是官方的**Docker Hub**，这也是默认的Registry，并拥有大量的高质量的官方镜像。\n\n好了，说完了Docker，我们再把目光转向K8S。\n\n就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。\n\n就在这个时候，K8S出现了。\n\n**K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134529220-885595947.png)\n\nKubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。\n\n和Docker不同，K8S的创造者，是众人皆知的行业巨头——**Google**。\n\n然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的**Borg系统**。\n\nK8S是2014年6月由Google公司正式公布出来并宣布开源的。\n\n同年7月，微软、Red Hat、IBM、Docker、CoreOS、Mesosphere和Saltstack等公司，相继加入K8S。\n\n之后的一年内，VMware、HP、Intel等公司，也陆续加入。\n\n2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。\n\n目前，kubernetes的版本已经发展到V1.13。\n\nK8S的架构，略微有一点复杂，我们简单来看一下。\n\n一个K8S系统，通常称为一个**K8S集群（Cluster）**。\n\n这个集群主要包括两个部分：\n\n- **一个Master节点（主节点）**\n- **一群Node节点（计算节点）**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134539670-1577644922.png)\n\n一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。\n\n深入来看这两种节点。\n\n首先是**Master节点。**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134549651-376208258.png)\n\nMaster节点包括API Server、Scheduler、Controller manager、etcd。\n\nAPI Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。\n\nScheduler负责对集群内部的资源进行调度，相当于“调度室”。\n\nController manager负责管理控制器，相当于“大总管”。\n\n然后是**Node节点**。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134600202-626807958.png)\n\nNode节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是**Pod**。\n\n> Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。\n\nDocker，不用说了，创建容器的。\n\nKubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。\n\nKube-proxy，主要负责为Pod对象提供代理。\n\nFluentd，主要负责日志收集、存储与查询。\n\n是不是有点懵？唉，三言两语真的很难讲清楚，继续跳过吧。\n\nDocker和K8S都介绍完了，然而文章并没有结束。\n\n接下来的部分，是**写给核心网工程师甚至所有通信工程师看的**。\n\n从几十年前的1G，到现在的4G，再到将来的5G，移动通信发生了翻天覆地的变化，核心网亦是如此。\n\n但是，如果你仔细洞察这些变化，会发现，所谓的核心网，其实本质上并没有发生改变，无非就是很多的服务器而已。不同的核心网网元，就是不同的服务器，不同的计算节点。\n\n变化的，是这些“服务器”的形态和接口：形态，从机柜单板，变成机柜刀片，从机柜刀片，变成X86通用刀片服务器；接口，从中继线缆，变成网线，从网线，变成光纤。\n\n就算变来变去，还是服务器，是计算节点，是CPU。\n\n既然是服务器，那么就势必会和IT云计算一样，走上虚拟化的道路。毕竟，虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度，等等。\n\n前几年，大家以为虚拟机是核心网的终极形态。目前看来，更有可能是**容器化**。这几年经常说的NFV（网元功能虚拟化），也有可能改口为NFC（网元功能容器化）。\n\n以VoLTE为例，如果按以前2G/3G的方式，那需要大量的专用设备，分别充当EPC和IMS的不同网元。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134611008-1358657705.png)\n\nVoLTE相关的网元\n\n而采用容器之后，很可能只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同网元的服务程序。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134621637-1646543877.png)\n\n这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。\n\n简直完美！\n\n5G时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成N个专能型。每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134635090-835720705.png)\n\n精细化分工\n\n按照这样的发展趋势，在移动通信系统中，除了天线，剩下的部分都有可能虚拟化。核心网是第一个，但不是最后一个。虚拟化之后的核心网，与其说属于通信，实际上更应该归为IT。核心网的功能，只是容器中普通一个软件功能而已。\n\n至于说在座的各位核心网工程师，恭喜你们，马上就要成功转型啦！","source":"_posts/linux/linux与k8s的区别.md","raw":"---\ntitle: linux与k8s的区别\nabbrlink: 2578104314\ndate: 2017-08-18 17:59:25\nindex_img: ./img/docker.png\ntags: \n  - Docker\n---\n\n# [10分钟看懂Docker和K8S](https://www.cnblogs.com/itbsl/p/10178698.html)\n\n**本文来源：鲜枣课堂**\n\n2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。\n\n![img](../../img/720430-20181226134250810-1685533200.png)\n\n这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。\n\n![img](../../img/720430-20181226134259735-1931086473.png)\n\nLXC，就是Linux容器虚拟技术（Linux container）\n\n后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。\n\n![img](../../img/720430-20181226134308841-1109691453.png)\n\nDocker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。\n\n正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。\n\n什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。\n\n![img](../../img/720430-20181226134321094-1025894099.png)\n\nOpen Source，开源\n\n有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。\n\n2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134409452-99479785.png)\n\nSolomon Hykes（今年刚从Docker离职）\n\n不开则已，一开惊人。\n\n越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。\n\nDocker的人气迅速攀升，速度之快，令人瞠目结舌。\n\n开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。\n\n此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。\n\nDocker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。\n\nDocker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。\n\n在容器技术之前，业界的网红是虚拟机。**虚拟机**技术的代表，是**VMWare**和**OpenStack**。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134345971-148194642.png)\n\n相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134357583-1178315643.png)\n\n虚拟机，类似于“子电脑”\n\n在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是**相互隔离**的，互不影响。\n\n虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于**轻量级的虚拟化**。\n\n虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。\n\n而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134422660-219996811.png)\n\n沙箱\n\n它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134430830-648875754.png)\n\n容器和虚拟机的对比\n\n正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。\n\n我们具体来看看Docker。\n\n大家需要注意，**Docker本身并不是容器**，它是创建容器的工具，是应用容器引擎。\n\n想要搞懂Docker，其实看它的两句口号就行。\n\n第一句，是“**Build, Ship and Run**”。\n\n![img](linux%E4%B8%8Ek8s%E7%9A%84%E5%8C%BA%E5%88%AB.assets/720430-20181226134440039-355719052.png)\n\n也就是，“搭建、发送、运行”，三板斧。\n\n举个例子：\n\n我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134448189-1614413776.png)\n\n结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。\n\n但是，跑来一个老巫婆，教会我一种魔法。\n\n这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134458048-1632935313.png)\n\n等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134507695-502496013.png)\n\n怎么样？是不是很神奇？\n\n所以，Docker的第二句口号就是：“**Build once，Run anywhere（搭建一次，到处能用）**”。\n\nDocker技术的三大核心概念，分别是：\n\n- **镜像（Image）**\n- **容器（Container）**\n- **仓库（Repository）**\n\n我刚才例子里面，那个放在包里的“镜像”，就是**Docker镜像**。而我的背包，就是**Docker仓库**。我在空地上，用魔法造好的房子，就是一个**Docker容器**。\n\n说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。\n\n每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！\n\n也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。\n\n这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134517561-1517184540.png)\n\n于是乎，就变成了一个大的公共仓库。\n\n负责对Docker镜像进行管理的，是**Docker Registry服务**（类似仓库管理员）。\n\n不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？\n\n所以，Docker Registry服务对镜像的管理是非常严格的。\n\n最常使用的Registry公开服务，是官方的**Docker Hub**，这也是默认的Registry，并拥有大量的高质量的官方镜像。\n\n好了，说完了Docker，我们再把目光转向K8S。\n\n就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。\n\n就在这个时候，K8S出现了。\n\n**K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134529220-885595947.png)\n\nKubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。\n\n和Docker不同，K8S的创造者，是众人皆知的行业巨头——**Google**。\n\n然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的**Borg系统**。\n\nK8S是2014年6月由Google公司正式公布出来并宣布开源的。\n\n同年7月，微软、Red Hat、IBM、Docker、CoreOS、Mesosphere和Saltstack等公司，相继加入K8S。\n\n之后的一年内，VMware、HP、Intel等公司，也陆续加入。\n\n2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。\n\n目前，kubernetes的版本已经发展到V1.13。\n\nK8S的架构，略微有一点复杂，我们简单来看一下。\n\n一个K8S系统，通常称为一个**K8S集群（Cluster）**。\n\n这个集群主要包括两个部分：\n\n- **一个Master节点（主节点）**\n- **一群Node节点（计算节点）**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134539670-1577644922.png)\n\n一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。\n\n深入来看这两种节点。\n\n首先是**Master节点。**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134549651-376208258.png)\n\nMaster节点包括API Server、Scheduler、Controller manager、etcd。\n\nAPI Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。\n\nScheduler负责对集群内部的资源进行调度，相当于“调度室”。\n\nController manager负责管理控制器，相当于“大总管”。\n\n然后是**Node节点**。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134600202-626807958.png)\n\nNode节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是**Pod**。\n\n> Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。\n\nDocker，不用说了，创建容器的。\n\nKubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。\n\nKube-proxy，主要负责为Pod对象提供代理。\n\nFluentd，主要负责日志收集、存储与查询。\n\n是不是有点懵？唉，三言两语真的很难讲清楚，继续跳过吧。\n\nDocker和K8S都介绍完了，然而文章并没有结束。\n\n接下来的部分，是**写给核心网工程师甚至所有通信工程师看的**。\n\n从几十年前的1G，到现在的4G，再到将来的5G，移动通信发生了翻天覆地的变化，核心网亦是如此。\n\n但是，如果你仔细洞察这些变化，会发现，所谓的核心网，其实本质上并没有发生改变，无非就是很多的服务器而已。不同的核心网网元，就是不同的服务器，不同的计算节点。\n\n变化的，是这些“服务器”的形态和接口：形态，从机柜单板，变成机柜刀片，从机柜刀片，变成X86通用刀片服务器；接口，从中继线缆，变成网线，从网线，变成光纤。\n\n就算变来变去，还是服务器，是计算节点，是CPU。\n\n既然是服务器，那么就势必会和IT云计算一样，走上虚拟化的道路。毕竟，虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度，等等。\n\n前几年，大家以为虚拟机是核心网的终极形态。目前看来，更有可能是**容器化**。这几年经常说的NFV（网元功能虚拟化），也有可能改口为NFC（网元功能容器化）。\n\n以VoLTE为例，如果按以前2G/3G的方式，那需要大量的专用设备，分别充当EPC和IMS的不同网元。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134611008-1358657705.png)\n\nVoLTE相关的网元\n\n而采用容器之后，很可能只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同网元的服务程序。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134621637-1646543877.png)\n\n这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。\n\n简直完美！\n\n5G时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成N个专能型。每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134635090-835720705.png)\n\n精细化分工\n\n按照这样的发展趋势，在移动通信系统中，除了天线，剩下的部分都有可能虚拟化。核心网是第一个，但不是最后一个。虚拟化之后的核心网，与其说属于通信，实际上更应该归为IT。核心网的功能，只是容器中普通一个软件功能而已。\n\n至于说在座的各位核心网工程师，恭喜你们，马上就要成功转型啦！","slug":"linux/linux与k8s的区别","published":1,"updated":"2020-12-15T02:54:30.187Z","_id":"ckipcgz88001imxcd73ph8ypk","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"10分钟看懂Docker和K8S\"><a href=\"#10分钟看懂Docker和K8S\" class=\"headerlink\" title=\"10分钟看懂Docker和K8S\"></a><a href=\"https://www.cnblogs.com/itbsl/p/10178698.html\" target=\"_blank\" rel=\"noopener\">10分钟看懂Docker和K8S</a></h1><p><strong>本文来源：鲜枣课堂</strong></p>\n<p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。</p>\n<p><img src=\"../../img/720430-20181226134250810-1685533200.png\" alt=\"img\"></p>\n<p>这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。</p>\n<p><img src=\"../../img/720430-20181226134259735-1931086473.png\" alt=\"img\"></p>\n<p>LXC，就是Linux容器虚拟技术（Linux container）</p>\n<p>后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。</p>\n<p><img src=\"../../img/720430-20181226134308841-1109691453.png\" alt=\"img\"></p>\n<p>Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p>\n<p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。</p>\n<p>什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p>\n<p><img src=\"../../img/720430-20181226134321094-1025894099.png\" alt=\"img\"></p>\n<p>Open Source，开源</p>\n<p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p>\n<p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134409452-99479785.png\" alt=\"img\"></p>\n<p>Solomon Hykes（今年刚从Docker离职）</p>\n<p>不开则已，一开惊人。</p>\n<p>越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。</p>\n<p>Docker的人气迅速攀升，速度之快，令人瞠目结舌。</p>\n<p>开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p>\n<p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。</p>\n<p>Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。</p>\n<p>Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p>\n<p>在容器技术之前，业界的网红是虚拟机。<strong>虚拟机</strong>技术的代表，是<strong>VMWare</strong>和<strong>OpenStack</strong>。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134345971-148194642.png\" alt=\"img\"></p>\n<p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134357583-1178315643.png\" alt=\"img\"></p>\n<p>虚拟机，类似于“子电脑”</p>\n<p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p>\n<p>虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化</strong>。</p>\n<p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。</p>\n<p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134422660-219996811.png\" alt=\"img\"></p>\n<p>沙箱</p>\n<p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134430830-648875754.png\" alt=\"img\"></p>\n<p>容器和虚拟机的对比</p>\n<p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p>\n<p>我们具体来看看Docker。</p>\n<p>大家需要注意，<strong>Docker本身并不是容器</strong>，它是创建容器的工具，是应用容器引擎。</p>\n<p>想要搞懂Docker，其实看它的两句口号就行。</p>\n<p>第一句，是“<strong>Build, Ship and Run</strong>”。</p>\n<p><img src=\"linux%E4%B8%8Ek8s%E7%9A%84%E5%8C%BA%E5%88%AB.assets/720430-20181226134440039-355719052.png\" alt=\"img\"></p>\n<p>也就是，“搭建、发送、运行”，三板斧。</p>\n<p>举个例子：</p>\n<p>我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134448189-1614413776.png\" alt=\"img\"></p>\n<p>结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。</p>\n<p>但是，跑来一个老巫婆，教会我一种魔法。</p>\n<p>这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134458048-1632935313.png\" alt=\"img\"></p>\n<p>等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134507695-502496013.png\" alt=\"img\"></p>\n<p>怎么样？是不是很神奇？</p>\n<p>所以，Docker的第二句口号就是：“<strong>Build once，Run anywhere（搭建一次，到处能用）</strong>”。</p>\n<p>Docker技术的三大核心概念，分别是：</p>\n<ul>\n<li><strong>镜像（Image）</strong></li>\n<li><strong>容器（Container）</strong></li>\n<li><strong>仓库（Repository）</strong></li>\n</ul>\n<p>我刚才例子里面，那个放在包里的“镜像”，就是<strong>Docker镜像</strong>。而我的背包，就是<strong>Docker仓库</strong>。我在空地上，用魔法造好的房子，就是一个<strong>Docker容器</strong>。</p>\n<p>说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<p>也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。</p>\n<p>每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！</p>\n<p>也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。</p>\n<p>这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134517561-1517184540.png\" alt=\"img\"></p>\n<p>于是乎，就变成了一个大的公共仓库。</p>\n<p>负责对Docker镜像进行管理的，是<strong>Docker Registry服务</strong>（类似仓库管理员）。</p>\n<p>不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？</p>\n<p>所以，Docker Registry服务对镜像的管理是非常严格的。</p>\n<p>最常使用的Registry公开服务，是官方的<strong>Docker Hub</strong>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p>\n<p>好了，说完了Docker，我们再把目光转向K8S。</p>\n<p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p>\n<p>就在这个时候，K8S出现了。</p>\n<p><strong>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134529220-885595947.png\" alt=\"img\"></p>\n<p>Kubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。</p>\n<p>和Docker不同，K8S的创造者，是众人皆知的行业巨头——<strong>Google</strong>。</p>\n<p>然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的<strong>Borg系统</strong>。</p>\n<p>K8S是2014年6月由Google公司正式公布出来并宣布开源的。</p>\n<p>同年7月，微软、Red Hat、IBM、Docker、CoreOS、Mesosphere和Saltstack等公司，相继加入K8S。</p>\n<p>之后的一年内，VMware、HP、Intel等公司，也陆续加入。</p>\n<p>2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。</p>\n<p>目前，kubernetes的版本已经发展到V1.13。</p>\n<p>K8S的架构，略微有一点复杂，我们简单来看一下。</p>\n<p>一个K8S系统，通常称为一个<strong>K8S集群（Cluster）</strong>。</p>\n<p>这个集群主要包括两个部分：</p>\n<ul>\n<li><strong>一个Master节点（主节点）</strong></li>\n<li><strong>一群Node节点（计算节点）</strong></li>\n</ul>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134539670-1577644922.png\" alt=\"img\"></p>\n<p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p>\n<p>深入来看这两种节点。</p>\n<p>首先是<strong>Master节点。</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134549651-376208258.png\" alt=\"img\"></p>\n<p>Master节点包括API Server、Scheduler、Controller manager、etcd。</p>\n<p>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</p>\n<p>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</p>\n<p>Controller manager负责管理控制器，相当于“大总管”。</p>\n<p>然后是<strong>Node节点</strong>。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134600202-626807958.png\" alt=\"img\"></p>\n<p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是<strong>Pod</strong>。</p>\n<blockquote>\n<p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。</p>\n</blockquote>\n<p>Docker，不用说了，创建容器的。</p>\n<p>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p>\n<p>Kube-proxy，主要负责为Pod对象提供代理。</p>\n<p>Fluentd，主要负责日志收集、存储与查询。</p>\n<p>是不是有点懵？唉，三言两语真的很难讲清楚，继续跳过吧。</p>\n<p>Docker和K8S都介绍完了，然而文章并没有结束。</p>\n<p>接下来的部分，是<strong>写给核心网工程师甚至所有通信工程师看的</strong>。</p>\n<p>从几十年前的1G，到现在的4G，再到将来的5G，移动通信发生了翻天覆地的变化，核心网亦是如此。</p>\n<p>但是，如果你仔细洞察这些变化，会发现，所谓的核心网，其实本质上并没有发生改变，无非就是很多的服务器而已。不同的核心网网元，就是不同的服务器，不同的计算节点。</p>\n<p>变化的，是这些“服务器”的形态和接口：形态，从机柜单板，变成机柜刀片，从机柜刀片，变成X86通用刀片服务器；接口，从中继线缆，变成网线，从网线，变成光纤。</p>\n<p>就算变来变去，还是服务器，是计算节点，是CPU。</p>\n<p>既然是服务器，那么就势必会和IT云计算一样，走上虚拟化的道路。毕竟，虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度，等等。</p>\n<p>前几年，大家以为虚拟机是核心网的终极形态。目前看来，更有可能是<strong>容器化</strong>。这几年经常说的NFV（网元功能虚拟化），也有可能改口为NFC（网元功能容器化）。</p>\n<p>以VoLTE为例，如果按以前2G/3G的方式，那需要大量的专用设备，分别充当EPC和IMS的不同网元。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134611008-1358657705.png\" alt=\"img\"></p>\n<p>VoLTE相关的网元</p>\n<p>而采用容器之后，很可能只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同网元的服务程序。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134621637-1646543877.png\" alt=\"img\"></p>\n<p>这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。</p>\n<p>简直完美！</p>\n<p>5G时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成N个专能型。每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134635090-835720705.png\" alt=\"img\"></p>\n<p>精细化分工</p>\n<p>按照这样的发展趋势，在移动通信系统中，除了天线，剩下的部分都有可能虚拟化。核心网是第一个，但不是最后一个。虚拟化之后的核心网，与其说属于通信，实际上更应该归为IT。核心网的功能，只是容器中普通一个软件功能而已。</p>\n<p>至于说在座的各位核心网工程师，恭喜你们，马上就要成功转型啦！</p>\n","site":{"data":{"next":{"override":false,"reminder":false,"cache":{"enable":true},"minify":false,"custom_file_path":null,"favicon":{"small":"/images/favicon-16x16-next.png","medium":"/images/favicon-32x32-next.png","apple_touch_icon":"/images/apple-touch-icon-next.png","safari_pinned_tab":"/images/logo.svg"},"language_switcher":true,"footer":{"icon":{"name":"user","animated":false,"color":"#808080"},"copyright":null,"powered":true,"beian":{"enable":false,"icp":null,"gongan_id":null,"gongan_num":null,"gongan_icon_url":null}},"creative_commons":{"license":"by-nc-sa","sidebar":false,"post":false,"language":null},"scheme":"Gemini","darkmode":false,"menu":{"home":"/ || home","about":"/about/ || user","tags":"/tags/ || tags","categories":"/categories/ || th","archives":"/archives/ || archive","schedule":"/schedule/ || calendar","sitemap":"/sitemap.xml || sitemap","commonweal":"/404.html || heartbeat"},"menu_settings":{"icons":true,"badges":false},"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"avatar":{"url":null,"rounded":false,"rotated":false},"site_state":true,"social":{"GitHub":"https://github.com/tanxinzheng || github"},"social_icons":{"enable":true,"icons_only":false,"transition":false},"links_settings":{"icon":"link","title":"Links","layout":"block"},"links":null,"toc":{"enable":true,"number":true,"wrap":false,"expand_all":false,"max_depth":6},"chat":{"enable":false,"icon":"comment","text":"Chat"},"excerpt_description":true,"read_more_btn":true,"post_meta":{"item_text":true,"created_at":true,"updated_at":{"enable":true,"another_day":true},"categories":true},"symbols_count_time":{"separated_meta":true,"item_text_post":true,"item_text_total":false},"tag_icon":false,"reward_settings":{"enable":true,"animation":false},"reward":{"wechatpay":"/img/wechatpay.jpg","alipay":"/img/alipay.jpg"},"follow_me":null,"related_posts":{"enable":false,"title":null,"display_in_home":false,"params":{"maxCount":5}},"post_edit":{"enable":false,"url":"https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name"},"post_navigation":"left","tagcloud":{"min":12,"max":30,"start":"#ccc","end":"#111","amount":200},"calendar":{"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"showDeleted":false,"singleEvents":true,"maxResults":250},"text_align":{"desktop":"justify","mobile":"justify"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":null,"codeblock":{"highlight_theme":"normal","copy_button":{"enable":false,"show_result":false,"style":null}},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"reading_progress":{"enable":false,"position":"top","color":"#37c6c0","height":"3px"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"github_banner":{"enable":false,"permalink":"https://github.com/yourname","title":"Follow me on GitHub"},"font":{"enable":false,"host":null,"global":{"external":true,"family":"Lato","size":null},"title":{"external":true,"family":null,"size":null},"headings":{"external":true,"family":null,"size":null},"posts":{"external":true,"family":null},"codes":{"external":true,"family":null}},"disable_baidu_transformation":false,"index_with_subtitle":false,"exturl":false,"google_site_verification":null,"bing_site_verification":null,"yandex_site_verification":null,"baidu_site_verification":null,"baidu_push":false,"math":{"per_page":true,"mathjax":{"enable":false,"mhchem":false},"katex":{"enable":false,"copy_tex":false}},"pjax":false,"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"quicklink":{"enable":false,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"ignores":null},"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"disqus":{"enable":false,"shortname":null,"count":true},"disqusjs":{"enable":false,"api":null,"apikey":null,"shortname":null},"changyan":{"enable":false,"appid":null,"appkey":null},"valine":{"enable":false,"appid":null,"appkey":null,"notify":false,"verify":false,"placeholder":"Just go go","avatar":"mm","guest_info":"nick,mail,link","pageSize":10,"language":null,"visitor":false,"comment_count":true,"recordIP":false,"serverURLs":null},"livere_uid":null,"gitalk":{"enable":false,"github_id":null,"repo":null,"client_id":null,"client_secret":null,"admin_user":null,"distraction_free_mode":true,"language":null},"rating":{"enable":false,"id":null,"color":"fc6423"},"add_this_id":null,"google_analytics":{"tracking_id":null,"only_pageview":false},"baidu_analytics":null,"growingio_analytics":null,"cnzz_siteid":null,"leancloud_visitors":{"enable":false,"app_id":null,"app_key":null,"server_url":null,"security":true},"firestore":{"enable":false,"collection":"articles","apiKey":null,"projectId":null},"busuanzi_count":{"enable":false,"total_visitors":true,"total_visitors_icon":"user","total_views":true,"total_views_icon":"eye","post_views":true,"post_views_icon":"eye"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"swiftype_key":null,"chatra":{"enable":false,"async":true,"id":null},"tidio":{"enable":false,"key":null},"note":{"style":"simple","icons":false,"light_bg_offset":0},"tabs":{"transition":{"tabs":false,"labels":true}},"pdf":{"enable":false,"height":"500px"},"mermaid":{"enable":false,"theme":"forest"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"pace":{"enable":false,"theme":"minimal"},"three":{"enable":false,"three_waves":false,"canvas_lines":false,"canvas_sphere":false},"canvas_ribbon":{"enable":false,"size":300,"alpha":0.6,"zIndex":-1},"vendors":{"_internal":"lib","anime":null,"fontawesome":null,"mathjax":null,"katex":null,"copy_tex_js":null,"copy_tex_css":null,"pjax":null,"jquery":null,"fancybox":null,"fancybox_css":null,"mediumzoom":null,"lazyload":null,"pangu":null,"quicklink":null,"disqusjs_js":null,"disqusjs_css":null,"valine":null,"gitalk_js":null,"gitalk_css":null,"algolia_search":null,"instant_search":null,"mermaid":null,"velocity":null,"velocity_ui":null,"pace":null,"pace_css":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null},"css":"css","js":"js","images":"images"},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h1 id=\"10分钟看懂Docker和K8S\"><a href=\"#10分钟看懂Docker和K8S\" class=\"headerlink\" title=\"10分钟看懂Docker和K8S\"></a><a href=\"https://www.cnblogs.com/itbsl/p/10178698.html\" target=\"_blank\" rel=\"noopener\">10分钟看懂Docker和K8S</a></h1><p><strong>本文来源：鲜枣课堂</strong></p>\n<p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。</p>\n<p><img src=\"../../img/720430-20181226134250810-1685533200.png\" alt=\"img\"></p>\n<p>这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。</p>\n<p><img src=\"../../img/720430-20181226134259735-1931086473.png\" alt=\"img\"></p>\n<p>LXC，就是Linux容器虚拟技术（Linux container）</p>\n<p>后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。</p>\n<p><img src=\"../../img/720430-20181226134308841-1109691453.png\" alt=\"img\"></p>\n<p>Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p>\n<p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。</p>\n<p>什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p>\n<p><img src=\"../../img/720430-20181226134321094-1025894099.png\" alt=\"img\"></p>\n<p>Open Source，开源</p>\n<p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p>\n<p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134409452-99479785.png\" alt=\"img\"></p>\n<p>Solomon Hykes（今年刚从Docker离职）</p>\n<p>不开则已，一开惊人。</p>\n<p>越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。</p>\n<p>Docker的人气迅速攀升，速度之快，令人瞠目结舌。</p>\n<p>开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p>\n<p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。</p>\n<p>Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。</p>\n<p>Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p>\n<p>在容器技术之前，业界的网红是虚拟机。<strong>虚拟机</strong>技术的代表，是<strong>VMWare</strong>和<strong>OpenStack</strong>。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134345971-148194642.png\" alt=\"img\"></p>\n<p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134357583-1178315643.png\" alt=\"img\"></p>\n<p>虚拟机，类似于“子电脑”</p>\n<p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p>\n<p>虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化</strong>。</p>\n<p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。</p>\n<p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134422660-219996811.png\" alt=\"img\"></p>\n<p>沙箱</p>\n<p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134430830-648875754.png\" alt=\"img\"></p>\n<p>容器和虚拟机的对比</p>\n<p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p>\n<p>我们具体来看看Docker。</p>\n<p>大家需要注意，<strong>Docker本身并不是容器</strong>，它是创建容器的工具，是应用容器引擎。</p>\n<p>想要搞懂Docker，其实看它的两句口号就行。</p>\n<p>第一句，是“<strong>Build, Ship and Run</strong>”。</p>\n<p><img src=\"linux%E4%B8%8Ek8s%E7%9A%84%E5%8C%BA%E5%88%AB.assets/720430-20181226134440039-355719052.png\" alt=\"img\"></p>\n<p>也就是，“搭建、发送、运行”，三板斧。</p>\n<p>举个例子：</p>\n<p>我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134448189-1614413776.png\" alt=\"img\"></p>\n<p>结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。</p>\n<p>但是，跑来一个老巫婆，教会我一种魔法。</p>\n<p>这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134458048-1632935313.png\" alt=\"img\"></p>\n<p>等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134507695-502496013.png\" alt=\"img\"></p>\n<p>怎么样？是不是很神奇？</p>\n<p>所以，Docker的第二句口号就是：“<strong>Build once，Run anywhere（搭建一次，到处能用）</strong>”。</p>\n<p>Docker技术的三大核心概念，分别是：</p>\n<ul>\n<li><strong>镜像（Image）</strong></li>\n<li><strong>容器（Container）</strong></li>\n<li><strong>仓库（Repository）</strong></li>\n</ul>\n<p>我刚才例子里面，那个放在包里的“镜像”，就是<strong>Docker镜像</strong>。而我的背包，就是<strong>Docker仓库</strong>。我在空地上，用魔法造好的房子，就是一个<strong>Docker容器</strong>。</p>\n<p>说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<p>也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。</p>\n<p>每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！</p>\n<p>也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。</p>\n<p>这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134517561-1517184540.png\" alt=\"img\"></p>\n<p>于是乎，就变成了一个大的公共仓库。</p>\n<p>负责对Docker镜像进行管理的，是<strong>Docker Registry服务</strong>（类似仓库管理员）。</p>\n<p>不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？</p>\n<p>所以，Docker Registry服务对镜像的管理是非常严格的。</p>\n<p>最常使用的Registry公开服务，是官方的<strong>Docker Hub</strong>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p>\n<p>好了，说完了Docker，我们再把目光转向K8S。</p>\n<p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p>\n<p>就在这个时候，K8S出现了。</p>\n<p><strong>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134529220-885595947.png\" alt=\"img\"></p>\n<p>Kubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。</p>\n<p>和Docker不同，K8S的创造者，是众人皆知的行业巨头——<strong>Google</strong>。</p>\n<p>然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的<strong>Borg系统</strong>。</p>\n<p>K8S是2014年6月由Google公司正式公布出来并宣布开源的。</p>\n<p>同年7月，微软、Red Hat、IBM、Docker、CoreOS、Mesosphere和Saltstack等公司，相继加入K8S。</p>\n<p>之后的一年内，VMware、HP、Intel等公司，也陆续加入。</p>\n<p>2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。</p>\n<p>目前，kubernetes的版本已经发展到V1.13。</p>\n<p>K8S的架构，略微有一点复杂，我们简单来看一下。</p>\n<p>一个K8S系统，通常称为一个<strong>K8S集群（Cluster）</strong>。</p>\n<p>这个集群主要包括两个部分：</p>\n<ul>\n<li><strong>一个Master节点（主节点）</strong></li>\n<li><strong>一群Node节点（计算节点）</strong></li>\n</ul>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134539670-1577644922.png\" alt=\"img\"></p>\n<p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p>\n<p>深入来看这两种节点。</p>\n<p>首先是<strong>Master节点。</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134549651-376208258.png\" alt=\"img\"></p>\n<p>Master节点包括API Server、Scheduler、Controller manager、etcd。</p>\n<p>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</p>\n<p>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</p>\n<p>Controller manager负责管理控制器，相当于“大总管”。</p>\n<p>然后是<strong>Node节点</strong>。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134600202-626807958.png\" alt=\"img\"></p>\n<p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是<strong>Pod</strong>。</p>\n<blockquote>\n<p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。</p>\n</blockquote>\n<p>Docker，不用说了，创建容器的。</p>\n<p>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p>\n<p>Kube-proxy，主要负责为Pod对象提供代理。</p>\n<p>Fluentd，主要负责日志收集、存储与查询。</p>\n<p>是不是有点懵？唉，三言两语真的很难讲清楚，继续跳过吧。</p>\n<p>Docker和K8S都介绍完了，然而文章并没有结束。</p>\n<p>接下来的部分，是<strong>写给核心网工程师甚至所有通信工程师看的</strong>。</p>\n<p>从几十年前的1G，到现在的4G，再到将来的5G，移动通信发生了翻天覆地的变化，核心网亦是如此。</p>\n<p>但是，如果你仔细洞察这些变化，会发现，所谓的核心网，其实本质上并没有发生改变，无非就是很多的服务器而已。不同的核心网网元，就是不同的服务器，不同的计算节点。</p>\n<p>变化的，是这些“服务器”的形态和接口：形态，从机柜单板，变成机柜刀片，从机柜刀片，变成X86通用刀片服务器；接口，从中继线缆，变成网线，从网线，变成光纤。</p>\n<p>就算变来变去，还是服务器，是计算节点，是CPU。</p>\n<p>既然是服务器，那么就势必会和IT云计算一样，走上虚拟化的道路。毕竟，虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度，等等。</p>\n<p>前几年，大家以为虚拟机是核心网的终极形态。目前看来，更有可能是<strong>容器化</strong>。这几年经常说的NFV（网元功能虚拟化），也有可能改口为NFC（网元功能容器化）。</p>\n<p>以VoLTE为例，如果按以前2G/3G的方式，那需要大量的专用设备，分别充当EPC和IMS的不同网元。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134611008-1358657705.png\" alt=\"img\"></p>\n<p>VoLTE相关的网元</p>\n<p>而采用容器之后，很可能只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同网元的服务程序。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134621637-1646543877.png\" alt=\"img\"></p>\n<p>这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。</p>\n<p>简直完美！</p>\n<p>5G时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成N个专能型。每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134635090-835720705.png\" alt=\"img\"></p>\n<p>精细化分工</p>\n<p>按照这样的发展趋势，在移动通信系统中，除了天线，剩下的部分都有可能虚拟化。核心网是第一个，但不是最后一个。虚拟化之后的核心网，与其说属于通信，实际上更应该归为IT。核心网的功能，只是容器中普通一个软件功能而已。</p>\n<p>至于说在座的各位核心网工程师，恭喜你们，马上就要成功转型啦！</p>\n"},{"title":"kafka入门教程[一]","abbrlink":1125805293,"_content":"\n\n## 一、概念理解\n\n**Kafka**是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。\n\n### （1）产生背景\n\n当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：\n\n1. 如何收集这些巨大的信息\n2. 如何分析它\n3. 如何及时做到如上两点\n\n以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁-消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。\n\n**Kafka诞生**\nKafka由 linked-in 开源\nkafka-即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。\nkafka-高产出的分布式消息系统(A high-throughput distributed messaging system)\n\n### （2）Kafka的特性\n\n- **高吞吐量、低延迟**：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒\n- **可扩展性**：kafka集群支持热扩展\n- **持久性、可靠性**：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失\n- **容错性**：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）\n- **高并发**：支持数千个客户端同时读写\n\n### （3）Kafka场景应用\n\n- **日志收集**：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。\n- **消息系统**：解耦和生产者和消费者、缓存消息等。\n- **用户活动跟踪**：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。\n- **运营指标**：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。\n- **流式处理**：比如spark streaming和storm\n- **事件源**\n\n### （4）Kafka一些重要设计思想\n\n- **Consumergroup**：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。\n- **消息状态**：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。\n- **消息持久化**：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。\n- **消息有效期**：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。\n- **批量发送**：Kafka支持以消息集合为单位进行批量发送，以提高push效率。\n- **push-and-pull** :Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。\n- **Kafka集群中broker之间的关系**：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。\n- **负载均衡方面**： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。\n- **同步异步**：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。\n- **分区机制partition**：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。\n- **离线数据装载**：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。\n- **插件支持**：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。\n\n## 二、消息队列通信的模式\n\n### （1）点对点模式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624144932564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。\n\n### （2）发布订阅模式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020062414495136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！\n\n## 三、Kafka的架构原理\n\n上面简单的介绍了为什么需要消息队列以及消息队列通信的两种模式，下面主角介绍Kafka。Kafka是一种**高吞吐量的分布式发布订阅消息系统**，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。。\n\n### （1）基础架构与名词解释\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624145628396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n\n- Producer：Producer即生产者，消息的产生者，是消息的入口。\n- Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……\n- Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。\n- Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！\n- Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。\n- Message：每一条发送的消息主体。\n- Consumer：消费者，即消息的消费方，是消息的出口。\n- Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！\n- Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。\n\n### （2）工作流程分析\n\n#### （1）发送数据\n\n我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，**Producer在写入数据的时候永远的找leader**，不会直接将数据写入**follower**！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624150617430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624150636117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：\n\n1. **方便扩展**：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。\n2. **提高并发**：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。\n\n熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：\n\n1. partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。\n2. 如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。\n3. 如果既没指定partition，又没有设置key，则会轮询选出一个partition。\n\n保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为**0、1、all**。\n\n- 0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。\n- 1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。\n- all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。\n\n最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。\n\n#### （2）保存数据\n\nProducer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。\n\n##### （1）Partition 结构\n\n前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624170905606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。\n\n##### （2）Message结构\n\n上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：\n\n- **offset**：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！\n- **消息大小**：消息大小占用4byte，用于描述消息的大小。\n- **消息体**：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。\n\n##### （3）存储策略\n\n无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？\n\n- 基于时间，默认配置是168小时（7天）。\n- 基于大小，默认配置是1073741824。\n\n需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！\n\n#### （3）消费数据\n\n消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka采用的是点对点的模式，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找**leader**去拉取。\n\n多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！我们看下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624171149382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，**建议消费者组的consumer的数量与partition的数量一致**！\n\n在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624171235860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n\n1. 先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。\n2. 打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的相对offset为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。\n3. 根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。\n\n这套机制是建立在offset为有序的基础上，利用segment+有序offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！","source":"_posts/中间件/kafka入门教程.md","raw":"---\ntitle: kafka入门教程[一]\nabbrlink: 1125805293\ntags:\n\t- kafka\n\t- mq\n---\n\n\n## 一、概念理解\n\n**Kafka**是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。\n\n### （1）产生背景\n\n当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：\n\n1. 如何收集这些巨大的信息\n2. 如何分析它\n3. 如何及时做到如上两点\n\n以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁-消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。\n\n**Kafka诞生**\nKafka由 linked-in 开源\nkafka-即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。\nkafka-高产出的分布式消息系统(A high-throughput distributed messaging system)\n\n### （2）Kafka的特性\n\n- **高吞吐量、低延迟**：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒\n- **可扩展性**：kafka集群支持热扩展\n- **持久性、可靠性**：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失\n- **容错性**：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）\n- **高并发**：支持数千个客户端同时读写\n\n### （3）Kafka场景应用\n\n- **日志收集**：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。\n- **消息系统**：解耦和生产者和消费者、缓存消息等。\n- **用户活动跟踪**：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。\n- **运营指标**：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。\n- **流式处理**：比如spark streaming和storm\n- **事件源**\n\n### （4）Kafka一些重要设计思想\n\n- **Consumergroup**：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。\n- **消息状态**：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。\n- **消息持久化**：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。\n- **消息有效期**：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。\n- **批量发送**：Kafka支持以消息集合为单位进行批量发送，以提高push效率。\n- **push-and-pull** :Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。\n- **Kafka集群中broker之间的关系**：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。\n- **负载均衡方面**： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。\n- **同步异步**：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。\n- **分区机制partition**：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。\n- **离线数据装载**：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。\n- **插件支持**：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。\n\n## 二、消息队列通信的模式\n\n### （1）点对点模式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624144932564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。\n\n### （2）发布订阅模式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020062414495136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！\n\n## 三、Kafka的架构原理\n\n上面简单的介绍了为什么需要消息队列以及消息队列通信的两种模式，下面主角介绍Kafka。Kafka是一种**高吞吐量的分布式发布订阅消息系统**，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。。\n\n### （1）基础架构与名词解释\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624145628396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n\n- Producer：Producer即生产者，消息的产生者，是消息的入口。\n- Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……\n- Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。\n- Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！\n- Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。\n- Message：每一条发送的消息主体。\n- Consumer：消费者，即消息的消费方，是消息的出口。\n- Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！\n- Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。\n\n### （2）工作流程分析\n\n#### （1）发送数据\n\n我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，**Producer在写入数据的时候永远的找leader**，不会直接将数据写入**follower**！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624150617430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624150636117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：\n\n1. **方便扩展**：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。\n2. **提高并发**：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。\n\n熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：\n\n1. partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。\n2. 如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。\n3. 如果既没指定partition，又没有设置key，则会轮询选出一个partition。\n\n保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为**0、1、all**。\n\n- 0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。\n- 1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。\n- all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。\n\n最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。\n\n#### （2）保存数据\n\nProducer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。\n\n##### （1）Partition 结构\n\n前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624170905606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。\n\n##### （2）Message结构\n\n上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：\n\n- **offset**：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！\n- **消息大小**：消息大小占用4byte，用于描述消息的大小。\n- **消息体**：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。\n\n##### （3）存储策略\n\n无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？\n\n- 基于时间，默认配置是168小时（7天）。\n- 基于大小，默认配置是1073741824。\n\n需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！\n\n#### （3）消费数据\n\n消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka采用的是点对点的模式，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找**leader**去拉取。\n\n多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！我们看下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624171149382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，**建议消费者组的consumer的数量与partition的数量一致**！\n\n在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624171235860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n\n1. 先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。\n2. 打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的相对offset为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。\n3. 根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。\n\n这套机制是建立在offset为有序的基础上，利用segment+有序offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！","slug":"中间件/kafka入门教程","published":1,"date":"2020-12-15T01:19:34.263Z","updated":"2020-12-15T02:03:06.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz8r001smxcdcy30603i","content":"<h2 id=\"一、概念理解\"><a href=\"#一、概念理解\" class=\"headerlink\" title=\"一、概念理解\"></a>一、概念理解</h2><p><strong>Kafka</strong>是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p>\n<h3 id=\"（1）产生背景\"><a href=\"#（1）产生背景\" class=\"headerlink\" title=\"（1）产生背景\"></a>（1）产生背景</h3><p>当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：</p>\n<ol>\n<li>如何收集这些巨大的信息</li>\n<li>如何分析它</li>\n<li>如何及时做到如上两点</li>\n</ol>\n<p>以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁-消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。</p>\n<p><strong>Kafka诞生</strong><br>Kafka由 linked-in 开源<br>kafka-即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。<br>kafka-高产出的分布式消息系统(A high-throughput distributed messaging system)</p>\n<h3 id=\"（2）Kafka的特性\"><a href=\"#（2）Kafka的特性\" class=\"headerlink\" title=\"（2）Kafka的特性\"></a>（2）Kafka的特性</h3><ul>\n<li><strong>高吞吐量、低延迟</strong>：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li>\n<li><strong>可扩展性</strong>：kafka集群支持热扩展</li>\n<li><strong>持久性、可靠性</strong>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>\n<li><strong>容错性</strong>：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>\n<li><strong>高并发</strong>：支持数千个客户端同时读写</li>\n</ul>\n<h3 id=\"（3）Kafka场景应用\"><a href=\"#（3）Kafka场景应用\" class=\"headerlink\" title=\"（3）Kafka场景应用\"></a>（3）Kafka场景应用</h3><ul>\n<li><strong>日志收集</strong>：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>\n<li><strong>消息系统</strong>：解耦和生产者和消费者、缓存消息等。</li>\n<li><strong>用户活动跟踪</strong>：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li>\n<li><strong>运营指标</strong>：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>\n<li><strong>流式处理</strong>：比如spark streaming和storm</li>\n<li><strong>事件源</strong></li>\n</ul>\n<h3 id=\"（4）Kafka一些重要设计思想\"><a href=\"#（4）Kafka一些重要设计思想\" class=\"headerlink\" title=\"（4）Kafka一些重要设计思想\"></a>（4）Kafka一些重要设计思想</h3><ul>\n<li><strong>Consumergroup</strong>：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。</li>\n<li><strong>消息状态</strong>：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。</li>\n<li><strong>消息持久化</strong>：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。</li>\n<li><strong>消息有效期</strong>：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。</li>\n<li><strong>批量发送</strong>：Kafka支持以消息集合为单位进行批量发送，以提高push效率。</li>\n<li><strong>push-and-pull</strong> :Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。</li>\n<li><strong>Kafka集群中broker之间的关系</strong>：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。</li>\n<li><strong>负载均衡方面</strong>： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。</li>\n<li><strong>同步异步</strong>：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</li>\n<li><strong>分区机制partition</strong>：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。</li>\n<li><strong>离线数据装载</strong>：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。</li>\n<li><strong>插件支持</strong>：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。</li>\n</ul>\n<h2 id=\"二、消息队列通信的模式\"><a href=\"#二、消息队列通信的模式\" class=\"headerlink\" title=\"二、消息队列通信的模式\"></a>二、消息队列通信的模式</h2><h3 id=\"（1）点对点模式\"><a href=\"#（1）点对点模式\" class=\"headerlink\" title=\"（1）点对点模式\"></a>（1）点对点模式</h3><p><img src=\"https://img-blog.csdnimg.cn/20200624144932564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p>\n<h3 id=\"（2）发布订阅模式\"><a href=\"#（2）发布订阅模式\" class=\"headerlink\" title=\"（2）发布订阅模式\"></a>（2）发布订阅模式</h3><p><img src=\"https://img-blog.csdnimg.cn/2020062414495136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！</p>\n<h2 id=\"三、Kafka的架构原理\"><a href=\"#三、Kafka的架构原理\" class=\"headerlink\" title=\"三、Kafka的架构原理\"></a>三、Kafka的架构原理</h2><p>上面简单的介绍了为什么需要消息队列以及消息队列通信的两种模式，下面主角介绍Kafka。Kafka是一种<strong>高吞吐量的分布式发布订阅消息系统</strong>，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。。</p>\n<h3 id=\"（1）基础架构与名词解释\"><a href=\"#（1）基础架构与名词解释\" class=\"headerlink\" title=\"（1）基础架构与名词解释\"></a>（1）基础架构与名词解释</h3><p><img src=\"https://img-blog.csdnimg.cn/20200624145628396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>Producer：Producer即生产者，消息的产生者，是消息的入口。</li>\n<li>Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……</li>\n<li>Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。</li>\n<li>Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！</li>\n<li>Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</li>\n<li>Message：每一条发送的消息主体。</li>\n<li>Consumer：消费者，即消息的消费方，是消息的出口。</li>\n<li>Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！</li>\n<li>Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。</li>\n</ul>\n<h3 id=\"（2）工作流程分析\"><a href=\"#（2）工作流程分析\" class=\"headerlink\" title=\"（2）工作流程分析\"></a>（2）工作流程分析</h3><h4 id=\"（1）发送数据\"><a href=\"#（1）发送数据\" class=\"headerlink\" title=\"（1）发送数据\"></a>（1）发送数据</h4><p>我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，<strong>Producer在写入数据的时候永远的找leader</strong>，不会直接将数据写入<strong>follower</strong>！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：<br><img src=\"https://img-blog.csdnimg.cn/20200624150617430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：<br><img src=\"https://img-blog.csdnimg.cn/20200624150636117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：</p>\n<ol>\n<li><strong>方便扩展</strong>：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。</li>\n<li><strong>提高并发</strong>：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li>\n</ol>\n<p>熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：</p>\n<ol>\n<li>partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。</li>\n<li>如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。</li>\n<li>如果既没指定partition，又没有设置key，则会轮询选出一个partition。</li>\n</ol>\n<p>保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为<strong>0、1、all</strong>。</p>\n<ul>\n<li>0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。</li>\n<li>1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。</li>\n<li>all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</li>\n</ul>\n<p>最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。</p>\n<h4 id=\"（2）保存数据\"><a href=\"#（2）保存数据\" class=\"headerlink\" title=\"（2）保存数据\"></a>（2）保存数据</h4><p>Producer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。</p>\n<h5 id=\"（1）Partition-结构\"><a href=\"#（1）Partition-结构\" class=\"headerlink\" title=\"（1）Partition 结构\"></a>（1）Partition 结构</h5><p>前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。<br><img src=\"https://img-blog.csdnimg.cn/20200624170905606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。</p>\n<h5 id=\"（2）Message结构\"><a href=\"#（2）Message结构\" class=\"headerlink\" title=\"（2）Message结构\"></a>（2）Message结构</h5><p>上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：</p>\n<ul>\n<li><strong>offset</strong>：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！</li>\n<li><strong>消息大小</strong>：消息大小占用4byte，用于描述消息的大小。</li>\n<li><strong>消息体</strong>：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。</li>\n</ul>\n<h5 id=\"（3）存储策略\"><a href=\"#（3）存储策略\" class=\"headerlink\" title=\"（3）存储策略\"></a>（3）存储策略</h5><p>无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？</p>\n<ul>\n<li>基于时间，默认配置是168小时（7天）。</li>\n<li>基于大小，默认配置是1073741824。</li>\n</ul>\n<p>需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！</p>\n<h4 id=\"（3）消费数据\"><a href=\"#（3）消费数据\" class=\"headerlink\" title=\"（3）消费数据\"></a>（3）消费数据</h4><p>消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka采用的是点对点的模式，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找<strong>leader</strong>去拉取。</p>\n<p>多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！我们看下图：<br><img src=\"https://img-blog.csdnimg.cn/20200624171149382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，<strong>建议消费者组的consumer的数量与partition的数量一致</strong>！</p>\n<p>在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：<br><img src=\"https://img-blog.csdnimg.cn/20200624171235860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li>先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。</li>\n<li>打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的相对offset为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。</li>\n<li>根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。</li>\n</ol>\n<p>这套机制是建立在offset为有序的基础上，利用segment+有序offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！</p>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h2 id=\"一、概念理解\"><a href=\"#一、概念理解\" class=\"headerlink\" title=\"一、概念理解\"></a>一、概念理解</h2><p><strong>Kafka</strong>是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p>\n<h3 id=\"（1）产生背景\"><a href=\"#（1）产生背景\" class=\"headerlink\" title=\"（1）产生背景\"></a>（1）产生背景</h3><p>当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：</p>\n<ol>\n<li>如何收集这些巨大的信息</li>\n<li>如何分析它</li>\n<li>如何及时做到如上两点</li>\n</ol>\n<p>以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁-消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。</p>\n<p><strong>Kafka诞生</strong><br>Kafka由 linked-in 开源<br>kafka-即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。<br>kafka-高产出的分布式消息系统(A high-throughput distributed messaging system)</p>\n<h3 id=\"（2）Kafka的特性\"><a href=\"#（2）Kafka的特性\" class=\"headerlink\" title=\"（2）Kafka的特性\"></a>（2）Kafka的特性</h3><ul>\n<li><strong>高吞吐量、低延迟</strong>：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li>\n<li><strong>可扩展性</strong>：kafka集群支持热扩展</li>\n<li><strong>持久性、可靠性</strong>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>\n<li><strong>容错性</strong>：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>\n<li><strong>高并发</strong>：支持数千个客户端同时读写</li>\n</ul>\n<h3 id=\"（3）Kafka场景应用\"><a href=\"#（3）Kafka场景应用\" class=\"headerlink\" title=\"（3）Kafka场景应用\"></a>（3）Kafka场景应用</h3><ul>\n<li><strong>日志收集</strong>：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>\n<li><strong>消息系统</strong>：解耦和生产者和消费者、缓存消息等。</li>\n<li><strong>用户活动跟踪</strong>：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li>\n<li><strong>运营指标</strong>：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>\n<li><strong>流式处理</strong>：比如spark streaming和storm</li>\n<li><strong>事件源</strong></li>\n</ul>\n<h3 id=\"（4）Kafka一些重要设计思想\"><a href=\"#（4）Kafka一些重要设计思想\" class=\"headerlink\" title=\"（4）Kafka一些重要设计思想\"></a>（4）Kafka一些重要设计思想</h3><ul>\n<li><strong>Consumergroup</strong>：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。</li>\n<li><strong>消息状态</strong>：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。</li>\n<li><strong>消息持久化</strong>：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。</li>\n<li><strong>消息有效期</strong>：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。</li>\n<li><strong>批量发送</strong>：Kafka支持以消息集合为单位进行批量发送，以提高push效率。</li>\n<li><strong>push-and-pull</strong> :Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。</li>\n<li><strong>Kafka集群中broker之间的关系</strong>：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。</li>\n<li><strong>负载均衡方面</strong>： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。</li>\n<li><strong>同步异步</strong>：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</li>\n<li><strong>分区机制partition</strong>：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。</li>\n<li><strong>离线数据装载</strong>：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。</li>\n<li><strong>插件支持</strong>：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。</li>\n</ul>\n<h2 id=\"二、消息队列通信的模式\"><a href=\"#二、消息队列通信的模式\" class=\"headerlink\" title=\"二、消息队列通信的模式\"></a>二、消息队列通信的模式</h2><h3 id=\"（1）点对点模式\"><a href=\"#（1）点对点模式\" class=\"headerlink\" title=\"（1）点对点模式\"></a>（1）点对点模式</h3><p><img src=\"https://img-blog.csdnimg.cn/20200624144932564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p>\n<h3 id=\"（2）发布订阅模式\"><a href=\"#（2）发布订阅模式\" class=\"headerlink\" title=\"（2）发布订阅模式\"></a>（2）发布订阅模式</h3><p><img src=\"https://img-blog.csdnimg.cn/2020062414495136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！</p>\n<h2 id=\"三、Kafka的架构原理\"><a href=\"#三、Kafka的架构原理\" class=\"headerlink\" title=\"三、Kafka的架构原理\"></a>三、Kafka的架构原理</h2><p>上面简单的介绍了为什么需要消息队列以及消息队列通信的两种模式，下面主角介绍Kafka。Kafka是一种<strong>高吞吐量的分布式发布订阅消息系统</strong>，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。。</p>\n<h3 id=\"（1）基础架构与名词解释\"><a href=\"#（1）基础架构与名词解释\" class=\"headerlink\" title=\"（1）基础架构与名词解释\"></a>（1）基础架构与名词解释</h3><p><img src=\"https://img-blog.csdnimg.cn/20200624145628396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>Producer：Producer即生产者，消息的产生者，是消息的入口。</li>\n<li>Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……</li>\n<li>Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。</li>\n<li>Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！</li>\n<li>Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</li>\n<li>Message：每一条发送的消息主体。</li>\n<li>Consumer：消费者，即消息的消费方，是消息的出口。</li>\n<li>Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！</li>\n<li>Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。</li>\n</ul>\n<h3 id=\"（2）工作流程分析\"><a href=\"#（2）工作流程分析\" class=\"headerlink\" title=\"（2）工作流程分析\"></a>（2）工作流程分析</h3><h4 id=\"（1）发送数据\"><a href=\"#（1）发送数据\" class=\"headerlink\" title=\"（1）发送数据\"></a>（1）发送数据</h4><p>我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，<strong>Producer在写入数据的时候永远的找leader</strong>，不会直接将数据写入<strong>follower</strong>！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：<br><img src=\"https://img-blog.csdnimg.cn/20200624150617430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：<br><img src=\"https://img-blog.csdnimg.cn/20200624150636117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：</p>\n<ol>\n<li><strong>方便扩展</strong>：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。</li>\n<li><strong>提高并发</strong>：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li>\n</ol>\n<p>熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：</p>\n<ol>\n<li>partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。</li>\n<li>如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。</li>\n<li>如果既没指定partition，又没有设置key，则会轮询选出一个partition。</li>\n</ol>\n<p>保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为<strong>0、1、all</strong>。</p>\n<ul>\n<li>0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。</li>\n<li>1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。</li>\n<li>all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</li>\n</ul>\n<p>最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。</p>\n<h4 id=\"（2）保存数据\"><a href=\"#（2）保存数据\" class=\"headerlink\" title=\"（2）保存数据\"></a>（2）保存数据</h4><p>Producer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。</p>\n<h5 id=\"（1）Partition-结构\"><a href=\"#（1）Partition-结构\" class=\"headerlink\" title=\"（1）Partition 结构\"></a>（1）Partition 结构</h5><p>前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。<br><img src=\"https://img-blog.csdnimg.cn/20200624170905606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。</p>\n<h5 id=\"（2）Message结构\"><a href=\"#（2）Message结构\" class=\"headerlink\" title=\"（2）Message结构\"></a>（2）Message结构</h5><p>上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：</p>\n<ul>\n<li><strong>offset</strong>：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！</li>\n<li><strong>消息大小</strong>：消息大小占用4byte，用于描述消息的大小。</li>\n<li><strong>消息体</strong>：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。</li>\n</ul>\n<h5 id=\"（3）存储策略\"><a href=\"#（3）存储策略\" class=\"headerlink\" title=\"（3）存储策略\"></a>（3）存储策略</h5><p>无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？</p>\n<ul>\n<li>基于时间，默认配置是168小时（7天）。</li>\n<li>基于大小，默认配置是1073741824。</li>\n</ul>\n<p>需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！</p>\n<h4 id=\"（3）消费数据\"><a href=\"#（3）消费数据\" class=\"headerlink\" title=\"（3）消费数据\"></a>（3）消费数据</h4><p>消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka采用的是点对点的模式，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找<strong>leader</strong>去拉取。</p>\n<p>多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！我们看下图：<br><img src=\"https://img-blog.csdnimg.cn/20200624171149382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，<strong>建议消费者组的consumer的数量与partition的数量一致</strong>！</p>\n<p>在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：<br><img src=\"https://img-blog.csdnimg.cn/20200624171235860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li>先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。</li>\n<li>打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的相对offset为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。</li>\n<li>根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。</li>\n</ol>\n<p>这套机制是建立在offset为有序的基础上，利用segment+有序offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！</p>\n"},{"title":"Linux命令killall","abbrlink":1026478353,"_content":"\n# Linux命令killall\n\n[![Linux 命令大全](https://www.runoob.com/images/up.gif) Linux 命令大全](https://www.runoob.com/linux/linux-command-manual.html)\n\nLinux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。\n\nkill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。\n\n### 语法\n\n```shell\n  killall [选项]  name\n```\n\n**参数说明**：\n\n- name ： 进程名\n\n\n\n选项包含如下几个参数：\n\n\n\n- -e | --exact ： 进程需要和名字完全相符\n- -I | --ignore-case ：忽略大小写\n- -g | --process-group ：结束进程组\n- -i | --interactive ：结束之前询问\n- -l | --list ：列出所有的信号名称\n- -q | --quite ：进程没有结束时，不输出任何信息\n- -r | --regexp ：将进程名模式解释为扩展的正则表达式。\n- -s | --signal ：发送指定信号\n- -u | --user ：结束指定用户的进程\n- -v | --verbose ：显示详细执行过程\n- -w | --wait ：等待所有的进程都结束\n- -V |--version ：显示版本信息\n- --help ：显示帮助信息\n\n### 实例\n\n```shell\n# killall -9 php-fpm          //结束所有的 php-fpm 进程\n```","source":"_posts/linux/linux命令/Linux命令killall.md","raw":"---\ntitle: Linux命令killall\nabbrlink: 1026478353\n---\n\n# Linux命令killall\n\n[![Linux 命令大全](https://www.runoob.com/images/up.gif) Linux 命令大全](https://www.runoob.com/linux/linux-command-manual.html)\n\nLinux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。\n\nkill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。\n\n### 语法\n\n```shell\n  killall [选项]  name\n```\n\n**参数说明**：\n\n- name ： 进程名\n\n\n\n选项包含如下几个参数：\n\n\n\n- -e | --exact ： 进程需要和名字完全相符\n- -I | --ignore-case ：忽略大小写\n- -g | --process-group ：结束进程组\n- -i | --interactive ：结束之前询问\n- -l | --list ：列出所有的信号名称\n- -q | --quite ：进程没有结束时，不输出任何信息\n- -r | --regexp ：将进程名模式解释为扩展的正则表达式。\n- -s | --signal ：发送指定信号\n- -u | --user ：结束指定用户的进程\n- -v | --verbose ：显示详细执行过程\n- -w | --wait ：等待所有的进程都结束\n- -V |--version ：显示版本信息\n- --help ：显示帮助信息\n\n### 实例\n\n```shell\n# killall -9 php-fpm          //结束所有的 php-fpm 进程\n```","slug":"linux/linux命令/Linux命令killall","published":1,"date":"2020-12-15T01:15:24.225Z","updated":"2020-12-15T01:16:29.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz8s001tmxcd7emi8w4y","content":"<h1 id=\"Linux命令killall\"><a href=\"#Linux命令killall\" class=\"headerlink\" title=\"Linux命令killall\"></a>Linux命令killall</h1><p><a href=\"https://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener\"><img src=\"https://www.runoob.com/images/up.gif\" alt=\"Linux 命令大全\"> Linux 命令大全</a></p>\n<p>Linux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。</p>\n<p>kill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">killall [选项]  name</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数说明</strong>：</p>\n<ul>\n<li>name ： 进程名</li>\n</ul>\n<p>选项包含如下几个参数：</p>\n<ul>\n<li>-e | –exact ： 进程需要和名字完全相符</li>\n<li>-I | –ignore-case ：忽略大小写</li>\n<li>-g | –process-group ：结束进程组</li>\n<li>-i | –interactive ：结束之前询问</li>\n<li>-l | –list ：列出所有的信号名称</li>\n<li>-q | –quite ：进程没有结束时，不输出任何信息</li>\n<li>-r | –regexp ：将进程名模式解释为扩展的正则表达式。</li>\n<li>-s | –signal ：发送指定信号</li>\n<li>-u | –user ：结束指定用户的进程</li>\n<li>-v | –verbose ：显示详细执行过程</li>\n<li>-w | –wait ：等待所有的进程都结束</li>\n<li>-V |–version ：显示版本信息</li>\n<li>–help ：显示帮助信息</li>\n</ul>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> killall -9 php-fpm          //结束所有的 php-fpm 进程</span></span><br></pre></td></tr></table></figure>","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h1 id=\"Linux命令killall\"><a href=\"#Linux命令killall\" class=\"headerlink\" title=\"Linux命令killall\"></a>Linux命令killall</h1><p><a href=\"https://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener\"><img src=\"https://www.runoob.com/images/up.gif\" alt=\"Linux 命令大全\"> Linux 命令大全</a></p>\n<p>Linux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。</p>\n<p>kill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">killall [选项]  name</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数说明</strong>：</p>\n<ul>\n<li>name ： 进程名</li>\n</ul>\n<p>选项包含如下几个参数：</p>\n<ul>\n<li>-e | –exact ： 进程需要和名字完全相符</li>\n<li>-I | –ignore-case ：忽略大小写</li>\n<li>-g | –process-group ：结束进程组</li>\n<li>-i | –interactive ：结束之前询问</li>\n<li>-l | –list ：列出所有的信号名称</li>\n<li>-q | –quite ：进程没有结束时，不输出任何信息</li>\n<li>-r | –regexp ：将进程名模式解释为扩展的正则表达式。</li>\n<li>-s | –signal ：发送指定信号</li>\n<li>-u | –user ：结束指定用户的进程</li>\n<li>-v | –verbose ：显示详细执行过程</li>\n<li>-w | –wait ：等待所有的进程都结束</li>\n<li>-V |–version ：显示版本信息</li>\n<li>–help ：显示帮助信息</li>\n</ul>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> killall -9 php-fpm          //结束所有的 php-fpm 进程</span></span><br></pre></td></tr></table></figure>"},{"title":"Linux命令systemd","abbrlink":1026478354,"_content":"\n[TOC]\n\n## **Systemd 概述**\n\n### **Systemd 简介**\n\nSystemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。\n\nSystemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。\n\n1. 更少的进程\n\nSystemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。\n\n1. 允许更多的进程并行启动\n\n在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。\n\n1. 使用 CGroup 跟踪和管理进程的生命周期\n\n在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。\n\n而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。\n\n1. 统一管理服务日志\n\nSystemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。\n\n### **Systemd 架构**\n\n![img](https://ask.qcloudimg.com/http-save/yehe-5449090/97kx52pwuj.png?imageView2/2/w/1620)\n\n## **Systemd 的 Unit 文件**\n\nSystemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）。\n\n在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。\n\n1. Systemd 支持的 12 种 Unit 文件类型\n\n- .automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务\n- .device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系\n- .mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件\n- .path：用于监控指定目录或文件的变化，并触发其它 Unit 运行\n- .scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息\n- .service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件\n- .slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件\n- .snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照\n- .socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动\n- .swap：定义一个用户做虚拟内存的交换分区\n- .target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式\n- .timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能\n\n1. Systemd 目录\n\nUnit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。\n\n- /etc/systemd/system：系统或用户自定义的配置文件\n- /run/systemd/system：软件运行时生成的配置文件\n- /usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。\n  - CentOS 7：Unit 文件指向该目录\n  - ubuntu 16：被移到了 /lib/systemd/system\n\nSystemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。\n\n1. Unit 和 Target\n\nUnit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。\n\nTarget 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。\n\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。\n\n## **Systemd Service Unit**\n\n### **Unit 文件结构**\n\n```javascript\n[Unit]\nDescription=Hello World\nAfter=docker.service\nRequires=docker.service\n[Service]\nTimeoutStartSec=0\nExecStartPre=-/usr/bin/docker kill busybox1\nExecStartPre=-/usr/bin/docker rm busybox1\nExecStartPre=/usr/bin/docker pull busybox\nExecStart=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c \"while true; do echo Hello World; sleep 1; done\"\nExecStop=\"/usr/bin/docker stop busybox1\"\nExecStopPost=\"/usr/bin/docker rm busybox1\"\n[Install]\nWantedBy=multi-user.target\n```\n\n如下所示，Systemd 服务的 Unit 文件可以分为三个配置区段：\n\n- Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式\n- Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法\n\n#### **Unit 段**\n\n- Description：描述这个 Unit 文件的信息\n- Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径\n- Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止\n- Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功\n- After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务\n- Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行\n- Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启\n- Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动\n- OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块\n- Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然\n\n#### **Install 段**\n\n这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束：\n\n- WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 <Target 名> + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“\n\n```javascript\n# find /etc/systemd/system/* -type d\n/etc/systemd/system/default.target.wants\n/etc/systemd/system/getty.target.wants\n/etc/systemd/system/graphical.target.wants\n/etc/systemd/system/multi-user.target.wants\n/etc/systemd/system/network-online.target.wants\n/etc/systemd/system/paths.target.wants\n/etc/systemd/system/shutdown.target.wants\n/etc/systemd/system/sockets.target.wants\n/etc/systemd/system/sysinit.target.wants\n/etc/systemd/system/timers.target.wants\n```\n\n- RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 <Target 名> + .required 后缀构成的子目录中\n- Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit\n- Alias：当前 Unit 可用于启动的别名\n\n1. SysV-init 运行级别与 Systemd Target 对应的 Unit 文件\n\n![img](https://ask.qcloudimg.com/http-save/yehe-5449090/mvna7qlr41.png?imageView2/2/w/1620)\n\n通过 systemctl list-units --type=target 命令可以获取当前正在使用的运行目标\n\n```javascript\n# systemctl list-units --type=target\nUNIT                   LOAD   ACTIVE SUB    DESCRIPTION\nbasic.target           loaded active active Basic System\ncryptsetup.target      loaded active active Encrypted Volumes\ngetty.target           loaded active active Login Prompts\ngraphical.target       loaded active active Graphical Interface\nlocal-fs-pre.target    loaded active active Local File Systems (Pre)\nlocal-fs.target        loaded active active Local File Systems\nmulti-user.target      loaded active active Multi-User System\nnetwork-online.target  loaded active active Network is Online\nnetwork.target         loaded active active Network\nnss-user-lookup.target loaded active active User and Group Name Lookups\npaths.target           loaded active active Paths\nremote-fs-pre.target   loaded active active Remote File Systems (Pre)\nremote-fs.target       loaded active active Remote File Systems\nslices.target          loaded active active Slices\nsockets.target         loaded active active Sockets\nsound.target           loaded active active Sound Card\nswap.target            loaded active active Swap\nsysinit.target         loaded active active System Initialization\ntime-sync.target       loaded active active System Time Synchronized\ntimers.target          loaded active active Timers\nLOAD   = Reflects whether the unit definition was properly loaded.\nACTIVE = The high-level unit activation state, i.e. generalization of SUB.\nSUB    = The low-level unit activation state, values depend on unit type.\n20 loaded units listed. Pass --all to see loaded but inactive units, too.\nTo show all installed unit files use 'systemctl list-unit-files'.\n```\n\n#### **Service 段**\n\n用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段分为服务生命周期和服务上下文配置两个方面。\n\n1. 服务生命周期控制相关\n\n- Type：定义启动时的进程行为，它有以下几种值：\n  - Type=simple：默认值，执行ExecStart指定的命令，启动主进程\n  - Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出\n  - Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行\n  - Type=dbus：当前服务通过D-Bus启动\n  - Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行\n  - Type=idle：若有其他任务执行完毕，当前服务才会运行\n- RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。\n- ExecStart：启动当前服务的命令\n- ExecStartPre：启动当前服务之前执行的命令\n- ExecStartPos：启动当前服务之后执行的命令\n- ExecReload：重启当前服务时执行的命令\n- ExecStop：停止当前服务时执行的命令\n- ExecStopPost：停止当其服务之后执行的命令\n- RestartSec：自动重启当前服务间隔的秒数\n- Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog\n- TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测\n- TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程\n\n1. 服务上下文配置相关\n\n- Environment：为服务指定环境变量\n- EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义\n- Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级\n- WorkingDirectory：指定服务的工作目录\n- RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件\n- User：指定运行服务的用户\n- Group：指定运行服务的用户组\n- MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private\n  - shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上\n  - slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上\n  - private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上\n- LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等\n\n> 注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。\n\n### **Unit 文件占位符和模板**\n\n#### **Unit 文件占位符**\n\n在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行被动态地替换实际的值。\n\n- %n：完整的 Unit 文件名字，包括 .service 后缀名\n- %p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号\n- %i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名\n- %t：存放系统运行文件的目录，通常是 “run”\n- %u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root\n- %U：运行服务的用户 ID\n- %h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值\n- %s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值\n- %m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用\n- %b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变\n- %H：实际运行节点的主机名\n- %v：内核版本，即 “uname -r” 命令输出的内容\n- %%：在 Unit 模板文件中表示一个普通的百分号\n\n#### **Unit 模板**\n\n在现实中，往往有一些应用需要被复制多份运行。例如，用于同一个[负载均衡](https://cloud.tencent.com/product/clb?from=10680)器分流的多个服务实例，或者为每个 SSH 连接建立一个独立的 sshd 服务进程。\n\nUnit 模板文件的写法与普通的服务 Unit 文件基本相同，不过 Unit 模板的文件名是以 @ 符号结尾的。通过模板启动服务实例时，需要在其文件名的 @ 字符后面附加一个参数字符串。\n\n1. 示例：apache@.service\n\n- apache@.service 模板\n\n```javascript\n[Unit]\nDescription=My Advanced Service Template\nAfter=etcd.service docker.service\n[Service]\nTimeoutStartSec=0\nExecStartPre=-/usr/bin/docker kill apache%i\nExecStartPre=-/usr/bin/docker rm apache%i\nExecStartPre=/usr/bin/docker pull coreos/apache\nExecStart=/usr/bin/docker run --name apache%i -p %i:80 coreos/apache /usr/sbin/apache2ctl -D FOREGROUND\nExecStartPost=/usr/bin/etcdctl set /domains/example.com/%H:%i running\nExecStop=/usr/bin/docker stop apache1\nExecStopPost=/usr/bin/docker rm apache1\nExecStopPost=/usr/bin/etcdctl rm /domains/example.com/%H:%i\n[Install]\nWantedBy=multi-user.target\n```\n\n- 启动 Unit 模板的服务实例\n\n在服务启动时需要在 @ 后面放置一个用于区分服务实例的附加字符参数，通常这个参数用于监控的端口号或控制台 TTY 编译号。\n\n```javascript\n# systemctl start apache@8080.service\n```\n\nSystemd 在运行服务时，总是会先尝试找到一个完整匹配的 Unit 文件，如果没有找到，才会尝试选择匹配模板。例如上面的命令，System 首先会在约定的目录下寻找名为 apache@8080.service 的文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 apache@8080.service，systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。\n\n## **Systemd 的资源管理**\n\n### **Systemctl 命令**\n\n```javascript\n# systemctl --help\nsystemctl [OPTIONS...] {COMMAND} ...\nQuery or send control commands to the systemd manager.\n  -h --help           Show this help\n     --version        Show package version\n     --system         Connect to system manager\n  -H --host=[USER@]HOST\n                      Operate on remote host\n  -M --machine=CONTAINER\n                      Operate on local container\n  -t --type=TYPE      List units of a particular type\n     --state=STATE    List units with particular LOAD or SUB or ACTIVE state\n  -p --property=NAME  Show only properties by this name\n  -a --all            Show all loaded units/properties, including dead/empty\n                      ones. To list all units installed on the system, use\n                      the 'list-unit-files' command instead.\n  -l --full           Don't ellipsize unit names on output\n  -r --recursive      Show unit list of host and local containers\n     --reverse        Show reverse dependencies with 'list-dependencies'\n     --job-mode=MODE  Specify how to deal with already queued jobs, when\n                      queueing a new job\n     --show-types     When showing sockets, explicitly show their type\n  -i --ignore-inhibitors\n                      When shutting down or sleeping, ignore inhibitors\n     --kill-who=WHO   Who to send signal to\n  -s --signal=SIGNAL  Which signal to send\n     --now            Start or stop unit in addition to enabling or disabling it\n  -q --quiet          Suppress output\n     --no-block       Do not wait until operation finished\n     --no-wall        Don't send wall message before halt/power-off/reboot\n     --no-reload      Don't reload daemon after en-/dis-abling unit files\n     --no-legend      Do not print a legend (column headers and hints)\n     --no-pager       Do not pipe output into a pager\n     --no-ask-password\n                      Do not ask for system passwords\n     --global         Enable/disable unit files globally\n     --runtime        Enable unit files only temporarily until next reboot\n  -f --force          When enabling unit files, override existing symlinks\n                      When shutting down, execute action immediately\n     --preset-mode=   Apply only enable, only disable, or all presets\n     --root=PATH      Enable unit files in the specified root directory\n  -n --lines=INTEGER  Number of journal entries to show\n  -o --output=STRING  Change journal output mode (short, short-iso,\n                              short-precise, short-monotonic, verbose,\n                              export, json, json-pretty, json-sse, cat)\n     --plain          Print unit dependencies as a list instead of a tree\nUnit Commands:\n  list-units [PATTERN...]         List loaded units\n  list-sockets [PATTERN...]       List loaded sockets ordered by address\n  list-timers [PATTERN...]        List loaded timers ordered by next elapse\n  start NAME...                   Start (activate) one or more units\n  stop NAME...                    Stop (deactivate) one or more units\n  reload NAME...                  Reload one or more units\n  restart NAME...                 Start or restart one or more units\n  try-restart NAME...             Restart one or more units if active\n  reload-or-restart NAME...       Reload one or more units if possible,\n                                  otherwise start or restart\n  reload-or-try-restart NAME...   Reload one or more units if possible,\n                                  otherwise restart if active\n  isolate NAME                    Start one unit and stop all others\n  kill NAME...                    Send signal to processes of a unit\n  is-active PATTERN...            Check whether units are active\n  is-failed PATTERN...            Check whether units are failed\n  status [PATTERN...|PID...]      Show runtime status of one or more units\n  show [PATTERN...|JOB...]        Show properties of one or more\n                                  units/jobs or the manager\n  cat PATTERN...                  Show files and drop-ins of one or more units\n  set-property NAME ASSIGNMENT... Sets one or more properties of a unit\n  help PATTERN...|PID...          Show manual for one or more units\n  reset-failed [PATTERN...]       Reset failed state for all, one, or more\n                                  units\n  list-dependencies [NAME]        Recursively show units which are required\n                                  or wanted by this unit or by which this\n                                  unit is required or wanted\nUnit File Commands:\n  list-unit-files [PATTERN...]    List installed unit files\n  enable NAME...                  Enable one or more unit files\n  disable NAME...                 Disable one or more unit files\n  reenable NAME...                Reenable one or more unit files\n  preset NAME...                  Enable/disable one or more unit files\n                                  based on preset configuration\n  preset-all                      Enable/disable all unit files based on\n                                  preset configuration\n  is-enabled NAME...              Check whether unit files are enabled\n  mask NAME...                    Mask one or more units\n  unmask NAME...                  Unmask one or more units\n  link PATH...                    Link one or more units files into\n                                  the search path\n  add-wants TARGET NAME...        Add 'Wants' dependency for the target\n                                  on specified one or more units\n  add-requires TARGET NAME...     Add 'Requires' dependency for the target\n                                  on specified one or more units\n  edit NAME...                    Edit one or more unit files\n  get-default                     Get the name of the default target\n  set-default NAME                Set the default target\nMachine Commands:\n  list-machines [PATTERN...]      List local containers and host\nJob Commands:\n  list-jobs [PATTERN...]          List jobs\n  cancel [JOB...]                 Cancel all, one, or more jobs\nSnapshot Commands:\n  snapshot [NAME]                 Create a snapshot\n  delete NAME...                  Remove one or more snapshots\nEnvironment Commands:\n  show-environment                Dump environment\n  set-environment NAME=VALUE...   Set one or more environment variables\n  unset-environment NAME...       Unset one or more environment variables\n  import-environment [NAME...]    Import all or some environment variables\nManager Lifecycle Commands:\n  daemon-reload                   Reload systemd manager configuration\n  daemon-reexec                   Reexecute systemd manager\nSystem Commands:\n  is-system-running               Check whether system is fully running\n  default                         Enter system default mode\n  rescue                          Enter system rescue mode\n  emergency                       Enter system emergency mode\n  halt                            Shut down and halt the system\n  poweroff                        Shut down and power-off the system\n  reboot [ARG]                    Shut down and reboot the system\n  kexec                           Shut down and reboot the system with kexec\n  exit                            Request user instance exit\n  switch-root ROOT [INIT]         Change to a different root file system\n  suspend                         Suspend the system\n  hibernate                       Hibernate the system\n  hybrid-sleep                    Hibernate and suspend the system\n```\n\n### **Unit 管理**\n\n1. 查看当前系统的所有 Unit\n\n```javascript\n# 列出正在运行的 Unit\n$ systemctl list-units\n\n# 列出所有Unit，包括没有找到配置文件的或者启动失败的\n$ systemctl list-units --all\n\n# 列出所有没有运行的 Unit\n$ systemctl list-units --all --state=inactive\n\n# 列出所有加载失败的 Unit\n$ systemctl list-units --failed\n\n# 列出所有正在运行的、类型为 service 的 Unit\n$ systemctl list-units --type=service\n\n# 查看 Unit 配置文件的内容\n$ systemctl cat docker.service\n```\n\n1. 查看 Unit 的状态\n\n- enabled：已建立启动链接\n- disabled：没建立启动链接\n- static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖\n- masked：该配置文件被禁止建立启动链接\n\n```javascript\n# 显示系统状态\n$ systemctl status\n\n# 显示单个 Unit 的状态\n$ ystemctl status bluetooth.service\n\n# 显示远程主机的某个 Unit 的状态\n$ systemctl -H root@rhel7.example.com status httpd.service\n```\n\n1. Unit 的管理\n\n```javascript\n# 立即启动一个服务\n$ sudo systemctl start apache.service\n\n# 立即停止一个服务\n$ sudo systemctl stop apache.service\n\n# 重启一个服务\n$ sudo systemctl restart apache.service\n\n# 杀死一个服务的所有子进程\n$ sudo systemctl kill apache.service\n\n# 重新加载一个服务的配置文件\n$ sudo systemctl reload apache.service\n\n# 重载所有修改过的配置文件\n$ sudo systemctl daemon-reload\n\n# 显示某个 Unit 的所有底层参数\n$ systemctl show httpd.service\n\n# 显示某个 Unit 的指定属性的值\n$ systemctl show -p CPUShares httpd.service\n\n# 设置某个 Unit 的指定属性\n$ sudo systemctl set-property httpd.service CPUShares=500\n```\n\n1. 查看 Unit 的依赖关系\n\n```javascript\n# 列出一个 Unit 的所有依赖，默认不会列出 target 类型\n$ systemctl list-dependencies nginx.service\n\n# 列出一个 Unit 的所有依赖，包括 target 类型\n$ systemctl list-dependencies --all nginx.service\n```\n\n### **服务的生命周期**\n\n当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。\n\n1. 服务的激活\n\n- systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中\n- systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令\n\n1. 服务的启动和停止\n\n- systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令\n- systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令\n- systemctl restart：重启服务\n- systemctl kill：立即杀死服务\n\n1. 服务的开机启动和取消\n\n- systemctl enable：除了激活服务以外，也可以置服务为开机启动\n- systemctl disable：取消服务的开机启动\n\n1. 服务的修改和移除\n\n- systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件\n- systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。\n\n### **Target 管理**\n\nTarget 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。\n\n在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n\n```javascript\n# 查看当前系统的所有 Target\n$ systemctl list-unit-files --type=target\n\n# 查看一个 Target 包含的所有 Unit\n$ systemctl list-dependencies multi-user.target\n\n# 查看启动时的默认 Target\n$ systemctl get-default\n\n# 设置启动时的默认 Target\n$ sudo systemctl set-default multi-user.target\n\n# 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程\n$ sudo systemctl isolate multi-user.target\n```\n\n1. Target 与 SysV-init 进程的主要区别：\n\n- 默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n- 启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。\n- 配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。\n\n### **日志管理**\n\nSystemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。\n\nSystemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。\n\n默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。\n\n```javascript\n# 查看所有日志（默认情况下 ，只保存本次启动的日志）\n$ sudo journalctl\n\n# 查看内核日志（不显示应用日志）：--dmesg 或 -k\n$ sudo journalctl -k\n\n# 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b\n$ sudo journalctl -b\n$ sudo journalctl -b -0\n\n# 查看上一次启动的日志（需更改设置）\n$ sudo journalctl -b -1\n\n# 查看指定服务的日志：--unit 或 -u\n$ sudo journalctl -u docker.servcie\n\n# 查看指定服务的日志\n$ sudo journalctl /usr/lib/systemd/systemd\n\n# 实时滚动显示最新日志\n$ sudo journalctl -f\n\n# 查看指定时间的日志\n$ sudo journalctl --since=\"2012-10-30 18:17:16\"\n$ sudo journalctl --since \"20 min ago\"\n$ sudo journalctl --since yesterday\n$ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"\n$ sudo journalctl --since 09:00 --until \"1 hour ago\"\n\n# 显示尾部的最新 10 行日志：--lines 或 -n\n$ sudo journalctl -n\n\n# 显示尾部指定行数的日志\n$ sudo journalctl -n 20\n\n# 将最新的日志显示在前面\n$ sudo journalctl -r -u docker.service\n\n# 改变输出的格式：--output 或 -o\n$ sudo journalctl -r -u docker.service -o json-pretty\n\n# 查看指定进程的日志\n$ sudo journalctl _PID=1\n\n# 查看某个路径的脚本的日志\n$ sudo journalctl /usr/bin/bash\n\n# 查看指定用户的日志\n$ sudo journalctl _UID=33 --since today\n\n# 查看某个 Unit 的日志\n$ sudo journalctl -u nginx.service\n$ sudo journalctl -u nginx.service --since today\n\n# 实时滚动显示某个 Unit 的最新日志\n$ sudo journalctl -u nginx.service -f\n\n# 合并显示多个 Unit 的日志\n$ journalctl -u nginx.service -u php-fpm.service --since today\n\n# 查看指定优先级（及其以上级别）的日志，共有 8 级\n# 0: emerg\n# 1: alert\n# 2: crit\n# 3: err\n# 4: warning\n# 5: notice\n# 6: info\n# 7: debug\n$ sudo journalctl -p err -b\n\n# 日志默认分页输出，--no-pager 改为正常的标准输出\n$ sudo journalctl --no-pager\n\n# 以 JSON 格式（单行）输出\n$ sudo journalctl -b -u nginx.service -o json\n\n# 以 JSON 格式（多行）输出，可读性更好\n$ sudo journalctl -b -u nginx.serviceqq\n -o json-pretty\n\n# 显示日志占据的硬盘空间\n$ sudo journalctl --disk-usage\n\n# 指定日志文件占据的最大空间\n$ sudo journalctl --vacuum-size=1G\n\n# 指定日志文件保存多久\n$ sudo journalctl --vacuum-time=1years\n```\n\n## **Systemd 工具集**\n\n- systemctl：用于检查和控制各种系统服务和资源的状态\n- bootctl：用于查看和管理系统启动分区\n- hostnamectl：用于查看和修改系统的主机名和主机信息\n- journalctl：用于查看系统日志和各类应用服务日志\n- localectl：用于查看和管理系统的地区信息\n- loginctl：用于管理系统已登录用户和 Session 的信息\n- machinectl：用于操作 Systemd 容器\n- timedatectl：用于查看和管理系统的时间和时区信息\n- systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈\n- systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容\n- systemd-cat：用于将其他命令的输出重定向到系统日志\n- systemd-cgls：递归地显示指定 CGroup 的继承链\n- systemd-cgtop：显示系统当前最耗资源的 CGroup 单元\n- systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符\n- systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库\n- systemd-delta：对比当前系统配置与默认系统配置的差异\n- systemd-detect-virt：显示主机的虚拟化类型\n- systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件\n- systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID\n- systemd-notify：Systemd 的内部工具，用于通知服务的状态变化\n- systemd-nspawn：用于创建 Systemd 容器\n- systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置\n- systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行\n- systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线\n- systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录\n- systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求\n\n1. systemctl\n\n```javascript\n# 重启系统\n$ sudo systemctl reboot\n\n# 关闭系统，切断电源\n$ sudo systemctl poweroff\n\n# CPU停止工作\n$ sudo systemctl halt\n\n# 暂停系统\n$ sudo systemctl suspend\n\n# 让系统进入冬眠状态\n$ sudo systemctl hibernate\n\n# 让系统进入交互式休眠状态\n$ sudo systemctl hybrid-sleep\n\n# 启动进入救援状态（单用户状态）\n$ sudo systemctl rescue\n```\n\n1. systemd-analyze\n\n```javascript\n# 查看启动耗时\n$ systemd-analyze\n\n# 查看每个服务的启动耗时\n$ systemd-analyze blame\n\n# 显示瀑布状的启动过程流\n$ systemd-analyze critical-chain\n\n# 显示指定服务的启动流\n$ systemd-analyze critical-chain atd.service\n```\n\n1. hostnamectl\n\n```javascript\n# 显示当前主机的信息\n$ hostnamectl\n\n# 设置主机名。\n$ sudo hostnamectl set-hostname rhel7\n```\n\n1. timedatectl\n\n```javascript\n# 查看当前时区设置\n$ timedatectl\n\n# 显示所有可用的时区\n$ timedatectl list-timezones\n\n# 设置当前时区\n$ sudo timedatectl set-timezone America/New_York\n$ sudo timedatectl set-time YYYY-MM-DD\n$ sudo timedatectl set-time HH:MM:SS\n```\n\n1. loginctl\n\n```javascript\n# 列出当前 session\n$ loginctl list-sessions\n\n# 列出当前登录用户\n$ loginctl list-users\n\n# 列出显示指定用户的信息\n$ loginctl show-user ruanyf\n```\n\n1. systemd-ask-password\n\n```javascript\n$ PASSWORD=$(systemd-ask-password \"Input Your Passowrd:\")\n```\n\n1. systemd-run\n\nsystemd-run 可以将一个指定的操作变成后台运行的服务。它的效果似乎与直接在命令后加上表示后台运行的 & 符号很相似。然而，它让命令成为服务还意味着，它的生命周期将由 Systemd 控制。具体来说，包括以下好处：\n\n- 服务的生命击期由 Systemd 接管，不会随着启动它的控制台关闭而结束\n- 可以通过 systemctl 工具管理服务的状态\n- 可以通过 journalctl 工具查看和管理服务的日志信息\n- 可以通过 Systemd 提供的方法限制服务的 CPU、内存、磁盘 IO 等系统资源的使用情况。","source":"_posts/linux/linux命令/Linux命令systemd.md","raw":"---\ntitle: Linux命令systemd\nabbrlink: 1026478354\ntags:\n\t- Linux\n\t- Centos\n---\n\n[TOC]\n\n## **Systemd 概述**\n\n### **Systemd 简介**\n\nSystemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。\n\nSystemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。\n\n1. 更少的进程\n\nSystemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。\n\n1. 允许更多的进程并行启动\n\n在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。\n\n1. 使用 CGroup 跟踪和管理进程的生命周期\n\n在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。\n\n而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。\n\n1. 统一管理服务日志\n\nSystemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。\n\n### **Systemd 架构**\n\n![img](https://ask.qcloudimg.com/http-save/yehe-5449090/97kx52pwuj.png?imageView2/2/w/1620)\n\n## **Systemd 的 Unit 文件**\n\nSystemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）。\n\n在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。\n\n1. Systemd 支持的 12 种 Unit 文件类型\n\n- .automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务\n- .device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系\n- .mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件\n- .path：用于监控指定目录或文件的变化，并触发其它 Unit 运行\n- .scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息\n- .service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件\n- .slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件\n- .snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照\n- .socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动\n- .swap：定义一个用户做虚拟内存的交换分区\n- .target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式\n- .timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能\n\n1. Systemd 目录\n\nUnit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。\n\n- /etc/systemd/system：系统或用户自定义的配置文件\n- /run/systemd/system：软件运行时生成的配置文件\n- /usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。\n  - CentOS 7：Unit 文件指向该目录\n  - ubuntu 16：被移到了 /lib/systemd/system\n\nSystemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。\n\n1. Unit 和 Target\n\nUnit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。\n\nTarget 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。\n\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。\n\n## **Systemd Service Unit**\n\n### **Unit 文件结构**\n\n```javascript\n[Unit]\nDescription=Hello World\nAfter=docker.service\nRequires=docker.service\n[Service]\nTimeoutStartSec=0\nExecStartPre=-/usr/bin/docker kill busybox1\nExecStartPre=-/usr/bin/docker rm busybox1\nExecStartPre=/usr/bin/docker pull busybox\nExecStart=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c \"while true; do echo Hello World; sleep 1; done\"\nExecStop=\"/usr/bin/docker stop busybox1\"\nExecStopPost=\"/usr/bin/docker rm busybox1\"\n[Install]\nWantedBy=multi-user.target\n```\n\n如下所示，Systemd 服务的 Unit 文件可以分为三个配置区段：\n\n- Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式\n- Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法\n\n#### **Unit 段**\n\n- Description：描述这个 Unit 文件的信息\n- Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径\n- Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止\n- Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功\n- After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务\n- Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行\n- Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启\n- Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动\n- OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块\n- Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然\n\n#### **Install 段**\n\n这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束：\n\n- WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 <Target 名> + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“\n\n```javascript\n# find /etc/systemd/system/* -type d\n/etc/systemd/system/default.target.wants\n/etc/systemd/system/getty.target.wants\n/etc/systemd/system/graphical.target.wants\n/etc/systemd/system/multi-user.target.wants\n/etc/systemd/system/network-online.target.wants\n/etc/systemd/system/paths.target.wants\n/etc/systemd/system/shutdown.target.wants\n/etc/systemd/system/sockets.target.wants\n/etc/systemd/system/sysinit.target.wants\n/etc/systemd/system/timers.target.wants\n```\n\n- RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 <Target 名> + .required 后缀构成的子目录中\n- Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit\n- Alias：当前 Unit 可用于启动的别名\n\n1. SysV-init 运行级别与 Systemd Target 对应的 Unit 文件\n\n![img](https://ask.qcloudimg.com/http-save/yehe-5449090/mvna7qlr41.png?imageView2/2/w/1620)\n\n通过 systemctl list-units --type=target 命令可以获取当前正在使用的运行目标\n\n```javascript\n# systemctl list-units --type=target\nUNIT                   LOAD   ACTIVE SUB    DESCRIPTION\nbasic.target           loaded active active Basic System\ncryptsetup.target      loaded active active Encrypted Volumes\ngetty.target           loaded active active Login Prompts\ngraphical.target       loaded active active Graphical Interface\nlocal-fs-pre.target    loaded active active Local File Systems (Pre)\nlocal-fs.target        loaded active active Local File Systems\nmulti-user.target      loaded active active Multi-User System\nnetwork-online.target  loaded active active Network is Online\nnetwork.target         loaded active active Network\nnss-user-lookup.target loaded active active User and Group Name Lookups\npaths.target           loaded active active Paths\nremote-fs-pre.target   loaded active active Remote File Systems (Pre)\nremote-fs.target       loaded active active Remote File Systems\nslices.target          loaded active active Slices\nsockets.target         loaded active active Sockets\nsound.target           loaded active active Sound Card\nswap.target            loaded active active Swap\nsysinit.target         loaded active active System Initialization\ntime-sync.target       loaded active active System Time Synchronized\ntimers.target          loaded active active Timers\nLOAD   = Reflects whether the unit definition was properly loaded.\nACTIVE = The high-level unit activation state, i.e. generalization of SUB.\nSUB    = The low-level unit activation state, values depend on unit type.\n20 loaded units listed. Pass --all to see loaded but inactive units, too.\nTo show all installed unit files use 'systemctl list-unit-files'.\n```\n\n#### **Service 段**\n\n用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段分为服务生命周期和服务上下文配置两个方面。\n\n1. 服务生命周期控制相关\n\n- Type：定义启动时的进程行为，它有以下几种值：\n  - Type=simple：默认值，执行ExecStart指定的命令，启动主进程\n  - Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出\n  - Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行\n  - Type=dbus：当前服务通过D-Bus启动\n  - Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行\n  - Type=idle：若有其他任务执行完毕，当前服务才会运行\n- RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。\n- ExecStart：启动当前服务的命令\n- ExecStartPre：启动当前服务之前执行的命令\n- ExecStartPos：启动当前服务之后执行的命令\n- ExecReload：重启当前服务时执行的命令\n- ExecStop：停止当前服务时执行的命令\n- ExecStopPost：停止当其服务之后执行的命令\n- RestartSec：自动重启当前服务间隔的秒数\n- Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog\n- TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测\n- TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程\n\n1. 服务上下文配置相关\n\n- Environment：为服务指定环境变量\n- EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义\n- Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级\n- WorkingDirectory：指定服务的工作目录\n- RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件\n- User：指定运行服务的用户\n- Group：指定运行服务的用户组\n- MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private\n  - shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上\n  - slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上\n  - private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上\n- LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等\n\n> 注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。\n\n### **Unit 文件占位符和模板**\n\n#### **Unit 文件占位符**\n\n在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行被动态地替换实际的值。\n\n- %n：完整的 Unit 文件名字，包括 .service 后缀名\n- %p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号\n- %i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名\n- %t：存放系统运行文件的目录，通常是 “run”\n- %u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root\n- %U：运行服务的用户 ID\n- %h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值\n- %s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值\n- %m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用\n- %b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变\n- %H：实际运行节点的主机名\n- %v：内核版本，即 “uname -r” 命令输出的内容\n- %%：在 Unit 模板文件中表示一个普通的百分号\n\n#### **Unit 模板**\n\n在现实中，往往有一些应用需要被复制多份运行。例如，用于同一个[负载均衡](https://cloud.tencent.com/product/clb?from=10680)器分流的多个服务实例，或者为每个 SSH 连接建立一个独立的 sshd 服务进程。\n\nUnit 模板文件的写法与普通的服务 Unit 文件基本相同，不过 Unit 模板的文件名是以 @ 符号结尾的。通过模板启动服务实例时，需要在其文件名的 @ 字符后面附加一个参数字符串。\n\n1. 示例：apache@.service\n\n- apache@.service 模板\n\n```javascript\n[Unit]\nDescription=My Advanced Service Template\nAfter=etcd.service docker.service\n[Service]\nTimeoutStartSec=0\nExecStartPre=-/usr/bin/docker kill apache%i\nExecStartPre=-/usr/bin/docker rm apache%i\nExecStartPre=/usr/bin/docker pull coreos/apache\nExecStart=/usr/bin/docker run --name apache%i -p %i:80 coreos/apache /usr/sbin/apache2ctl -D FOREGROUND\nExecStartPost=/usr/bin/etcdctl set /domains/example.com/%H:%i running\nExecStop=/usr/bin/docker stop apache1\nExecStopPost=/usr/bin/docker rm apache1\nExecStopPost=/usr/bin/etcdctl rm /domains/example.com/%H:%i\n[Install]\nWantedBy=multi-user.target\n```\n\n- 启动 Unit 模板的服务实例\n\n在服务启动时需要在 @ 后面放置一个用于区分服务实例的附加字符参数，通常这个参数用于监控的端口号或控制台 TTY 编译号。\n\n```javascript\n# systemctl start apache@8080.service\n```\n\nSystemd 在运行服务时，总是会先尝试找到一个完整匹配的 Unit 文件，如果没有找到，才会尝试选择匹配模板。例如上面的命令，System 首先会在约定的目录下寻找名为 apache@8080.service 的文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 apache@8080.service，systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。\n\n## **Systemd 的资源管理**\n\n### **Systemctl 命令**\n\n```javascript\n# systemctl --help\nsystemctl [OPTIONS...] {COMMAND} ...\nQuery or send control commands to the systemd manager.\n  -h --help           Show this help\n     --version        Show package version\n     --system         Connect to system manager\n  -H --host=[USER@]HOST\n                      Operate on remote host\n  -M --machine=CONTAINER\n                      Operate on local container\n  -t --type=TYPE      List units of a particular type\n     --state=STATE    List units with particular LOAD or SUB or ACTIVE state\n  -p --property=NAME  Show only properties by this name\n  -a --all            Show all loaded units/properties, including dead/empty\n                      ones. To list all units installed on the system, use\n                      the 'list-unit-files' command instead.\n  -l --full           Don't ellipsize unit names on output\n  -r --recursive      Show unit list of host and local containers\n     --reverse        Show reverse dependencies with 'list-dependencies'\n     --job-mode=MODE  Specify how to deal with already queued jobs, when\n                      queueing a new job\n     --show-types     When showing sockets, explicitly show their type\n  -i --ignore-inhibitors\n                      When shutting down or sleeping, ignore inhibitors\n     --kill-who=WHO   Who to send signal to\n  -s --signal=SIGNAL  Which signal to send\n     --now            Start or stop unit in addition to enabling or disabling it\n  -q --quiet          Suppress output\n     --no-block       Do not wait until operation finished\n     --no-wall        Don't send wall message before halt/power-off/reboot\n     --no-reload      Don't reload daemon after en-/dis-abling unit files\n     --no-legend      Do not print a legend (column headers and hints)\n     --no-pager       Do not pipe output into a pager\n     --no-ask-password\n                      Do not ask for system passwords\n     --global         Enable/disable unit files globally\n     --runtime        Enable unit files only temporarily until next reboot\n  -f --force          When enabling unit files, override existing symlinks\n                      When shutting down, execute action immediately\n     --preset-mode=   Apply only enable, only disable, or all presets\n     --root=PATH      Enable unit files in the specified root directory\n  -n --lines=INTEGER  Number of journal entries to show\n  -o --output=STRING  Change journal output mode (short, short-iso,\n                              short-precise, short-monotonic, verbose,\n                              export, json, json-pretty, json-sse, cat)\n     --plain          Print unit dependencies as a list instead of a tree\nUnit Commands:\n  list-units [PATTERN...]         List loaded units\n  list-sockets [PATTERN...]       List loaded sockets ordered by address\n  list-timers [PATTERN...]        List loaded timers ordered by next elapse\n  start NAME...                   Start (activate) one or more units\n  stop NAME...                    Stop (deactivate) one or more units\n  reload NAME...                  Reload one or more units\n  restart NAME...                 Start or restart one or more units\n  try-restart NAME...             Restart one or more units if active\n  reload-or-restart NAME...       Reload one or more units if possible,\n                                  otherwise start or restart\n  reload-or-try-restart NAME...   Reload one or more units if possible,\n                                  otherwise restart if active\n  isolate NAME                    Start one unit and stop all others\n  kill NAME...                    Send signal to processes of a unit\n  is-active PATTERN...            Check whether units are active\n  is-failed PATTERN...            Check whether units are failed\n  status [PATTERN...|PID...]      Show runtime status of one or more units\n  show [PATTERN...|JOB...]        Show properties of one or more\n                                  units/jobs or the manager\n  cat PATTERN...                  Show files and drop-ins of one or more units\n  set-property NAME ASSIGNMENT... Sets one or more properties of a unit\n  help PATTERN...|PID...          Show manual for one or more units\n  reset-failed [PATTERN...]       Reset failed state for all, one, or more\n                                  units\n  list-dependencies [NAME]        Recursively show units which are required\n                                  or wanted by this unit or by which this\n                                  unit is required or wanted\nUnit File Commands:\n  list-unit-files [PATTERN...]    List installed unit files\n  enable NAME...                  Enable one or more unit files\n  disable NAME...                 Disable one or more unit files\n  reenable NAME...                Reenable one or more unit files\n  preset NAME...                  Enable/disable one or more unit files\n                                  based on preset configuration\n  preset-all                      Enable/disable all unit files based on\n                                  preset configuration\n  is-enabled NAME...              Check whether unit files are enabled\n  mask NAME...                    Mask one or more units\n  unmask NAME...                  Unmask one or more units\n  link PATH...                    Link one or more units files into\n                                  the search path\n  add-wants TARGET NAME...        Add 'Wants' dependency for the target\n                                  on specified one or more units\n  add-requires TARGET NAME...     Add 'Requires' dependency for the target\n                                  on specified one or more units\n  edit NAME...                    Edit one or more unit files\n  get-default                     Get the name of the default target\n  set-default NAME                Set the default target\nMachine Commands:\n  list-machines [PATTERN...]      List local containers and host\nJob Commands:\n  list-jobs [PATTERN...]          List jobs\n  cancel [JOB...]                 Cancel all, one, or more jobs\nSnapshot Commands:\n  snapshot [NAME]                 Create a snapshot\n  delete NAME...                  Remove one or more snapshots\nEnvironment Commands:\n  show-environment                Dump environment\n  set-environment NAME=VALUE...   Set one or more environment variables\n  unset-environment NAME...       Unset one or more environment variables\n  import-environment [NAME...]    Import all or some environment variables\nManager Lifecycle Commands:\n  daemon-reload                   Reload systemd manager configuration\n  daemon-reexec                   Reexecute systemd manager\nSystem Commands:\n  is-system-running               Check whether system is fully running\n  default                         Enter system default mode\n  rescue                          Enter system rescue mode\n  emergency                       Enter system emergency mode\n  halt                            Shut down and halt the system\n  poweroff                        Shut down and power-off the system\n  reboot [ARG]                    Shut down and reboot the system\n  kexec                           Shut down and reboot the system with kexec\n  exit                            Request user instance exit\n  switch-root ROOT [INIT]         Change to a different root file system\n  suspend                         Suspend the system\n  hibernate                       Hibernate the system\n  hybrid-sleep                    Hibernate and suspend the system\n```\n\n### **Unit 管理**\n\n1. 查看当前系统的所有 Unit\n\n```javascript\n# 列出正在运行的 Unit\n$ systemctl list-units\n\n# 列出所有Unit，包括没有找到配置文件的或者启动失败的\n$ systemctl list-units --all\n\n# 列出所有没有运行的 Unit\n$ systemctl list-units --all --state=inactive\n\n# 列出所有加载失败的 Unit\n$ systemctl list-units --failed\n\n# 列出所有正在运行的、类型为 service 的 Unit\n$ systemctl list-units --type=service\n\n# 查看 Unit 配置文件的内容\n$ systemctl cat docker.service\n```\n\n1. 查看 Unit 的状态\n\n- enabled：已建立启动链接\n- disabled：没建立启动链接\n- static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖\n- masked：该配置文件被禁止建立启动链接\n\n```javascript\n# 显示系统状态\n$ systemctl status\n\n# 显示单个 Unit 的状态\n$ ystemctl status bluetooth.service\n\n# 显示远程主机的某个 Unit 的状态\n$ systemctl -H root@rhel7.example.com status httpd.service\n```\n\n1. Unit 的管理\n\n```javascript\n# 立即启动一个服务\n$ sudo systemctl start apache.service\n\n# 立即停止一个服务\n$ sudo systemctl stop apache.service\n\n# 重启一个服务\n$ sudo systemctl restart apache.service\n\n# 杀死一个服务的所有子进程\n$ sudo systemctl kill apache.service\n\n# 重新加载一个服务的配置文件\n$ sudo systemctl reload apache.service\n\n# 重载所有修改过的配置文件\n$ sudo systemctl daemon-reload\n\n# 显示某个 Unit 的所有底层参数\n$ systemctl show httpd.service\n\n# 显示某个 Unit 的指定属性的值\n$ systemctl show -p CPUShares httpd.service\n\n# 设置某个 Unit 的指定属性\n$ sudo systemctl set-property httpd.service CPUShares=500\n```\n\n1. 查看 Unit 的依赖关系\n\n```javascript\n# 列出一个 Unit 的所有依赖，默认不会列出 target 类型\n$ systemctl list-dependencies nginx.service\n\n# 列出一个 Unit 的所有依赖，包括 target 类型\n$ systemctl list-dependencies --all nginx.service\n```\n\n### **服务的生命周期**\n\n当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。\n\n1. 服务的激活\n\n- systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中\n- systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令\n\n1. 服务的启动和停止\n\n- systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令\n- systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令\n- systemctl restart：重启服务\n- systemctl kill：立即杀死服务\n\n1. 服务的开机启动和取消\n\n- systemctl enable：除了激活服务以外，也可以置服务为开机启动\n- systemctl disable：取消服务的开机启动\n\n1. 服务的修改和移除\n\n- systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件\n- systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。\n\n### **Target 管理**\n\nTarget 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。\n\n在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n\n```javascript\n# 查看当前系统的所有 Target\n$ systemctl list-unit-files --type=target\n\n# 查看一个 Target 包含的所有 Unit\n$ systemctl list-dependencies multi-user.target\n\n# 查看启动时的默认 Target\n$ systemctl get-default\n\n# 设置启动时的默认 Target\n$ sudo systemctl set-default multi-user.target\n\n# 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程\n$ sudo systemctl isolate multi-user.target\n```\n\n1. Target 与 SysV-init 进程的主要区别：\n\n- 默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n- 启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。\n- 配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。\n\n### **日志管理**\n\nSystemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。\n\nSystemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。\n\n默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。\n\n```javascript\n# 查看所有日志（默认情况下 ，只保存本次启动的日志）\n$ sudo journalctl\n\n# 查看内核日志（不显示应用日志）：--dmesg 或 -k\n$ sudo journalctl -k\n\n# 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b\n$ sudo journalctl -b\n$ sudo journalctl -b -0\n\n# 查看上一次启动的日志（需更改设置）\n$ sudo journalctl -b -1\n\n# 查看指定服务的日志：--unit 或 -u\n$ sudo journalctl -u docker.servcie\n\n# 查看指定服务的日志\n$ sudo journalctl /usr/lib/systemd/systemd\n\n# 实时滚动显示最新日志\n$ sudo journalctl -f\n\n# 查看指定时间的日志\n$ sudo journalctl --since=\"2012-10-30 18:17:16\"\n$ sudo journalctl --since \"20 min ago\"\n$ sudo journalctl --since yesterday\n$ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"\n$ sudo journalctl --since 09:00 --until \"1 hour ago\"\n\n# 显示尾部的最新 10 行日志：--lines 或 -n\n$ sudo journalctl -n\n\n# 显示尾部指定行数的日志\n$ sudo journalctl -n 20\n\n# 将最新的日志显示在前面\n$ sudo journalctl -r -u docker.service\n\n# 改变输出的格式：--output 或 -o\n$ sudo journalctl -r -u docker.service -o json-pretty\n\n# 查看指定进程的日志\n$ sudo journalctl _PID=1\n\n# 查看某个路径的脚本的日志\n$ sudo journalctl /usr/bin/bash\n\n# 查看指定用户的日志\n$ sudo journalctl _UID=33 --since today\n\n# 查看某个 Unit 的日志\n$ sudo journalctl -u nginx.service\n$ sudo journalctl -u nginx.service --since today\n\n# 实时滚动显示某个 Unit 的最新日志\n$ sudo journalctl -u nginx.service -f\n\n# 合并显示多个 Unit 的日志\n$ journalctl -u nginx.service -u php-fpm.service --since today\n\n# 查看指定优先级（及其以上级别）的日志，共有 8 级\n# 0: emerg\n# 1: alert\n# 2: crit\n# 3: err\n# 4: warning\n# 5: notice\n# 6: info\n# 7: debug\n$ sudo journalctl -p err -b\n\n# 日志默认分页输出，--no-pager 改为正常的标准输出\n$ sudo journalctl --no-pager\n\n# 以 JSON 格式（单行）输出\n$ sudo journalctl -b -u nginx.service -o json\n\n# 以 JSON 格式（多行）输出，可读性更好\n$ sudo journalctl -b -u nginx.serviceqq\n -o json-pretty\n\n# 显示日志占据的硬盘空间\n$ sudo journalctl --disk-usage\n\n# 指定日志文件占据的最大空间\n$ sudo journalctl --vacuum-size=1G\n\n# 指定日志文件保存多久\n$ sudo journalctl --vacuum-time=1years\n```\n\n## **Systemd 工具集**\n\n- systemctl：用于检查和控制各种系统服务和资源的状态\n- bootctl：用于查看和管理系统启动分区\n- hostnamectl：用于查看和修改系统的主机名和主机信息\n- journalctl：用于查看系统日志和各类应用服务日志\n- localectl：用于查看和管理系统的地区信息\n- loginctl：用于管理系统已登录用户和 Session 的信息\n- machinectl：用于操作 Systemd 容器\n- timedatectl：用于查看和管理系统的时间和时区信息\n- systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈\n- systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容\n- systemd-cat：用于将其他命令的输出重定向到系统日志\n- systemd-cgls：递归地显示指定 CGroup 的继承链\n- systemd-cgtop：显示系统当前最耗资源的 CGroup 单元\n- systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符\n- systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库\n- systemd-delta：对比当前系统配置与默认系统配置的差异\n- systemd-detect-virt：显示主机的虚拟化类型\n- systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件\n- systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID\n- systemd-notify：Systemd 的内部工具，用于通知服务的状态变化\n- systemd-nspawn：用于创建 Systemd 容器\n- systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置\n- systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行\n- systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线\n- systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录\n- systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求\n\n1. systemctl\n\n```javascript\n# 重启系统\n$ sudo systemctl reboot\n\n# 关闭系统，切断电源\n$ sudo systemctl poweroff\n\n# CPU停止工作\n$ sudo systemctl halt\n\n# 暂停系统\n$ sudo systemctl suspend\n\n# 让系统进入冬眠状态\n$ sudo systemctl hibernate\n\n# 让系统进入交互式休眠状态\n$ sudo systemctl hybrid-sleep\n\n# 启动进入救援状态（单用户状态）\n$ sudo systemctl rescue\n```\n\n1. systemd-analyze\n\n```javascript\n# 查看启动耗时\n$ systemd-analyze\n\n# 查看每个服务的启动耗时\n$ systemd-analyze blame\n\n# 显示瀑布状的启动过程流\n$ systemd-analyze critical-chain\n\n# 显示指定服务的启动流\n$ systemd-analyze critical-chain atd.service\n```\n\n1. hostnamectl\n\n```javascript\n# 显示当前主机的信息\n$ hostnamectl\n\n# 设置主机名。\n$ sudo hostnamectl set-hostname rhel7\n```\n\n1. timedatectl\n\n```javascript\n# 查看当前时区设置\n$ timedatectl\n\n# 显示所有可用的时区\n$ timedatectl list-timezones\n\n# 设置当前时区\n$ sudo timedatectl set-timezone America/New_York\n$ sudo timedatectl set-time YYYY-MM-DD\n$ sudo timedatectl set-time HH:MM:SS\n```\n\n1. loginctl\n\n```javascript\n# 列出当前 session\n$ loginctl list-sessions\n\n# 列出当前登录用户\n$ loginctl list-users\n\n# 列出显示指定用户的信息\n$ loginctl show-user ruanyf\n```\n\n1. systemd-ask-password\n\n```javascript\n$ PASSWORD=$(systemd-ask-password \"Input Your Passowrd:\")\n```\n\n1. systemd-run\n\nsystemd-run 可以将一个指定的操作变成后台运行的服务。它的效果似乎与直接在命令后加上表示后台运行的 & 符号很相似。然而，它让命令成为服务还意味着，它的生命周期将由 Systemd 控制。具体来说，包括以下好处：\n\n- 服务的生命击期由 Systemd 接管，不会随着启动它的控制台关闭而结束\n- 可以通过 systemctl 工具管理服务的状态\n- 可以通过 journalctl 工具查看和管理服务的日志信息\n- 可以通过 Systemd 提供的方法限制服务的 CPU、内存、磁盘 IO 等系统资源的使用情况。","slug":"linux/linux命令/Linux命令systemd","published":1,"date":"2020-12-15T01:17:06.036Z","updated":"2020-12-15T01:18:22.433Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipcgz9v001ymxcd1brjhqma","content":"<p>[TOC]</p>\n<h2 id=\"Systemd-概述\"><a href=\"#Systemd-概述\" class=\"headerlink\" title=\"Systemd 概述\"></a><strong>Systemd 概述</strong></h2><h3 id=\"Systemd-简介\"><a href=\"#Systemd-简介\" class=\"headerlink\" title=\"Systemd 简介\"></a><strong>Systemd 简介</strong></h3><p>Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。</p>\n<p>Systemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。</p>\n<ol>\n<li>更少的进程</li>\n</ol>\n<p>Systemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。</p>\n<ol>\n<li>允许更多的进程并行启动</li>\n</ol>\n<p>在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。</p>\n<ol>\n<li>使用 CGroup 跟踪和管理进程的生命周期</li>\n</ol>\n<p>在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。</p>\n<p>而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。</p>\n<ol>\n<li>统一管理服务日志</li>\n</ol>\n<p>Systemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。</p>\n<h3 id=\"Systemd-架构\"><a href=\"#Systemd-架构\" class=\"headerlink\" title=\"Systemd 架构\"></a><strong>Systemd 架构</strong></h3><p><img src=\"https://ask.qcloudimg.com/http-save/yehe-5449090/97kx52pwuj.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2 id=\"Systemd-的-Unit-文件\"><a href=\"#Systemd-的-Unit-文件\" class=\"headerlink\" title=\"Systemd 的 Unit 文件\"></a><strong>Systemd 的 Unit 文件</strong></h2><p>Systemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）。</p>\n<p>在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。</p>\n<ol>\n<li>Systemd 支持的 12 种 Unit 文件类型</li>\n</ol>\n<ul>\n<li>.automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</li>\n<li>.device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系</li>\n<li>.mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件</li>\n<li>.path：用于监控指定目录或文件的变化，并触发其它 Unit 运行</li>\n<li>.scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</li>\n<li>.service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</li>\n<li>.slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件</li>\n<li>.snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照</li>\n<li>.socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动</li>\n<li>.swap：定义一个用户做虚拟内存的交换分区</li>\n<li>.target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式</li>\n<li>.timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能</li>\n</ul>\n<ol>\n<li>Systemd 目录</li>\n</ol>\n<p>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p>\n<ul>\n<li>/etc/systemd/system：系统或用户自定义的配置文件</li>\n<li>/run/systemd/system：软件运行时生成的配置文件</li>\n<li>/usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。<ul>\n<li>CentOS 7：Unit 文件指向该目录</li>\n<li>ubuntu 16：被移到了 /lib/systemd/system</li>\n</ul>\n</li>\n</ul>\n<p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p>\n<ol>\n<li>Unit 和 Target</li>\n</ol>\n<p>Unit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。</p>\n<p>Target 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。</p>\n<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p>\n<h2 id=\"Systemd-Service-Unit\"><a href=\"#Systemd-Service-Unit\" class=\"headerlink\" title=\"Systemd Service Unit\"></a><strong>Systemd Service Unit</strong></h2><h3 id=\"Unit-文件结构\"><a href=\"#Unit-文件结构\" class=\"headerlink\" title=\"Unit 文件结构\"></a><strong>Unit 文件结构</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Hello World</span><br><span class=\"line\">After=docker.service</span><br><span class=\"line\">Requires=docker.service</span><br><span class=\"line\">[Service]</span><br><span class=\"line\">TimeoutStartSec=<span class=\"number\">0</span></span><br><span class=\"line\">ExecStartPre=-<span class=\"regexp\">/usr/</span>bin/docker kill busybox1</span><br><span class=\"line\">ExecStartPre=-<span class=\"regexp\">/usr/</span>bin/docker rm busybox1</span><br><span class=\"line\">ExecStartPre=<span class=\"regexp\">/usr/</span>bin/docker pull busybox</span><br><span class=\"line\">ExecStart=<span class=\"regexp\">/usr/</span>bin/docker run --name busybox1 busybox /bin/ sh -c <span class=\"string\">\"while true; do echo Hello World; sleep 1; done\"</span></span><br><span class=\"line\">ExecStop=<span class=\"string\">\"/usr/bin/docker stop busybox1\"</span></span><br><span class=\"line\">ExecStopPost=<span class=\"string\">\"/usr/bin/docker rm busybox1\"</span></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p>如下所示，Systemd 服务的 Unit 文件可以分为三个配置区段：</p>\n<ul>\n<li>Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式</li>\n<li>Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法</li>\n</ul>\n<h4 id=\"Unit-段\"><a href=\"#Unit-段\" class=\"headerlink\" title=\"Unit 段\"></a><strong>Unit 段</strong></h4><ul>\n<li>Description：描述这个 Unit 文件的信息</li>\n<li>Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径</li>\n<li>Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止</li>\n<li>Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功</li>\n<li>After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务</li>\n<li>Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行</li>\n<li>Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启</li>\n<li>Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动</li>\n<li>OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块</li>\n<li>Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然</li>\n</ul>\n<h4 id=\"Install-段\"><a href=\"#Install-段\" class=\"headerlink\" title=\"Install 段\"></a><strong>Install 段</strong></h4><p>这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束：</p>\n<ul>\n<li>WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># find /etc/systemd/system/* -type d</span><br><span class=\"line\">/etc/systemd/system/<span class=\"keyword\">default</span>.target.wants</span><br><span class=\"line\">/etc/systemd/system/getty.target.wants</span><br><span class=\"line\">/etc/systemd/system/graphical.target.wants</span><br><span class=\"line\">/etc/systemd/system/multi-user.target.wants</span><br><span class=\"line\">/etc/systemd/system/network-online.target.wants</span><br><span class=\"line\">/etc/systemd/system/paths.target.wants</span><br><span class=\"line\">/etc/systemd/system/shutdown.target.wants</span><br><span class=\"line\">/etc/systemd/system/sockets.target.wants</span><br><span class=\"line\">/etc/systemd/system/sysinit.target.wants</span><br><span class=\"line\">/etc/systemd/system/timers.target.wants</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .required 后缀构成的子目录中</li>\n<li>Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit</li>\n<li>Alias：当前 Unit 可用于启动的别名</li>\n</ul>\n<ol>\n<li>SysV-init 运行级别与 Systemd Target 对应的 Unit 文件</li>\n</ol>\n<p><img src=\"https://ask.qcloudimg.com/http-save/yehe-5449090/mvna7qlr41.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>通过 systemctl list-units –type=target 命令可以获取当前正在使用的运行目标</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl list-units --type=target</span><br><span class=\"line\">UNIT                   LOAD   ACTIVE SUB    DESCRIPTION</span><br><span class=\"line\">basic.target           loaded active active Basic System</span><br><span class=\"line\">cryptsetup.target      loaded active active Encrypted Volumes</span><br><span class=\"line\">getty.target           loaded active active Login Prompts</span><br><span class=\"line\">graphical.target       loaded active active Graphical Interface</span><br><span class=\"line\">local-fs-pre.target    loaded active active Local File Systems (Pre)</span><br><span class=\"line\">local-fs.target        loaded active active Local File Systems</span><br><span class=\"line\">multi-user.target      loaded active active Multi-User System</span><br><span class=\"line\">network-online.target  loaded active active Network is Online</span><br><span class=\"line\">network.target         loaded active active Network</span><br><span class=\"line\">nss-user-lookup.target loaded active active User and Group Name Lookups</span><br><span class=\"line\">paths.target           loaded active active Paths</span><br><span class=\"line\">remote-fs-pre.target   loaded active active Remote File Systems (Pre)</span><br><span class=\"line\">remote-fs.target       loaded active active Remote File Systems</span><br><span class=\"line\">slices.target          loaded active active Slices</span><br><span class=\"line\">sockets.target         loaded active active Sockets</span><br><span class=\"line\">sound.target           loaded active active Sound Card</span><br><span class=\"line\">swap.target            loaded active active Swap</span><br><span class=\"line\">sysinit.target         loaded active active System Initialization</span><br><span class=\"line\">time-sync.target       loaded active active System Time Synchronized</span><br><span class=\"line\">timers.target          loaded active active Timers</span><br><span class=\"line\">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class=\"line\">ACTIVE = The high-level unit activation state, i.e. generalization <span class=\"keyword\">of</span> SUB.</span><br><span class=\"line\">SUB    = The low-level unit activation state, values depend on unit type.</span><br><span class=\"line\"><span class=\"number\">20</span> loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class=\"line\">To show all installed unit files use <span class=\"string\">'systemctl list-unit-files'</span>.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Service-段\"><a href=\"#Service-段\" class=\"headerlink\" title=\"Service 段\"></a><strong>Service 段</strong></h4><p>用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段分为服务生命周期和服务上下文配置两个方面。</p>\n<ol>\n<li>服务生命周期控制相关</li>\n</ol>\n<ul>\n<li>Type：定义启动时的进程行为，它有以下几种值：<ul>\n<li>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</li>\n<li>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>\n<li>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>\n<li>Type=dbus：当前服务通过D-Bus启动</li>\n<li>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</li>\n<li>Type=idle：若有其他任务执行完毕，当前服务才会运行</li>\n</ul>\n</li>\n<li>RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。</li>\n<li>ExecStart：启动当前服务的命令</li>\n<li>ExecStartPre：启动当前服务之前执行的命令</li>\n<li>ExecStartPos：启动当前服务之后执行的命令</li>\n<li>ExecReload：重启当前服务时执行的命令</li>\n<li>ExecStop：停止当前服务时执行的命令</li>\n<li>ExecStopPost：停止当其服务之后执行的命令</li>\n<li>RestartSec：自动重启当前服务间隔的秒数</li>\n<li>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li>\n<li>TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测</li>\n<li>TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程</li>\n</ul>\n<ol>\n<li>服务上下文配置相关</li>\n</ol>\n<ul>\n<li>Environment：为服务指定环境变量</li>\n<li>EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义</li>\n<li>Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级</li>\n<li>WorkingDirectory：指定服务的工作目录</li>\n<li>RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件</li>\n<li>User：指定运行服务的用户</li>\n<li>Group：指定运行服务的用户组</li>\n<li>MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private<ul>\n<li>shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上</li>\n<li>slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上</li>\n<li>private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上</li>\n</ul>\n</li>\n<li>LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等</li>\n</ul>\n<blockquote>\n<p>注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。</p>\n</blockquote>\n<h3 id=\"Unit-文件占位符和模板\"><a href=\"#Unit-文件占位符和模板\" class=\"headerlink\" title=\"Unit 文件占位符和模板\"></a><strong>Unit 文件占位符和模板</strong></h3><h4 id=\"Unit-文件占位符\"><a href=\"#Unit-文件占位符\" class=\"headerlink\" title=\"Unit 文件占位符\"></a><strong>Unit 文件占位符</strong></h4><p>在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行被动态地替换实际的值。</p>\n<ul>\n<li>%n：完整的 Unit 文件名字，包括 .service 后缀名</li>\n<li>%p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号</li>\n<li>%i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名</li>\n<li>%t：存放系统运行文件的目录，通常是 “run”</li>\n<li>%u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root</li>\n<li>%U：运行服务的用户 ID</li>\n<li>%h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值</li>\n<li>%s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值</li>\n<li>%m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用</li>\n<li>%b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变</li>\n<li>%H：实际运行节点的主机名</li>\n<li>%v：内核版本，即 “uname -r” 命令输出的内容</li>\n<li>%%：在 Unit 模板文件中表示一个普通的百分号</li>\n</ul>\n<h4 id=\"Unit-模板\"><a href=\"#Unit-模板\" class=\"headerlink\" title=\"Unit 模板\"></a><strong>Unit 模板</strong></h4><p>在现实中，往往有一些应用需要被复制多份运行。例如，用于同一个<a href=\"https://cloud.tencent.com/product/clb?from=10680\" target=\"_blank\" rel=\"noopener\">负载均衡</a>器分流的多个服务实例，或者为每个 SSH 连接建立一个独立的 sshd 服务进程。</p>\n<p>Unit 模板文件的写法与普通的服务 Unit 文件基本相同，不过 Unit 模板的文件名是以 @ 符号结尾的。通过模板启动服务实例时，需要在其文件名的 @ 字符后面附加一个参数字符串。</p>\n<ol>\n<li>示例：apache@.service</li>\n</ol>\n<ul>\n<li>apache@.service 模板</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=My Advanced Service Template</span><br><span class=\"line\">After=etcd.service docker.service</span><br><span class=\"line\">[Service]</span><br><span class=\"line\">TimeoutStartSec=<span class=\"number\">0</span></span><br><span class=\"line\">ExecStartPre=-<span class=\"regexp\">/usr/</span>bin/docker kill apache%i</span><br><span class=\"line\">ExecStartPre=-<span class=\"regexp\">/usr/</span>bin/docker rm apache%i</span><br><span class=\"line\">ExecStartPre=<span class=\"regexp\">/usr/</span>bin/docker pull coreos/apache</span><br><span class=\"line\">ExecStart=<span class=\"regexp\">/usr/</span>bin/docker run --name apache%i -p %i:<span class=\"number\">80</span> coreos/apache /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class=\"line\">ExecStartPost=<span class=\"regexp\">/usr/</span>bin/etcdctl <span class=\"keyword\">set</span> /domains/example.com/%H:%i running</span><br><span class=\"line\">ExecStop=/usr/bin/docker stop apache1</span><br><span class=\"line\">ExecStopPost=/usr/bin/docker rm apache1</span><br><span class=\"line\">ExecStopPost=/usr/bin/etcdctl rm /domains/example.com/%H:%i</span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>启动 Unit 模板的服务实例</li>\n</ul>\n<p>在服务启动时需要在 @ 后面放置一个用于区分服务实例的附加字符参数，通常这个参数用于监控的端口号或控制台 TTY 编译号。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl start apache@8080.service</span><br></pre></td></tr></table></figure>\n\n<p>Systemd 在运行服务时，总是会先尝试找到一个完整匹配的 Unit 文件，如果没有找到，才会尝试选择匹配模板。例如上面的命令，System 首先会在约定的目录下寻找名为 <a href=\"mailto:apache@8080.service\">apache@8080.service</a> 的文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 <a href=\"mailto:apache@8080.service\">apache@8080.service</a>，systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。</p>\n<h2 id=\"Systemd-的资源管理\"><a href=\"#Systemd-的资源管理\" class=\"headerlink\" title=\"Systemd 的资源管理\"></a><strong>Systemd 的资源管理</strong></h2><h3 id=\"Systemctl-命令\"><a href=\"#Systemctl-命令\" class=\"headerlink\" title=\"Systemctl 命令\"></a><strong>Systemctl 命令</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl --help</span><br><span class=\"line\">systemctl [OPTIONS...] &#123;COMMAND&#125; ...</span><br><span class=\"line\">Query or send control commands to the systemd manager.</span><br><span class=\"line\">  -h --help           Show <span class=\"keyword\">this</span> help</span><br><span class=\"line\">     --version        Show package version</span><br><span class=\"line\">     --system         Connect to system manager</span><br><span class=\"line\">  -H --host=[USER@]HOST</span><br><span class=\"line\">                      Operate on remote host</span><br><span class=\"line\">  -M --machine=CONTAINER</span><br><span class=\"line\">                      Operate on local container</span><br><span class=\"line\">  -t --type=TYPE      List units <span class=\"keyword\">of</span> a particular type</span><br><span class=\"line\">     --state=STATE    List units <span class=\"keyword\">with</span> particular LOAD or SUB or ACTIVE state</span><br><span class=\"line\">  -p --property=NAME  Show only properties by <span class=\"keyword\">this</span> name</span><br><span class=\"line\">  -a --all            Show all loaded units/properties, including dead/empty</span><br><span class=\"line\">                      ones. To list all units installed on the system, use</span><br><span class=\"line\">                      the <span class=\"string\">'list-unit-files'</span> command instead.</span><br><span class=\"line\">  -l --full           Don<span class=\"string\">'t ellipsize unit names on output</span></span><br><span class=\"line\"><span class=\"string\">  -r --recursive      Show unit list of host and local containers</span></span><br><span class=\"line\"><span class=\"string\">     --reverse        Show reverse dependencies with '</span>list-dependencies<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">     --job-mode=MODE  Specify how to deal with already queued jobs, when</span></span><br><span class=\"line\"><span class=\"string\">                      queueing a new job</span></span><br><span class=\"line\"><span class=\"string\">     --show-types     When showing sockets, explicitly show their type</span></span><br><span class=\"line\"><span class=\"string\">  -i --ignore-inhibitors</span></span><br><span class=\"line\"><span class=\"string\">                      When shutting down or sleeping, ignore inhibitors</span></span><br><span class=\"line\"><span class=\"string\">     --kill-who=WHO   Who to send signal to</span></span><br><span class=\"line\"><span class=\"string\">  -s --signal=SIGNAL  Which signal to send</span></span><br><span class=\"line\"><span class=\"string\">     --now            Start or stop unit in addition to enabling or disabling it</span></span><br><span class=\"line\"><span class=\"string\">  -q --quiet          Suppress output</span></span><br><span class=\"line\"><span class=\"string\">     --no-block       Do not wait until operation finished</span></span><br><span class=\"line\"><span class=\"string\">     --no-wall        Don'</span>t send wall message before halt/power-off/reboot</span><br><span class=\"line\">     --no-reload      Don<span class=\"string\">'t reload daemon after en-/dis-abling unit files</span></span><br><span class=\"line\"><span class=\"string\">     --no-legend      Do not print a legend (column headers and hints)</span></span><br><span class=\"line\"><span class=\"string\">     --no-pager       Do not pipe output into a pager</span></span><br><span class=\"line\"><span class=\"string\">     --no-ask-password</span></span><br><span class=\"line\"><span class=\"string\">                      Do not ask for system passwords</span></span><br><span class=\"line\"><span class=\"string\">     --global         Enable/disable unit files globally</span></span><br><span class=\"line\"><span class=\"string\">     --runtime        Enable unit files only temporarily until next reboot</span></span><br><span class=\"line\"><span class=\"string\">  -f --force          When enabling unit files, override existing symlinks</span></span><br><span class=\"line\"><span class=\"string\">                      When shutting down, execute action immediately</span></span><br><span class=\"line\"><span class=\"string\">     --preset-mode=   Apply only enable, only disable, or all presets</span></span><br><span class=\"line\"><span class=\"string\">     --root=PATH      Enable unit files in the specified root directory</span></span><br><span class=\"line\"><span class=\"string\">  -n --lines=INTEGER  Number of journal entries to show</span></span><br><span class=\"line\"><span class=\"string\">  -o --output=STRING  Change journal output mode (short, short-iso,</span></span><br><span class=\"line\"><span class=\"string\">                              short-precise, short-monotonic, verbose,</span></span><br><span class=\"line\"><span class=\"string\">                              export, json, json-pretty, json-sse, cat)</span></span><br><span class=\"line\"><span class=\"string\">     --plain          Print unit dependencies as a list instead of a tree</span></span><br><span class=\"line\"><span class=\"string\">Unit Commands:</span></span><br><span class=\"line\"><span class=\"string\">  list-units [PATTERN...]         List loaded units</span></span><br><span class=\"line\"><span class=\"string\">  list-sockets [PATTERN...]       List loaded sockets ordered by address</span></span><br><span class=\"line\"><span class=\"string\">  list-timers [PATTERN...]        List loaded timers ordered by next elapse</span></span><br><span class=\"line\"><span class=\"string\">  start NAME...                   Start (activate) one or more units</span></span><br><span class=\"line\"><span class=\"string\">  stop NAME...                    Stop (deactivate) one or more units</span></span><br><span class=\"line\"><span class=\"string\">  reload NAME...                  Reload one or more units</span></span><br><span class=\"line\"><span class=\"string\">  restart NAME...                 Start or restart one or more units</span></span><br><span class=\"line\"><span class=\"string\">  try-restart NAME...             Restart one or more units if active</span></span><br><span class=\"line\"><span class=\"string\">  reload-or-restart NAME...       Reload one or more units if possible,</span></span><br><span class=\"line\"><span class=\"string\">                                  otherwise start or restart</span></span><br><span class=\"line\"><span class=\"string\">  reload-or-try-restart NAME...   Reload one or more units if possible,</span></span><br><span class=\"line\"><span class=\"string\">                                  otherwise restart if active</span></span><br><span class=\"line\"><span class=\"string\">  isolate NAME                    Start one unit and stop all others</span></span><br><span class=\"line\"><span class=\"string\">  kill NAME...                    Send signal to processes of a unit</span></span><br><span class=\"line\"><span class=\"string\">  is-active PATTERN...            Check whether units are active</span></span><br><span class=\"line\"><span class=\"string\">  is-failed PATTERN...            Check whether units are failed</span></span><br><span class=\"line\"><span class=\"string\">  status [PATTERN...|PID...]      Show runtime status of one or more units</span></span><br><span class=\"line\"><span class=\"string\">  show [PATTERN...|JOB...]        Show properties of one or more</span></span><br><span class=\"line\"><span class=\"string\">                                  units/jobs or the manager</span></span><br><span class=\"line\"><span class=\"string\">  cat PATTERN...                  Show files and drop-ins of one or more units</span></span><br><span class=\"line\"><span class=\"string\">  set-property NAME ASSIGNMENT... Sets one or more properties of a unit</span></span><br><span class=\"line\"><span class=\"string\">  help PATTERN...|PID...          Show manual for one or more units</span></span><br><span class=\"line\"><span class=\"string\">  reset-failed [PATTERN...]       Reset failed state for all, one, or more</span></span><br><span class=\"line\"><span class=\"string\">                                  units</span></span><br><span class=\"line\"><span class=\"string\">  list-dependencies [NAME]        Recursively show units which are required</span></span><br><span class=\"line\"><span class=\"string\">                                  or wanted by this unit or by which this</span></span><br><span class=\"line\"><span class=\"string\">                                  unit is required or wanted</span></span><br><span class=\"line\"><span class=\"string\">Unit File Commands:</span></span><br><span class=\"line\"><span class=\"string\">  list-unit-files [PATTERN...]    List installed unit files</span></span><br><span class=\"line\"><span class=\"string\">  enable NAME...                  Enable one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">  disable NAME...                 Disable one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">  reenable NAME...                Reenable one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">  preset NAME...                  Enable/disable one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">                                  based on preset configuration</span></span><br><span class=\"line\"><span class=\"string\">  preset-all                      Enable/disable all unit files based on</span></span><br><span class=\"line\"><span class=\"string\">                                  preset configuration</span></span><br><span class=\"line\"><span class=\"string\">  is-enabled NAME...              Check whether unit files are enabled</span></span><br><span class=\"line\"><span class=\"string\">  mask NAME...                    Mask one or more units</span></span><br><span class=\"line\"><span class=\"string\">  unmask NAME...                  Unmask one or more units</span></span><br><span class=\"line\"><span class=\"string\">  link PATH...                    Link one or more units files into</span></span><br><span class=\"line\"><span class=\"string\">                                  the search path</span></span><br><span class=\"line\"><span class=\"string\">  add-wants TARGET NAME...        Add '</span>Wants<span class=\"string\">' dependency for the target</span></span><br><span class=\"line\"><span class=\"string\">                                  on specified one or more units</span></span><br><span class=\"line\"><span class=\"string\">  add-requires TARGET NAME...     Add '</span>Requires<span class=\"string\">' dependency for the target</span></span><br><span class=\"line\"><span class=\"string\">                                  on specified one or more units</span></span><br><span class=\"line\"><span class=\"string\">  edit NAME...                    Edit one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">  get-default                     Get the name of the default target</span></span><br><span class=\"line\"><span class=\"string\">  set-default NAME                Set the default target</span></span><br><span class=\"line\"><span class=\"string\">Machine Commands:</span></span><br><span class=\"line\"><span class=\"string\">  list-machines [PATTERN...]      List local containers and host</span></span><br><span class=\"line\"><span class=\"string\">Job Commands:</span></span><br><span class=\"line\"><span class=\"string\">  list-jobs [PATTERN...]          List jobs</span></span><br><span class=\"line\"><span class=\"string\">  cancel [JOB...]                 Cancel all, one, or more jobs</span></span><br><span class=\"line\"><span class=\"string\">Snapshot Commands:</span></span><br><span class=\"line\"><span class=\"string\">  snapshot [NAME]                 Create a snapshot</span></span><br><span class=\"line\"><span class=\"string\">  delete NAME...                  Remove one or more snapshots</span></span><br><span class=\"line\"><span class=\"string\">Environment Commands:</span></span><br><span class=\"line\"><span class=\"string\">  show-environment                Dump environment</span></span><br><span class=\"line\"><span class=\"string\">  set-environment NAME=VALUE...   Set one or more environment variables</span></span><br><span class=\"line\"><span class=\"string\">  unset-environment NAME...       Unset one or more environment variables</span></span><br><span class=\"line\"><span class=\"string\">  import-environment [NAME...]    Import all or some environment variables</span></span><br><span class=\"line\"><span class=\"string\">Manager Lifecycle Commands:</span></span><br><span class=\"line\"><span class=\"string\">  daemon-reload                   Reload systemd manager configuration</span></span><br><span class=\"line\"><span class=\"string\">  daemon-reexec                   Reexecute systemd manager</span></span><br><span class=\"line\"><span class=\"string\">System Commands:</span></span><br><span class=\"line\"><span class=\"string\">  is-system-running               Check whether system is fully running</span></span><br><span class=\"line\"><span class=\"string\">  default                         Enter system default mode</span></span><br><span class=\"line\"><span class=\"string\">  rescue                          Enter system rescue mode</span></span><br><span class=\"line\"><span class=\"string\">  emergency                       Enter system emergency mode</span></span><br><span class=\"line\"><span class=\"string\">  halt                            Shut down and halt the system</span></span><br><span class=\"line\"><span class=\"string\">  poweroff                        Shut down and power-off the system</span></span><br><span class=\"line\"><span class=\"string\">  reboot [ARG]                    Shut down and reboot the system</span></span><br><span class=\"line\"><span class=\"string\">  kexec                           Shut down and reboot the system with kexec</span></span><br><span class=\"line\"><span class=\"string\">  exit                            Request user instance exit</span></span><br><span class=\"line\"><span class=\"string\">  switch-root ROOT [INIT]         Change to a different root file system</span></span><br><span class=\"line\"><span class=\"string\">  suspend                         Suspend the system</span></span><br><span class=\"line\"><span class=\"string\">  hibernate                       Hibernate the system</span></span><br><span class=\"line\"><span class=\"string\">  hybrid-sleep                    Hibernate and suspend the system</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Unit-管理\"><a href=\"#Unit-管理\" class=\"headerlink\" title=\"Unit 管理\"></a><strong>Unit 管理</strong></h3><ol>\n<li>查看当前系统的所有 Unit</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出正在运行的 Unit</span><br><span class=\"line\">$ systemctl list-units</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span><br><span class=\"line\">$ systemctl list-units --all</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有没有运行的 Unit</span><br><span class=\"line\">$ systemctl list-units --all --state=inactive</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有加载失败的 Unit</span><br><span class=\"line\">$ systemctl list-units --failed</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有正在运行的、类型为 service 的 Unit</span><br><span class=\"line\">$ systemctl list-units --type=service</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看 Unit 配置文件的内容</span><br><span class=\"line\">$ systemctl cat docker.service</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>查看 Unit 的状态</li>\n</ol>\n<ul>\n<li>enabled：已建立启动链接</li>\n<li>disabled：没建立启动链接</li>\n<li>static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖</li>\n<li>masked：该配置文件被禁止建立启动链接</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示系统状态</span><br><span class=\"line\">$ systemctl status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示单个 Unit 的状态</span><br><span class=\"line\">$ ystemctl status bluetooth.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示远程主机的某个 Unit 的状态</span><br><span class=\"line\">$ systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Unit 的管理</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 立即启动一个服务</span><br><span class=\"line\">$ sudo systemctl start apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 立即停止一个服务</span><br><span class=\"line\">$ sudo systemctl stop apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启一个服务</span><br><span class=\"line\">$ sudo systemctl restart apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 杀死一个服务的所有子进程</span><br><span class=\"line\">$ sudo systemctl kill apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重新加载一个服务的配置文件</span><br><span class=\"line\">$ sudo systemctl reload apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重载所有修改过的配置文件</span><br><span class=\"line\">$ sudo systemctl daemon-reload</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 的所有底层参数</span><br><span class=\"line\">$ systemctl show httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 的指定属性的值</span><br><span class=\"line\">$ systemctl show -p CPUShares httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置某个 Unit 的指定属性</span><br><span class=\"line\">$ sudo systemctl <span class=\"keyword\">set</span>-property httpd.service CPUShares=500</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>查看 Unit 的依赖关系</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出一个 Unit 的所有依赖，默认不会列出 target 类型</span><br><span class=\"line\">$ systemctl list-dependencies nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出一个 Unit 的所有依赖，包括 target 类型</span><br><span class=\"line\">$ systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务的生命周期\"><a href=\"#服务的生命周期\" class=\"headerlink\" title=\"服务的生命周期\"></a><strong>服务的生命周期</strong></h3><p>当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。</p>\n<ol>\n<li>服务的激活</li>\n</ol>\n<ul>\n<li>systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中</li>\n<li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li>\n</ul>\n<ol>\n<li>服务的启动和停止</li>\n</ol>\n<ul>\n<li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li>\n<li>systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令</li>\n<li>systemctl restart：重启服务</li>\n<li>systemctl kill：立即杀死服务</li>\n</ul>\n<ol>\n<li>服务的开机启动和取消</li>\n</ol>\n<ul>\n<li>systemctl enable：除了激活服务以外，也可以置服务为开机启动</li>\n<li>systemctl disable：取消服务的开机启动</li>\n</ul>\n<ol>\n<li>服务的修改和移除</li>\n</ol>\n<ul>\n<li>systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件</li>\n<li>systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。</li>\n</ul>\n<h3 id=\"Target-管理\"><a href=\"#Target-管理\" class=\"headerlink\" title=\"Target 管理\"></a><strong>Target 管理</strong></h3><p>Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p>\n<p>在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看当前系统的所有 Target</span><br><span class=\"line\">$ systemctl list-unit-files --type=target</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看一个 Target 包含的所有 Unit</span><br><span class=\"line\">$ systemctl list-dependencies multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看启动时的默认 Target</span><br><span class=\"line\">$ systemctl <span class=\"keyword\">get</span>-default</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置启动时的默认 Target</span><br><span class=\"line\">$ sudo systemctl <span class=\"keyword\">set</span>-default multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程</span><br><span class=\"line\">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Target 与 SysV-init 进程的主要区别：</li>\n</ol>\n<ul>\n<li>默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</li>\n<li>启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。</li>\n<li>配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。</li>\n</ul>\n<h3 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a><strong>日志管理</strong></h3><p>Systemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。</p>\n<p>Systemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。</p>\n<p>默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span><br><span class=\"line\">$ sudo journalctl</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看内核日志（不显示应用日志）：--dmesg 或 -k</span><br><span class=\"line\">$ sudo journalctl -k</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b</span><br><span class=\"line\">$ sudo journalctl -b</span><br><span class=\"line\">$ sudo journalctl -b <span class=\"number\">-0</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 查看上一次启动的日志（需更改设置）</span><br><span class=\"line\">$ sudo journalctl -b <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定服务的日志：--unit 或 -u</span><br><span class=\"line\">$ sudo journalctl -u docker.servcie</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定服务的日志</span><br><span class=\"line\">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class=\"line\"></span><br><span class=\"line\"># 实时滚动显示最新日志</span><br><span class=\"line\">$ sudo journalctl -f</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定时间的日志</span><br><span class=\"line\">$ sudo journalctl --since=<span class=\"string\">\"2012-10-30 18:17:16\"</span></span><br><span class=\"line\">$ sudo journalctl --since <span class=\"string\">\"20 min ago\"</span></span><br><span class=\"line\">$ sudo journalctl --since yesterday</span><br><span class=\"line\">$ sudo journalctl --since <span class=\"string\">\"2015-01-10\"</span> --until <span class=\"string\">\"2015-01-11 03:00\"</span></span><br><span class=\"line\">$ sudo journalctl --since <span class=\"number\">09</span>:<span class=\"number\">00</span> --until <span class=\"string\">\"1 hour ago\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 显示尾部的最新 10 行日志：--lines 或 -n</span><br><span class=\"line\">$ sudo journalctl -n</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示尾部指定行数的日志</span><br><span class=\"line\">$ sudo journalctl -n <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 将最新的日志显示在前面</span><br><span class=\"line\">$ sudo journalctl -r -u docker.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 改变输出的格式：--output 或 -o</span><br><span class=\"line\">$ sudo journalctl -r -u docker.service -o json-pretty</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定进程的日志</span><br><span class=\"line\">$ sudo journalctl _PID=<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 查看某个路径的脚本的日志</span><br><span class=\"line\">$ sudo journalctl /usr/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定用户的日志</span><br><span class=\"line\">$ sudo journalctl _UID=<span class=\"number\">33</span> --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看某个 Unit 的日志</span><br><span class=\"line\">$ sudo journalctl -u nginx.service</span><br><span class=\"line\">$ sudo journalctl -u nginx.service --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 实时滚动显示某个 Unit 的最新日志</span><br><span class=\"line\">$ sudo journalctl -u nginx.service -f</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并显示多个 Unit 的日志</span><br><span class=\"line\">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定优先级（及其以上级别）的日志，共有 8 级</span><br><span class=\"line\"># 0: emerg</span><br><span class=\"line\"># 1: alert</span><br><span class=\"line\"># 2: crit</span><br><span class=\"line\"># 3: err</span><br><span class=\"line\"># 4: warning</span><br><span class=\"line\"># 5: notice</span><br><span class=\"line\"># 6: info</span><br><span class=\"line\"># 7: debug</span><br><span class=\"line\">$ sudo journalctl -p err -b</span><br><span class=\"line\"></span><br><span class=\"line\"># 日志默认分页输出，--no-pager 改为正常的标准输出</span><br><span class=\"line\">$ sudo journalctl --no-pager</span><br><span class=\"line\"></span><br><span class=\"line\"># 以 JSON 格式（单行）输出</span><br><span class=\"line\">$ sudo journalctl -b -u nginx.service -o json</span><br><span class=\"line\"></span><br><span class=\"line\"># 以 JSON 格式（多行）输出，可读性更好</span><br><span class=\"line\">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class=\"line\"> -o json-pretty</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示日志占据的硬盘空间</span><br><span class=\"line\">$ sudo journalctl --disk-usage</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件占据的最大空间</span><br><span class=\"line\">$ sudo journalctl --vacuum-size=<span class=\"number\">1</span>G</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件保存多久</span><br><span class=\"line\">$ sudo journalctl --vacuum-time=<span class=\"number\">1</span>years</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Systemd-工具集\"><a href=\"#Systemd-工具集\" class=\"headerlink\" title=\"Systemd 工具集\"></a><strong>Systemd 工具集</strong></h2><ul>\n<li>systemctl：用于检查和控制各种系统服务和资源的状态</li>\n<li>bootctl：用于查看和管理系统启动分区</li>\n<li>hostnamectl：用于查看和修改系统的主机名和主机信息</li>\n<li>journalctl：用于查看系统日志和各类应用服务日志</li>\n<li>localectl：用于查看和管理系统的地区信息</li>\n<li>loginctl：用于管理系统已登录用户和 Session 的信息</li>\n<li>machinectl：用于操作 Systemd 容器</li>\n<li>timedatectl：用于查看和管理系统的时间和时区信息</li>\n<li>systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈</li>\n<li>systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容</li>\n<li>systemd-cat：用于将其他命令的输出重定向到系统日志</li>\n<li>systemd-cgls：递归地显示指定 CGroup 的继承链</li>\n<li>systemd-cgtop：显示系统当前最耗资源的 CGroup 单元</li>\n<li>systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符</li>\n<li>systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库</li>\n<li>systemd-delta：对比当前系统配置与默认系统配置的差异</li>\n<li>systemd-detect-virt：显示主机的虚拟化类型</li>\n<li>systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件</li>\n<li>systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID</li>\n<li>systemd-notify：Systemd 的内部工具，用于通知服务的状态变化</li>\n<li>systemd-nspawn：用于创建 Systemd 容器</li>\n<li>systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置</li>\n<li>systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行</li>\n<li>systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线</li>\n<li>systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录</li>\n<li>systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求</li>\n</ul>\n<ol>\n<li>systemctl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 重启系统</span><br><span class=\"line\">$ sudo systemctl reboot</span><br><span class=\"line\"></span><br><span class=\"line\"># 关闭系统，切断电源</span><br><span class=\"line\">$ sudo systemctl poweroff</span><br><span class=\"line\"></span><br><span class=\"line\"># CPU停止工作</span><br><span class=\"line\">$ sudo systemctl halt</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂停系统</span><br><span class=\"line\">$ sudo systemctl suspend</span><br><span class=\"line\"></span><br><span class=\"line\"># 让系统进入冬眠状态</span><br><span class=\"line\">$ sudo systemctl hibernate</span><br><span class=\"line\"></span><br><span class=\"line\"># 让系统进入交互式休眠状态</span><br><span class=\"line\">$ sudo systemctl hybrid-sleep</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动进入救援状态（单用户状态）</span><br><span class=\"line\">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>systemd-analyze</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看启动耗时</span><br><span class=\"line\">$ systemd-analyze</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看每个服务的启动耗时</span><br><span class=\"line\">$ systemd-analyze blame</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示瀑布状的启动过程流</span><br><span class=\"line\">$ systemd-analyze critical-chain</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定服务的启动流</span><br><span class=\"line\">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>hostnamectl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前主机的信息</span><br><span class=\"line\">$ hostnamectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置主机名。</span><br><span class=\"line\">$ sudo hostnamectl <span class=\"keyword\">set</span>-hostname rhel7</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>timedatectl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看当前时区设置</span><br><span class=\"line\">$ timedatectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有可用的时区</span><br><span class=\"line\">$ timedatectl list-timezones</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置当前时区</span><br><span class=\"line\">$ sudo timedatectl <span class=\"keyword\">set</span>-timezone America/New_York</span><br><span class=\"line\">$ sudo timedatectl <span class=\"keyword\">set</span>-time YYYY-MM-DD</span><br><span class=\"line\">$ sudo timedatectl <span class=\"keyword\">set</span>-time HH:MM:SS</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>loginctl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出当前 session</span><br><span class=\"line\">$ loginctl list-sessions</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出当前登录用户</span><br><span class=\"line\">$ loginctl list-users</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出显示指定用户的信息</span><br><span class=\"line\">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>systemd-ask-password</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ PASSWORD=$(systemd-ask-password <span class=\"string\">\"Input Your Passowrd:\"</span>)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>systemd-run</li>\n</ol>\n<p>systemd-run 可以将一个指定的操作变成后台运行的服务。它的效果似乎与直接在命令后加上表示后台运行的 &amp; 符号很相似。然而，它让命令成为服务还意味着，它的生命周期将由 Systemd 控制。具体来说，包括以下好处：</p>\n<ul>\n<li>服务的生命击期由 Systemd 接管，不会随着启动它的控制台关闭而结束</li>\n<li>可以通过 systemctl 工具管理服务的状态</li>\n<li>可以通过 journalctl 工具查看和管理服务的日志信息</li>\n<li>可以通过 Systemd 提供的方法限制服务的 CPU、内存、磁盘 IO 等系统资源的使用情况。</li>\n</ul>\n","site":{"data":{"next":{"language":"zh-Hans","duoshuo":{"enable":true,"shortname":"your-duoshuo-shortname"},"menu":{"home":"/","about":"/about || user","tags":"/tags","categories":"/categories","archives":"/archives","schedule":"/schedule","sitemap":"/sitemap.xml","commonweal":"/404"}},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>[TOC]</p>\n<h2 id=\"Systemd-概述\"><a href=\"#Systemd-概述\" class=\"headerlink\" title=\"Systemd 概述\"></a><strong>Systemd 概述</strong></h2><h3 id=\"Systemd-简介\"><a href=\"#Systemd-简介\" class=\"headerlink\" title=\"Systemd 简介\"></a><strong>Systemd 简介</strong></h3><p>Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。</p>\n<p>Systemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。</p>\n<ol>\n<li>更少的进程</li>\n</ol>\n<p>Systemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。</p>\n<ol>\n<li>允许更多的进程并行启动</li>\n</ol>\n<p>在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。</p>\n<ol>\n<li>使用 CGroup 跟踪和管理进程的生命周期</li>\n</ol>\n<p>在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。</p>\n<p>而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。</p>\n<ol>\n<li>统一管理服务日志</li>\n</ol>\n<p>Systemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。</p>\n<h3 id=\"Systemd-架构\"><a href=\"#Systemd-架构\" class=\"headerlink\" title=\"Systemd 架构\"></a><strong>Systemd 架构</strong></h3><p><img src=\"https://ask.qcloudimg.com/http-save/yehe-5449090/97kx52pwuj.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2 id=\"Systemd-的-Unit-文件\"><a href=\"#Systemd-的-Unit-文件\" class=\"headerlink\" title=\"Systemd 的 Unit 文件\"></a><strong>Systemd 的 Unit 文件</strong></h2><p>Systemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）。</p>\n<p>在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。</p>\n<ol>\n<li>Systemd 支持的 12 种 Unit 文件类型</li>\n</ol>\n<ul>\n<li>.automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</li>\n<li>.device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系</li>\n<li>.mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件</li>\n<li>.path：用于监控指定目录或文件的变化，并触发其它 Unit 运行</li>\n<li>.scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</li>\n<li>.service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</li>\n<li>.slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件</li>\n<li>.snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照</li>\n<li>.socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动</li>\n<li>.swap：定义一个用户做虚拟内存的交换分区</li>\n<li>.target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式</li>\n<li>.timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能</li>\n</ul>\n<ol>\n<li>Systemd 目录</li>\n</ol>\n<p>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p>\n<ul>\n<li>/etc/systemd/system：系统或用户自定义的配置文件</li>\n<li>/run/systemd/system：软件运行时生成的配置文件</li>\n<li>/usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。<ul>\n<li>CentOS 7：Unit 文件指向该目录</li>\n<li>ubuntu 16：被移到了 /lib/systemd/system</li>\n</ul>\n</li>\n</ul>\n<p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p>\n<ol>\n<li>Unit 和 Target</li>\n</ol>\n<p>Unit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。</p>\n<p>Target 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。</p>\n<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p>\n<h2 id=\"Systemd-Service-Unit\"><a href=\"#Systemd-Service-Unit\" class=\"headerlink\" title=\"Systemd Service Unit\"></a><strong>Systemd Service Unit</strong></h2><h3 id=\"Unit-文件结构\"><a href=\"#Unit-文件结构\" class=\"headerlink\" title=\"Unit 文件结构\"></a><strong>Unit 文件结构</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Hello World</span><br><span class=\"line\">After=docker.service</span><br><span class=\"line\">Requires=docker.service</span><br><span class=\"line\">[Service]</span><br><span class=\"line\">TimeoutStartSec=<span class=\"number\">0</span></span><br><span class=\"line\">ExecStartPre=-<span class=\"regexp\">/usr/</span>bin/docker kill busybox1</span><br><span class=\"line\">ExecStartPre=-<span class=\"regexp\">/usr/</span>bin/docker rm busybox1</span><br><span class=\"line\">ExecStartPre=<span class=\"regexp\">/usr/</span>bin/docker pull busybox</span><br><span class=\"line\">ExecStart=<span class=\"regexp\">/usr/</span>bin/docker run --name busybox1 busybox /bin/ sh -c <span class=\"string\">\"while true; do echo Hello World; sleep 1; done\"</span></span><br><span class=\"line\">ExecStop=<span class=\"string\">\"/usr/bin/docker stop busybox1\"</span></span><br><span class=\"line\">ExecStopPost=<span class=\"string\">\"/usr/bin/docker rm busybox1\"</span></span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p>如下所示，Systemd 服务的 Unit 文件可以分为三个配置区段：</p>\n<ul>\n<li>Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式</li>\n<li>Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法</li>\n</ul>\n<h4 id=\"Unit-段\"><a href=\"#Unit-段\" class=\"headerlink\" title=\"Unit 段\"></a><strong>Unit 段</strong></h4><ul>\n<li>Description：描述这个 Unit 文件的信息</li>\n<li>Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径</li>\n<li>Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止</li>\n<li>Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功</li>\n<li>After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务</li>\n<li>Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行</li>\n<li>Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启</li>\n<li>Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动</li>\n<li>OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块</li>\n<li>Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然</li>\n</ul>\n<h4 id=\"Install-段\"><a href=\"#Install-段\" class=\"headerlink\" title=\"Install 段\"></a><strong>Install 段</strong></h4><p>这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束：</p>\n<ul>\n<li>WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># find /etc/systemd/system/* -type d</span><br><span class=\"line\">/etc/systemd/system/<span class=\"keyword\">default</span>.target.wants</span><br><span class=\"line\">/etc/systemd/system/getty.target.wants</span><br><span class=\"line\">/etc/systemd/system/graphical.target.wants</span><br><span class=\"line\">/etc/systemd/system/multi-user.target.wants</span><br><span class=\"line\">/etc/systemd/system/network-online.target.wants</span><br><span class=\"line\">/etc/systemd/system/paths.target.wants</span><br><span class=\"line\">/etc/systemd/system/shutdown.target.wants</span><br><span class=\"line\">/etc/systemd/system/sockets.target.wants</span><br><span class=\"line\">/etc/systemd/system/sysinit.target.wants</span><br><span class=\"line\">/etc/systemd/system/timers.target.wants</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .required 后缀构成的子目录中</li>\n<li>Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit</li>\n<li>Alias：当前 Unit 可用于启动的别名</li>\n</ul>\n<ol>\n<li>SysV-init 运行级别与 Systemd Target 对应的 Unit 文件</li>\n</ol>\n<p><img src=\"https://ask.qcloudimg.com/http-save/yehe-5449090/mvna7qlr41.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>通过 systemctl list-units –type=target 命令可以获取当前正在使用的运行目标</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl list-units --type=target</span><br><span class=\"line\">UNIT                   LOAD   ACTIVE SUB    DESCRIPTION</span><br><span class=\"line\">basic.target           loaded active active Basic System</span><br><span class=\"line\">cryptsetup.target      loaded active active Encrypted Volumes</span><br><span class=\"line\">getty.target           loaded active active Login Prompts</span><br><span class=\"line\">graphical.target       loaded active active Graphical Interface</span><br><span class=\"line\">local-fs-pre.target    loaded active active Local File Systems (Pre)</span><br><span class=\"line\">local-fs.target        loaded active active Local File Systems</span><br><span class=\"line\">multi-user.target      loaded active active Multi-User System</span><br><span class=\"line\">network-online.target  loaded active active Network is Online</span><br><span class=\"line\">network.target         loaded active active Network</span><br><span class=\"line\">nss-user-lookup.target loaded active active User and Group Name Lookups</span><br><span class=\"line\">paths.target           loaded active active Paths</span><br><span class=\"line\">remote-fs-pre.target   loaded active active Remote File Systems (Pre)</span><br><span class=\"line\">remote-fs.target       loaded active active Remote File Systems</span><br><span class=\"line\">slices.target          loaded active active Slices</span><br><span class=\"line\">sockets.target         loaded active active Sockets</span><br><span class=\"line\">sound.target           loaded active active Sound Card</span><br><span class=\"line\">swap.target            loaded active active Swap</span><br><span class=\"line\">sysinit.target         loaded active active System Initialization</span><br><span class=\"line\">time-sync.target       loaded active active System Time Synchronized</span><br><span class=\"line\">timers.target          loaded active active Timers</span><br><span class=\"line\">LOAD   = Reflects whether the unit definition was properly loaded.</span><br><span class=\"line\">ACTIVE = The high-level unit activation state, i.e. generalization <span class=\"keyword\">of</span> SUB.</span><br><span class=\"line\">SUB    = The low-level unit activation state, values depend on unit type.</span><br><span class=\"line\"><span class=\"number\">20</span> loaded units listed. Pass --all to see loaded but inactive units, too.</span><br><span class=\"line\">To show all installed unit files use <span class=\"string\">'systemctl list-unit-files'</span>.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Service-段\"><a href=\"#Service-段\" class=\"headerlink\" title=\"Service 段\"></a><strong>Service 段</strong></h4><p>用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段分为服务生命周期和服务上下文配置两个方面。</p>\n<ol>\n<li>服务生命周期控制相关</li>\n</ol>\n<ul>\n<li>Type：定义启动时的进程行为，它有以下几种值：<ul>\n<li>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</li>\n<li>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>\n<li>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>\n<li>Type=dbus：当前服务通过D-Bus启动</li>\n<li>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</li>\n<li>Type=idle：若有其他任务执行完毕，当前服务才会运行</li>\n</ul>\n</li>\n<li>RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。</li>\n<li>ExecStart：启动当前服务的命令</li>\n<li>ExecStartPre：启动当前服务之前执行的命令</li>\n<li>ExecStartPos：启动当前服务之后执行的命令</li>\n<li>ExecReload：重启当前服务时执行的命令</li>\n<li>ExecStop：停止当前服务时执行的命令</li>\n<li>ExecStopPost：停止当其服务之后执行的命令</li>\n<li>RestartSec：自动重启当前服务间隔的秒数</li>\n<li>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li>\n<li>TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测</li>\n<li>TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程</li>\n</ul>\n<ol>\n<li>服务上下文配置相关</li>\n</ol>\n<ul>\n<li>Environment：为服务指定环境变量</li>\n<li>EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义</li>\n<li>Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级</li>\n<li>WorkingDirectory：指定服务的工作目录</li>\n<li>RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件</li>\n<li>User：指定运行服务的用户</li>\n<li>Group：指定运行服务的用户组</li>\n<li>MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private<ul>\n<li>shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上</li>\n<li>slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上</li>\n<li>private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上</li>\n</ul>\n</li>\n<li>LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等</li>\n</ul>\n<blockquote>\n<p>注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。</p>\n</blockquote>\n<h3 id=\"Unit-文件占位符和模板\"><a href=\"#Unit-文件占位符和模板\" class=\"headerlink\" title=\"Unit 文件占位符和模板\"></a><strong>Unit 文件占位符和模板</strong></h3><h4 id=\"Unit-文件占位符\"><a href=\"#Unit-文件占位符\" class=\"headerlink\" title=\"Unit 文件占位符\"></a><strong>Unit 文件占位符</strong></h4><p>在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行被动态地替换实际的值。</p>\n<ul>\n<li>%n：完整的 Unit 文件名字，包括 .service 后缀名</li>\n<li>%p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号</li>\n<li>%i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名</li>\n<li>%t：存放系统运行文件的目录，通常是 “run”</li>\n<li>%u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root</li>\n<li>%U：运行服务的用户 ID</li>\n<li>%h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值</li>\n<li>%s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值</li>\n<li>%m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用</li>\n<li>%b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变</li>\n<li>%H：实际运行节点的主机名</li>\n<li>%v：内核版本，即 “uname -r” 命令输出的内容</li>\n<li>%%：在 Unit 模板文件中表示一个普通的百分号</li>\n</ul>\n<h4 id=\"Unit-模板\"><a href=\"#Unit-模板\" class=\"headerlink\" title=\"Unit 模板\"></a><strong>Unit 模板</strong></h4><p>在现实中，往往有一些应用需要被复制多份运行。例如，用于同一个<a href=\"https://cloud.tencent.com/product/clb?from=10680\" target=\"_blank\" rel=\"noopener\">负载均衡</a>器分流的多个服务实例，或者为每个 SSH 连接建立一个独立的 sshd 服务进程。</p>\n<p>Unit 模板文件的写法与普通的服务 Unit 文件基本相同，不过 Unit 模板的文件名是以 @ 符号结尾的。通过模板启动服务实例时，需要在其文件名的 @ 字符后面附加一个参数字符串。</p>\n<ol>\n<li>示例：apache@.service</li>\n</ol>\n<ul>\n<li>apache@.service 模板</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=My Advanced Service Template</span><br><span class=\"line\">After=etcd.service docker.service</span><br><span class=\"line\">[Service]</span><br><span class=\"line\">TimeoutStartSec=<span class=\"number\">0</span></span><br><span class=\"line\">ExecStartPre=-<span class=\"regexp\">/usr/</span>bin/docker kill apache%i</span><br><span class=\"line\">ExecStartPre=-<span class=\"regexp\">/usr/</span>bin/docker rm apache%i</span><br><span class=\"line\">ExecStartPre=<span class=\"regexp\">/usr/</span>bin/docker pull coreos/apache</span><br><span class=\"line\">ExecStart=<span class=\"regexp\">/usr/</span>bin/docker run --name apache%i -p %i:<span class=\"number\">80</span> coreos/apache /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class=\"line\">ExecStartPost=<span class=\"regexp\">/usr/</span>bin/etcdctl <span class=\"keyword\">set</span> /domains/example.com/%H:%i running</span><br><span class=\"line\">ExecStop=/usr/bin/docker stop apache1</span><br><span class=\"line\">ExecStopPost=/usr/bin/docker rm apache1</span><br><span class=\"line\">ExecStopPost=/usr/bin/etcdctl rm /domains/example.com/%H:%i</span><br><span class=\"line\">[Install]</span><br><span class=\"line\">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>启动 Unit 模板的服务实例</li>\n</ul>\n<p>在服务启动时需要在 @ 后面放置一个用于区分服务实例的附加字符参数，通常这个参数用于监控的端口号或控制台 TTY 编译号。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl start apache@8080.service</span><br></pre></td></tr></table></figure>\n\n<p>Systemd 在运行服务时，总是会先尝试找到一个完整匹配的 Unit 文件，如果没有找到，才会尝试选择匹配模板。例如上面的命令，System 首先会在约定的目录下寻找名为 <a href=\"mailto:apache@8080.service\">apache@8080.service</a> 的文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 <a href=\"mailto:apache@8080.service\">apache@8080.service</a>，systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。</p>\n<h2 id=\"Systemd-的资源管理\"><a href=\"#Systemd-的资源管理\" class=\"headerlink\" title=\"Systemd 的资源管理\"></a><strong>Systemd 的资源管理</strong></h2><h3 id=\"Systemctl-命令\"><a href=\"#Systemctl-命令\" class=\"headerlink\" title=\"Systemctl 命令\"></a><strong>Systemctl 命令</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># systemctl --help</span><br><span class=\"line\">systemctl [OPTIONS...] &#123;COMMAND&#125; ...</span><br><span class=\"line\">Query or send control commands to the systemd manager.</span><br><span class=\"line\">  -h --help           Show <span class=\"keyword\">this</span> help</span><br><span class=\"line\">     --version        Show package version</span><br><span class=\"line\">     --system         Connect to system manager</span><br><span class=\"line\">  -H --host=[USER@]HOST</span><br><span class=\"line\">                      Operate on remote host</span><br><span class=\"line\">  -M --machine=CONTAINER</span><br><span class=\"line\">                      Operate on local container</span><br><span class=\"line\">  -t --type=TYPE      List units <span class=\"keyword\">of</span> a particular type</span><br><span class=\"line\">     --state=STATE    List units <span class=\"keyword\">with</span> particular LOAD or SUB or ACTIVE state</span><br><span class=\"line\">  -p --property=NAME  Show only properties by <span class=\"keyword\">this</span> name</span><br><span class=\"line\">  -a --all            Show all loaded units/properties, including dead/empty</span><br><span class=\"line\">                      ones. To list all units installed on the system, use</span><br><span class=\"line\">                      the <span class=\"string\">'list-unit-files'</span> command instead.</span><br><span class=\"line\">  -l --full           Don<span class=\"string\">'t ellipsize unit names on output</span></span><br><span class=\"line\"><span class=\"string\">  -r --recursive      Show unit list of host and local containers</span></span><br><span class=\"line\"><span class=\"string\">     --reverse        Show reverse dependencies with '</span>list-dependencies<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">     --job-mode=MODE  Specify how to deal with already queued jobs, when</span></span><br><span class=\"line\"><span class=\"string\">                      queueing a new job</span></span><br><span class=\"line\"><span class=\"string\">     --show-types     When showing sockets, explicitly show their type</span></span><br><span class=\"line\"><span class=\"string\">  -i --ignore-inhibitors</span></span><br><span class=\"line\"><span class=\"string\">                      When shutting down or sleeping, ignore inhibitors</span></span><br><span class=\"line\"><span class=\"string\">     --kill-who=WHO   Who to send signal to</span></span><br><span class=\"line\"><span class=\"string\">  -s --signal=SIGNAL  Which signal to send</span></span><br><span class=\"line\"><span class=\"string\">     --now            Start or stop unit in addition to enabling or disabling it</span></span><br><span class=\"line\"><span class=\"string\">  -q --quiet          Suppress output</span></span><br><span class=\"line\"><span class=\"string\">     --no-block       Do not wait until operation finished</span></span><br><span class=\"line\"><span class=\"string\">     --no-wall        Don'</span>t send wall message before halt/power-off/reboot</span><br><span class=\"line\">     --no-reload      Don<span class=\"string\">'t reload daemon after en-/dis-abling unit files</span></span><br><span class=\"line\"><span class=\"string\">     --no-legend      Do not print a legend (column headers and hints)</span></span><br><span class=\"line\"><span class=\"string\">     --no-pager       Do not pipe output into a pager</span></span><br><span class=\"line\"><span class=\"string\">     --no-ask-password</span></span><br><span class=\"line\"><span class=\"string\">                      Do not ask for system passwords</span></span><br><span class=\"line\"><span class=\"string\">     --global         Enable/disable unit files globally</span></span><br><span class=\"line\"><span class=\"string\">     --runtime        Enable unit files only temporarily until next reboot</span></span><br><span class=\"line\"><span class=\"string\">  -f --force          When enabling unit files, override existing symlinks</span></span><br><span class=\"line\"><span class=\"string\">                      When shutting down, execute action immediately</span></span><br><span class=\"line\"><span class=\"string\">     --preset-mode=   Apply only enable, only disable, or all presets</span></span><br><span class=\"line\"><span class=\"string\">     --root=PATH      Enable unit files in the specified root directory</span></span><br><span class=\"line\"><span class=\"string\">  -n --lines=INTEGER  Number of journal entries to show</span></span><br><span class=\"line\"><span class=\"string\">  -o --output=STRING  Change journal output mode (short, short-iso,</span></span><br><span class=\"line\"><span class=\"string\">                              short-precise, short-monotonic, verbose,</span></span><br><span class=\"line\"><span class=\"string\">                              export, json, json-pretty, json-sse, cat)</span></span><br><span class=\"line\"><span class=\"string\">     --plain          Print unit dependencies as a list instead of a tree</span></span><br><span class=\"line\"><span class=\"string\">Unit Commands:</span></span><br><span class=\"line\"><span class=\"string\">  list-units [PATTERN...]         List loaded units</span></span><br><span class=\"line\"><span class=\"string\">  list-sockets [PATTERN...]       List loaded sockets ordered by address</span></span><br><span class=\"line\"><span class=\"string\">  list-timers [PATTERN...]        List loaded timers ordered by next elapse</span></span><br><span class=\"line\"><span class=\"string\">  start NAME...                   Start (activate) one or more units</span></span><br><span class=\"line\"><span class=\"string\">  stop NAME...                    Stop (deactivate) one or more units</span></span><br><span class=\"line\"><span class=\"string\">  reload NAME...                  Reload one or more units</span></span><br><span class=\"line\"><span class=\"string\">  restart NAME...                 Start or restart one or more units</span></span><br><span class=\"line\"><span class=\"string\">  try-restart NAME...             Restart one or more units if active</span></span><br><span class=\"line\"><span class=\"string\">  reload-or-restart NAME...       Reload one or more units if possible,</span></span><br><span class=\"line\"><span class=\"string\">                                  otherwise start or restart</span></span><br><span class=\"line\"><span class=\"string\">  reload-or-try-restart NAME...   Reload one or more units if possible,</span></span><br><span class=\"line\"><span class=\"string\">                                  otherwise restart if active</span></span><br><span class=\"line\"><span class=\"string\">  isolate NAME                    Start one unit and stop all others</span></span><br><span class=\"line\"><span class=\"string\">  kill NAME...                    Send signal to processes of a unit</span></span><br><span class=\"line\"><span class=\"string\">  is-active PATTERN...            Check whether units are active</span></span><br><span class=\"line\"><span class=\"string\">  is-failed PATTERN...            Check whether units are failed</span></span><br><span class=\"line\"><span class=\"string\">  status [PATTERN...|PID...]      Show runtime status of one or more units</span></span><br><span class=\"line\"><span class=\"string\">  show [PATTERN...|JOB...]        Show properties of one or more</span></span><br><span class=\"line\"><span class=\"string\">                                  units/jobs or the manager</span></span><br><span class=\"line\"><span class=\"string\">  cat PATTERN...                  Show files and drop-ins of one or more units</span></span><br><span class=\"line\"><span class=\"string\">  set-property NAME ASSIGNMENT... Sets one or more properties of a unit</span></span><br><span class=\"line\"><span class=\"string\">  help PATTERN...|PID...          Show manual for one or more units</span></span><br><span class=\"line\"><span class=\"string\">  reset-failed [PATTERN...]       Reset failed state for all, one, or more</span></span><br><span class=\"line\"><span class=\"string\">                                  units</span></span><br><span class=\"line\"><span class=\"string\">  list-dependencies [NAME]        Recursively show units which are required</span></span><br><span class=\"line\"><span class=\"string\">                                  or wanted by this unit or by which this</span></span><br><span class=\"line\"><span class=\"string\">                                  unit is required or wanted</span></span><br><span class=\"line\"><span class=\"string\">Unit File Commands:</span></span><br><span class=\"line\"><span class=\"string\">  list-unit-files [PATTERN...]    List installed unit files</span></span><br><span class=\"line\"><span class=\"string\">  enable NAME...                  Enable one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">  disable NAME...                 Disable one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">  reenable NAME...                Reenable one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">  preset NAME...                  Enable/disable one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">                                  based on preset configuration</span></span><br><span class=\"line\"><span class=\"string\">  preset-all                      Enable/disable all unit files based on</span></span><br><span class=\"line\"><span class=\"string\">                                  preset configuration</span></span><br><span class=\"line\"><span class=\"string\">  is-enabled NAME...              Check whether unit files are enabled</span></span><br><span class=\"line\"><span class=\"string\">  mask NAME...                    Mask one or more units</span></span><br><span class=\"line\"><span class=\"string\">  unmask NAME...                  Unmask one or more units</span></span><br><span class=\"line\"><span class=\"string\">  link PATH...                    Link one or more units files into</span></span><br><span class=\"line\"><span class=\"string\">                                  the search path</span></span><br><span class=\"line\"><span class=\"string\">  add-wants TARGET NAME...        Add '</span>Wants<span class=\"string\">' dependency for the target</span></span><br><span class=\"line\"><span class=\"string\">                                  on specified one or more units</span></span><br><span class=\"line\"><span class=\"string\">  add-requires TARGET NAME...     Add '</span>Requires<span class=\"string\">' dependency for the target</span></span><br><span class=\"line\"><span class=\"string\">                                  on specified one or more units</span></span><br><span class=\"line\"><span class=\"string\">  edit NAME...                    Edit one or more unit files</span></span><br><span class=\"line\"><span class=\"string\">  get-default                     Get the name of the default target</span></span><br><span class=\"line\"><span class=\"string\">  set-default NAME                Set the default target</span></span><br><span class=\"line\"><span class=\"string\">Machine Commands:</span></span><br><span class=\"line\"><span class=\"string\">  list-machines [PATTERN...]      List local containers and host</span></span><br><span class=\"line\"><span class=\"string\">Job Commands:</span></span><br><span class=\"line\"><span class=\"string\">  list-jobs [PATTERN...]          List jobs</span></span><br><span class=\"line\"><span class=\"string\">  cancel [JOB...]                 Cancel all, one, or more jobs</span></span><br><span class=\"line\"><span class=\"string\">Snapshot Commands:</span></span><br><span class=\"line\"><span class=\"string\">  snapshot [NAME]                 Create a snapshot</span></span><br><span class=\"line\"><span class=\"string\">  delete NAME...                  Remove one or more snapshots</span></span><br><span class=\"line\"><span class=\"string\">Environment Commands:</span></span><br><span class=\"line\"><span class=\"string\">  show-environment                Dump environment</span></span><br><span class=\"line\"><span class=\"string\">  set-environment NAME=VALUE...   Set one or more environment variables</span></span><br><span class=\"line\"><span class=\"string\">  unset-environment NAME...       Unset one or more environment variables</span></span><br><span class=\"line\"><span class=\"string\">  import-environment [NAME...]    Import all or some environment variables</span></span><br><span class=\"line\"><span class=\"string\">Manager Lifecycle Commands:</span></span><br><span class=\"line\"><span class=\"string\">  daemon-reload                   Reload systemd manager configuration</span></span><br><span class=\"line\"><span class=\"string\">  daemon-reexec                   Reexecute systemd manager</span></span><br><span class=\"line\"><span class=\"string\">System Commands:</span></span><br><span class=\"line\"><span class=\"string\">  is-system-running               Check whether system is fully running</span></span><br><span class=\"line\"><span class=\"string\">  default                         Enter system default mode</span></span><br><span class=\"line\"><span class=\"string\">  rescue                          Enter system rescue mode</span></span><br><span class=\"line\"><span class=\"string\">  emergency                       Enter system emergency mode</span></span><br><span class=\"line\"><span class=\"string\">  halt                            Shut down and halt the system</span></span><br><span class=\"line\"><span class=\"string\">  poweroff                        Shut down and power-off the system</span></span><br><span class=\"line\"><span class=\"string\">  reboot [ARG]                    Shut down and reboot the system</span></span><br><span class=\"line\"><span class=\"string\">  kexec                           Shut down and reboot the system with kexec</span></span><br><span class=\"line\"><span class=\"string\">  exit                            Request user instance exit</span></span><br><span class=\"line\"><span class=\"string\">  switch-root ROOT [INIT]         Change to a different root file system</span></span><br><span class=\"line\"><span class=\"string\">  suspend                         Suspend the system</span></span><br><span class=\"line\"><span class=\"string\">  hibernate                       Hibernate the system</span></span><br><span class=\"line\"><span class=\"string\">  hybrid-sleep                    Hibernate and suspend the system</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Unit-管理\"><a href=\"#Unit-管理\" class=\"headerlink\" title=\"Unit 管理\"></a><strong>Unit 管理</strong></h3><ol>\n<li>查看当前系统的所有 Unit</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出正在运行的 Unit</span><br><span class=\"line\">$ systemctl list-units</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span><br><span class=\"line\">$ systemctl list-units --all</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有没有运行的 Unit</span><br><span class=\"line\">$ systemctl list-units --all --state=inactive</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有加载失败的 Unit</span><br><span class=\"line\">$ systemctl list-units --failed</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有正在运行的、类型为 service 的 Unit</span><br><span class=\"line\">$ systemctl list-units --type=service</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看 Unit 配置文件的内容</span><br><span class=\"line\">$ systemctl cat docker.service</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>查看 Unit 的状态</li>\n</ol>\n<ul>\n<li>enabled：已建立启动链接</li>\n<li>disabled：没建立启动链接</li>\n<li>static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖</li>\n<li>masked：该配置文件被禁止建立启动链接</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示系统状态</span><br><span class=\"line\">$ systemctl status</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示单个 Unit 的状态</span><br><span class=\"line\">$ ystemctl status bluetooth.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示远程主机的某个 Unit 的状态</span><br><span class=\"line\">$ systemctl -H root@rhel7.example.com status httpd.service</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Unit 的管理</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 立即启动一个服务</span><br><span class=\"line\">$ sudo systemctl start apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 立即停止一个服务</span><br><span class=\"line\">$ sudo systemctl stop apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重启一个服务</span><br><span class=\"line\">$ sudo systemctl restart apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 杀死一个服务的所有子进程</span><br><span class=\"line\">$ sudo systemctl kill apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重新加载一个服务的配置文件</span><br><span class=\"line\">$ sudo systemctl reload apache.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 重载所有修改过的配置文件</span><br><span class=\"line\">$ sudo systemctl daemon-reload</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 的所有底层参数</span><br><span class=\"line\">$ systemctl show httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示某个 Unit 的指定属性的值</span><br><span class=\"line\">$ systemctl show -p CPUShares httpd.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置某个 Unit 的指定属性</span><br><span class=\"line\">$ sudo systemctl <span class=\"keyword\">set</span>-property httpd.service CPUShares=500</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>查看 Unit 的依赖关系</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出一个 Unit 的所有依赖，默认不会列出 target 类型</span><br><span class=\"line\">$ systemctl list-dependencies nginx.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出一个 Unit 的所有依赖，包括 target 类型</span><br><span class=\"line\">$ systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务的生命周期\"><a href=\"#服务的生命周期\" class=\"headerlink\" title=\"服务的生命周期\"></a><strong>服务的生命周期</strong></h3><p>当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。</p>\n<ol>\n<li>服务的激活</li>\n</ol>\n<ul>\n<li>systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中</li>\n<li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li>\n</ul>\n<ol>\n<li>服务的启动和停止</li>\n</ol>\n<ul>\n<li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li>\n<li>systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令</li>\n<li>systemctl restart：重启服务</li>\n<li>systemctl kill：立即杀死服务</li>\n</ul>\n<ol>\n<li>服务的开机启动和取消</li>\n</ol>\n<ul>\n<li>systemctl enable：除了激活服务以外，也可以置服务为开机启动</li>\n<li>systemctl disable：取消服务的开机启动</li>\n</ul>\n<ol>\n<li>服务的修改和移除</li>\n</ol>\n<ul>\n<li>systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件</li>\n<li>systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。</li>\n</ul>\n<h3 id=\"Target-管理\"><a href=\"#Target-管理\" class=\"headerlink\" title=\"Target 管理\"></a><strong>Target 管理</strong></h3><p>Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p>\n<p>在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看当前系统的所有 Target</span><br><span class=\"line\">$ systemctl list-unit-files --type=target</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看一个 Target 包含的所有 Unit</span><br><span class=\"line\">$ systemctl list-dependencies multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看启动时的默认 Target</span><br><span class=\"line\">$ systemctl <span class=\"keyword\">get</span>-default</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置启动时的默认 Target</span><br><span class=\"line\">$ sudo systemctl <span class=\"keyword\">set</span>-default multi-user.target</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程</span><br><span class=\"line\">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Target 与 SysV-init 进程的主要区别：</li>\n</ol>\n<ul>\n<li>默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</li>\n<li>启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。</li>\n<li>配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。</li>\n</ul>\n<h3 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a><strong>日志管理</strong></h3><p>Systemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。</p>\n<p>Systemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。</p>\n<p>默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span><br><span class=\"line\">$ sudo journalctl</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看内核日志（不显示应用日志）：--dmesg 或 -k</span><br><span class=\"line\">$ sudo journalctl -k</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b</span><br><span class=\"line\">$ sudo journalctl -b</span><br><span class=\"line\">$ sudo journalctl -b <span class=\"number\">-0</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 查看上一次启动的日志（需更改设置）</span><br><span class=\"line\">$ sudo journalctl -b <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定服务的日志：--unit 或 -u</span><br><span class=\"line\">$ sudo journalctl -u docker.servcie</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定服务的日志</span><br><span class=\"line\">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class=\"line\"></span><br><span class=\"line\"># 实时滚动显示最新日志</span><br><span class=\"line\">$ sudo journalctl -f</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定时间的日志</span><br><span class=\"line\">$ sudo journalctl --since=<span class=\"string\">\"2012-10-30 18:17:16\"</span></span><br><span class=\"line\">$ sudo journalctl --since <span class=\"string\">\"20 min ago\"</span></span><br><span class=\"line\">$ sudo journalctl --since yesterday</span><br><span class=\"line\">$ sudo journalctl --since <span class=\"string\">\"2015-01-10\"</span> --until <span class=\"string\">\"2015-01-11 03:00\"</span></span><br><span class=\"line\">$ sudo journalctl --since <span class=\"number\">09</span>:<span class=\"number\">00</span> --until <span class=\"string\">\"1 hour ago\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 显示尾部的最新 10 行日志：--lines 或 -n</span><br><span class=\"line\">$ sudo journalctl -n</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示尾部指定行数的日志</span><br><span class=\"line\">$ sudo journalctl -n <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 将最新的日志显示在前面</span><br><span class=\"line\">$ sudo journalctl -r -u docker.service</span><br><span class=\"line\"></span><br><span class=\"line\"># 改变输出的格式：--output 或 -o</span><br><span class=\"line\">$ sudo journalctl -r -u docker.service -o json-pretty</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定进程的日志</span><br><span class=\"line\">$ sudo journalctl _PID=<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 查看某个路径的脚本的日志</span><br><span class=\"line\">$ sudo journalctl /usr/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定用户的日志</span><br><span class=\"line\">$ sudo journalctl _UID=<span class=\"number\">33</span> --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看某个 Unit 的日志</span><br><span class=\"line\">$ sudo journalctl -u nginx.service</span><br><span class=\"line\">$ sudo journalctl -u nginx.service --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 实时滚动显示某个 Unit 的最新日志</span><br><span class=\"line\">$ sudo journalctl -u nginx.service -f</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并显示多个 Unit 的日志</span><br><span class=\"line\">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定优先级（及其以上级别）的日志，共有 8 级</span><br><span class=\"line\"># 0: emerg</span><br><span class=\"line\"># 1: alert</span><br><span class=\"line\"># 2: crit</span><br><span class=\"line\"># 3: err</span><br><span class=\"line\"># 4: warning</span><br><span class=\"line\"># 5: notice</span><br><span class=\"line\"># 6: info</span><br><span class=\"line\"># 7: debug</span><br><span class=\"line\">$ sudo journalctl -p err -b</span><br><span class=\"line\"></span><br><span class=\"line\"># 日志默认分页输出，--no-pager 改为正常的标准输出</span><br><span class=\"line\">$ sudo journalctl --no-pager</span><br><span class=\"line\"></span><br><span class=\"line\"># 以 JSON 格式（单行）输出</span><br><span class=\"line\">$ sudo journalctl -b -u nginx.service -o json</span><br><span class=\"line\"></span><br><span class=\"line\"># 以 JSON 格式（多行）输出，可读性更好</span><br><span class=\"line\">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class=\"line\"> -o json-pretty</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示日志占据的硬盘空间</span><br><span class=\"line\">$ sudo journalctl --disk-usage</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件占据的最大空间</span><br><span class=\"line\">$ sudo journalctl --vacuum-size=<span class=\"number\">1</span>G</span><br><span class=\"line\"></span><br><span class=\"line\"># 指定日志文件保存多久</span><br><span class=\"line\">$ sudo journalctl --vacuum-time=<span class=\"number\">1</span>years</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Systemd-工具集\"><a href=\"#Systemd-工具集\" class=\"headerlink\" title=\"Systemd 工具集\"></a><strong>Systemd 工具集</strong></h2><ul>\n<li>systemctl：用于检查和控制各种系统服务和资源的状态</li>\n<li>bootctl：用于查看和管理系统启动分区</li>\n<li>hostnamectl：用于查看和修改系统的主机名和主机信息</li>\n<li>journalctl：用于查看系统日志和各类应用服务日志</li>\n<li>localectl：用于查看和管理系统的地区信息</li>\n<li>loginctl：用于管理系统已登录用户和 Session 的信息</li>\n<li>machinectl：用于操作 Systemd 容器</li>\n<li>timedatectl：用于查看和管理系统的时间和时区信息</li>\n<li>systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈</li>\n<li>systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容</li>\n<li>systemd-cat：用于将其他命令的输出重定向到系统日志</li>\n<li>systemd-cgls：递归地显示指定 CGroup 的继承链</li>\n<li>systemd-cgtop：显示系统当前最耗资源的 CGroup 单元</li>\n<li>systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符</li>\n<li>systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库</li>\n<li>systemd-delta：对比当前系统配置与默认系统配置的差异</li>\n<li>systemd-detect-virt：显示主机的虚拟化类型</li>\n<li>systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件</li>\n<li>systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID</li>\n<li>systemd-notify：Systemd 的内部工具，用于通知服务的状态变化</li>\n<li>systemd-nspawn：用于创建 Systemd 容器</li>\n<li>systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置</li>\n<li>systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行</li>\n<li>systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线</li>\n<li>systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录</li>\n<li>systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求</li>\n</ul>\n<ol>\n<li>systemctl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 重启系统</span><br><span class=\"line\">$ sudo systemctl reboot</span><br><span class=\"line\"></span><br><span class=\"line\"># 关闭系统，切断电源</span><br><span class=\"line\">$ sudo systemctl poweroff</span><br><span class=\"line\"></span><br><span class=\"line\"># CPU停止工作</span><br><span class=\"line\">$ sudo systemctl halt</span><br><span class=\"line\"></span><br><span class=\"line\"># 暂停系统</span><br><span class=\"line\">$ sudo systemctl suspend</span><br><span class=\"line\"></span><br><span class=\"line\"># 让系统进入冬眠状态</span><br><span class=\"line\">$ sudo systemctl hibernate</span><br><span class=\"line\"></span><br><span class=\"line\"># 让系统进入交互式休眠状态</span><br><span class=\"line\">$ sudo systemctl hybrid-sleep</span><br><span class=\"line\"></span><br><span class=\"line\"># 启动进入救援状态（单用户状态）</span><br><span class=\"line\">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>systemd-analyze</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看启动耗时</span><br><span class=\"line\">$ systemd-analyze</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看每个服务的启动耗时</span><br><span class=\"line\">$ systemd-analyze blame</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示瀑布状的启动过程流</span><br><span class=\"line\">$ systemd-analyze critical-chain</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示指定服务的启动流</span><br><span class=\"line\">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>hostnamectl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显示当前主机的信息</span><br><span class=\"line\">$ hostnamectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置主机名。</span><br><span class=\"line\">$ sudo hostnamectl <span class=\"keyword\">set</span>-hostname rhel7</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>timedatectl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查看当前时区设置</span><br><span class=\"line\">$ timedatectl</span><br><span class=\"line\"></span><br><span class=\"line\"># 显示所有可用的时区</span><br><span class=\"line\">$ timedatectl list-timezones</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置当前时区</span><br><span class=\"line\">$ sudo timedatectl <span class=\"keyword\">set</span>-timezone America/New_York</span><br><span class=\"line\">$ sudo timedatectl <span class=\"keyword\">set</span>-time YYYY-MM-DD</span><br><span class=\"line\">$ sudo timedatectl <span class=\"keyword\">set</span>-time HH:MM:SS</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>loginctl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出当前 session</span><br><span class=\"line\">$ loginctl list-sessions</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出当前登录用户</span><br><span class=\"line\">$ loginctl list-users</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出显示指定用户的信息</span><br><span class=\"line\">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>systemd-ask-password</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ PASSWORD=$(systemd-ask-password <span class=\"string\">\"Input Your Passowrd:\"</span>)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>systemd-run</li>\n</ol>\n<p>systemd-run 可以将一个指定的操作变成后台运行的服务。它的效果似乎与直接在命令后加上表示后台运行的 &amp; 符号很相似。然而，它让命令成为服务还意味着，它的生命周期将由 Systemd 控制。具体来说，包括以下好处：</p>\n<ul>\n<li>服务的生命击期由 Systemd 接管，不会随着启动它的控制台关闭而结束</li>\n<li>可以通过 systemctl 工具管理服务的状态</li>\n<li>可以通过 journalctl 工具查看和管理服务的日志信息</li>\n<li>可以通过 Systemd 提供的方法限制服务的 CPU、内存、磁盘 IO 等系统资源的使用情况。</li>\n</ul>\n"},{"title":"Linux查看内存使用情况","abbrlink":1026478353,"_content":"\n> 有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。\n\n有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 `free`、`ps`。而另一些命令允许通过多种方式展示系统的性能统计信息，比如 `top`。在这篇文章中，我们将介绍一些命令以帮助你确定当前占用着最多内存资源的用户或者进程。\n\n下面是一些按照进程查看内存使用情况的命令：\n\n### 按照进程查看内存使用情况\n\n#### 使用 top\n\n`top` 是最好的查看内存使用情况的命令之一。为了查看哪个进程使用着最多的内存，一个简单的办法就是启动 `top`，然后按下 `shift+m`，这样便可以查看按照内存占用百分比从高到底排列的进程。当你按下了 `shift+m` ，你的 `top` 应该会得到类似于下面这样的输出结果：\n\n```\n$toptop - 09:39:34 up 5 days, 3 min,  3 users,  load average: 4.77, 4.43, 3.72Tasks: 251 total,   3 running, 247 sleeping,   1 stopped,   0 zombie%Cpu(s): 50.6 us, 35.9 sy,  0.0 ni, 13.4 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    128.9 free,   2509.3 used,   3306.2 buff/cacheMiB Swap:   2048.0 total,   2045.7 free,      2.2 used.   3053.5 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3309580 550188 168372 S   0.3   9.0   1:33.27 Web Content32469 nemo      20   0 3492840 447372 163296 S   7.3   7.3   3:55.60 firefox32542 nemo      20   0 2845732 433388 140984 S   6.0   7.1   4:11.16 Web Content  342 nemo      20   0 2848520 352288 118972 S  10.3   5.8   4:04.89 Web Content 2389 nemo      20   0 1774412 236700  90044 S  39.7   3.9   9:32.64 vlc29527 nemo      20   0 2735792 225980  84744 S   9.6   3.7   3:02.35 gnome-shell30497 nemo      30  10 1088476 159636  88884 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 140952  33128 S   0.0   2.3   0:04.58 gnome-software32533 nemo      20   0 2389088 104712  79544 S   0.0   1.7   0:01.43 WebExtensions 2256 nemo      20   0 1217884 103424  31304 T   0.0   1.7   0:00.28 vlc 1713 nemo      20   0 2374396  79588  61452 S   0.0   1.3   0:00.49 Web Content29306 nemo      20   0  389668  74376  54340 S   2.3   1.2   0:57.25 Xorg32739 nemo      20   0  289528  58900  34480 S   1.0   1.0   1:04.08 RDD Process29732 nemo      20   0  789196  57724  42428 S   0.0   0.9   0:00.38 evolution-alarm 2373 root      20   0  150408  57000   9924 S   0.3   0.9  10:15.35 nessusd\n```\n\n注意 `%MEM` 排序。列表的大小取决于你的窗口大小，但是占据着最多的内存的进程将会显示在列表的顶端。\n\n#### 使用 ps\n\n`ps` 命令中的一列用来展示每个进程的内存使用情况。为了展示和查看哪个进程使用着最多的内存，你可以将 `ps` 命令的结果传递给 `sort` 命令。下面是一个有用的示例：\n\n```\n$ ps aux | sort -rnk 4 | head -5nemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 /usr/lib/firefox/firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts/1  Sl+  09:15  12:21 vlc videos/edge_computing.mp4\n```\n\n在上面的例子中（文中已截断），`sort` 命令使用了 `-r` 选项（反转）、`-n` 选项（数字值）、`-k` 选项（关键字），使 `sort` 命令对 `ps` 命令的结果按照第四列（内存使用情况）中的数字逆序进行排列并输出。如果我们首先显示 `ps` 命令的标题，那么将会便于查看。\n\n```\n$ ps aux | head -1; ps aux | sort -rnk 4 | head -5USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 /usr/lib/firefox/firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts/1  Sl+  09:15  12:21 vlc videos/edge_computing.mp4\n```\n\n如果你喜欢这个命令，你可以用下面的命令为他指定一个别名，如果你想一直使用它，不要忘记把该命令添加到你的 `~/.bashrc` 文件中。\n\n```\n$ alias mem-by-proc=\"ps aux | head -1; ps aux | sort -rnk 4\"\n```\n\n下面是一些根据用户查看内存使用情况的命令：\n\n### 按用户查看内存使用情况\n\n#### 使用 top\n\n按照用户检查内存使用情况会更复杂一些，因为你需要找到一种方法把用户所拥有的所有进程统计为单一的内存使用量。\n\n如果你只想查看单个用户进程使用情况，`top` 命令可以采用与上文中同样的方法进行使用。只需要添加 `-U` 选项并在其后面指定你要查看的用户名，然后按下 `shift+m` 便可以按照内存使用有多到少进行查看。\n\n```\n$ top -U nemotop - 10:16:33 up 5 days, 40 min,  3 users,  load average: 1.91, 1.82, 2.15Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie%Cpu(s): 28.5 us, 36.8 sy,  0.0 ni, 34.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    224.1 free,   2752.9 used,   2967.4 buff/cacheMiB Swap:   2048.0 total,   2042.7 free,      5.2 used.   2812.0 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3315724 623748 165440 S   1.0  10.2   1:48.78 Web Content32469 nemo      20   0 3629380 607492 161688 S   2.3  10.0   6:06.89 firefox32542 nemo      20   0 2886700 404980 136648 S   5.6   6.7   6:50.01 Web Content  342 nemo      20   0 2922248 375784 116096 S  19.5   6.2   8:16.07 Web Content 2389 nemo      20   0 1762960 234644  87452 S   0.0   3.9  13:57.53 vlc29527 nemo      20   0 2736924 227260  86092 S   0.0   3.7   4:09.11 gnome-shell30497 nemo      30  10 1088476 156372  85620 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 138160  30336 S   0.0   2.3   0:04.62 gnome-software32533 nemo      20   0 2389088 102532  76808 S   0.0   1.7   0:01.79 WebExtensions\n```\n\n#### 使用 ps\n\n你依旧可以使用 `ps` 命令通过内存使用情况来排列某个用户的进程。在这个例子中，我们将使用 `grep` 命令来筛选得到某个用户的所有进程。\n\n```\n$ ps aux | head -1; ps aux | grep ^nemo| sort -rnk 4 | moreUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo     32469  7.1 11.5 3724364 701388 ?      Sl   08:54   7:21 /usr/lib/firefox/firefox -new-windownemo       400  2.0  8.9 3308556 543232 ?      Sl   08:59   2:01 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni/usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32542  7.9  7.1 2903084 436196 ?      Sl   08:55   8:07 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342 10.8  7.0 2941056 426484 ?      Rl   08:59  10:45 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 16.9  3.8 1762960 234644 pts/1  Sl+  09:15  13:57 vlc videos/edge_computing.mp4nemo     29527  3.9  3.7 2736924 227448 ?      Ssl  08:50   4:11 /usr/bin/gnome-shell\n```\n\n### 使用 ps 和其他命令的搭配\n\n如果你想比较某个用户与其他用户内存使用情况将会比较复杂。在这种情况中，创建并排序一个按照用户总的内存使用量是一个不错的方法，但是它需要做一些更多的工作，并涉及到许多命令。在下面的脚本中，我们使用 `ps aux | grep -v COMMAND | awk '{print $1}' | sort -u` 命令得到了用户列表。其中包含了系统用户比如 `syslog`。我们对每个任务使用 `awk` 命令以收集每个用户总的内存使用情况。在最后一步中，我们展示每个用户总的内存使用量（按照从大到小的顺序）。\n\n```\n#!/bin/bashstats=””echo \"%   user\"echo \"============\"# collect the datafor user in `ps aux | grep -v COMMAND | awk '{print $1}' | sort -u`do  stats=\"$stats\\n`ps aux | egrep ^$user | awk 'BEGIN{total=0}; \\    {total += $4};END{print total,$1}'`\"done# sort data numerically (largest first)echo -e $stats | grep -v ^$ | sort -rn | head\n```\n\n这个脚本的输出可能如下：\n\n```\n$ ./show_user_mem_usage%   user============69.6 nemo5.8 root0.5 www-data0.3 shs0.2 whoopsie0.2 systemd+0.2 colord0.2 clamav0 syslog0 rtkit\n```\n\n在 Linux 有许多方法可以报告内存使用情况。可以通过一些用心设计的工具和命令，来查看并获得某个进程或者用户占用着最多的内存。","source":"_posts/linux/Linux查看内存使用量.md","raw":"---\ntitle: Linux查看内存使用情况\nabbrlink: 1026478353\ntags:\n\t- Linux\n---\n\n> 有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。\n\n有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 `free`、`ps`。而另一些命令允许通过多种方式展示系统的性能统计信息，比如 `top`。在这篇文章中，我们将介绍一些命令以帮助你确定当前占用着最多内存资源的用户或者进程。\n\n下面是一些按照进程查看内存使用情况的命令：\n\n### 按照进程查看内存使用情况\n\n#### 使用 top\n\n`top` 是最好的查看内存使用情况的命令之一。为了查看哪个进程使用着最多的内存，一个简单的办法就是启动 `top`，然后按下 `shift+m`，这样便可以查看按照内存占用百分比从高到底排列的进程。当你按下了 `shift+m` ，你的 `top` 应该会得到类似于下面这样的输出结果：\n\n```\n$toptop - 09:39:34 up 5 days, 3 min,  3 users,  load average: 4.77, 4.43, 3.72Tasks: 251 total,   3 running, 247 sleeping,   1 stopped,   0 zombie%Cpu(s): 50.6 us, 35.9 sy,  0.0 ni, 13.4 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    128.9 free,   2509.3 used,   3306.2 buff/cacheMiB Swap:   2048.0 total,   2045.7 free,      2.2 used.   3053.5 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3309580 550188 168372 S   0.3   9.0   1:33.27 Web Content32469 nemo      20   0 3492840 447372 163296 S   7.3   7.3   3:55.60 firefox32542 nemo      20   0 2845732 433388 140984 S   6.0   7.1   4:11.16 Web Content  342 nemo      20   0 2848520 352288 118972 S  10.3   5.8   4:04.89 Web Content 2389 nemo      20   0 1774412 236700  90044 S  39.7   3.9   9:32.64 vlc29527 nemo      20   0 2735792 225980  84744 S   9.6   3.7   3:02.35 gnome-shell30497 nemo      30  10 1088476 159636  88884 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 140952  33128 S   0.0   2.3   0:04.58 gnome-software32533 nemo      20   0 2389088 104712  79544 S   0.0   1.7   0:01.43 WebExtensions 2256 nemo      20   0 1217884 103424  31304 T   0.0   1.7   0:00.28 vlc 1713 nemo      20   0 2374396  79588  61452 S   0.0   1.3   0:00.49 Web Content29306 nemo      20   0  389668  74376  54340 S   2.3   1.2   0:57.25 Xorg32739 nemo      20   0  289528  58900  34480 S   1.0   1.0   1:04.08 RDD Process29732 nemo      20   0  789196  57724  42428 S   0.0   0.9   0:00.38 evolution-alarm 2373 root      20   0  150408  57000   9924 S   0.3   0.9  10:15.35 nessusd\n```\n\n注意 `%MEM` 排序。列表的大小取决于你的窗口大小，但是占据着最多的内存的进程将会显示在列表的顶端。\n\n#### 使用 ps\n\n`ps` 命令中的一列用来展示每个进程的内存使用情况。为了展示和查看哪个进程使用着最多的内存，你可以将 `ps` 命令的结果传递给 `sort` 命令。下面是一个有用的示例：\n\n```\n$ ps aux | sort -rnk 4 | head -5nemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 /usr/lib/firefox/firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts/1  Sl+  09:15  12:21 vlc videos/edge_computing.mp4\n```\n\n在上面的例子中（文中已截断），`sort` 命令使用了 `-r` 选项（反转）、`-n` 选项（数字值）、`-k` 选项（关键字），使 `sort` 命令对 `ps` 命令的结果按照第四列（内存使用情况）中的数字逆序进行排列并输出。如果我们首先显示 `ps` 命令的标题，那么将会便于查看。\n\n```\n$ ps aux | head -1; ps aux | sort -rnk 4 | head -5USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 /usr/lib/firefox/firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts/1  Sl+  09:15  12:21 vlc videos/edge_computing.mp4\n```\n\n如果你喜欢这个命令，你可以用下面的命令为他指定一个别名，如果你想一直使用它，不要忘记把该命令添加到你的 `~/.bashrc` 文件中。\n\n```\n$ alias mem-by-proc=\"ps aux | head -1; ps aux | sort -rnk 4\"\n```\n\n下面是一些根据用户查看内存使用情况的命令：\n\n### 按用户查看内存使用情况\n\n#### 使用 top\n\n按照用户检查内存使用情况会更复杂一些，因为你需要找到一种方法把用户所拥有的所有进程统计为单一的内存使用量。\n\n如果你只想查看单个用户进程使用情况，`top` 命令可以采用与上文中同样的方法进行使用。只需要添加 `-U` 选项并在其后面指定你要查看的用户名，然后按下 `shift+m` 便可以按照内存使用有多到少进行查看。\n\n```\n$ top -U nemotop - 10:16:33 up 5 days, 40 min,  3 users,  load average: 1.91, 1.82, 2.15Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie%Cpu(s): 28.5 us, 36.8 sy,  0.0 ni, 34.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    224.1 free,   2752.9 used,   2967.4 buff/cacheMiB Swap:   2048.0 total,   2042.7 free,      5.2 used.   2812.0 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3315724 623748 165440 S   1.0  10.2   1:48.78 Web Content32469 nemo      20   0 3629380 607492 161688 S   2.3  10.0   6:06.89 firefox32542 nemo      20   0 2886700 404980 136648 S   5.6   6.7   6:50.01 Web Content  342 nemo      20   0 2922248 375784 116096 S  19.5   6.2   8:16.07 Web Content 2389 nemo      20   0 1762960 234644  87452 S   0.0   3.9  13:57.53 vlc29527 nemo      20   0 2736924 227260  86092 S   0.0   3.7   4:09.11 gnome-shell30497 nemo      30  10 1088476 156372  85620 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 138160  30336 S   0.0   2.3   0:04.62 gnome-software32533 nemo      20   0 2389088 102532  76808 S   0.0   1.7   0:01.79 WebExtensions\n```\n\n#### 使用 ps\n\n你依旧可以使用 `ps` 命令通过内存使用情况来排列某个用户的进程。在这个例子中，我们将使用 `grep` 命令来筛选得到某个用户的所有进程。\n\n```\n$ ps aux | head -1; ps aux | grep ^nemo| sort -rnk 4 | moreUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo     32469  7.1 11.5 3724364 701388 ?      Sl   08:54   7:21 /usr/lib/firefox/firefox -new-windownemo       400  2.0  8.9 3308556 543232 ?      Sl   08:59   2:01 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni/usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32542  7.9  7.1 2903084 436196 ?      Sl   08:55   8:07 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342 10.8  7.0 2941056 426484 ?      Rl   08:59  10:45 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 16.9  3.8 1762960 234644 pts/1  Sl+  09:15  13:57 vlc videos/edge_computing.mp4nemo     29527  3.9  3.7 2736924 227448 ?      Ssl  08:50   4:11 /usr/bin/gnome-shell\n```\n\n### 使用 ps 和其他命令的搭配\n\n如果你想比较某个用户与其他用户内存使用情况将会比较复杂。在这种情况中，创建并排序一个按照用户总的内存使用量是一个不错的方法，但是它需要做一些更多的工作，并涉及到许多命令。在下面的脚本中，我们使用 `ps aux | grep -v COMMAND | awk '{print $1}' | sort -u` 命令得到了用户列表。其中包含了系统用户比如 `syslog`。我们对每个任务使用 `awk` 命令以收集每个用户总的内存使用情况。在最后一步中，我们展示每个用户总的内存使用量（按照从大到小的顺序）。\n\n```\n#!/bin/bashstats=””echo \"%   user\"echo \"============\"# collect the datafor user in `ps aux | grep -v COMMAND | awk '{print $1}' | sort -u`do  stats=\"$stats\\n`ps aux | egrep ^$user | awk 'BEGIN{total=0}; \\    {total += $4};END{print total,$1}'`\"done# sort data numerically (largest first)echo -e $stats | grep -v ^$ | sort -rn | head\n```\n\n这个脚本的输出可能如下：\n\n```\n$ ./show_user_mem_usage%   user============69.6 nemo5.8 root0.5 www-data0.3 shs0.2 whoopsie0.2 systemd+0.2 colord0.2 clamav0 syslog0 rtkit\n```\n\n在 Linux 有许多方法可以报告内存使用情况。可以通过一些用心设计的工具和命令，来查看并获得某个进程或者用户占用着最多的内存。","slug":"linux/Linux查看内存使用量","published":1,"date":"2020-12-15T03:37:33.925Z","updated":"2020-12-15T03:38:34.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckipy0qs800002hcd3h2wgo1j","content":"<blockquote>\n<p>有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。</p>\n</blockquote>\n<p>有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 <code>free</code>、<code>ps</code>。而另一些命令允许通过多种方式展示系统的性能统计信息，比如 <code>top</code>。在这篇文章中，我们将介绍一些命令以帮助你确定当前占用着最多内存资源的用户或者进程。</p>\n<p>下面是一些按照进程查看内存使用情况的命令：</p>\n<h3 id=\"按照进程查看内存使用情况\"><a href=\"#按照进程查看内存使用情况\" class=\"headerlink\" title=\"按照进程查看内存使用情况\"></a>按照进程查看内存使用情况</h3><h4 id=\"使用-top\"><a href=\"#使用-top\" class=\"headerlink\" title=\"使用 top\"></a>使用 top</h4><p><code>top</code> 是最好的查看内存使用情况的命令之一。为了查看哪个进程使用着最多的内存，一个简单的办法就是启动 <code>top</code>，然后按下 <code>shift+m</code>，这样便可以查看按照内存占用百分比从高到底排列的进程。当你按下了 <code>shift+m</code> ，你的 <code>top</code> 应该会得到类似于下面这样的输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$toptop - 09:39:34 up 5 days, 3 min,  3 users,  load average: 4.77, 4.43, 3.72Tasks: 251 total,   3 running, 247 sleeping,   1 stopped,   0 zombie%Cpu(s): 50.6 us, 35.9 sy,  0.0 ni, 13.4 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    128.9 free,   2509.3 used,   3306.2 buff&#x2F;cacheMiB Swap:   2048.0 total,   2045.7 free,      2.2 used.   3053.5 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3309580 550188 168372 S   0.3   9.0   1:33.27 Web Content32469 nemo      20   0 3492840 447372 163296 S   7.3   7.3   3:55.60 firefox32542 nemo      20   0 2845732 433388 140984 S   6.0   7.1   4:11.16 Web Content  342 nemo      20   0 2848520 352288 118972 S  10.3   5.8   4:04.89 Web Content 2389 nemo      20   0 1774412 236700  90044 S  39.7   3.9   9:32.64 vlc29527 nemo      20   0 2735792 225980  84744 S   9.6   3.7   3:02.35 gnome-shell30497 nemo      30  10 1088476 159636  88884 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 140952  33128 S   0.0   2.3   0:04.58 gnome-software32533 nemo      20   0 2389088 104712  79544 S   0.0   1.7   0:01.43 WebExtensions 2256 nemo      20   0 1217884 103424  31304 T   0.0   1.7   0:00.28 vlc 1713 nemo      20   0 2374396  79588  61452 S   0.0   1.3   0:00.49 Web Content29306 nemo      20   0  389668  74376  54340 S   2.3   1.2   0:57.25 Xorg32739 nemo      20   0  289528  58900  34480 S   1.0   1.0   1:04.08 RDD Process29732 nemo      20   0  789196  57724  42428 S   0.0   0.9   0:00.38 evolution-alarm 2373 root      20   0  150408  57000   9924 S   0.3   0.9  10:15.35 nessusd</span><br></pre></td></tr></table></figure>\n\n<p>注意 <code>%MEM</code> 排序。列表的大小取决于你的窗口大小，但是占据着最多的内存的进程将会显示在列表的顶端。</p>\n<h4 id=\"使用-ps\"><a href=\"#使用-ps\" class=\"headerlink\" title=\"使用 ps\"></a>使用 ps</h4><p><code>ps</code> 命令中的一列用来展示每个进程的内存使用情况。为了展示和查看哪个进程使用着最多的内存，你可以将 <code>ps</code> 命令的结果传递给 <code>sort</code> 命令。下面是一个有用的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps aux | sort -rnk 4 | head -5nemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中（文中已截断），<code>sort</code> 命令使用了 <code>-r</code> 选项（反转）、<code>-n</code> 选项（数字值）、<code>-k</code> 选项（关键字），使 <code>sort</code> 命令对 <code>ps</code> 命令的结果按照第四列（内存使用情况）中的数字逆序进行排列并输出。如果我们首先显示 <code>ps</code> 命令的标题，那么将会便于查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps aux | head -1; ps aux | sort -rnk 4 | head -5USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4</span><br></pre></td></tr></table></figure>\n\n<p>如果你喜欢这个命令，你可以用下面的命令为他指定一个别名，如果你想一直使用它，不要忘记把该命令添加到你的 <code>~/.bashrc</code> 文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ alias mem-by-proc&#x3D;&quot;ps aux | head -1; ps aux | sort -rnk 4&quot;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一些根据用户查看内存使用情况的命令：</p>\n<h3 id=\"按用户查看内存使用情况\"><a href=\"#按用户查看内存使用情况\" class=\"headerlink\" title=\"按用户查看内存使用情况\"></a>按用户查看内存使用情况</h3><h4 id=\"使用-top-1\"><a href=\"#使用-top-1\" class=\"headerlink\" title=\"使用 top\"></a>使用 top</h4><p>按照用户检查内存使用情况会更复杂一些，因为你需要找到一种方法把用户所拥有的所有进程统计为单一的内存使用量。</p>\n<p>如果你只想查看单个用户进程使用情况，<code>top</code> 命令可以采用与上文中同样的方法进行使用。只需要添加 <code>-U</code> 选项并在其后面指定你要查看的用户名，然后按下 <code>shift+m</code> 便可以按照内存使用有多到少进行查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ top -U nemotop - 10:16:33 up 5 days, 40 min,  3 users,  load average: 1.91, 1.82, 2.15Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie%Cpu(s): 28.5 us, 36.8 sy,  0.0 ni, 34.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    224.1 free,   2752.9 used,   2967.4 buff&#x2F;cacheMiB Swap:   2048.0 total,   2042.7 free,      5.2 used.   2812.0 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3315724 623748 165440 S   1.0  10.2   1:48.78 Web Content32469 nemo      20   0 3629380 607492 161688 S   2.3  10.0   6:06.89 firefox32542 nemo      20   0 2886700 404980 136648 S   5.6   6.7   6:50.01 Web Content  342 nemo      20   0 2922248 375784 116096 S  19.5   6.2   8:16.07 Web Content 2389 nemo      20   0 1762960 234644  87452 S   0.0   3.9  13:57.53 vlc29527 nemo      20   0 2736924 227260  86092 S   0.0   3.7   4:09.11 gnome-shell30497 nemo      30  10 1088476 156372  85620 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 138160  30336 S   0.0   2.3   0:04.62 gnome-software32533 nemo      20   0 2389088 102532  76808 S   0.0   1.7   0:01.79 WebExtensions</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用-ps-1\"><a href=\"#使用-ps-1\" class=\"headerlink\" title=\"使用 ps\"></a>使用 ps</h4><p>你依旧可以使用 <code>ps</code> 命令通过内存使用情况来排列某个用户的进程。在这个例子中，我们将使用 <code>grep</code> 命令来筛选得到某个用户的所有进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps aux | head -1; ps aux | grep ^nemo| sort -rnk 4 | moreUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo     32469  7.1 11.5 3724364 701388 ?      Sl   08:54   7:21 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo       400  2.0  8.9 3308556 543232 ?      Sl   08:59   2:01 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni&#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32542  7.9  7.1 2903084 436196 ?      Sl   08:55   8:07 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342 10.8  7.0 2941056 426484 ?      Rl   08:59  10:45 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 16.9  3.8 1762960 234644 pts&#x2F;1  Sl+  09:15  13:57 vlc videos&#x2F;edge_computing.mp4nemo     29527  3.9  3.7 2736924 227448 ?      Ssl  08:50   4:11 &#x2F;usr&#x2F;bin&#x2F;gnome-shell</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-ps-和其他命令的搭配\"><a href=\"#使用-ps-和其他命令的搭配\" class=\"headerlink\" title=\"使用 ps 和其他命令的搭配\"></a>使用 ps 和其他命令的搭配</h3><p>如果你想比较某个用户与其他用户内存使用情况将会比较复杂。在这种情况中，创建并排序一个按照用户总的内存使用量是一个不错的方法，但是它需要做一些更多的工作，并涉及到许多命令。在下面的脚本中，我们使用 <code>ps aux | grep -v COMMAND | awk &#39;{print $1}&#39; | sort -u</code> 命令得到了用户列表。其中包含了系统用户比如 <code>syslog</code>。我们对每个任务使用 <code>awk</code> 命令以收集每个用户总的内存使用情况。在最后一步中，我们展示每个用户总的内存使用量（按照从大到小的顺序）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;bin&#x2F;bashstats&#x3D;””echo &quot;%   user&quot;echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;# collect the datafor user in &#96;ps aux | grep -v COMMAND | awk &#39;&#123;print $1&#125;&#39; | sort -u&#96;do  stats&#x3D;&quot;$stats\\n&#96;ps aux | egrep ^$user | awk &#39;BEGIN&#123;total&#x3D;0&#125;; \\    &#123;total +&#x3D; $4&#125;;END&#123;print total,$1&#125;&#39;&#96;&quot;done# sort data numerically (largest first)echo -e $stats | grep -v ^$ | sort -rn | head</span><br></pre></td></tr></table></figure>\n\n<p>这个脚本的输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ .&#x2F;show_user_mem_usage%   user&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;69.6 nemo5.8 root0.5 www-data0.3 shs0.2 whoopsie0.2 systemd+0.2 colord0.2 clamav0 syslog0 rtkit</span><br></pre></td></tr></table></figure>\n\n<p>在 Linux 有许多方法可以报告内存使用情况。可以通过一些用心设计的工具和命令，来查看并获得某个进程或者用户占用着最多的内存。</p>\n","site":{"data":{"next":{"override":false,"reminder":false,"cache":{"enable":true},"minify":false,"custom_file_path":null,"favicon":{"small":"/images/favicon-16x16-next.png","medium":"/images/favicon-32x32-next.png","apple_touch_icon":"/images/apple-touch-icon-next.png","safari_pinned_tab":"/images/logo.svg"},"language_switcher":true,"footer":{"icon":{"name":"user","animated":false,"color":"#808080"},"copyright":null,"powered":true,"beian":{"enable":false,"icp":null,"gongan_id":null,"gongan_num":null,"gongan_icon_url":null}},"creative_commons":{"license":"by-nc-sa","sidebar":false,"post":false,"language":null},"scheme":"Gemini","darkmode":false,"menu":{"home":"/ || home","about":"/about/ || user","tags":"/tags/ || tags","categories":"/categories/ || th","archives":"/archives/ || archive","schedule":"/schedule/ || calendar","sitemap":"/sitemap.xml || sitemap","commonweal":"/404.html || heartbeat"},"menu_settings":{"icons":true,"badges":false},"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"avatar":{"url":null,"rounded":false,"rotated":false},"site_state":true,"social":{"GitHub":"https://github.com/tanxinzheng || github"},"social_icons":{"enable":true,"icons_only":false,"transition":false},"links_settings":{"icon":"link","title":"Links","layout":"block"},"links":null,"toc":{"enable":true,"number":true,"wrap":false,"expand_all":false,"max_depth":6},"chat":{"enable":false,"icon":"comment","text":"Chat"},"excerpt_description":true,"read_more_btn":true,"post_meta":{"item_text":true,"created_at":true,"updated_at":{"enable":true,"another_day":true},"categories":true},"symbols_count_time":{"separated_meta":true,"item_text_post":true,"item_text_total":false},"tag_icon":false,"reward_settings":{"enable":true,"animation":false},"reward":{"wechatpay":"/img/wechatpay.jpg","alipay":"/img/alipay.jpg"},"follow_me":null,"related_posts":{"enable":false,"title":null,"display_in_home":false,"params":{"maxCount":5}},"post_edit":{"enable":false,"url":"https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name"},"post_navigation":"left","tagcloud":{"min":12,"max":30,"start":"#ccc","end":"#111","amount":200},"calendar":{"calendar_id":"<required>","api_key":"<required>","orderBy":"startTime","offsetMax":24,"offsetMin":4,"showDeleted":false,"singleEvents":true,"maxResults":250},"text_align":{"desktop":"justify","mobile":"justify"},"mobile_layout_economy":false,"android_chrome_color":"#222","custom_logo":null,"codeblock":{"highlight_theme":"normal","copy_button":{"enable":false,"show_result":false,"style":null}},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"reading_progress":{"enable":false,"position":"top","color":"#37c6c0","height":"3px"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"github_banner":{"enable":false,"permalink":"https://github.com/yourname","title":"Follow me on GitHub"},"font":{"enable":false,"host":null,"global":{"external":true,"family":"Lato","size":null},"title":{"external":true,"family":null,"size":null},"headings":{"external":true,"family":null,"size":null},"posts":{"external":true,"family":null},"codes":{"external":true,"family":null}},"disable_baidu_transformation":false,"index_with_subtitle":false,"exturl":false,"google_site_verification":null,"bing_site_verification":null,"yandex_site_verification":null,"baidu_site_verification":null,"baidu_push":false,"math":{"per_page":true,"mathjax":{"enable":false,"mhchem":false},"katex":{"enable":false,"copy_tex":false}},"pjax":false,"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"quicklink":{"enable":false,"home":false,"archive":false,"delay":true,"timeout":3000,"priority":true,"ignores":null},"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"disqus":{"enable":false,"shortname":null,"count":true},"disqusjs":{"enable":false,"api":null,"apikey":null,"shortname":null},"changyan":{"enable":false,"appid":null,"appkey":null},"valine":{"enable":false,"appid":null,"appkey":null,"notify":false,"verify":false,"placeholder":"Just go go","avatar":"mm","guest_info":"nick,mail,link","pageSize":10,"language":null,"visitor":false,"comment_count":true,"recordIP":false,"serverURLs":null},"livere_uid":null,"gitalk":{"enable":false,"github_id":null,"repo":null,"client_id":null,"client_secret":null,"admin_user":null,"distraction_free_mode":true,"language":null},"rating":{"enable":false,"id":null,"color":"fc6423"},"add_this_id":null,"google_analytics":{"tracking_id":null,"only_pageview":false},"baidu_analytics":null,"growingio_analytics":null,"cnzz_siteid":null,"leancloud_visitors":{"enable":false,"app_id":null,"app_key":null,"server_url":null,"security":true},"firestore":{"enable":false,"collection":"articles","apiKey":null,"projectId":null},"busuanzi_count":{"enable":false,"total_visitors":true,"total_visitors_icon":"user","total_views":true,"total_views_icon":"eye","post_views":true,"post_views_icon":"eye"},"algolia_search":{"enable":false,"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"local_search":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"swiftype_key":null,"chatra":{"enable":false,"async":true,"id":null},"tidio":{"enable":false,"key":null},"note":{"style":"simple","icons":false,"light_bg_offset":0},"tabs":{"transition":{"tabs":false,"labels":true}},"pdf":{"enable":false,"height":"500px"},"mermaid":{"enable":false,"theme":"forest"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"pace":{"enable":false,"theme":"minimal"},"three":{"enable":false,"three_waves":false,"canvas_lines":false,"canvas_sphere":false},"canvas_ribbon":{"enable":false,"size":300,"alpha":0.6,"zIndex":-1},"vendors":{"_internal":"lib","anime":null,"fontawesome":null,"mathjax":null,"katex":null,"copy_tex_js":null,"copy_tex_css":null,"pjax":null,"jquery":null,"fancybox":null,"fancybox_css":null,"mediumzoom":null,"lazyload":null,"pangu":null,"quicklink":null,"disqusjs_js":null,"disqusjs_css":null,"valine":null,"gitalk_js":null,"gitalk_css":null,"algolia_search":null,"instant_search":null,"mermaid":null,"velocity":null,"velocity_ui":null,"pace":null,"pace_css":null,"three":null,"three_waves":null,"canvas_lines":null,"canvas_sphere":null,"canvas_ribbon":null},"css":"css","js":"js","images":"images"},"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/apple-touch-icon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":true,"style":"values"}},"color":{"body_bg_color":"#eee","navbar_bg_color":"#2f4154","navbar_text_color":"white","text_color":"#3c4858","sec_text_color":"#718096","post_text_color":"#2c3e50","post_heading_color":"#1a202c","link_color":"#3c4858","link_hover_color":"#1abc9c","link_hover_bg_color":"#ebedef","board_color":"#fff"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":true,"autoplay":true,"loop":"all","order":"random","theme":"#b7daff","volume":0.2,"songs":[{"name":"Memories","artist":"Maroon 5","url":"/music/memories.mp3","cover":"/music/Memories-Maroon 5.jpg"},{"name":"Someone You Loved","artist":"Lewis Capaldi","url":"/music/someone you loved.mp3","cover":"/music/Someone You Loved-Lewis Capaldi.jpg"},{"name":"Simple Song","artist":"Passenger","url":"/music/Simple Song.mp3","cover":"/music/Passenger.jpg"},{"name":"Sketch Plane","artist":"Cam Kelley","url":"/music/M800002kitDY3lqvHN.mp3","cover":"/music/Sketch Plane-Cam Kelley.jpg"}]},"reward":{"enable":true,"text":"感谢大爷的咖啡☕️","alipay":"/img/alipay.jpg","wechatpay":"/img/wechatpay.jpg"},"version":{"check":true},"navbar":{"blog_title":null,"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/index.html","icon":"iconfont icon-archive-fill"},{"key":"tag","link":"/tags/index.html","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/index.html","icon":"iconfont icon-user-fill"},{"key":"links","link":"/links/index.html","icon":"iconfont icon-link-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":true,"icp_text":"湘ICP备20010696号-1","police_text":null,"police_code":null,"police_icon":null}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/banner.jpg","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"/img/default_thumbnail.jpg","slogan":{"enable":true,"text":null},"hitokoto":{"enable":true},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/banner.jpg","banner_img_height":70,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"dddd, MMMM Do YYYY, h:mm a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于："},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC\" rel=\"nofollow noopener\">CC BY-SA 3.0协议</a> 。转载请注明出处！"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"comments":{"enable":true,"type":"gitalk"},"image_zoom":{"enable":true},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}}},"utterances":{"repo":null,"issue_term":null,"label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null},"gitalk":{"enable":true,"clientID":"646b996eb5ffb5eaf34d","clientSecret":"9154e13bd5869e2811b3852e07545337eb10e735","repo":"tanxinzheng.github.io","owner":"tanxinzheng","admin":"tanxinzheng","id":"tanxinzheng","language":"zh-CN","labels":"['Gitalk']","perPage":15,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":null,"appkey":null,"placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":null,"mathJax":false},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null},"tag":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"~拉菲~","introduce":"程序猿 / 户外达人","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com/tanxinzheng"},{"class":"iconfont icon-linkedin-fill","link":"https://www.linkedin.com/in/tanxinzheng"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Changelog","intro":"主题更新日志","link":"https://github.com/fluid-dev/hexo-theme-fluid/blob/master/Changelog.md","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<blockquote>\n<p>有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。</p>\n</blockquote>\n<p>有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 <code>free</code>、<code>ps</code>。而另一些命令允许通过多种方式展示系统的性能统计信息，比如 <code>top</code>。在这篇文章中，我们将介绍一些命令以帮助你确定当前占用着最多内存资源的用户或者进程。</p>\n<p>下面是一些按照进程查看内存使用情况的命令：</p>\n<h3 id=\"按照进程查看内存使用情况\"><a href=\"#按照进程查看内存使用情况\" class=\"headerlink\" title=\"按照进程查看内存使用情况\"></a>按照进程查看内存使用情况</h3><h4 id=\"使用-top\"><a href=\"#使用-top\" class=\"headerlink\" title=\"使用 top\"></a>使用 top</h4><p><code>top</code> 是最好的查看内存使用情况的命令之一。为了查看哪个进程使用着最多的内存，一个简单的办法就是启动 <code>top</code>，然后按下 <code>shift+m</code>，这样便可以查看按照内存占用百分比从高到底排列的进程。当你按下了 <code>shift+m</code> ，你的 <code>top</code> 应该会得到类似于下面这样的输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$toptop - 09:39:34 up 5 days, 3 min,  3 users,  load average: 4.77, 4.43, 3.72Tasks: 251 total,   3 running, 247 sleeping,   1 stopped,   0 zombie%Cpu(s): 50.6 us, 35.9 sy,  0.0 ni, 13.4 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    128.9 free,   2509.3 used,   3306.2 buff&#x2F;cacheMiB Swap:   2048.0 total,   2045.7 free,      2.2 used.   3053.5 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3309580 550188 168372 S   0.3   9.0   1:33.27 Web Content32469 nemo      20   0 3492840 447372 163296 S   7.3   7.3   3:55.60 firefox32542 nemo      20   0 2845732 433388 140984 S   6.0   7.1   4:11.16 Web Content  342 nemo      20   0 2848520 352288 118972 S  10.3   5.8   4:04.89 Web Content 2389 nemo      20   0 1774412 236700  90044 S  39.7   3.9   9:32.64 vlc29527 nemo      20   0 2735792 225980  84744 S   9.6   3.7   3:02.35 gnome-shell30497 nemo      30  10 1088476 159636  88884 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 140952  33128 S   0.0   2.3   0:04.58 gnome-software32533 nemo      20   0 2389088 104712  79544 S   0.0   1.7   0:01.43 WebExtensions 2256 nemo      20   0 1217884 103424  31304 T   0.0   1.7   0:00.28 vlc 1713 nemo      20   0 2374396  79588  61452 S   0.0   1.3   0:00.49 Web Content29306 nemo      20   0  389668  74376  54340 S   2.3   1.2   0:57.25 Xorg32739 nemo      20   0  289528  58900  34480 S   1.0   1.0   1:04.08 RDD Process29732 nemo      20   0  789196  57724  42428 S   0.0   0.9   0:00.38 evolution-alarm 2373 root      20   0  150408  57000   9924 S   0.3   0.9  10:15.35 nessusd</span><br></pre></td></tr></table></figure>\n\n<p>注意 <code>%MEM</code> 排序。列表的大小取决于你的窗口大小，但是占据着最多的内存的进程将会显示在列表的顶端。</p>\n<h4 id=\"使用-ps\"><a href=\"#使用-ps\" class=\"headerlink\" title=\"使用 ps\"></a>使用 ps</h4><p><code>ps</code> 命令中的一列用来展示每个进程的内存使用情况。为了展示和查看哪个进程使用着最多的内存，你可以将 <code>ps</code> 命令的结果传递给 <code>sort</code> 命令。下面是一个有用的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps aux | sort -rnk 4 | head -5nemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4</span><br></pre></td></tr></table></figure>\n\n<p>在上面的例子中（文中已截断），<code>sort</code> 命令使用了 <code>-r</code> 选项（反转）、<code>-n</code> 选项（数字值）、<code>-k</code> 选项（关键字），使 <code>sort</code> 命令对 <code>ps</code> 命令的结果按照第四列（内存使用情况）中的数字逆序进行排列并输出。如果我们首先显示 <code>ps</code> 命令的标题，那么将会便于查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps aux | head -1; ps aux | sort -rnk 4 | head -5USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4</span><br></pre></td></tr></table></figure>\n\n<p>如果你喜欢这个命令，你可以用下面的命令为他指定一个别名，如果你想一直使用它，不要忘记把该命令添加到你的 <code>~/.bashrc</code> 文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ alias mem-by-proc&#x3D;&quot;ps aux | head -1; ps aux | sort -rnk 4&quot;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一些根据用户查看内存使用情况的命令：</p>\n<h3 id=\"按用户查看内存使用情况\"><a href=\"#按用户查看内存使用情况\" class=\"headerlink\" title=\"按用户查看内存使用情况\"></a>按用户查看内存使用情况</h3><h4 id=\"使用-top-1\"><a href=\"#使用-top-1\" class=\"headerlink\" title=\"使用 top\"></a>使用 top</h4><p>按照用户检查内存使用情况会更复杂一些，因为你需要找到一种方法把用户所拥有的所有进程统计为单一的内存使用量。</p>\n<p>如果你只想查看单个用户进程使用情况，<code>top</code> 命令可以采用与上文中同样的方法进行使用。只需要添加 <code>-U</code> 选项并在其后面指定你要查看的用户名，然后按下 <code>shift+m</code> 便可以按照内存使用有多到少进行查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ top -U nemotop - 10:16:33 up 5 days, 40 min,  3 users,  load average: 1.91, 1.82, 2.15Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie%Cpu(s): 28.5 us, 36.8 sy,  0.0 ni, 34.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    224.1 free,   2752.9 used,   2967.4 buff&#x2F;cacheMiB Swap:   2048.0 total,   2042.7 free,      5.2 used.   2812.0 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3315724 623748 165440 S   1.0  10.2   1:48.78 Web Content32469 nemo      20   0 3629380 607492 161688 S   2.3  10.0   6:06.89 firefox32542 nemo      20   0 2886700 404980 136648 S   5.6   6.7   6:50.01 Web Content  342 nemo      20   0 2922248 375784 116096 S  19.5   6.2   8:16.07 Web Content 2389 nemo      20   0 1762960 234644  87452 S   0.0   3.9  13:57.53 vlc29527 nemo      20   0 2736924 227260  86092 S   0.0   3.7   4:09.11 gnome-shell30497 nemo      30  10 1088476 156372  85620 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 138160  30336 S   0.0   2.3   0:04.62 gnome-software32533 nemo      20   0 2389088 102532  76808 S   0.0   1.7   0:01.79 WebExtensions</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用-ps-1\"><a href=\"#使用-ps-1\" class=\"headerlink\" title=\"使用 ps\"></a>使用 ps</h4><p>你依旧可以使用 <code>ps</code> 命令通过内存使用情况来排列某个用户的进程。在这个例子中，我们将使用 <code>grep</code> 命令来筛选得到某个用户的所有进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ps aux | head -1; ps aux | grep ^nemo| sort -rnk 4 | moreUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo     32469  7.1 11.5 3724364 701388 ?      Sl   08:54   7:21 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo       400  2.0  8.9 3308556 543232 ?      Sl   08:59   2:01 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni&#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32542  7.9  7.1 2903084 436196 ?      Sl   08:55   8:07 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342 10.8  7.0 2941056 426484 ?      Rl   08:59  10:45 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 16.9  3.8 1762960 234644 pts&#x2F;1  Sl+  09:15  13:57 vlc videos&#x2F;edge_computing.mp4nemo     29527  3.9  3.7 2736924 227448 ?      Ssl  08:50   4:11 &#x2F;usr&#x2F;bin&#x2F;gnome-shell</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-ps-和其他命令的搭配\"><a href=\"#使用-ps-和其他命令的搭配\" class=\"headerlink\" title=\"使用 ps 和其他命令的搭配\"></a>使用 ps 和其他命令的搭配</h3><p>如果你想比较某个用户与其他用户内存使用情况将会比较复杂。在这种情况中，创建并排序一个按照用户总的内存使用量是一个不错的方法，但是它需要做一些更多的工作，并涉及到许多命令。在下面的脚本中，我们使用 <code>ps aux | grep -v COMMAND | awk &#39;{print $1}&#39; | sort -u</code> 命令得到了用户列表。其中包含了系统用户比如 <code>syslog</code>。我们对每个任务使用 <code>awk</code> 命令以收集每个用户总的内存使用情况。在最后一步中，我们展示每个用户总的内存使用量（按照从大到小的顺序）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!&#x2F;bin&#x2F;bashstats&#x3D;””echo &quot;%   user&quot;echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;# collect the datafor user in &#96;ps aux | grep -v COMMAND | awk &#39;&#123;print $1&#125;&#39; | sort -u&#96;do  stats&#x3D;&quot;$stats\\n&#96;ps aux | egrep ^$user | awk &#39;BEGIN&#123;total&#x3D;0&#125;; \\    &#123;total +&#x3D; $4&#125;;END&#123;print total,$1&#125;&#39;&#96;&quot;done# sort data numerically (largest first)echo -e $stats | grep -v ^$ | sort -rn | head</span><br></pre></td></tr></table></figure>\n\n<p>这个脚本的输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ .&#x2F;show_user_mem_usage%   user&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;69.6 nemo5.8 root0.5 www-data0.3 shs0.2 whoopsie0.2 systemd+0.2 colord0.2 clamav0 syslog0 rtkit</span><br></pre></td></tr></table></figure>\n\n<p>在 Linux 有许多方法可以报告内存使用情况。可以通过一些用心设计的工具和命令，来查看并获得某个进程或者用户占用着最多的内存。</p>\n"}],"PostAsset":[{"_id":"source/_posts/spring/spring-cloud-learning/3.png","slug":"3.png","post":"ckipcgz87001hmxcd1our15vm","modified":0,"renderable":0},{"_id":"source/_posts/spring/spring-cloud-learning/4.png","slug":"4.png","post":"ckipcgz87001hmxcd1our15vm","modified":0,"renderable":0},{"_id":"source/_posts/data-structure-overview/hashtable.jpg","slug":"hashtable.jpg","post":"ckipcgz5t000pmxcd556qev6h","modified":0,"renderable":0},{"_id":"source/_posts/data-structure-overview/heap.jpg","slug":"heap.jpg","post":"ckipcgz5t000pmxcd556qev6h","modified":0,"renderable":0},{"_id":"source/_posts/data-structure-overview/linkedlist.jpg","slug":"linkedlist.jpg","post":"ckipcgz5t000pmxcd556qev6h","modified":0,"renderable":0},{"_id":"source/_posts/data-structure-overview/overview.png","slug":"overview.png","post":"ckipcgz5t000pmxcd556qev6h","modified":0,"renderable":0},{"_id":"source/_posts/data-structure-overview/queue.png","slug":"queue.png","post":"ckipcgz5t000pmxcd556qev6h","modified":0,"renderable":0},{"_id":"source/_posts/data-structure-overview/stack.png","slug":"stack.png","post":"ckipcgz5t000pmxcd556qev6h","modified":0,"renderable":0},{"_id":"source/_posts/data-structure-overview/tree.png","slug":"tree.png","post":"ckipcgz5t000pmxcd556qev6h","modified":0,"renderable":0},{"_id":"source/_posts/spring/spring-cloud-learning/1.png","slug":"1.png","post":"ckipcgz87001hmxcd1our15vm","modified":0,"renderable":0},{"_id":"source/_posts/spring/spring-cloud-learning/2.png","slug":"2.png","post":"ckipcgz87001hmxcd1our15vm","modified":0,"renderable":0},{"_id":"source/_posts/spring/spring-cloud-learning/5.png","slug":"5.png","post":"ckipcgz87001hmxcd1our15vm","modified":0,"renderable":0},{"_id":"source/_posts/spring/spring-cloud-learning/6.png","slug":"6.png","post":"ckipcgz87001hmxcd1our15vm","modified":0,"renderable":0},{"_id":"source/_posts/spring/spring-cloud-learning/7.png","slug":"7.png","post":"ckipcgz87001hmxcd1our15vm","modified":0,"renderable":0},{"_id":"source/_posts/spring/spring-cloud-learning/8.png","slug":"8.png","post":"ckipcgz87001hmxcd1our15vm","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"ckipcgz450000mxcd0gyn1o4p","tag_id":"ckipcgz4h0004mxcd4ntkexj3","_id":"ckipcgz4m0009mxcdbrs2b5fp"},{"post_id":"ckipcgz4e0002mxcd7nkf2iuq","tag_id":"ckipcgz4l0008mxcd0prx6kgx","_id":"ckipcgz4n000cmxcd5pxh55f6"},{"post_id":"ckipcgz4e0002mxcd7nkf2iuq","tag_id":"ckipcgz4m000amxcdgac16bn7","_id":"ckipcgz4o000dmxcd3m9h9x4t"},{"post_id":"ckipcgz4i0005mxcda3cd4y3x","tag_id":"ckipcgz4m000bmxcdgwbe8ama","_id":"ckipcgz4o000fmxcd88zr64v8"},{"post_id":"ckipcgz4k0007mxcd89izgkbn","tag_id":"ckipcgz4o000emxcd064w43e2","_id":"ckipcgz4q000jmxcdh85g1jay"},{"post_id":"ckipcgz4k0007mxcd89izgkbn","tag_id":"ckipcgz4p000gmxcdg7bedcp0","_id":"ckipcgz4q000kmxcd0ynx1tfm"},{"post_id":"ckipcgz4k0007mxcd89izgkbn","tag_id":"ckipcgz4p000hmxcd8jjfcqf8","_id":"ckipcgz4q000lmxcd93yx2izc"},{"post_id":"ckipcgz4k0007mxcd89izgkbn","tag_id":"ckipcgz4p000imxcdedlt6uwp","_id":"ckipcgz4q000mmxcdd64r6ssy"},{"post_id":"ckipcgz5r000nmxcdej19bm0l","tag_id":"ckipcgz4h0004mxcd4ntkexj3","_id":"ckipcgz5y000smxcdf6ktcod5"},{"post_id":"ckipcgz5r000nmxcdej19bm0l","tag_id":"ckipcgz5v000qmxcd6knjfh9p","_id":"ckipcgz5y000tmxcd1hzb84pk"},{"post_id":"ckipcgz5t000pmxcd556qev6h","tag_id":"ckipcgz4h0004mxcd4ntkexj3","_id":"ckipcgz5y000umxcd3px8hxbb"},{"post_id":"ckipcgz5t000pmxcd556qev6h","tag_id":"ckipcgz5v000qmxcd6knjfh9p","_id":"ckipcgz5y000vmxcd7ryf9q82"},{"post_id":"ckipcgz790010mxcdcwgd6ogz","tag_id":"ckipcgz4m000amxcdgac16bn7","_id":"ckipcgz7f0013mxcde9qf8bk7"},{"post_id":"ckipcgz74000wmxcd6qlf6w2l","tag_id":"ckipcgz76000ymxcddqsy6miq","_id":"ckipcgz7i0014mxcdexfd9h0t"},{"post_id":"ckipcgz75000xmxcdeftp4t4a","tag_id":"ckipcgz76000ymxcddqsy6miq","_id":"ckipcgz7j0017mxcderkr3g7c"},{"post_id":"ckipcgz75000xmxcdeftp4t4a","tag_id":"ckipcgz7i0015mxcdetekaxfg","_id":"ckipcgz7j0018mxcd9l1e8v0g"},{"post_id":"ckipcgz76000zmxcd1o4174cy","tag_id":"ckipcgz76000ymxcddqsy6miq","_id":"ckipcgz7j001amxcdfwi27lty"},{"post_id":"ckipcgz7c0011mxcdec14ffwy","tag_id":"ckipcgz7j0019mxcdbgpp1dkc","_id":"ckipcgz7j001cmxcd52z3a5fl"},{"post_id":"ckipcgz7c0011mxcdec14ffwy","tag_id":"ckipcgz7j001bmxcdak2w6gjv","_id":"ckipcgz7k001dmxcd11atds4s"},{"post_id":"ckipcgz85001emxcdcdqp70jg","tag_id":"ckipcgz87001gmxcdbgsxegnh","_id":"ckipcgz89001kmxcd2vy7fp8e"},{"post_id":"ckipcgz86001fmxcd144h5sya","tag_id":"ckipcgz87001gmxcdbgsxegnh","_id":"ckipcgz8a001mmxcdhpmngws0"},{"post_id":"ckipcgz87001hmxcd1our15vm","tag_id":"ckipcgz8a001lmxcda6kyhf19","_id":"ckipcgz8b001pmxcdbdd36b5n"},{"post_id":"ckipcgz87001hmxcd1our15vm","tag_id":"ckipcgz87001gmxcdbgsxegnh","_id":"ckipcgz8b001qmxcdfjvz6m4t"},{"post_id":"ckipcgz88001imxcd73ph8ypk","tag_id":"ckipcgz8b001omxcd1q5xcv7d","_id":"ckipcgz8b001rmxcd77eqc8rl"},{"post_id":"ckipcgz8r001smxcdcy30603i","tag_id":"ckipcgz8w001umxcdbuld9vsp","_id":"ckipcgz8z001wmxcda4pi33do"},{"post_id":"ckipcgz8r001smxcdcy30603i","tag_id":"ckipcgz8x001vmxcd8ac2dzfp","_id":"ckipcgz8z001xmxcd1a22eek7"},{"post_id":"ckipcgz9v001ymxcd1brjhqma","tag_id":"ckipcgz4m000amxcdgac16bn7","_id":"ckipcgz9w0020mxcd03kdben8"},{"post_id":"ckipcgz9v001ymxcd1brjhqma","tag_id":"ckipcgz9w001zmxcdd2d47fko","_id":"ckipcgz9w0021mxcd72grddcx"},{"post_id":"ckipy0qs800002hcd3h2wgo1j","tag_id":"ckipcgz4m000amxcdgac16bn7","_id":"ckipy0qse00012hcd181w3mka"}],"Tag":[{"name":"数据结构","_id":"ckipcgz4h0004mxcd4ntkexj3"},{"name":"Mac","_id":"ckipcgz4l0008mxcd0prx6kgx"},{"name":"Linux","_id":"ckipcgz4m000amxcdgac16bn7"},{"name":"MySQL","_id":"ckipcgz4m000bmxcdgwbe8ama"},{"name":"redis","_id":"ckipcgz4o000emxcd064w43e2"},{"name":"cluster","_id":"ckipcgz4p000gmxcdg7bedcp0"},{"name":"docker","_id":"ckipcgz4p000hmxcd8jjfcqf8"},{"name":"docker-compose","_id":"ckipcgz4p000imxcdedlt6uwp"},{"name":"算法","_id":"ckipcgz5v000qmxcd6knjfh9p"},{"name":"Hexo","_id":"ckipcgz76000ymxcddqsy6miq"},{"name":"Github","_id":"ckipcgz7i0015mxcdetekaxfg"},{"name":"mac","_id":"ckipcgz7j0019mxcdbgpp1dkc"},{"name":"node","_id":"ckipcgz7j001bmxcdak2w6gjv"},{"name":"Java","_id":"ckipcgz87001gmxcdbgsxegnh"},{"name":"Spring","_id":"ckipcgz8a001lmxcda6kyhf19"},{"name":"Docker","_id":"ckipcgz8b001omxcd1q5xcv7d"},{"name":"kafka","_id":"ckipcgz8w001umxcdbuld9vsp"},{"name":"mq","_id":"ckipcgz8x001vmxcd8ac2dzfp"},{"name":"Centos","_id":"ckipcgz9w001zmxcdd2d47fko"}]}}