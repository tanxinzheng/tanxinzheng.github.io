{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/BingSiteAuth.xml","path":"BingSiteAuth.xml","modified":0,"renderable":0},{"_id":"source/images/post/1879991184/thumbnail.jpeg","path":"images/post/1879991184/thumbnail.jpeg","modified":0,"renderable":0},{"_id":"source/images/post/2231850037/thumbnail.jpg","path":"images/post/2231850037/thumbnail.jpg","modified":0,"renderable":0},{"_id":"source/images/post/2578104314/720430-20181226134250810-1685533200.png","path":"images/post/2578104314/720430-20181226134250810-1685533200.png","modified":0,"renderable":0},{"_id":"source/images/post/2578104314/720430-20181226134259735-1931086473.png","path":"images/post/2578104314/720430-20181226134259735-1931086473.png","modified":0,"renderable":0},{"_id":"source/images/post/2578104314/720430-20181226134308841-1109691453.png","path":"images/post/2578104314/720430-20181226134308841-1109691453.png","modified":0,"renderable":0},{"_id":"source/images/post/2578104314/720430-20181226134321094-1025894099.png","path":"images/post/2578104314/720430-20181226134321094-1025894099.png","modified":0,"renderable":0},{"_id":"source/images/post/2827031203/cover.png","path":"images/post/2827031203/cover.png","modified":0,"renderable":0},{"_id":"source/images/post/2827031203/hashtable.jpg","path":"images/post/2827031203/hashtable.jpg","modified":0,"renderable":0},{"_id":"source/images/post/2827031203/heap.jpg","path":"images/post/2827031203/heap.jpg","modified":0,"renderable":0},{"_id":"source/images/post/2827031203/linkedlist.jpg","path":"images/post/2827031203/linkedlist.jpg","modified":0,"renderable":0},{"_id":"source/images/post/2827031203/overview.png","path":"images/post/2827031203/overview.png","modified":0,"renderable":0},{"_id":"source/images/post/2827031203/queue.png","path":"images/post/2827031203/queue.png","modified":0,"renderable":0},{"_id":"source/images/post/2827031203/stack.png","path":"images/post/2827031203/stack.png","modified":0,"renderable":0},{"_id":"source/images/post/2827031203/tree.png","path":"images/post/2827031203/tree.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201216105335033.png","path":"images/post/41928511/image-20201216105335033.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201216105708714.png","path":"images/post/41928511/image-20201216105708714.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217231236527.png","path":"images/post/41928511/image-20201217231236527.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217232318516.png","path":"images/post/41928511/image-20201217232318516.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217232602098.png","path":"images/post/41928511/image-20201217232602098.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217232654936.png","path":"images/post/41928511/image-20201217232654936.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217232930044.png","path":"images/post/41928511/image-20201217232930044.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217233140546.png","path":"images/post/41928511/image-20201217233140546.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217233418235.png","path":"images/post/41928511/image-20201217233418235.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217233631334.png","path":"images/post/41928511/image-20201217233631334.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217233848143.png","path":"images/post/41928511/image-20201217233848143.png","modified":0,"renderable":0},{"_id":"source/images/post/41928511/image-20201217234030155.png","path":"images/post/41928511/image-20201217234030155.png","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/ea0d59f6be5a616851c2d2d5e7f267e9.txt","path":"ea0d59f6be5a616851c2d2d5e7f267e9.txt","modified":0,"renderable":0}],"Cache":[{"_id":"themes/butterfly/README.md","hash":"4d0b23ad00caadaa717555cb8fd37d272eeaeca0","modified":1608303883665},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1608303883665},{"_id":"themes/butterfly/package.json","hash":"3de369e085b5a39cfda46604f34be74ed6f7ac6d","modified":1608303883683},{"_id":"themes/butterfly/README_CN.md","hash":"37062b0e965b9070a42f06283d597d895c8aa9e3","modified":1608303883665},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1608303883665},{"_id":"themes/butterfly/languages/default.yml","hash":"690fae93ee2e578e9085e988654ddb013d2fffd9","modified":1608303883666},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"5fd8a9d0e115c3237ce6119ad7c4636303dc9aaf","modified":1608375009814},{"_id":"themes/butterfly/_config.yml","hash":"7277478e158dca3c1d34cf1053f7c5eccaf9d172","modified":1608820441369},{"_id":"themes/butterfly/languages/en.yml","hash":"948f4a29cd5fafdc46ad2008f60929acf76be2a3","modified":1608303883666},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"3a02788767ed6a751e1c350ec620354b50ac86b9","modified":1608303883666},{"_id":"themes/butterfly/layout/404.pug","hash":"10ce9b0764d975460069bf116bfceaaeb9691d3a","modified":1608303883667},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1608303883667},{"_id":"themes/butterfly/layout/category.pug","hash":"90e56274a7c853f6f30337011f9c9d6d035950dc","modified":1608303883667},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1608303883683},{"_id":"themes/butterfly/layout/page.pug","hash":"76536c903cabc8e4619759e3a8b6a384c0518716","modified":1608303883683},{"_id":"themes/butterfly/layout/post.pug","hash":"0277577f7fce2b830259e29d3a2a82f35addbf78","modified":1608303883683},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1608303883683},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1608303883664},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1608303883664},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1608303883665},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"924e1fefc81f33f165a5fa9856712a98e7c83ad5","modified":1608303883667},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"d36ce54746a582a542ef520f926894c036a8f8ee","modified":1608303883667},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"780566ea9155df8f503af4e80ec7eff10e00859a","modified":1608303883668},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"6006ae4885ad82bd41ffd0f1734bde94d442c9ff","modified":1608303883671},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"012e46f5130a2ff312c28a4fcdc060195f92efde","modified":1608303883672},{"_id":"themes/butterfly/scripts/events/404.js","hash":"5f6127ede7d139891208340b5cf5bf9314e4be7d","modified":1608303883684},{"_id":"themes/butterfly/scripts/events/init.js","hash":"f7ab55363d05c945569d9ac4afc889f9706308c6","modified":1608303883684},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"66b14189a1913119ff5927c0b933b5c73fb37f48","modified":1608303883673},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1608303883684},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"1e2ac4d26df7cd18a92f1404329f8eb1c388dc18","modified":1608303883684},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"dbce193ba170e004790550fe4694de8e29b299b9","modified":1608303883684},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"86b2a4d500542fe764fdc5ff71cf029604325930","modified":1608303883673},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"d9cdeecfb0098ad9bf4814ea2f95167b637e015d","modified":1608303883685},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"ff3815e6923f248501ed76aebfa6e8e083edb9f7","modified":1608303883685},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"f42b2358a44d91ef6c853ce75f23af6e8d3ff423","modified":1608303883685},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"0745597f4ffadde037e57e0f66f7d984dc576dc6","modified":1608303883685},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"54c0c9c6d4d4ca754680cd24d7e204a745a6eec0","modified":1608303883685},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ffbe625f184116e442648c8416ea58614a1cef8","modified":1608303883685},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"eb019da8c190923e759d2fd7cb846281eef8594e","modified":1608303883686},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"829229b0074b332ba779e159219eb2466612ff6e","modified":1608303883686},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1608303883686},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1608303883686},{"_id":"themes/butterfly/source/css/index.styl","hash":"74f6e2a97d8b83e74375cfdc57818d19762c8ae5","modified":1608303883695},{"_id":"themes/butterfly/source/css/var.styl","hash":"ae8193bd0107c823b8d2a123f1c301084c9c227a","modified":1608303883695},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1608303883696},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1608285148484},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1608285148485},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1608285148486},{"_id":"themes/butterfly/source/js/main.js","hash":"cbc4d7e84f0a963769efd70c8075dcae2aeccf99","modified":1608303883697},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1608303883698},{"_id":"themes/butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1608285148487},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"0cdd68a0aaea5aa629fee1c135d6202b40da1202","modified":1608367067035},{"_id":"themes/butterfly/source/js/utils.js","hash":"ba7e672a7bed2aefb9174e8122d92a643814272a","modified":1608303883698},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"767b425f97e74a98002f4a435e36e8ec27e8a994","modified":1608303883668},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"e33b993af0bfc521334dac8e3c8a227dfbf9fcaa","modified":1608303883668},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1608303883668},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"afe703c766b8717d119379ee27037481f1165af8","modified":1608303883668},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"f8068879e0b6592e347ccdf78b945c4ad172d948","modified":1608459219084},{"_id":"themes/butterfly/layout/includes/head/js.pug","hash":"473059d3a4a63fa95ea4d2ca71ae16c003502e0a","modified":1608303883669},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1608303883669},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1608303883669},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"1ddbd09e1902da7fa4bf7824654f132e41622c42","modified":1608303883669},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"9a6f8211cdcb4aa87ccb5fa4f62b89c245412c94","modified":1608303883670},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"d22d4c98028272dfc6c2e721e469f572a6b62ed3","modified":1608303883670},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"0060598ca1cf25619bdb110ea2c83c690e4d2939","modified":1608303883670},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1608303883670},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"81a34e9d642a68e77650609601a8096c6445daef","modified":1608303883671},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"a9a8ed40a258e6ee0a049fae50bcf5040604b63b","modified":1608303883670},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1608303883671},{"_id":"themes/butterfly/layout/includes/page/artitalk.pug","hash":"f1476d8b05d81e572556f246ac2212085cbdf792","modified":1608303883672},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"95924d28d71b28769963529f82b376a9dc731fad","modified":1608303883672},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"f5ea1e10a169aeb98e42b19ac084c4eb27693b46","modified":1608303883672},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"7e7832aafdf5ca50e71a039ad3fc98d8ef6e7d30","modified":1608303883672},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"62dc2e683d56ddc9b588abc44dc1cfb778a2c68f","modified":1608303883672},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2beb27e33e4492fa80e88c37dcb7a3ffd7da9e24","modified":1608303883671},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1608303883673},{"_id":"themes/butterfly/layout/includes/third-party/baidu_push.pug","hash":"8d40e62805466d35d815df0cd97537fed8664421","modified":1608570025088},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"90b5c2600569f8cf769c5fb3a37c12536f71e375","modified":1608303883671},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"d9b96f24c2439f263a606fd38a5517bd4bb162b7","modified":1608303883673},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1608303883674},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"38504aec959c050c082db1c5aeaf99345f97bbee","modified":1608303883679},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1608303883677},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"21a7f17ff457c0cf8747f0847dee6df675482574","modified":1608303883679},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1608303883679},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1608303883681},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"851514d1200d1dbc99268b190c03d3bd83ba68d5","modified":1608303883681},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"e0e8bf00ef7a0a62ea2265bd5e4a33d0edab5946","modified":1608303883681},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"a72b8e82b99ba79903eaa53478bbd8f4ba4412e1","modified":1608303883681},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"1c8eb5752cc6d42b384d7e363e66ece3f742f479","modified":1608398612971},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"9066634f04443953e5c4e1b563e79ab6218983de","modified":1608303883681},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"1b48347561b6d068f3c720802dd9223a8d1971a5","modified":1608303883682},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"41790dac9780bebe95a2be2d7e327bd98be362d3","modified":1608303883682},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"3a8e63d6c9f74578c55b96e3888adbf9928dad0a","modified":1608303883682},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"966c31e7c57dbc543bb94e6f3802c4738c79ba47","modified":1608303883682},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"e00568eb9a3c9ff005e1fbd505042081884a552a","modified":1608303883682},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"8df2824b78b28d12da61a82a0da995b3116673a3","modified":1608303883682},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"56ce639b394ba195207ee00f5a2d6f22926b403f","modified":1608303883687},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"18474102233847c9452c7eb1048df58dfd33c962","modified":1608303883687},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"d67ecb6c950e802a9c73975b13cab44f899eb192","modified":1608303883687},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3f0b8699f529f0842c3b101006f60cb7933c16ff","modified":1608303883689},{"_id":"themes/butterfly/source/css/_layout/404.styl","hash":"84c14368d3fab66d5fb7d03678766274e2e0d84f","modified":1608303883689},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1608303883689},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"8a59aa7c185d89b437c0f529d57381dc21ff06ed","modified":1608303883689},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8e6c9a2c1881985e4b2ae14ef1bdfdbb1bc83b37","modified":1608303883690},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"bfc4b9d8df66593c11c9ae78899f54e69785ca90","modified":1608303883690},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"807f18717c29b5c41de6fc600a69a80ce8b7a19c","modified":1608303883690},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"c4ae9292d6b7e42943b1b11e109ed560dc3a7753","modified":1608303883691},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"9e66e9672eb6d60950024d5f73cb7b925b2549b2","modified":1608303883690},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"ba391266cd967fa96109677455dd6701292afd52","modified":1608303883691},{"_id":"themes/butterfly/source/css/_layout/footer_badge.styl","hash":"dc2fffffebae7b254a4d69ce9d28c2c6b134df42","modified":1608303883690},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"d6149c50ad33b3feb3da8a9d0b9e6557d1137210","modified":1608303883691},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"6c74997b89984db3696572efc7cbafdf59ce7803","modified":1608303883691},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"e00d34774a0d5644bae9989f0e89743b5f9e2ea5","modified":1608303883691},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"0cb678f991af06015804eaebafa8e983b0dcc3de","modified":1608303883692},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"17f2d47f93cb91e1f5d5c046fcd649d4c54f0107","modified":1608303883692},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"78ef182c0f6711c8491a8ee421b708c8f2a63c30","modified":1608303883691},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"573d3834d15768f9a6f70b86d28d9a9c44764e89","modified":1608303883692},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"92aa84cdec97729c86ba4674a355496eb37c986a","modified":1608303883694},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"202b01db6ef3cca9e5a173e1a0dadfee8854a849","modified":1608303883693},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"ca1d3a885a85a91fcd6f7b55fca96cafb6a1b0a3","modified":1608303883692},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"a470029a157fbb8406ff72322a75ef63d6675431","modified":1608303883693},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1608303883692},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4058ab759577efe280d5e38902be39054ed4b471","modified":1608303883693},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"26e26797b3175498e20b2a8bf1679d3ed9fac5a6","modified":1608303883693},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"75c87cb69b2eb2a219eec9447cd79282ef612a68","modified":1608303883693},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"3c7a7efbb14d8ce6538f612992aa1a62fd278991","modified":1608303883693},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6c12a03e26ca5d538537d472657d3d03a7fcbb87","modified":1608303883694},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1608303883694},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"5fe4235c038ed128819bd6918cd0781b372b598e","modified":1608303883694},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"56691537c7f06c2cf1ffa1509a328f506d938ee8","modified":1608303883694},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"75a5c15c7029197ec5cffd27f7c5455891c946c9","modified":1608303883694},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1608303883695},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1608303883695},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a19f12257b14f70806a0c3cb0e9df1090f36e919","modified":1608303883698},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1608303883674},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"3234942decaa1fde5b872766d4943a2e8cb9ef72","modified":1608303883698},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1608303883674},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1608303883674},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1608303883674},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1608303883675},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1608303883675},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"663a298253eddb5126ca1a6139d69c7097ffb52e","modified":1608303883675},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"47d5367d8308a5a134058f9f63c33c75890960f8","modified":1608303883675},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"9b6b7b589ef7a8109d88ba439b2d8baf7286b961","modified":1608303883675},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"a8d8be37236400508e97f75615f03cedccacddfb","modified":1608303883675},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"91f269cdec593209950506b8b65e938ca3d0372a","modified":1608303883676},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"6f4829a8e08c3bd36e96477efdbe552c85a7350b","modified":1608303883676},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1608303883676},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1608303883676},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"776b71dd76a900b1bdf8e6e6fdf94e82bbe7e2b1","modified":1608303883676},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"c8245cbb908c64430470b0ef2887d468ef77189c","modified":1608303883677},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"0322d640fd6a91853dec3ad39cc24c9b1291322b","modified":1608303883677},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"407d88e4af099d5f1a3f44623ec276c999219ec3","modified":1608303883677},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"6f92311afe60ca5f44055016db9cecce8fb2dc62","modified":1608303883677},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"faf1113de12d6db0486572d7e99b03cbd0c4a896","modified":1608303883678},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"7ced4e62fc669b00c30bf5ffe814bd30d963a490","modified":1608303883678},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"732f4ebf7a1be1c94917dec426acaa494348c0ef","modified":1608303883678},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"6ba8915b0da215f306f0b055f0484d23eb26c84d","modified":1608303883678},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/leancloud.pug","hash":"d78d0bd454f6bea611a55601807e63e107dfb60c","modified":1608303883679},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"b187ee9721cfa864208af3e51a8b0d72fc5aa6ea","modified":1608303883679},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"1c06e60b120c946c1856904848ceba6ab58d1f82","modified":1608303883680},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1608303883680},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"fbcf94ecdca30bed7cfc4f4ec08b200579c2614e","modified":1608303883680},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1608303883680},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1608303883680},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"0622e955f3d2efef457f61d0cec0408376bd180a","modified":1608303883680},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1608303883680},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"ba3bdf02a6c78b15eada95638173a11445dac7ac","modified":1608303883688},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"1b2dc0ef768c9be9f18d1c1f93d88f916482c5df","modified":1608303883688},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1608303883688},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"ebae44a37ac143f4e35523ebd6809371958fb930","modified":1608303883688},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"c1747b8641303a1d9472ec94f2bc654885feb270","modified":1608303883688},{"_id":"source/.DS_Store","hash":"d2ee64bc83a9ab7a3240a6f1a78a7ad5e26ca267","modified":1608295905559},{"_id":"source/404.html","hash":"651f5594772adaefc5344a226d2b61bc0a690dec","modified":1608316996497},{"_id":"source/BingSiteAuth.xml","hash":"edf8a00778a364244213b8cd364542a568af235b","modified":1608517474404},{"_id":"source/_posts/todos.md","hash":"486ff874389fcc1a6f33eb6264364fef103bb437","modified":1608517474405},{"_id":"source/_data/link.yml","hash":"7430359d1fe72809876d29612204ad0728fb83b5","modified":1608374422616},{"_id":"source/categories/index.md","hash":"79d0cb7b22c9f1d2fafca8ebfdcdd45e88990c07","modified":1608819541341},{"_id":"source/about/index.md","hash":"40765722e5d92482d07c8f7fcda7d8bfb349efb6","modified":1608819541341},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1608295914129},{"_id":"source/movies/index.md","hash":"8f947a60225d9c9f57d901b931f55652d8b9e7f2","modified":1608819541341},{"_id":"source/books/index.md","hash":"17dded9d039fb2abef0c4bda37f9af1c39aae7a5","modified":1608819541341},{"_id":"source/tags/index.md","hash":"f0b6af95c5493a3c683dc5bbf3bc6098b3089076","modified":1608819541341},{"_id":"source/links/index.md","hash":"59645ba7edcc072936ac01ac13c6bd1eff177e81","modified":1608820505585},{"_id":"source/_drafts/.DS_Store","hash":"23507b682cc6652f55072d30d75a60e9cb45d8c5","modified":1587395061901},{"_id":"source/_posts/技术分享/data-structure.md","hash":"231cca36c381c2b3b2643431da91ee2e70de1191","modified":1608820775813},{"_id":"source/images/.DS_Store","hash":"b7f0f60c4b54c7c59ca5e9814420f3b3852e4b87","modified":1608534121105},{"_id":"source/_posts/技术分享/mysql-index-learning.md","hash":"b90a175049b7f232f94c20b1f5566f504b0ddde3","modified":1608820775813},{"_id":"source/_posts/技术分享/redis-cluster.md","hash":"2eca08c63fd6bd8d05d8460bf1261179a8dc956c","modified":1608820775813},{"_id":"source/_posts/技术分享/正则表达式大全.md","hash":"81dfb0f9238d27c9dc7f508f763db7a6f25c1e75","modified":1608820775813},{"_id":"source/_posts/技术分享/修改hosts加速Github访问.md","hash":"cd5e367905c1d98d79b8bdfc36d8a7aa7c3269af","modified":1608820775813},{"_id":"source/images/category/git-logo.jpg","hash":"cb212801ab930fb0603b1a8a518cf0323404df8c","modified":1608517474544},{"_id":"source/images/category/github-office.jpg","hash":"7468826fd37b3bf60c21bcba5d3d8fe0c867f0d8","modified":1608517474544},{"_id":"source/images/category/hexo.jpeg","hash":"adaaf4d9ebaea9c4a43bb90187368967a48f8888","modified":1608517474545},{"_id":"source/images/category/https.jpg","hash":"6045840c81de5a769d8008a640c0984525856c4b","modified":1608517474546},{"_id":"source/images/category/kafka.jpg","hash":"2c11154a8d767ce070c80bd1b2c0e1f66dfb3d97","modified":1608517474577},{"_id":"source/images/category/linux.jpeg","hash":"b437e6194f139a064d3e096f9fd4a107ef02dde8","modified":1608517474584},{"_id":"source/images/category/macos.png","hash":"24d35599607ea5ec6bf5edd6caa2e4c41c20cec2","modified":1608517474587},{"_id":"source/images/category/markdown.png","hash":"08d9a1ade68de7c678cff7972573eabaf8231333","modified":1608517474592},{"_id":"source/images/category/nodejs.png","hash":"4f5a755691f7aebd1d60aaa7e2f6124a739cacb8","modified":1608517474597},{"_id":"source/images/category/redis.jpg","hash":"48afb52220396b7dcdf6d9668c35021943ac0efa","modified":1608517474597},{"_id":"source/_posts/技术分享/git/github访问加速.md","hash":"aeb526eb0136b278e8a05630eb1b3eb336d007df","modified":1608820775813},{"_id":"source/_posts/技术分享/git/git添加ssh密钥.md","hash":"3298a8afb6332a84615c9b788689c60eabe106e0","modified":1608820775813},{"_id":"source/_posts/技术分享/linux/Linux之SSH免密登录.md","hash":"16f92a1b7712e280a6d4897e11a16137ecf1d665","modified":1608820775813},{"_id":"source/_posts/技术分享/linux/Linux查看内存使用量.md","hash":"c4fe1040e63eef8f23aad79f4d5c3f9cc76d74dc","modified":1608820775813},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning.md","hash":"d055eacb91da80803c1d2bfd2a7c77045f4e678a","modified":1608820775813},{"_id":"source/_posts/技术分享/linux/linux与k8s的区别.md","hash":"9b65b0b8a687fc9f4f718342fb362a2a8988a3f7","modified":1608820775813},{"_id":"source/_posts/理论学习/java/hashcode.md","hash":"f3f060a204f6ef16ae14c3dae561a0fcff18d80e","modified":1608820775813},{"_id":"source/_posts/理论学习/java/jvm.md","hash":"aebec8343beee75c78597e38a2bd3e47c45c6517","modified":1608820775813},{"_id":"source/_posts/技术分享/mac/Mac命令生成crt证书.md","hash":"1c304f6057fa769531e2846154b4a34a2e579522","modified":1608820775813},{"_id":"source/_posts/技术分享/mac/Mac系统下升级node版本.md","hash":"6a1d97a06fe40ad05a9402492787cf5ab0a43d66","modified":1608820775814},{"_id":"source/_posts/技术分享/mac/Mac命令生成pem证书.md","hash":"d597ae336c1da3a849bdd084cf60f9e9dbb8e489","modified":1608820775813},{"_id":"source/_posts/理论学习/markdown/Markdown导出带目录的html文件.md","hash":"78450c058c3e1db2a93e4eacca539ba95e036a21","modified":1608820775813},{"_id":"source/_posts/理论学习/markdown/Markdown模板汇总.md","hash":"33b258bdf22f67647377d103317ec779012d15a2","modified":1608820775813},{"_id":"source/_posts/博客教程/hexo/hexo写作.md","hash":"b9c6e5fa8d4d7b3fa43eee7f93434e3ce2c36fa2","modified":1608820775813},{"_id":"source/_posts/博客教程/hexo/NexT主题自定义配置.md","hash":"3b63bb7320191498d336581d214a42fc965dec17","modified":1608820775813},{"_id":"source/_posts/各类教程/中间件/https教程.md","hash":"3a58ba7acf57cf6d3d217ef378b3b920036e11c5","modified":1608820775813},{"_id":"source/_posts/博客教程/hexo/hexo命令.md","hash":"677434967722e6fdba09718eee5d8e932074737a","modified":1608820775813},{"_id":"source/_posts/博客教程/hexo/基于Github Action工作流自动部署Hexo.md","hash":"5ff88832f6c6212f49397df3d2c5924bc66551d6","modified":1608820775813},{"_id":"source/images/post/1879991184/thumbnail.jpeg","hash":"7d01a6e80f2aa14cedb2e429cde591df5a526ea4","modified":1608517474599},{"_id":"source/images/post/2231850037/thumbnail.jpg","hash":"518d9efbbbc5f270f54775083e3ad5d397fa3256","modified":1608517474603},{"_id":"source/images/post/2827031203/hashtable.jpg","hash":"0228ea21bac82c01fdd0d9da4053897d32cb0666","modified":1608517474640},{"_id":"source/images/post/2827031203/linkedlist.jpg","hash":"a0e88d4b9e0f3b8fdf986a7264a82e8b5c65b52f","modified":1608517474648},{"_id":"source/images/post/2827031203/queue.png","hash":"2471e04cc8484d3796e670340ad0fa8e43232477","modified":1608517474652},{"_id":"source/images/post/2827031203/heap.jpg","hash":"906ce5bed102dd1cb26e16f716793267fbe53add","modified":1608517474643},{"_id":"source/images/post/41928511/image-20201217231236527.png","hash":"e66cedf158ce9491995bda51e5e4c8c1c51066e8","modified":1608517474730},{"_id":"source/_posts/各类教程/中间件/kafka入门教程.md","hash":"13aad814d9340930cdfd28c4d136d3aadbb97fab","modified":1608820775813},{"_id":"source/images/post/41928511/image-20201217232602098.png","hash":"a018b25f1f78c28a8b4cea7d183fb63eb4458e29","modified":1608517474734},{"_id":"source/images/post/41928511/image-20201217232318516.png","hash":"792fb92a1ba654f2176e8dcb763d35b207fd5f33","modified":1608517474731},{"_id":"source/images/post/41928511/image-20201217232654936.png","hash":"810ab508ce5ff4db9c75297ff006a350ca2c57b0","modified":1608517474737},{"_id":"source/images/post/41928511/image-20201217233631334.png","hash":"721945659da8217c52a7036e560a81d5c0f957df","modified":1608517474778},{"_id":"source/_posts/技术分享/linux/linux命令/Linux命令killall.md","hash":"ddb1f4849bc18e2fe54a9cbe5f6635e4a436d767","modified":1608820775813},{"_id":"source/_posts/技术分享/linux/linux命令/Linux命令systemd.md","hash":"b42f812684001ff635447cdf3b2d777799a482d2","modified":1608820775813},{"_id":"source/_posts/各类教程/中间件/https教程.assets/image-20201217231236527.png","hash":"e66cedf158ce9491995bda51e5e4c8c1c51066e8","modified":1608517474407},{"_id":"source/img/wechatpay.jpg","hash":"8547ff093d704c77131abe7bda9aa69ae723eac0","modified":1587266940841},{"_id":"source/_posts/技术分享/后端架构师技术图谱.md","hash":"92707a9fefcfed1daddb8f1357708e31285123b9","modified":1608820775813},{"_id":"source/images/category/mysql.png","hash":"a7fc1ca48a6dc7f044cdb0fce7d54ee8345b07d7","modified":1608517474596},{"_id":"source/images/banner/archives4.jpg","hash":"b4b0711b164f74265e2f9926e42059c5cf14cbcf","modified":1608545577143},{"_id":"source/images/category/regex.jpg","hash":"4a01bb34c42dbd4b977d3017108e07f9cf11c571","modified":1608518153728},{"_id":"source/images/banner/tag.jpg","hash":"38bb454359291bec38be878d4f1485b124c8ce4f","modified":1608545389267},{"_id":"source/images/post/2578104314/720430-20181226134250810-1685533200.png","hash":"3b3b78ddd2fb1927cadbac96bfdfcdf829c080fb","modified":1608517474607},{"_id":"source/images/post/2578104314/720430-20181226134259735-1931086473.png","hash":"70db176711e85e6ba1b6031a59b00125412492d0","modified":1608517474608},{"_id":"source/images/post/2827031203/cover.png","hash":"a082e734fb23ad199d8e5a2a53adb86349509a36","modified":1608517474640},{"_id":"source/images/post/2827031203/overview.png","hash":"e7ec9f16e9f389f7a20eb04f747fd0f86a8daacf","modified":1608517474649},{"_id":"source/images/post/2827031203/stack.png","hash":"3736ff92eaad9a88e52c47e393513bff93b84988","modified":1608517474659},{"_id":"source/images/post/41928511/image-20201217232930044.png","hash":"f5a55885100d3982fbfcf2f31a8932d8d5382f6f","modified":1608517474752},{"_id":"source/images/post/41928511/image-20201217233140546.png","hash":"0d59319a58f158325f6f06b652380d4446f2e822","modified":1608517474759},{"_id":"source/images/post/41928511/image-20201217233848143.png","hash":"8d00995231a4227ac4cd45f67327d35bacb1b52e","modified":1608517474785},{"_id":"source/images/post/41928511/image-20201217234030155.png","hash":"15c4c2b9bc8ccdd50ae864917cd4163067c5ebf2","modified":1608517474787},{"_id":"source/_posts/技术分享/linux/linux与k8s的区别.assets/720430-20181226134250810-1685533200.png","hash":"3b3b78ddd2fb1927cadbac96bfdfcdf829c080fb","modified":1608517474411},{"_id":"source/_posts/技术分享/linux/linux与k8s的区别.assets/720430-20181226134259735-1931086473.png","hash":"70db176711e85e6ba1b6031a59b00125412492d0","modified":1608517474414},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/7.png","hash":"4aebce32a523b2488b4c749ffa08632aee12f82e","modified":1608517474441},{"_id":"source/img/default.png","hash":"62df397913f137c5030743d68f839e0f80fd23c8","modified":1608517474788},{"_id":"source/img/avatar.png","hash":"61964f92efc9440d16847b1d5e5342c7d3a7a0b2","modified":1587140393984},{"_id":"source/images/banner/index.jpg","hash":"62df397913f137c5030743d68f839e0f80fd23c8","modified":1608517474527},{"_id":"source/img/alipay.jpg","hash":"d0589052ca92dc36723d0e122c0998dc829c8660","modified":1587266986049},{"_id":"source/images/category/docker.png","hash":"0880d9cf41fe327f3004a893a5eaa6ea382f9ea3","modified":1608517474544},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/1.png","hash":"abab5dc7c34d169807ac7a7b6d7cbf73638e63a6","modified":1608517474423},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/2.png","hash":"5302d6db6520be044a4103187168145dd2eb3dfa","modified":1608517474427},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/3.png","hash":"3ebf0ed986d4e4aa1fc327ca85b771b05745bb90","modified":1608517474430},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/4.png","hash":"52162d3dc7ec73d75afa5c3b7fbd801a719d58bc","modified":1608517474432},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/5.png","hash":"30f94353204cebe861c2d857e61a270a0d39d98d","modified":1608517474435},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/6.png","hash":"2bbcf8a0560d84d6aa8b5cf3b4e139609d365247","modified":1608517474437},{"_id":"source/images/banner/books.jpg","hash":"e847d8a36600595a2a8e147c52f74f2b41413efa","modified":1608545467955},{"_id":"source/images/post/2578104314/720430-20181226134308841-1109691453.png","hash":"0880d9cf41fe327f3004a893a5eaa6ea382f9ea3","modified":1608517474608},{"_id":"source/images/post/41928511/image-20201217233418235.png","hash":"134e0969bb0e94f3929fd8261b45a074ca899fb2","modified":1608517474773},{"_id":"source/_posts/技术分享/linux/linux与k8s的区别.assets/720430-20181226134308841-1109691453.png","hash":"0880d9cf41fe327f3004a893a5eaa6ea382f9ea3","modified":1608517474416},{"_id":"source/_posts/技术分享/linux/linux与k8s的区别.assets/720430-20181226134440039-355719052.png","hash":"c8fa2724b824af9e565c8ec3c909fad02e8cc9a3","modified":1608517474417},{"_id":"source/images/post/41928511/image-20201216105708714.png","hash":"9f100544d56128ecb5b41039e228ccdae4e7a284","modified":1608517474729},{"_id":"source/images/banner/category.jpg","hash":"f8a28f654796c8d5f759c5ead18874635bc6b19a","modified":1608517474519},{"_id":"source/images/banner/about.jpg","hash":"5b56d25b6b62e623fee419dfbabcc8f04b2d1b67","modified":1608545240702},{"_id":"source/images/post/2578104314/720430-20181226134321094-1025894099.png","hash":"fa897d20e20a15d6fb1a829904dae6455056c1ff","modified":1608517474637},{"_id":"source/images/banner/default_top.png","hash":"2e84eaeeb1f33c366bf05fa74539847da27a8560","modified":1608517474523},{"_id":"source/images/banner/links.jpg","hash":"65e176eb3de6101e9f5b55517142dda66b9faed7","modified":1608517474532},{"_id":"source/images/category/java.jpeg","hash":"b100e3b0e45ffdd57ca87d4976647ed2f4c09c80","modified":1608517474571},{"_id":"source/images/post/2827031203/tree.png","hash":"640752cff95dfa31c304680cbc1b1c7c2523425f","modified":1608517474676},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/8.png","hash":"66162d84f9e742607a6036b69ec666fc0e700769","modified":1608517474449},{"_id":"source/images/post/41928511/image-20201216105335033.png","hash":"2c81de397db83a350c526a75ebb5cf2f1a1f7d5b","modified":1608517474717},{"_id":"source/images/banner/archives.jpg","hash":"d99d70a66f5a7202c0e11f65e7fe977fc7a9120d","modified":1608545583919},{"_id":"source/images/post/default_top_img.jpg","hash":"dd0a5452aa9b824f89ccbb27075308dd1af89166","modified":1608533202649},{"_id":"public/atom.xml","hash":"5c69ae4f38c4af3d51a5a9f65f0ced578c4006b4","modified":1608565796207},{"_id":"public/search.xml","hash":"aebebc9ecc7864cd2a34e404c39c32de0eed9e3c","modified":1608565796207},{"_id":"public/sitemap.xml","hash":"cafe730574b6b7dcf655895fa6dd4662f333e63a","modified":1608565796207},{"_id":"public/404.html","hash":"cfcab8753efd4fb9b0779db877919886ed3b6552","modified":1608565796207},{"_id":"public/categories/index.html","hash":"3ac0b9e3aec8985af8222d6f4aad9df9bcce5e29","modified":1608565796207},{"_id":"public/about/index.html","hash":"fec6bf12a60671555c35c18b53b0b46ec8d7dbd3","modified":1608565796207},{"_id":"public/movies/index.html","hash":"2456beaafc5763aaf864691b9b5bc453a75292de","modified":1608565796207},{"_id":"public/books/index.html","hash":"b264f435f7e3b58cddc68964de24f3319e8bab4d","modified":1608565796207},{"_id":"public/tags/index.html","hash":"f1cbaf1753a02e157c2e49e42196dcc81a9b4e27","modified":1608565796207},{"_id":"public/links/index.html","hash":"8ba053cc55d877f2c4578eeb30b8b0ccf2d4f30e","modified":1608565796207},{"_id":"public/posts/189445432/index.html","hash":"dabc62ea465415e6f48450bf0c6253e978aac2aa","modified":1608565796207},{"_id":"public/posts/1345941684/index.html","hash":"c9e537a973b9f7b14630e22d2fdb29f905736c48","modified":1608565796207},{"_id":"public/posts/1026478353/index.html","hash":"d5c6a7659fc73c2343143ce8c60eba155e16926f","modified":1608565796207},{"_id":"public/posts/3878378061/index.html","hash":"c5d31314e25f14687f0a106263cf82454704fa4a","modified":1608565796207},{"_id":"public/posts/2628717197/index.html","hash":"5f6d4f3f5b8c004247d73d3a8db02733c37cd1a9","modified":1608565796207},{"_id":"public/posts/3878378062/index.html","hash":"5eb5afb6596585a6f07db1b2412295a51247138e","modified":1608565796207},{"_id":"public/posts/2413522498/index.html","hash":"4e8910af97a3857a6f31da1b5ad4eef85fc35407","modified":1608565796207},{"_id":"public/posts/2827031223/index.html","hash":"06ff0df883c6547fd0235de6b20a80f5e8164a9e","modified":1608565796207},{"_id":"public/posts/3858194484/index.html","hash":"7432a71f977e4c4d1380fb712a4c12cee43270f5","modified":1608565796207},{"_id":"public/posts/41928511/index.html","hash":"4c8fefbf40c5a76ee482d084b32111d6bffa93c0","modified":1608565796207},{"_id":"public/posts/41928510/index.html","hash":"c10156a11ab3c24bb1231c937a1d3e90a6c3a10e","modified":1608565796207},{"_id":"public/posts/1125805289/index.html","hash":"45cfcee0cdc31924bdfec3c4481e835f2053a7e2","modified":1608565796207},{"_id":"public/posts/41928529/index.html","hash":"2fb0a5563dd35c8347b4d69c88983733b748a392","modified":1608565796207},{"_id":"public/posts/2231850037/index.html","hash":"93f9345b96adb7d7e1eb5ba6a882cf6899c48f71","modified":1608565796207},{"_id":"public/posts/2936205123/index.html","hash":"d6b655375fa61e96cd1c678772c915ffb58fa6fa","modified":1608565796207},{"_id":"public/posts/250724270/index.html","hash":"412c9b2766c50e71c80d99d25db7c16e080fce15","modified":1608565796207},{"_id":"public/posts/250724269/index.html","hash":"581d996be44cf453c0e4ad2b2df1334a60da3da2","modified":1608565796207},{"_id":"public/posts/780159822/index.html","hash":"2f9e125b99c4234e9c0ec0c76a259398612ad579","modified":1608565796207},{"_id":"public/posts/1125805293/index.html","hash":"8302ec69f10fc1625645e4709786f04ff0e6131b","modified":1608565796207},{"_id":"public/posts/1026478354/index.html","hash":"fb6ec5783c04ebd5c617eaefddc664e31f4c4591","modified":1608565796207},{"_id":"public/posts/3058308324/index.html","hash":"a174e926d58993d848e39abbfbdf043364a459c0","modified":1608565796207},{"_id":"public/posts/2578104319/index.html","hash":"96bd6eeeca837c8d58d18485319058c6cf961d30","modified":1608565796207},{"_id":"public/posts/2578104314/index.html","hash":"aa36f56347565a4b46ca9a9211dd7e34c479408b","modified":1608565796207},{"_id":"public/posts/3058308323/index.html","hash":"d90bd4b0befe7a630c2dc382fee1bbe66f930576","modified":1608565796207},{"_id":"public/posts/2827031203/index.html","hash":"864ba7f8a36bd3b7890191610578e0e6261dd7e1","modified":1608565796207},{"_id":"public/posts/3097382278/index.html","hash":"d410c19a167834c6ffecdf7b411538663e4f2f51","modified":1608565796207},{"_id":"public/posts/1879991184/index.html","hash":"4240859460532e11eca0e39463dce6fe4835b5c7","modified":1608565796207},{"_id":"public/games/index.html","hash":"dce1f1df58c316b16b274c3fc4c3191d344bb00b","modified":1608565796207},{"_id":"public/archives/index.html","hash":"b8e6d8fb02d85055bf37717941df4dfc00228b95","modified":1608565796207},{"_id":"public/archives/page/2/index.html","hash":"831b7983554bac5a6eddc2d126e88c06b1cdb8ee","modified":1608565796207},{"_id":"public/archives/page/3/index.html","hash":"2aa83583807078dc4bdc90e9f0974c0be68ee407","modified":1608565796207},{"_id":"public/archives/2016/index.html","hash":"d305c50a62dbdde086a1f745212706b01d3fce60","modified":1608565796207},{"_id":"public/archives/2016/08/index.html","hash":"1857d114ebb98da40b5d5c5b54320abe2718c598","modified":1608565796207},{"_id":"public/archives/2016/10/index.html","hash":"8b060793e3cbb8d44f469bbe09c58ca55a088212","modified":1608565796207},{"_id":"public/archives/2017/index.html","hash":"cf61e4da6b90d0281767ab1ceaf8444fe2c5da39","modified":1608565796207},{"_id":"public/archives/2017/02/index.html","hash":"675da8f451a8e9a2f9635d91b1766748e49e0f5d","modified":1608565796207},{"_id":"public/archives/2017/03/index.html","hash":"e30c924e87c7153598f60ae1bbf23091976e28a4","modified":1608565796207},{"_id":"public/archives/2017/08/index.html","hash":"561d257430c344a9ea8f9a8184695d47a5c07326","modified":1608565796207},{"_id":"public/archives/2017/10/index.html","hash":"3797f4982668a5be9d4b4f4e73fdd0cec739c9ef","modified":1608565796207},{"_id":"public/archives/2017/12/index.html","hash":"678c5e7fc21a771d1a3105e83e42ea39acfcf12f","modified":1608565796207},{"_id":"public/archives/2018/index.html","hash":"4a3a86ec940e687e091001aa4382bd54431f95bc","modified":1608565796207},{"_id":"public/archives/2018/04/index.html","hash":"8b07977b9036a7cfbe4451e24216f1994c16842a","modified":1608565796207},{"_id":"public/archives/2018/07/index.html","hash":"e0e85f735d686d4f2b93605e7c4ff5619b2e463f","modified":1608565796207},{"_id":"public/archives/2018/12/index.html","hash":"d6a3abfd18f3a8ecb0fe5a71f900273ab152bd77","modified":1608565796207},{"_id":"public/archives/2019/index.html","hash":"c7a94d2b41ed54892c7ef3ece197d05092b2317d","modified":1608565796207},{"_id":"public/archives/2019/10/index.html","hash":"b95ce50297b6988f6740a35fddedd73b09c0714e","modified":1608565796207},{"_id":"public/archives/2020/index.html","hash":"091afa635993b982b95208d806b619390ee5a4d1","modified":1608565796207},{"_id":"public/archives/2020/page/2/index.html","hash":"428717c8a23a0bacbee22c2166099126f0805c23","modified":1608565796207},{"_id":"public/archives/2020/04/index.html","hash":"fcb021fe121100571eea53128f2e7972304a514e","modified":1608565796207},{"_id":"public/archives/2020/12/index.html","hash":"5f4d04de312a3662466be1b0e8ba460567571210","modified":1608565796207},{"_id":"public/archives/2020/12/page/2/index.html","hash":"4d132918a30e5ebc7b6a16cab615d975f3997746","modified":1608565796207},{"_id":"public/categories/理论学习/index.html","hash":"043192314e09835068b27f0173c8ca254e3b5ef3","modified":1608565796207},{"_id":"public/categories/解决方案/index.html","hash":"5b8fd2615081c362fd21592d1beb207b131e3278","modified":1608565796207},{"_id":"public/categories/技术分享/index.html","hash":"7223b6a9e244698d27c9730332600eb92a370f02","modified":1608565796207},{"_id":"public/categories/技术实践/index.html","hash":"4901c0557a349597f8f48d80c5a80040b7a662be","modified":1608565796207},{"_id":"public/categories/博客教程/index.html","hash":"306bed4fc92db7ff255168b72c22b9aeace9fd53","modified":1608565796207},{"_id":"public/categories/技术研究/index.html","hash":"10c72d2342e31322daf5419fa82f516d977899e3","modified":1608546366886},{"_id":"public/categories/手段方法/index.html","hash":"c35964068e23c6c25964c929f1175984de9636fd","modified":1608565796207},{"_id":"public/index.html","hash":"a146df0bc28d39672905aba6c7120797ceaeabf3","modified":1608565796207},{"_id":"public/page/2/index.html","hash":"2a4efe69197288952cbafc0c5e96aa5715e13460","modified":1608565796207},{"_id":"public/page/3/index.html","hash":"aed7769b41147b934e1d1db424f92e2c8cfeabb3","modified":1608565796207},{"_id":"public/tags/数据结构/index.html","hash":"d1a70d2baa77baa4573ed98e92373f4701085e7e","modified":1608565796207},{"_id":"public/tags/算法/index.html","hash":"4009897b42482fd014060f3a0600689366cdcebb","modified":1608565796207},{"_id":"public/tags/redis/index.html","hash":"d2e4efd64565de32af4596ce083ae70c8acb8c8b","modified":1608565796207},{"_id":"public/tags/cluster/index.html","hash":"15e7aedd75249917f4d7de95471474176ab1f307","modified":1608565796207},{"_id":"public/tags/docker/index.html","hash":"30e36a9888b59bb0287e2b6916081dc077af3c41","modified":1608565796207},{"_id":"public/tags/docker-compose/index.html","hash":"a408379ab219d97aed9a5c96b38ac1dcc13eaf28","modified":1608565796207},{"_id":"public/tags/hosts/index.html","hash":"6ed39b5cbecdb655b8ca4b620beb8cf6ed8f2678","modified":1608565796207},{"_id":"public/tags/github/index.html","hash":"7d0e449187c3d835071af83b88050c0e906518e9","modified":1608565796207},{"_id":"public/tags/python/index.html","hash":"9f2e946a32cfd82ee4936ac6e8093d7f73ed4fb2","modified":1608565796207},{"_id":"public/tags/git/index.html","hash":"a147146bf7f19b3cf52d197b226a7299ff571dc8","modified":1608565796207},{"_id":"public/tags/Linux/index.html","hash":"e67c429bb04fcd8fc4bb43a33b3af56bc0734083","modified":1608565796207},{"_id":"public/tags/Docker/index.html","hash":"442e7f289f050487160a7997b47721cf230b3adf","modified":1608565796207},{"_id":"public/tags/Spring/index.html","hash":"6d287849ca6844102ea786dcce64e25dac33eee2","modified":1608565796207},{"_id":"public/tags/Spring-Cloud/index.html","hash":"7bd1606a6598f9d1eabc2aaa7c570b697225ac3d","modified":1608565796207},{"_id":"public/tags/Java/index.html","hash":"1d62f00844c3c707278b847032d8b44e4e2f6209","modified":1608565796207},{"_id":"public/tags/RAS/index.html","hash":"7a9aab9a1abde4ca451872680adfa7dd7b2f8cae","modified":1608565796207},{"_id":"public/tags/Mac/index.html","hash":"af9c6562ce825a2a5fa8e77f156a2919271d805e","modified":1608565796207},{"_id":"public/tags/mac/index.html","hash":"2a6fa50ea8fe1ac97e9aa2d3f7addacadd991f65","modified":1608565796207},{"_id":"public/tags/node/index.html","hash":"b843c536df366661290a8b2b72f8672a27e3e67d","modified":1608565796207},{"_id":"public/tags/Markdown/index.html","hash":"6da7bcb38bf7e8e6e67a8b8f6edb3cf55b7f9e49","modified":1608565796207},{"_id":"public/tags/Hexo/index.html","hash":"fcb3237225657abdb3f2cf63c30bfbe4acc2964b","modified":1608565796207},{"_id":"public/tags/Github/index.html","hash":"f0db51fd5342a4db691350a74d17c8aba9995976","modified":1608565796207},{"_id":"public/tags/https/index.html","hash":"9eb4c3bd9d0a13266e43d332876fb8834303370c","modified":1608565796207},{"_id":"public/tags/ssl/index.html","hash":"9bc565e1a8ca5f92ad9a911359a95d2eaec3e434","modified":1608565796207},{"_id":"public/tags/MySQL/index.html","hash":"6fcb3468e6499092fbe23e7264d0dd9d189e81ef","modified":1608565796207},{"_id":"public/tags/正则表达式/index.html","hash":"0408977a706244deac65873ea4eb714e1c989580","modified":1608565796207},{"_id":"public/tags/regex/index.html","hash":"3d34e31d1c812a65087173708e07981e938f82a6","modified":1608565796207},{"_id":"public/tags/NexT/index.html","hash":"a0848cc4c360494d04da73881865f5cced719cc7","modified":1608565796207},{"_id":"public/tags/Kafka/index.html","hash":"408ac7c52d24b9496049e46d8ade9ccf413fcdd9","modified":1608565796207},{"_id":"public/tags/Centos/index.html","hash":"4148782e7d712e14eff4c904af012fdcc4595d9c","modified":1608565796207},{"_id":"public/tags/java/index.html","hash":"094697d947629a9b0392059a5ad1f678f7c144e9","modified":1608565796207},{"_id":"public/tags/架构师/index.html","hash":"2273363750a031e0e0e98dd581b987b3e8c5d17f","modified":1608565796207},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1608565796207},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1608565796207},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1608565796207},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1608565796207},{"_id":"public/BingSiteAuth.xml","hash":"edf8a00778a364244213b8cd364542a568af235b","modified":1608565796207},{"_id":"public/images/category/git-logo.jpg","hash":"cb212801ab930fb0603b1a8a518cf0323404df8c","modified":1608565796207},{"_id":"public/images/category/github-office.jpg","hash":"7468826fd37b3bf60c21bcba5d3d8fe0c867f0d8","modified":1608565796207},{"_id":"public/images/category/hexo.jpeg","hash":"adaaf4d9ebaea9c4a43bb90187368967a48f8888","modified":1608565796207},{"_id":"public/images/category/https.jpg","hash":"6045840c81de5a769d8008a640c0984525856c4b","modified":1608565796207},{"_id":"public/images/category/kafka.jpg","hash":"2c11154a8d767ce070c80bd1b2c0e1f66dfb3d97","modified":1608565796207},{"_id":"public/images/category/linux.jpeg","hash":"b437e6194f139a064d3e096f9fd4a107ef02dde8","modified":1608565796207},{"_id":"public/images/category/macos.png","hash":"24d35599607ea5ec6bf5edd6caa2e4c41c20cec2","modified":1608565796207},{"_id":"public/images/category/markdown.png","hash":"08d9a1ade68de7c678cff7972573eabaf8231333","modified":1608565796207},{"_id":"public/images/category/nodejs.png","hash":"4f5a755691f7aebd1d60aaa7e2f6124a739cacb8","modified":1608565796207},{"_id":"public/images/category/redis.jpg","hash":"48afb52220396b7dcdf6d9668c35021943ac0efa","modified":1608565796207},{"_id":"public/images/post/1879991184/thumbnail.jpeg","hash":"7d01a6e80f2aa14cedb2e429cde591df5a526ea4","modified":1608565796207},{"_id":"public/images/post/2231850037/thumbnail.jpg","hash":"518d9efbbbc5f270f54775083e3ad5d397fa3256","modified":1608565796207},{"_id":"public/images/post/2827031203/hashtable.jpg","hash":"0228ea21bac82c01fdd0d9da4053897d32cb0666","modified":1608565796207},{"_id":"public/images/post/2827031203/linkedlist.jpg","hash":"a0e88d4b9e0f3b8fdf986a7264a82e8b5c65b52f","modified":1608565796207},{"_id":"public/images/post/2827031203/heap.jpg","hash":"906ce5bed102dd1cb26e16f716793267fbe53add","modified":1608565796207},{"_id":"public/images/post/2827031203/queue.png","hash":"2471e04cc8484d3796e670340ad0fa8e43232477","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217232318516.png","hash":"792fb92a1ba654f2176e8dcb763d35b207fd5f33","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217232654936.png","hash":"810ab508ce5ff4db9c75297ff006a350ca2c57b0","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217233631334.png","hash":"721945659da8217c52a7036e560a81d5c0f957df","modified":1608565796207},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1608565796207},{"_id":"public/img/wechatpay.jpg","hash":"8547ff093d704c77131abe7bda9aa69ae723eac0","modified":1608565796207},{"_id":"public/images/banner/archives4.jpg","hash":"b4b0711b164f74265e2f9926e42059c5cf14cbcf","modified":1608546366886},{"_id":"public/images/banner/tag.jpg","hash":"38bb454359291bec38be878d4f1485b124c8ce4f","modified":1608565796207},{"_id":"public/images/category/mysql.png","hash":"a7fc1ca48a6dc7f044cdb0fce7d54ee8345b07d7","modified":1608565796207},{"_id":"public/images/category/regex.jpg","hash":"4a01bb34c42dbd4b977d3017108e07f9cf11c571","modified":1608565796207},{"_id":"public/images/post/2578104314/720430-20181226134250810-1685533200.png","hash":"3b3b78ddd2fb1927cadbac96bfdfcdf829c080fb","modified":1608565796207},{"_id":"public/images/post/2578104314/720430-20181226134259735-1931086473.png","hash":"70db176711e85e6ba1b6031a59b00125412492d0","modified":1608565796207},{"_id":"public/images/post/2827031203/cover.png","hash":"a082e734fb23ad199d8e5a2a53adb86349509a36","modified":1608565796207},{"_id":"public/images/post/2827031203/overview.png","hash":"e7ec9f16e9f389f7a20eb04f747fd0f86a8daacf","modified":1608565796207},{"_id":"public/images/post/2827031203/stack.png","hash":"3736ff92eaad9a88e52c47e393513bff93b84988","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217231236527.png","hash":"e66cedf158ce9491995bda51e5e4c8c1c51066e8","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217232602098.png","hash":"a018b25f1f78c28a8b4cea7d183fb63eb4458e29","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217233140546.png","hash":"0d59319a58f158325f6f06b652380d4446f2e822","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217233848143.png","hash":"8d00995231a4227ac4cd45f67327d35bacb1b52e","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217234030155.png","hash":"15c4c2b9bc8ccdd50ae864917cd4163067c5ebf2","modified":1608565796207},{"_id":"public/posts/1879991184/index/7.png","hash":"4aebce32a523b2488b4c749ffa08632aee12f82e","modified":1608565796207},{"_id":"public/img/alipay.jpg","hash":"d0589052ca92dc36723d0e122c0998dc829c8660","modified":1608565796207},{"_id":"public/img/avatar.png","hash":"61964f92efc9440d16847b1d5e5342c7d3a7a0b2","modified":1608565796207},{"_id":"public/images/banner/index.jpg","hash":"62df397913f137c5030743d68f839e0f80fd23c8","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217232930044.png","hash":"f5a55885100d3982fbfcf2f31a8932d8d5382f6f","modified":1608565796207},{"_id":"public/posts/1879991184/index/3.png","hash":"3ebf0ed986d4e4aa1fc327ca85b771b05745bb90","modified":1608565796207},{"_id":"public/posts/1879991184/index/4.png","hash":"52162d3dc7ec73d75afa5c3b7fbd801a719d58bc","modified":1608565796207},{"_id":"public/posts/1879991184/index/5.png","hash":"30f94353204cebe861c2d857e61a270a0d39d98d","modified":1608565796207},{"_id":"public/posts/1879991184/index/6.png","hash":"2bbcf8a0560d84d6aa8b5cf3b4e139609d365247","modified":1608565796207},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1608565796207},{"_id":"public/js/utils.js","hash":"41481019ef510c74e744f4f7ec4d0a13b5ccc04c","modified":1608565796207},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1608565796207},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1608565796207},{"_id":"public/css/index.css","hash":"e1856d78a74497b7f8ed2ae8ca6aafaa6ad28284","modified":1608565796207},{"_id":"public/img/default.png","hash":"62df397913f137c5030743d68f839e0f80fd23c8","modified":1608565796207},{"_id":"public/images/banner/books.jpg","hash":"e847d8a36600595a2a8e147c52f74f2b41413efa","modified":1608565796207},{"_id":"public/images/category/docker.png","hash":"0880d9cf41fe327f3004a893a5eaa6ea382f9ea3","modified":1608565796207},{"_id":"public/images/post/2578104314/720430-20181226134308841-1109691453.png","hash":"0880d9cf41fe327f3004a893a5eaa6ea382f9ea3","modified":1608565796207},{"_id":"public/posts/1879991184/index/1.png","hash":"abab5dc7c34d169807ac7a7b6d7cbf73638e63a6","modified":1608565796207},{"_id":"public/posts/1879991184/index/2.png","hash":"5302d6db6520be044a4103187168145dd2eb3dfa","modified":1608565796207},{"_id":"public/js/main.js","hash":"bc1c37de776d04c394b328d4595c75082593858e","modified":1608565796207},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1608565796207},{"_id":"public/images/banner/links.jpg","hash":"65e176eb3de6101e9f5b55517142dda66b9faed7","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201217233418235.png","hash":"134e0969bb0e94f3929fd8261b45a074ca899fb2","modified":1608565796207},{"_id":"public/images/banner/category.jpg","hash":"f8a28f654796c8d5f759c5ead18874635bc6b19a","modified":1608565796207},{"_id":"public/images/banner/default_top.png","hash":"2e84eaeeb1f33c366bf05fa74539847da27a8560","modified":1608565796207},{"_id":"public/images/category/java.jpeg","hash":"b100e3b0e45ffdd57ca87d4976647ed2f4c09c80","modified":1608565796207},{"_id":"public/images/post/2578104314/720430-20181226134321094-1025894099.png","hash":"fa897d20e20a15d6fb1a829904dae6455056c1ff","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201216105708714.png","hash":"9f100544d56128ecb5b41039e228ccdae4e7a284","modified":1608565796207},{"_id":"public/images/banner/about.jpg","hash":"5b56d25b6b62e623fee419dfbabcc8f04b2d1b67","modified":1608565796207},{"_id":"public/images/post/41928511/image-20201216105335033.png","hash":"2c81de397db83a350c526a75ebb5cf2f1a1f7d5b","modified":1608565796207},{"_id":"public/images/post/2827031203/tree.png","hash":"640752cff95dfa31c304680cbc1b1c7c2523425f","modified":1608565796207},{"_id":"public/posts/1879991184/index/8.png","hash":"66162d84f9e742607a6036b69ec666fc0e700769","modified":1608565796207},{"_id":"public/images/banner/archives.jpg","hash":"d99d70a66f5a7202c0e11f65e7fe977fc7a9120d","modified":1608565796207},{"_id":"public/images/post/default_top_img.jpg","hash":"dd0a5452aa9b824f89ccbb27075308dd1af89166","modified":1608565796207},{"_id":"source/images/category/java-structure.jpg","hash":"dffcf53cc2ba6ce3df52b629aaec464a0e3d1e8b","modified":1608546925831},{"_id":"source/robots.txt","hash":"6d8b87372f16a1cee36f7ce2e1af0282106fc88c","modified":1608569216885},{"_id":"public/images/category/java-structure.jpg","hash":"dffcf53cc2ba6ce3df52b629aaec464a0e3d1e8b","modified":1608565796207},{"_id":"public/robots.txt","hash":"34f3d3a8bc35ba72d8c9fe11730a10c4e925d646","modified":1608565796207},{"_id":"public/baidusitemap.xml","hash":"c71e70ad250bd3fc66019788091ecaa09ce2e356","modified":1608565796207},{"_id":"source/ea0d59f6be5a616851c2d2d5e7f267e9.txt","hash":"28fd7650dbfaed9e185847f01caf83a725b47712","modified":1608566723931}],"Category":[{"name":"理论学习","_id":"ckiyez6gv0006tvcdds3731qg"},{"name":"解决方案","_id":"ckiyez6h0000etvcd2p0nhvo1"},{"name":"技术分享","_id":"ckiyez6h3000ktvcd7isnd72g"},{"name":"技术实践","_id":"ckiyez6ha0011tvcd9hs996mo"},{"name":"博客教程","_id":"ckiyez6hm001ktvcd3mbk5lm4"},{"name":"技术研究","_id":"ckiyez6hq001utvcd7xlx36ys"},{"name":"手段方法","_id":"ckiyez6ig0040tvcdh5v8hb99"}],"Data":[{"_id":"link","data":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"https://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"https://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2020-12-18T18:43:16.497Z","updated":"2020-12-18T18:43:16.497Z","path":"404.html","_id":"ckiyez6gm0000tvcd2lnhbilp","title":"","comments":1,"layout":"page","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"https://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"https://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>"},{"title":"分类 | Categories","type":"categories","top_img":"https://cdn.tanxz.com/images/banner/category.jpg","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类 | Categories\ntype: \"categories\"\ntop_img: https://cdn.tanxz.com/images/banner/category.jpg\ncomments: false\n---","date":"2020-12-24T14:19:01.341Z","updated":"2020-12-24T14:19:01.341Z","path":"categories/index.html","_id":"ckiyez6gr0002tvcd049g4lgi","layout":"page","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"关于 | About Me","date":"2018-04-16T05:01:39.000Z","type":"about","top_img":"https://cdn.tanxz.com/images/banner/about.jpg","_content":"\n# 关于博主\n\n> 姓名：    TanXZ\n> 坐标：    中国·上海\n> 年龄:     ** [这是一个秘密]\n> 职业：    程序猿\n> Blog：    https://tanxz.com\n> Github:   https://github.com/tanxinzheng\n> 座右铭：  业精于勤，荒于嬉；行成于思，毁于随。---韩愈·《进学解》\n\n# 关于本站\n\n> 博客的搭建从2016年就已经开始了，起初是为了有个可以方便自己记录日常工作学习到的理论知识和分享生活中的点点滴滴，但文章断断续续的写着，但一直就效率不高，\n> 或许是因为博客记录理论知识不如云笔记来的方便，分享生活不如朋友圈来的方便，但终究还是要回归博客，因为感觉博客像是自己的孩子一样，别人家的始终是别人家的，孩子还是自己家的好啊，像怎么弄怎么弄！符合自己审美的和习惯的才是最好的。\n> PS：博客陆陆续续搞了几次了，换了N个主题，换了N个域名，最近才领悟到创作出优质的文章才是重点啊，后面应该会把精力投入到写作当中了。","source":"about/index.md","raw":"---\ntitle: 关于 | About Me\ndate: 2018-04-16 13:01:39\ntype: about\ntop_img: https://cdn.tanxz.com/images/banner/about.jpg\n---\n\n# 关于博主\n\n> 姓名：    TanXZ\n> 坐标：    中国·上海\n> 年龄:     ** [这是一个秘密]\n> 职业：    程序猿\n> Blog：    https://tanxz.com\n> Github:   https://github.com/tanxinzheng\n> 座右铭：  业精于勤，荒于嬉；行成于思，毁于随。---韩愈·《进学解》\n\n# 关于本站\n\n> 博客的搭建从2016年就已经开始了，起初是为了有个可以方便自己记录日常工作学习到的理论知识和分享生活中的点点滴滴，但文章断断续续的写着，但一直就效率不高，\n> 或许是因为博客记录理论知识不如云笔记来的方便，分享生活不如朋友圈来的方便，但终究还是要回归博客，因为感觉博客像是自己的孩子一样，别人家的始终是别人家的，孩子还是自己家的好啊，像怎么弄怎么弄！符合自己审美的和习惯的才是最好的。\n> PS：博客陆陆续续搞了几次了，换了N个主题，换了N个域名，最近才领悟到创作出优质的文章才是重点啊，后面应该会把精力投入到写作当中了。","updated":"2020-12-24T14:19:01.341Z","path":"about/index.html","_id":"ckiyez6gt0004tvcdbjux331i","comments":1,"layout":"page","content":"<h1 id=\"关于博主\"><a href=\"#关于博主\" class=\"headerlink\" title=\"关于博主\"></a>关于博主</h1><blockquote>\n<p>姓名：    TanXZ<br>坐标：    中国·上海<br>年龄:     ** [这是一个秘密]<br>职业：    程序猿<br>Blog：    <a href=\"https://tanxz.com\">https://tanxz.com</a><br>Github:   <a href=\"https://github.com/tanxinzheng\">https://github.com/tanxinzheng</a><br>座右铭：  业精于勤，荒于嬉；行成于思，毁于随。—韩愈·《进学解》</p>\n</blockquote>\n<h1 id=\"关于本站\"><a href=\"#关于本站\" class=\"headerlink\" title=\"关于本站\"></a>关于本站</h1><blockquote>\n<p>博客的搭建从2016年就已经开始了，起初是为了有个可以方便自己记录日常工作学习到的理论知识和分享生活中的点点滴滴，但文章断断续续的写着，但一直就效率不高，<br>或许是因为博客记录理论知识不如云笔记来的方便，分享生活不如朋友圈来的方便，但终究还是要回归博客，因为感觉博客像是自己的孩子一样，别人家的始终是别人家的，孩子还是自己家的好啊，像怎么弄怎么弄！符合自己审美的和习惯的才是最好的。<br>PS：博客陆陆续续搞了几次了，换了N个主题，换了N个域名，最近才领悟到创作出优质的文章才是重点啊，后面应该会把精力投入到写作当中了。</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"关于博主\"><a href=\"#关于博主\" class=\"headerlink\" title=\"关于博主\"></a>关于博主</h1><blockquote>\n<p>姓名：    TanXZ<br>坐标：    中国·上海<br>年龄:     ** [这是一个秘密]<br>职业：    程序猿<br>Blog：    <a href=\"https://tanxz.com\">https://tanxz.com</a><br>Github:   <a href=\"https://github.com/tanxinzheng\">https://github.com/tanxinzheng</a><br>座右铭：  业精于勤，荒于嬉；行成于思，毁于随。—韩愈·《进学解》</p>\n</blockquote>\n<h1 id=\"关于本站\"><a href=\"#关于本站\" class=\"headerlink\" title=\"关于本站\"></a>关于本站</h1><blockquote>\n<p>博客的搭建从2016年就已经开始了，起初是为了有个可以方便自己记录日常工作学习到的理论知识和分享生活中的点点滴滴，但文章断断续续的写着，但一直就效率不高，<br>或许是因为博客记录理论知识不如云笔记来的方便，分享生活不如朋友圈来的方便，但终究还是要回归博客，因为感觉博客像是自己的孩子一样，别人家的始终是别人家的，孩子还是自己家的好啊，像怎么弄怎么弄！符合自己审美的和习惯的才是最好的。<br>PS：博客陆陆续续搞了几次了，换了N个主题，换了N个域名，最近才领悟到创作出优质的文章才是重点啊，后面应该会把精力投入到写作当中了。</p>\n</blockquote>\n"},{"title":"movies","date":"2020-12-16T10:20:10.000Z","top_img":"https://cdn.tanxz.com/images/banner/books.jpg","_content":"","source":"movies/index.md","raw":"---\ntitle: movies\ndate: 2020-12-16 18:20:10\ntop_img: https://cdn.tanxz.com/images/banner/books.jpg\n---\n","updated":"2020-12-24T14:19:01.341Z","path":"movies/index.html","_id":"ckiyez6gw0008tvcd7782fouv","comments":1,"layout":"page","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"books","type":"books","date":"2020-12-16T10:20:04.000Z","top_img":"https://cdn.tanxz.com/images/banner/books.jpg","_content":"","source":"books/index.md","raw":"---\ntitle: books\ntype: books\ndate: 2020-12-16 18:20:04\ntop_img: https://cdn.tanxz.com/images/banner/books.jpg\n---\n","updated":"2020-12-24T14:19:01.341Z","path":"books/index.html","_id":"ckiyez6gx000atvcd79ne70dv","comments":1,"layout":"page","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"标签 | Tags","type":"tags","top_img":"https://cdn.tanxz.com/images/banner/tag.jpg","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签 | Tags\ntype: tags\ntop_img: https://cdn.tanxz.com/images/banner/tag.jpg\ncomments: false\n---","date":"2020-12-24T14:19:01.341Z","updated":"2020-12-24T14:19:01.341Z","path":"tags/index.html","_id":"ckiyez6gz000ctvcd8a507p47","layout":"page","content":"","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"友链 | My Friends","type":"link","date":"2020-12-15T17:10:05.000Z","top_img":"https://cdn.tanxz.com/images/banner/links.jpg","_content":"\n## 交个朋友呗\n若需申请友链，请按如下格式留言。（请保证头像链接有效）\n> Blog 名字： TanXZ\n> Blog 地址： https://www.tanxz.com\n> Blog 头像： https://cdn.tanxz.com/images/avatar.png\n> Blog 简介： 业精于勤，荒于嬉；行成于思，毁于随。—韩愈·《进学解》","source":"links/index.md","raw":"---\ntitle: 友链 | My Friends\ntype: link\ndate: 2020-12-16 01:10:05\ntop_img: https://cdn.tanxz.com/images/banner/links.jpg\n---\n\n## 交个朋友呗\n若需申请友链，请按如下格式留言。（请保证头像链接有效）\n> Blog 名字： TanXZ\n> Blog 地址： https://www.tanxz.com\n> Blog 头像： https://cdn.tanxz.com/images/avatar.png\n> Blog 简介： 业精于勤，荒于嬉；行成于思，毁于随。—韩愈·《进学解》","updated":"2020-12-24T14:35:05.585Z","path":"links/index.html","_id":"ckiyez6h0000gtvcd3kfi5lj3","comments":1,"layout":"page","content":"<h2 id=\"交个朋友呗\"><a href=\"#交个朋友呗\" class=\"headerlink\" title=\"交个朋友呗\"></a>交个朋友呗</h2><p>若需申请友链，请按如下格式留言。（请保证头像链接有效）</p>\n<blockquote>\n<p>Blog 名字： TanXZ<br>Blog 地址： <a href=\"https://www.tanxz.com\">https://www.tanxz.com</a><br>Blog 头像： <a href=\"https://cdn.tanxz.com/images/avatar.png\">https://cdn.tanxz.com/images/avatar.png</a><br>Blog 简介： 业精于勤，荒于嬉；行成于思，毁于随。—韩愈·《进学解》</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"交个朋友呗\"><a href=\"#交个朋友呗\" class=\"headerlink\" title=\"交个朋友呗\"></a>交个朋友呗</h2><p>若需申请友链，请按如下格式留言。（请保证头像链接有效）</p>\n<blockquote>\n<p>Blog 名字： TanXZ<br>Blog 地址： <a href=\"https://www.tanxz.com\">https://www.tanxz.com</a><br>Blog 头像： <a href=\"https://cdn.tanxz.com/images/avatar.png\">https://cdn.tanxz.com/images/avatar.png</a><br>Blog 简介： 业精于勤，荒于嬉；行成于思，毁于随。—韩愈·《进学解》</p>\n</blockquote>\n"}],"Post":[{"title":"待办事项","type":"post","description":"今日事，今日毕。","abbrlink":3858194484,"date":"2020-12-18T15:40:25.000Z","updated":"2020-12-21T02:24:34.405Z","comments":1,"keywords":null,"top_img":null,"mathjax":null,"katex":null,"aside":null,"aplayer":null,"highlight_shrink":null,"sticky":100,"_content":"\n## 近期待办事项清单\n- [x] 搭建博客：规范化历史文章目录\n- [ ] 搭建博客：博客的分类设计\n- [ ] 搭建博客：对历史文章进行重分类管理\n- [x] 添加常用工具类网站\n- [x] 添加百度、bing、cnzz站点统计功能\n","source":"_posts/todos.md","raw":"---\ntitle: 待办事项\ntype: post\ndescription: 今日事，今日毕。\nabbrlink: 3858194484\ndate: 2020-12-18 23:40:25\nupdated:\ncomments:\nkeywords:\ntop_img:\nmathjax:\nkatex:\naside:\naplayer:\nhighlight_shrink:\nsticky: 100\n---\n\n## 近期待办事项清单\n- [x] 搭建博客：规范化历史文章目录\n- [ ] 搭建博客：博客的分类设计\n- [ ] 搭建博客：对历史文章进行重分类管理\n- [x] 添加常用工具类网站\n- [x] 添加百度、bing、cnzz站点统计功能\n","slug":"todos","published":1,"layout":"post","photos":[],"link":"","_id":"ckiyez6gp0001tvcd2nee4442","content":"<h2 id=\"近期待办事项清单\"><a href=\"#近期待办事项清单\" class=\"headerlink\" title=\"近期待办事项清单\"></a>近期待办事项清单</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 搭建博客：规范化历史文章目录</li>\n<li><input disabled=\"\" type=\"checkbox\"> 搭建博客：博客的分类设计</li>\n<li><input disabled=\"\" type=\"checkbox\"> 搭建博客：对历史文章进行重分类管理</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 添加常用工具类网站</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 添加百度、bing、cnzz站点统计功能</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"近期待办事项清单\"><a href=\"#近期待办事项清单\" class=\"headerlink\" title=\"近期待办事项清单\"></a>近期待办事项清单</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 搭建博客：规范化历史文章目录</li>\n<li><input disabled=\"\" type=\"checkbox\"> 搭建博客：博客的分类设计</li>\n<li><input disabled=\"\" type=\"checkbox\"> 搭建博客：对历史文章进行重分类管理</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 添加常用工具类网站</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 添加百度、bing、cnzz站点统计功能</li>\n</ul>\n"},{"title":"【数据结构】八大数据结构简介","abbrlink":2827031203,"date":"2017-02-19T13:38:18.000Z","keywords":null,"description":null,"top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","comments":1,"cover":"/images/post/2827031203/cover.png","toc":null,"toc_number":true,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"\n\n# 数据结构分类\n数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。\n常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：\n\n![图片](/images/post/2827031203/overview.png)\n\n常见数据结构大致可分为三大类，如下所示\n- 线性表：顺序表、链表、栈和队列；\n- 树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；\n- 图存储结构\n\n## 优缺点对比表\n每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。\n\n<table>\n    <tr>\n        <td><b>数据结构</b></td>\n        <td><b>优点</b></td>\n        <td><b>缺点</b></td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n# 数组（Array）\n\n数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。\n\n    int[] data = new int[100]；\n    data[0]  = 1;\n\n## 优点\n- 按照索引查询元素速度快\n- 按照索引遍历数组方便\n\n## 缺点\n- 数组的大小固定后就无法扩容了\n- 数组只能存储一种类型的数据\n- 添加，删除的操作慢，因为要移动其他的元素。\n\n## 适用场景\n- 频繁查询，对存储空间要求不大，很少增加和删除的情况。\n\n# 栈（Stack）\n栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。\n![图片](/images/post/2827031203/stack.png)\n栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。\n\n# 队列\n队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：\n![图片](/images/post/2827031203/queue.png)\n使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。\n\n# 链表\n链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。\n![图片](/images/post/2827031203/linekdlist.jpg)\n## 优点\n- 链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；\n- 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；\n\n## 缺点\n- 因为含有大量的指针域，占用空间较大；\n- 查找元素需要遍历链表来查找，非常耗时。\n\n## 适用场景\n数据量较小，需要频繁增加，删除操作的场景\n\n# 树\n树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n![图片](/images/post/2827031203/tree.png)\n每个节点有零个或多个子节点；\n没有父节点的节点称为根节点；\n每一个非根节点有且只有一个父节点；\n除了根节点外，每个子节点可以分为多个不相交的子树；\n在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。\n\n二叉树是树的特殊一种，具有如下特点：\n\n- 每个结点最多有两颗子树，结点的度最大为2。\n- 左子树和右子树是有顺序的，次序不能颠倒。\n- 即使某结点只有一个子树，也要区分左右子树。\n\n二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。\n\n> 二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉> 树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。\n\n# 散列表\n散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。\n![图片](/images/post/2827031203/hashtable.jpg)\n记录的存储位置=f(key)\n\n这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。\n\n哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：\n\n从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。\n\n哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。\n\n# 堆\n![图片](/images/post/2827031203/heap.jpg)\n堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：\n\n- 堆中某个节点的值总是不大于或不小于其父节点的值；\n- 堆总是一棵完全二叉树。\n\n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。\n\n堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。\n(ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：\n\n因为堆有序的特点，一般用来做数组中的排序，称为堆排序。\n\n# 图\n图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。\n\n按照顶点指向的方向可分为无向图和有向图：\n\n图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。\n","source":"_posts/技术分享/data-structure.md","raw":"---\ntitle: 【数据结构】八大数据结构简介\ntags:\n  - 数据结构\n  - 算法\nabbrlink: 2827031203\ndate: 2017-02-19 21:38:18\ncategories:\n    - 理论学习\n    ## 理论知识的分享及学习\nkeywords:\ndescription:\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ncomments:\ncover: /images/post/2827031203/cover.png\ntoc:\ntoc_number: true\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n\n\n# 数据结构分类\n数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。\n常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：\n\n![图片](/images/post/2827031203/overview.png)\n\n常见数据结构大致可分为三大类，如下所示\n- 线性表：顺序表、链表、栈和队列；\n- 树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；\n- 图存储结构\n\n## 优缺点对比表\n每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。\n\n<table>\n    <tr>\n        <td><b>数据结构</b></td>\n        <td><b>优点</b></td>\n        <td><b>缺点</b></td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n# 数组（Array）\n\n数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。\n\n    int[] data = new int[100]；\n    data[0]  = 1;\n\n## 优点\n- 按照索引查询元素速度快\n- 按照索引遍历数组方便\n\n## 缺点\n- 数组的大小固定后就无法扩容了\n- 数组只能存储一种类型的数据\n- 添加，删除的操作慢，因为要移动其他的元素。\n\n## 适用场景\n- 频繁查询，对存储空间要求不大，很少增加和删除的情况。\n\n# 栈（Stack）\n栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。\n![图片](/images/post/2827031203/stack.png)\n栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。\n\n# 队列\n队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：\n![图片](/images/post/2827031203/queue.png)\n使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。\n\n# 链表\n链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。\n![图片](/images/post/2827031203/linekdlist.jpg)\n## 优点\n- 链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；\n- 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；\n\n## 缺点\n- 因为含有大量的指针域，占用空间较大；\n- 查找元素需要遍历链表来查找，非常耗时。\n\n## 适用场景\n数据量较小，需要频繁增加，删除操作的场景\n\n# 树\n树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：\n![图片](/images/post/2827031203/tree.png)\n每个节点有零个或多个子节点；\n没有父节点的节点称为根节点；\n每一个非根节点有且只有一个父节点；\n除了根节点外，每个子节点可以分为多个不相交的子树；\n在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。\n\n二叉树是树的特殊一种，具有如下特点：\n\n- 每个结点最多有两颗子树，结点的度最大为2。\n- 左子树和右子树是有顺序的，次序不能颠倒。\n- 即使某结点只有一个子树，也要区分左右子树。\n\n二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。\n\n> 二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉> 树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。\n\n# 散列表\n散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。\n![图片](/images/post/2827031203/hashtable.jpg)\n记录的存储位置=f(key)\n\n这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。\n\n哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：\n\n从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。\n\n哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。\n\n# 堆\n![图片](/images/post/2827031203/heap.jpg)\n堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：\n\n- 堆中某个节点的值总是不大于或不小于其父节点的值；\n- 堆总是一棵完全二叉树。\n\n将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。\n\n堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。\n(ki <= k2i,ki <= k2i+1)或者(ki >= k2i,ki >= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：\n\n因为堆有序的特点，一般用来做数组中的排序，称为堆排序。\n\n# 图\n图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。\n\n按照顶点指向的方向可分为无向图和有向图：\n\n图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。\n","slug":"技术分享/data-structure","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6gs0003tvcd959y8oip","layout":"post","photos":[],"link":"","content":"<h1 id=\"数据结构分类\"><a href=\"#数据结构分类\" class=\"headerlink\" title=\"数据结构分类\"></a>数据结构分类</h1><p>数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。<br>常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/images/post/2827031203/overview.png\" alt=\"图片\"></p>\n<p>常见数据结构大致可分为三大类，如下所示</p>\n<ul>\n<li>线性表：顺序表、链表、栈和队列；</li>\n<li>树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；</li>\n<li>图存储结构</li>\n</ul>\n<h2 id=\"优缺点对比表\"><a href=\"#优缺点对比表\" class=\"headerlink\" title=\"优缺点对比表\"></a>优缺点对比表</h2><p>每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。</p>\n<table>\n    <tr>\n        <td><b>数据结构</b></td>\n        <td><b>优点</b></td>\n        <td><b>缺点</b></td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n<h1 id=\"数组（Array）\"><a href=\"#数组（Array）\" class=\"headerlink\" title=\"数组（Array）\"></a>数组（Array）</h1><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。</p>\n<pre><code>int[] data = new int[100]；\ndata[0]  = 1;</code></pre><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>按照索引查询元素速度快</li>\n<li>按照索引遍历数组方便</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>数组的大小固定后就无法扩容了</li>\n<li>数组只能存储一种类型的数据</li>\n<li>添加，删除的操作慢，因为要移动其他的元素。</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li>频繁查询，对存储空间要求不大，很少增加和删除的情况。</li>\n</ul>\n<h1 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h1><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/images/post/2827031203/stack.png\" alt=\"图片\"><br>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。</p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/images/post/2827031203/queue.png\" alt=\"图片\"><br>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/images/post/2827031203/linekdlist.jpg\" alt=\"图片\"></p>\n<h2 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；</li>\n<li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</li>\n</ul>\n<h2 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>因为含有大量的指针域，占用空间较大；</li>\n<li>查找元素需要遍历链表来查找，非常耗时。</li>\n</ul>\n<h2 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>数据量较小，需要频繁增加，删除操作的场景</p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/images/post/2827031203/tree.png\" alt=\"图片\"><br>每个节点有零个或多个子节点；<br>没有父节点的节点称为根节点；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。</p>\n<p>二叉树是树的特殊一种，具有如下特点：</p>\n<ul>\n<li>每个结点最多有两颗子树，结点的度最大为2。</li>\n<li>左子树和右子树是有顺序的，次序不能颠倒。</li>\n<li>即使某结点只有一个子树，也要区分左右子树。</li>\n</ul>\n<p>二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</p>\n<blockquote>\n<p>二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉&gt; 树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p>\n</blockquote>\n<h1 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h1><p>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/images/post/2827031203/hashtable.jpg\" alt=\"图片\"><br>记录的存储位置=f(key)</p>\n<p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。</p>\n<p>哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：</p>\n<p>从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>\n<p>哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/images/post/2827031203/heap.jpg\" alt=\"图片\"><br>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p>\n<ul>\n<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>\n<li>堆总是一棵完全二叉树。</li>\n</ul>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>\n<p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：</p>\n<p>因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</p>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p>\n<p>按照顶点指向的方向可分为无向图和有向图：</p>\n<p>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"数据结构分类\"><a href=\"#数据结构分类\" class=\"headerlink\" title=\"数据结构分类\"></a>数据结构分类</h1><p>数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成 。<br>常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：</p>\n<p><img src=\"/images/post/2827031203/overview.png\" alt=\"图片\"></p>\n<p>常见数据结构大致可分为三大类，如下所示</p>\n<ul>\n<li>线性表：顺序表、链表、栈和队列；</li>\n<li>树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；</li>\n<li>图存储结构</li>\n</ul>\n<h2 id=\"优缺点对比表\"><a href=\"#优缺点对比表\" class=\"headerlink\" title=\"优缺点对比表\"></a>优缺点对比表</h2><p>每一种数据结构都有着独特的数据存储方式，下面为大家介绍它们的结构和优缺点。</p>\n<table>\n    <tr>\n        <td><b>数据结构</b></td>\n        <td><b>优点</b></td>\n        <td><b>缺点</b></td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>插入快，如果知道下标，可以非常快的存取</td>\n        <td>查找慢，删除慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>有序数组</td>\n        <td>比无序的数组查找快</td>\n        <td>删除和插入慢，大小固定</td>\n    </tr>\n    <tr>\n        <td>栈</td>\n        <td>提供后进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>队列</td>\n        <td>提供先进先出方式的存取</td>\n        <td>存取其他项很慢</td>\n    </tr>\n    <tr>\n        <td>二叉树</td>\n        <td>查找，插入，删除都快（如果树保持平衡）</td>\n        <td>删除算法复杂</td>\n    </tr>\n    <tr>\n        <td>红-黑树</td>\n        <td>查找，插入，删除都快，树总是平衡的</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>2-3-4树</td>\n        <td>查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用</td>\n        <td>算法复杂</td>\n    </tr>\n    <tr>\n        <td>哈希表</td>\n        <td>如果关键字已知则存取极快，插入快</td>\n        <td>删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分</td>\n    </tr>\n    <tr>\n        <td>堆</td>\n        <td>插入删除快，对最大数据项的存取很快</td>\n        <td>对其他数据项存取慢</td>\n    </tr>\n    <tr>\n        <td>图</td>\n        <td>对现实世界建模</td>\n        <td>有些算法慢且复杂</td>\n    </tr>\n</table>\n\n<h1 id=\"数组（Array）\"><a href=\"#数组（Array）\" class=\"headerlink\" title=\"数组（Array）\"></a>数组（Array）</h1><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。例如下面这段代码就是将数组的第一个元素赋值为 1。</p>\n<pre><code>int[] data = new int[100]；\ndata[0]  = 1;</code></pre><h2 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>按照索引查询元素速度快</li>\n<li>按照索引遍历数组方便</li>\n</ul>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>数组的大小固定后就无法扩容了</li>\n<li>数组只能存储一种类型的数据</li>\n<li>添加，删除的操作慢，因为要移动其他的元素。</li>\n</ul>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><ul>\n<li>频繁查询，对存储空间要求不大，很少增加和删除的情况。</li>\n</ul>\n<h1 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h1><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。<br><img src=\"/images/post/2827031203/stack.png\" alt=\"图片\"><br>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。</p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，示例图如下：<br><img src=\"/images/post/2827031203/queue.png\" alt=\"图片\"><br>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。<br><img src=\"/images/post/2827031203/linekdlist.jpg\" alt=\"图片\"></p>\n<h2 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h2><ul>\n<li>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；</li>\n<li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</li>\n</ul>\n<h2 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ul>\n<li>因为含有大量的指针域，占用空间较大；</li>\n<li>查找元素需要遍历链表来查找，非常耗时。</li>\n</ul>\n<h2 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><p>数据量较小，需要频繁增加，删除操作的场景</p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：<br><img src=\"/images/post/2827031203/tree.png\" alt=\"图片\"><br>每个节点有零个或多个子节点；<br>没有父节点的节点称为根节点；<br>每一个非根节点有且只有一个父节点；<br>除了根节点外，每个子节点可以分为多个不相交的子树；<br>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。</p>\n<p>二叉树是树的特殊一种，具有如下特点：</p>\n<ul>\n<li>每个结点最多有两颗子树，结点的度最大为2。</li>\n<li>左子树和右子树是有顺序的，次序不能颠倒。</li>\n<li>即使某结点只有一个子树，也要区分左右子树。</li>\n</ul>\n<p>二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</p>\n<blockquote>\n<p>二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉&gt; 树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p>\n</blockquote>\n<h1 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h1><p>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。<br><img src=\"/images/post/2827031203/hashtable.jpg\" alt=\"图片\"><br>记录的存储位置=f(key)</p>\n<p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。</p>\n<p>哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：</p>\n<p>从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>\n<p>哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p><img src=\"/images/post/2827031203/heap.jpg\" alt=\"图片\"><br>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p>\n<ul>\n<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>\n<li>堆总是一棵完全二叉树。</li>\n</ul>\n<p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</p>\n<p>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。<br>(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆，这两者的结构图可以用完全二叉树排列出来，示例图如下：</p>\n<p>因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</p>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p>\n<p>按照顶点指向的方向可分为无向图和有向图：</p>\n<p>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构，这里不做展开，读者有兴趣可以自己学习深入。</p>\n"},{"title":"Docker之Redis Cluster搭建","abbrlink":41928529,"cover":"https://cdn.tanxz.com/images/category/redis.jpg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","date":"2020-12-10T08:33:34.000Z","_content":"\n## 环境\n\nDocker 版本 19.03.8\n```\nMacBook-Pro-6:~ tanxinzheng$ docker -v\nDocker version 19.03.8, build afacb8b\n```\n\n## 搭建\n搭建的部署主要分为\n- 架构设计\n- 编写Docker Compose编排文件\n- 创建redis cluster配置文件\n- 启动服务容器\n- 创建Redis集群\n\n### 架构设计\nredis集群模式必须要有3个主节点3个从节点才能正常启动集群模式\n\n- 主节点端口：7000 | 7001 | 7002\n- 从节点端口：7003 | 7004 | 7005\n\n### Docker Compose\n为节省内存资源，主从节点都部署在单机实例中\n```\nversion: '2'\n\nservices:\n  cluster:\n    image: daocloud.io/redis\n    container_name: redis-cluster\n    # 添加该参数后服务后台运行后，容器不会自动退出\n    tty: true\n    restart: always\n    # linux环境下建议使用host模式\n    network_mode: host\n\n    volumes:\n      - ./data:/data\n      - ./config:/etc/redis  \n    ports:\n      - \"7000:7000\"\n      - \"7001:7001\"\n      - \"7002:7002\"\n      - \"7003:7003\"\n      - \"7004:7004\"\n      - \"7005:7005\"\n    ## 必须使用宿主机ip 作为集群总线ip，否则宿主机无法访问到容器内的redis集群ip \n    # 也可以加在配置文件中\n    #  --cluster-announce-ip 172.16.65.218 \n    command: \n      - /bin/bash \n      - -c \n      - |\n        redis-server /etc/redis/redis_cluster_7000.conf  --cluster-announce-ip 172.16.65.218 & \n        redis-server /etc/redis/redis_cluster_7001.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7002.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7003.conf  --cluster-announce-ip 172.16.65.218 & \n        redis-server /etc/redis/redis_cluster_7004.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7005.conf  --cluster-announce-ip 172.16.65.218 \n```\n### redis_700X.conf\n根据各端口修改配置中的端口号\n```\nport 7000\n# 绑定机器的内网IP或者公网IP,一定要设置，不要用 127.0.0.1\nbind 0.0.0.0\n# 启用集群模式\ncluster-enabled yes\n# 集群节点文件\ncluster-config-file nodes_7000.conf\n# 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录\ndir /data/7000/\n# 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间\ncluster-node-timeout 5000\n# 集群广播ip\n#cluster-announce-ip 172.20.0.4\n#cluster-announce-port 7000\n# 开启AOF模式\nappendonly yes\n# 关闭保护模式\nprotected-mode no\n# 是否后台启动\ndaemonize no\n# pid file所在目录\npidfile /var/run/redis_7000.pid \n# 客户端访问密码\n# requirepass redis2020\n# 日志文件\nlogfile /var/log/redis_7001.log\n```\n\n## 启动Redis Cluster\n```\ndocker-compose up -d\n```\n\n### 创建Redis集群\n\n- 进入容器\n```\n$ docker exec -it redis-cluster /bin/bash\n```\n- 创建集群\n```\n$ redis-cli --cluster create 127.0.0.1:7000 \\\n                           127.0.0.1:7001 \\\n                           127.0.0.1:7002 \\\n                           127.0.0.1:7003 \\\n                           127.0.0.1:7004 \\\n                           127.0.0.1:7005 \\\n                           --cluster-replicas 1\n```\n\n## 查看集群状态\n\n### \n```\n## -c表示集群模式进入\nroot@docker-desktop:/data# redis-cli -c -h localhost -p 7000\n\n## 查看集群信息 cluster_state为ok则表示集群创建成功\nlocalhost:7000> cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:6\ncluster_size:1\ncluster_current_epoch:6\ncluster_my_epoch:3\ncluster_stats_messages_ping_sent:5290\ncluster_stats_messages_pong_sent:5299\ncluster_stats_messages_update_sent:1\ncluster_stats_messages_sent:10590\ncluster_stats_messages_ping_received:5294\ncluster_stats_messages_pong_received:5290\ncluster_stats_messages_meet_received:5\ncluster_stats_messages_update_received:3\ncluster_stats_messages_received:10592\n\n## 查看集群节点信息\nlocalhost:7000> cluster nodes\n6b7f8c4767feb376a99e79068748253afcf6ea5a 127.0.0.1:7001@17001 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594235646 3 connected\n52b109a6491a2e4280b6a66642716939d0f46e89 127.0.0.1:7004@17004 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594236555 5 connected\ndf7dcbf82ecba0ff044f2715b052674e73ec1ca6 127.0.0.1:7000@17000 myself,slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594234000 1 connected\n51f5c9fb771a702933d8bc29fcd13eb41811e2bb 127.0.0.1:7005@17005 master - 0 1607594236000 6 connected\nef7fdf2421427d1da29da4c1dab9e8c26ca12854 127.0.0.1:7002@17002 master - 0 1607594236657 3 connected 0-16383\ncf7327c9ec3b374ebc6ba3f49c6bd5e0a7098601 127.0.0.1:7003@17003 master - 0 1607594235544 4 connected\n```\n\n## 参考\n- [1] [Redis Cluster](https://redis.io/topics/cluster-tutorial)","source":"_posts/技术分享/redis-cluster.md","raw":"---\ntitle: Docker之Redis Cluster搭建\ntags:\n  - redis\n  - cluster\n  - docker\n  - docker-compose\nabbrlink: 41928529\ncover: https://cdn.tanxz.com/images/category/redis.jpg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ndate: 2020-12-10 16:33:34\n---\n\n## 环境\n\nDocker 版本 19.03.8\n```\nMacBook-Pro-6:~ tanxinzheng$ docker -v\nDocker version 19.03.8, build afacb8b\n```\n\n## 搭建\n搭建的部署主要分为\n- 架构设计\n- 编写Docker Compose编排文件\n- 创建redis cluster配置文件\n- 启动服务容器\n- 创建Redis集群\n\n### 架构设计\nredis集群模式必须要有3个主节点3个从节点才能正常启动集群模式\n\n- 主节点端口：7000 | 7001 | 7002\n- 从节点端口：7003 | 7004 | 7005\n\n### Docker Compose\n为节省内存资源，主从节点都部署在单机实例中\n```\nversion: '2'\n\nservices:\n  cluster:\n    image: daocloud.io/redis\n    container_name: redis-cluster\n    # 添加该参数后服务后台运行后，容器不会自动退出\n    tty: true\n    restart: always\n    # linux环境下建议使用host模式\n    network_mode: host\n\n    volumes:\n      - ./data:/data\n      - ./config:/etc/redis  \n    ports:\n      - \"7000:7000\"\n      - \"7001:7001\"\n      - \"7002:7002\"\n      - \"7003:7003\"\n      - \"7004:7004\"\n      - \"7005:7005\"\n    ## 必须使用宿主机ip 作为集群总线ip，否则宿主机无法访问到容器内的redis集群ip \n    # 也可以加在配置文件中\n    #  --cluster-announce-ip 172.16.65.218 \n    command: \n      - /bin/bash \n      - -c \n      - |\n        redis-server /etc/redis/redis_cluster_7000.conf  --cluster-announce-ip 172.16.65.218 & \n        redis-server /etc/redis/redis_cluster_7001.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7002.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7003.conf  --cluster-announce-ip 172.16.65.218 & \n        redis-server /etc/redis/redis_cluster_7004.conf  --cluster-announce-ip 172.16.65.218 &\n        redis-server /etc/redis/redis_cluster_7005.conf  --cluster-announce-ip 172.16.65.218 \n```\n### redis_700X.conf\n根据各端口修改配置中的端口号\n```\nport 7000\n# 绑定机器的内网IP或者公网IP,一定要设置，不要用 127.0.0.1\nbind 0.0.0.0\n# 启用集群模式\ncluster-enabled yes\n# 集群节点文件\ncluster-config-file nodes_7000.conf\n# 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录\ndir /data/7000/\n# 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间\ncluster-node-timeout 5000\n# 集群广播ip\n#cluster-announce-ip 172.20.0.4\n#cluster-announce-port 7000\n# 开启AOF模式\nappendonly yes\n# 关闭保护模式\nprotected-mode no\n# 是否后台启动\ndaemonize no\n# pid file所在目录\npidfile /var/run/redis_7000.pid \n# 客户端访问密码\n# requirepass redis2020\n# 日志文件\nlogfile /var/log/redis_7001.log\n```\n\n## 启动Redis Cluster\n```\ndocker-compose up -d\n```\n\n### 创建Redis集群\n\n- 进入容器\n```\n$ docker exec -it redis-cluster /bin/bash\n```\n- 创建集群\n```\n$ redis-cli --cluster create 127.0.0.1:7000 \\\n                           127.0.0.1:7001 \\\n                           127.0.0.1:7002 \\\n                           127.0.0.1:7003 \\\n                           127.0.0.1:7004 \\\n                           127.0.0.1:7005 \\\n                           --cluster-replicas 1\n```\n\n## 查看集群状态\n\n### \n```\n## -c表示集群模式进入\nroot@docker-desktop:/data# redis-cli -c -h localhost -p 7000\n\n## 查看集群信息 cluster_state为ok则表示集群创建成功\nlocalhost:7000> cluster info\ncluster_state:ok\ncluster_slots_assigned:16384\ncluster_slots_ok:16384\ncluster_slots_pfail:0\ncluster_slots_fail:0\ncluster_known_nodes:6\ncluster_size:1\ncluster_current_epoch:6\ncluster_my_epoch:3\ncluster_stats_messages_ping_sent:5290\ncluster_stats_messages_pong_sent:5299\ncluster_stats_messages_update_sent:1\ncluster_stats_messages_sent:10590\ncluster_stats_messages_ping_received:5294\ncluster_stats_messages_pong_received:5290\ncluster_stats_messages_meet_received:5\ncluster_stats_messages_update_received:3\ncluster_stats_messages_received:10592\n\n## 查看集群节点信息\nlocalhost:7000> cluster nodes\n6b7f8c4767feb376a99e79068748253afcf6ea5a 127.0.0.1:7001@17001 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594235646 3 connected\n52b109a6491a2e4280b6a66642716939d0f46e89 127.0.0.1:7004@17004 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594236555 5 connected\ndf7dcbf82ecba0ff044f2715b052674e73ec1ca6 127.0.0.1:7000@17000 myself,slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594234000 1 connected\n51f5c9fb771a702933d8bc29fcd13eb41811e2bb 127.0.0.1:7005@17005 master - 0 1607594236000 6 connected\nef7fdf2421427d1da29da4c1dab9e8c26ca12854 127.0.0.1:7002@17002 master - 0 1607594236657 3 connected 0-16383\ncf7327c9ec3b374ebc6ba3f49c6bd5e0a7098601 127.0.0.1:7003@17003 master - 0 1607594235544 4 connected\n```\n\n## 参考\n- [1] [Redis Cluster](https://redis.io/topics/cluster-tutorial)","slug":"技术分享/redis-cluster","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6gt0005tvcd10wncotl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>Docker 版本 19.03.8</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">MacBook-Pro-6:~ tanxinzheng$ docker -v<br>Docker version 19.03.8, build afacb8b<br></code></pre></td></tr></table></figure>\n<h2 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h2><p>搭建的部署主要分为</p>\n<ul>\n<li>架构设计</li>\n<li>编写Docker Compose编排文件</li>\n<li>创建redis cluster配置文件</li>\n<li>启动服务容器</li>\n<li>创建Redis集群</li>\n</ul>\n<h3 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h3><p>redis集群模式必须要有3个主节点3个从节点才能正常启动集群模式</p>\n<ul>\n<li>主节点端口：7000 | 7001 | 7002</li>\n<li>从节点端口：7003 | 7004 | 7005</li>\n</ul>\n<h3 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker Compose\"></a>Docker Compose</h3><p>为节省内存资源，主从节点都部署在单机实例中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">version: &#39;2&#39;<br><br>services:<br>  cluster:<br>    image: daocloud.io&#x2F;redis<br>    container_name: redis-cluster<br>    # 添加该参数后服务后台运行后，容器不会自动退出<br>    tty: true<br>    restart: always<br>    # linux环境下建议使用host模式<br>    network_mode: host<br><br>    volumes:<br>      - .&#x2F;data:&#x2F;data<br>      - .&#x2F;config:&#x2F;etc&#x2F;redis  <br>    ports:<br>      - &quot;7000:7000&quot;<br>      - &quot;7001:7001&quot;<br>      - &quot;7002:7002&quot;<br>      - &quot;7003:7003&quot;<br>      - &quot;7004:7004&quot;<br>      - &quot;7005:7005&quot;<br>    ## 必须使用宿主机ip 作为集群总线ip，否则宿主机无法访问到容器内的redis集群ip <br>    # 也可以加在配置文件中<br>    #  --cluster-announce-ip 172.16.65.218 <br>    command: <br>      - &#x2F;bin&#x2F;bash <br>      - -c <br>      - |<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7000.conf  --cluster-announce-ip 172.16.65.218 &amp; <br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7001.conf  --cluster-announce-ip 172.16.65.218 &amp;<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7002.conf  --cluster-announce-ip 172.16.65.218 &amp;<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7003.conf  --cluster-announce-ip 172.16.65.218 &amp; <br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7004.conf  --cluster-announce-ip 172.16.65.218 &amp;<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7005.conf  --cluster-announce-ip 172.16.65.218 <br></code></pre></td></tr></table></figure>\n<h3 id=\"redis-700X-conf\"><a href=\"#redis-700X-conf\" class=\"headerlink\" title=\"redis_700X.conf\"></a>redis_700X.conf</h3><p>根据各端口修改配置中的端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">port 7000<br># 绑定机器的内网IP或者公网IP,一定要设置，不要用 127.0.0.1<br>bind 0.0.0.0<br># 启用集群模式<br>cluster-enabled yes<br># 集群节点文件<br>cluster-config-file nodes_7000.conf<br># 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录<br>dir &#x2F;data&#x2F;7000&#x2F;<br># 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间<br>cluster-node-timeout 5000<br># 集群广播ip<br>#cluster-announce-ip 172.20.0.4<br>#cluster-announce-port 7000<br># 开启AOF模式<br>appendonly yes<br># 关闭保护模式<br>protected-mode no<br># 是否后台启动<br>daemonize no<br># pid file所在目录<br>pidfile &#x2F;var&#x2F;run&#x2F;redis_7000.pid <br># 客户端访问密码<br># requirepass redis2020<br># 日志文件<br>logfile &#x2F;var&#x2F;log&#x2F;redis_7001.log<br></code></pre></td></tr></table></figure>\n<h2 id=\"启动Redis-Cluster\"><a href=\"#启动Redis-Cluster\" class=\"headerlink\" title=\"启动Redis Cluster\"></a>启动Redis Cluster</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">docker-compose up -d<br></code></pre></td></tr></table></figure>\n<h3 id=\"创建Redis集群\"><a href=\"#创建Redis集群\" class=\"headerlink\" title=\"创建Redis集群\"></a>创建Redis集群</h3><ul>\n<li>进入容器<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ docker exec -it redis-cluster &#x2F;bin&#x2F;bash<br></code></pre></td></tr></table></figure></li>\n<li>创建集群<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ redis-cli --cluster create 127.0.0.1:7000 \\<br>                           127.0.0.1:7001 \\<br>                           127.0.0.1:7002 \\<br>                           127.0.0.1:7003 \\<br>                           127.0.0.1:7004 \\<br>                           127.0.0.1:7005 \\<br>                           --cluster-replicas 1<br></code></pre></td></tr></table></figure>\n<h2 id=\"查看集群状态\"><a href=\"#查看集群状态\" class=\"headerlink\" title=\"查看集群状态\"></a>查看集群状态</h2></li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">## -c表示集群模式进入<br>root@docker-desktop:&#x2F;data# redis-cli -c -h localhost -p 7000<br><br>## 查看集群信息 cluster_state为ok则表示集群创建成功<br>localhost:7000&gt; cluster info<br>cluster_state:ok<br>cluster_slots_assigned:16384<br>cluster_slots_ok:16384<br>cluster_slots_pfail:0<br>cluster_slots_fail:0<br>cluster_known_nodes:6<br>cluster_size:1<br>cluster_current_epoch:6<br>cluster_my_epoch:3<br>cluster_stats_messages_ping_sent:5290<br>cluster_stats_messages_pong_sent:5299<br>cluster_stats_messages_update_sent:1<br>cluster_stats_messages_sent:10590<br>cluster_stats_messages_ping_received:5294<br>cluster_stats_messages_pong_received:5290<br>cluster_stats_messages_meet_received:5<br>cluster_stats_messages_update_received:3<br>cluster_stats_messages_received:10592<br><br>## 查看集群节点信息<br>localhost:7000&gt; cluster nodes<br>6b7f8c4767feb376a99e79068748253afcf6ea5a 127.0.0.1:7001@17001 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594235646 3 connected<br>52b109a6491a2e4280b6a66642716939d0f46e89 127.0.0.1:7004@17004 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594236555 5 connected<br>df7dcbf82ecba0ff044f2715b052674e73ec1ca6 127.0.0.1:7000@17000 myself,slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594234000 1 connected<br>51f5c9fb771a702933d8bc29fcd13eb41811e2bb 127.0.0.1:7005@17005 master - 0 1607594236000 6 connected<br>ef7fdf2421427d1da29da4c1dab9e8c26ca12854 127.0.0.1:7002@17002 master - 0 1607594236657 3 connected 0-16383<br>cf7327c9ec3b374ebc6ba3f49c6bd5e0a7098601 127.0.0.1:7003@17003 master - 0 1607594235544 4 connected<br></code></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>[1] <a href=\"https://redis.io/topics/cluster-tutorial\">Redis Cluster</a></li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h2><p>Docker 版本 19.03.8</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">MacBook-Pro-6:~ tanxinzheng$ docker -v<br>Docker version 19.03.8, build afacb8b<br></code></pre></td></tr></table></figure>\n<h2 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h2><p>搭建的部署主要分为</p>\n<ul>\n<li>架构设计</li>\n<li>编写Docker Compose编排文件</li>\n<li>创建redis cluster配置文件</li>\n<li>启动服务容器</li>\n<li>创建Redis集群</li>\n</ul>\n<h3 id=\"架构设计\"><a href=\"#架构设计\" class=\"headerlink\" title=\"架构设计\"></a>架构设计</h3><p>redis集群模式必须要有3个主节点3个从节点才能正常启动集群模式</p>\n<ul>\n<li>主节点端口：7000 | 7001 | 7002</li>\n<li>从节点端口：7003 | 7004 | 7005</li>\n</ul>\n<h3 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker Compose\"></a>Docker Compose</h3><p>为节省内存资源，主从节点都部署在单机实例中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">version: &#39;2&#39;<br><br>services:<br>  cluster:<br>    image: daocloud.io&#x2F;redis<br>    container_name: redis-cluster<br>    # 添加该参数后服务后台运行后，容器不会自动退出<br>    tty: true<br>    restart: always<br>    # linux环境下建议使用host模式<br>    network_mode: host<br><br>    volumes:<br>      - .&#x2F;data:&#x2F;data<br>      - .&#x2F;config:&#x2F;etc&#x2F;redis  <br>    ports:<br>      - &quot;7000:7000&quot;<br>      - &quot;7001:7001&quot;<br>      - &quot;7002:7002&quot;<br>      - &quot;7003:7003&quot;<br>      - &quot;7004:7004&quot;<br>      - &quot;7005:7005&quot;<br>    ## 必须使用宿主机ip 作为集群总线ip，否则宿主机无法访问到容器内的redis集群ip <br>    # 也可以加在配置文件中<br>    #  --cluster-announce-ip 172.16.65.218 <br>    command: <br>      - &#x2F;bin&#x2F;bash <br>      - -c <br>      - |<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7000.conf  --cluster-announce-ip 172.16.65.218 &amp; <br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7001.conf  --cluster-announce-ip 172.16.65.218 &amp;<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7002.conf  --cluster-announce-ip 172.16.65.218 &amp;<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7003.conf  --cluster-announce-ip 172.16.65.218 &amp; <br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7004.conf  --cluster-announce-ip 172.16.65.218 &amp;<br>        redis-server &#x2F;etc&#x2F;redis&#x2F;redis_cluster_7005.conf  --cluster-announce-ip 172.16.65.218 <br></code></pre></td></tr></table></figure>\n<h3 id=\"redis-700X-conf\"><a href=\"#redis-700X-conf\" class=\"headerlink\" title=\"redis_700X.conf\"></a>redis_700X.conf</h3><p>根据各端口修改配置中的端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">port 7000<br># 绑定机器的内网IP或者公网IP,一定要设置，不要用 127.0.0.1<br>bind 0.0.0.0<br># 启用集群模式<br>cluster-enabled yes<br># 集群节点文件<br>cluster-config-file nodes_7000.conf<br># 指定工作目录，rdb,aof持久化文件将会放在该目录下，不同实例一定要配置不同的工作目录<br>dir &#x2F;data&#x2F;7000&#x2F;<br># 节点宕机发现时间，可以理解为主节点宕机后从节点升级为主节点时间<br>cluster-node-timeout 5000<br># 集群广播ip<br>#cluster-announce-ip 172.20.0.4<br>#cluster-announce-port 7000<br># 开启AOF模式<br>appendonly yes<br># 关闭保护模式<br>protected-mode no<br># 是否后台启动<br>daemonize no<br># pid file所在目录<br>pidfile &#x2F;var&#x2F;run&#x2F;redis_7000.pid <br># 客户端访问密码<br># requirepass redis2020<br># 日志文件<br>logfile &#x2F;var&#x2F;log&#x2F;redis_7001.log<br></code></pre></td></tr></table></figure>\n<h2 id=\"启动Redis-Cluster\"><a href=\"#启动Redis-Cluster\" class=\"headerlink\" title=\"启动Redis Cluster\"></a>启动Redis Cluster</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">docker-compose up -d<br></code></pre></td></tr></table></figure>\n<h3 id=\"创建Redis集群\"><a href=\"#创建Redis集群\" class=\"headerlink\" title=\"创建Redis集群\"></a>创建Redis集群</h3><ul>\n<li>进入容器<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ docker exec -it redis-cluster &#x2F;bin&#x2F;bash<br></code></pre></td></tr></table></figure></li>\n<li>创建集群<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ redis-cli --cluster create 127.0.0.1:7000 \\<br>                           127.0.0.1:7001 \\<br>                           127.0.0.1:7002 \\<br>                           127.0.0.1:7003 \\<br>                           127.0.0.1:7004 \\<br>                           127.0.0.1:7005 \\<br>                           --cluster-replicas 1<br></code></pre></td></tr></table></figure>\n<h2 id=\"查看集群状态\"><a href=\"#查看集群状态\" class=\"headerlink\" title=\"查看集群状态\"></a>查看集群状态</h2></li>\n</ul>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">## -c表示集群模式进入<br>root@docker-desktop:&#x2F;data# redis-cli -c -h localhost -p 7000<br><br>## 查看集群信息 cluster_state为ok则表示集群创建成功<br>localhost:7000&gt; cluster info<br>cluster_state:ok<br>cluster_slots_assigned:16384<br>cluster_slots_ok:16384<br>cluster_slots_pfail:0<br>cluster_slots_fail:0<br>cluster_known_nodes:6<br>cluster_size:1<br>cluster_current_epoch:6<br>cluster_my_epoch:3<br>cluster_stats_messages_ping_sent:5290<br>cluster_stats_messages_pong_sent:5299<br>cluster_stats_messages_update_sent:1<br>cluster_stats_messages_sent:10590<br>cluster_stats_messages_ping_received:5294<br>cluster_stats_messages_pong_received:5290<br>cluster_stats_messages_meet_received:5<br>cluster_stats_messages_update_received:3<br>cluster_stats_messages_received:10592<br><br>## 查看集群节点信息<br>localhost:7000&gt; cluster nodes<br>6b7f8c4767feb376a99e79068748253afcf6ea5a 127.0.0.1:7001@17001 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594235646 3 connected<br>52b109a6491a2e4280b6a66642716939d0f46e89 127.0.0.1:7004@17004 slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594236555 5 connected<br>df7dcbf82ecba0ff044f2715b052674e73ec1ca6 127.0.0.1:7000@17000 myself,slave ef7fdf2421427d1da29da4c1dab9e8c26ca12854 0 1607594234000 1 connected<br>51f5c9fb771a702933d8bc29fcd13eb41811e2bb 127.0.0.1:7005@17005 master - 0 1607594236000 6 connected<br>ef7fdf2421427d1da29da4c1dab9e8c26ca12854 127.0.0.1:7002@17002 master - 0 1607594236657 3 connected 0-16383<br>cf7327c9ec3b374ebc6ba3f49c6bd5e0a7098601 127.0.0.1:7003@17003 master - 0 1607594235544 4 connected<br></code></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>[1] <a href=\"https://redis.io/topics/cluster-tutorial\">Redis Cluster</a></li>\n</ul>\n"},{"title":"修改hosts加速Github访问","abbrlink":2827031223,"date":"2020-12-20T05:33:29.000Z","updated":"2020-12-24T14:39:35.813Z","keywords":["hosts","github加速","python"],"description":null,"top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","comments":1,"cover":"https://cdn.tanxz.com/images/category/github-office.jpg","toc":null,"toc_number":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"\n## 一、介绍\n对 GitHub 说\"爱\"太难了：访问慢、图片加载不出来。\n\n*注：* 本项目还处于测试阶段，仅在本机测试通过，如有问题欢迎提 [issues](https://github.com/521xueweihan/GitHub520/issues/new)\n\n---\n\n本项目无需安装任何程序，通过修改本地 hosts 文件，试图解决：\n- GitHub 访问速度慢的问题\n- GitHub 项目中的图片显示不出的问题\n\n花 5 分钟时间，让你\"爱\"上 GitHub。\n\n## 二、使用方法\n\n### 2.1 复制下面的内容\n```bash\n# GitHub520 Host Start\n185.199.108.154                                   github.githubassets.com\n199.232.68.133                                    camo.githubusercontent.com\n199.232.68.133                                    github.map.fastly.net\n199.232.69.194                                    github.global.ssl.fastly.net\n140.82.114.4                                      github.com\n140.82.114.5                                      api.github.com\n40.65.224.72                                      raw.githubusercontent.com\n199.232.28.133                                    favicons.githubusercontent.com\n199.232.68.133                                    avatars5.githubusercontent.com\n199.232.68.133                                    avatars4.githubusercontent.com\n199.232.68.133                                    avatars3.githubusercontent.com\n199.232.68.133                                    avatars2.githubusercontent.com\n199.232.68.133                                    avatars1.githubusercontent.com\n199.232.68.133                                    avatars0.githubusercontent.com\n# GitHub520 Host End\n```\n\n上面内容会自动定时更新，保证最新有效。数据更新时间：2020-06-02T08:21:56+08:00（内容无变动不会更新）\n\n### 2.1 手动方式\n#### 2.1.1 修改 hosts 文件\nhosts 文件在每个系统的位置不一，详情如下：\n- Windows 系统：`C:\\Windows\\System32\\drivers\\etc\\hosts`\n- Linux 系统：`/etc/hosts`\n- Mac（苹果电脑）系统：`/etc/hosts`\n- Android（安卓）系统：`/system/etc/hosts`\n- iPhone（iOS）系统：`/etc/hosts`\n\n修改方法，把第一步的内容复制到文本末尾：\n\n1. Windows 使用记事本。\n2. Linux、Mac 使用 Root 权限：`sudo vi /etc/hosts`。\n3. iPhone、iPad 须越狱、Android 必须要 root。\n\n#### 2.1.2 激活生效\n大部分情况下是直接生效，如未生效可尝试下面的办法，刷新 DNS：\n\n1. Windows：在 CMD 窗口输入：`ipconfig /flushdns`\n\n2. Linux 命令：`sudo rcnscd restart`\n\n3. Mac 命令：`sudo killall -HUP mDNSResponder`\n\n**Tips：** 上述方法无效可以尝试重启机器。\n\n### 2.2 通过 Hosts 切换工具\n\n**Tip**：推荐 [SwitchHosts](https://github.com/oldj/SwitchHosts) 工具管理 hosts\n\n以 SwitchHosts 为例，看一下怎么使用的，配置参考下面：\n\nTitle: 随意\n\nType: `Remote`\n\nURL: `https://raw.githubusercontent.com/521xueweihan/GitHub520/master/hosts`\n\nAuto Refresh: 最好选 `1 hour`\n\n如图：\n\n![](./img/switch-hosts.png)\n\n这样每次 hots 有更新都能及时进行更新，免去手动更新\n\n## 三、效果对比\n之前的样子：\n\n![](./img/old.png)\n\n修改完 hosts 的样子：\n\n![](./img/new.png)\n\n\n## TODO\n- [x] 定时自动更新 hosts 内容\n- [x] hosts 内容无变动不会更新\n- [ ] 寻到最有 ip 解析结果\n\n\n## 声明\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\"><img alt=\"知识共享许可协议\" style=\"border-width: 0\" src=\"https://licensebuttons.net/l/by-nc-nd/4.0/88x31.png\"></a><br>本作品采用 <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\">署名-非商业性使用-禁止演绎 4.0 国际</a> 进行许可。\n\n","source":"_posts/技术分享/修改hosts加速Github访问.md","raw":"---\ntitle: 修改hosts加速Github访问\nabbrlink: 2827031223\ncategories:\n  - 解决方案\ndate: 2020-12-20 13:33:29\nupdated:\ntags:\n  - hosts\n  - github\n  - python\nkeywords:\n  - hosts\n  - github加速\n  - python\ndescription:\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ncomments:\ncover: https://cdn.tanxz.com/images/category/github-office.jpg\ntoc:\ntoc_number:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n\n## 一、介绍\n对 GitHub 说\"爱\"太难了：访问慢、图片加载不出来。\n\n*注：* 本项目还处于测试阶段，仅在本机测试通过，如有问题欢迎提 [issues](https://github.com/521xueweihan/GitHub520/issues/new)\n\n---\n\n本项目无需安装任何程序，通过修改本地 hosts 文件，试图解决：\n- GitHub 访问速度慢的问题\n- GitHub 项目中的图片显示不出的问题\n\n花 5 分钟时间，让你\"爱\"上 GitHub。\n\n## 二、使用方法\n\n### 2.1 复制下面的内容\n```bash\n# GitHub520 Host Start\n185.199.108.154                                   github.githubassets.com\n199.232.68.133                                    camo.githubusercontent.com\n199.232.68.133                                    github.map.fastly.net\n199.232.69.194                                    github.global.ssl.fastly.net\n140.82.114.4                                      github.com\n140.82.114.5                                      api.github.com\n40.65.224.72                                      raw.githubusercontent.com\n199.232.28.133                                    favicons.githubusercontent.com\n199.232.68.133                                    avatars5.githubusercontent.com\n199.232.68.133                                    avatars4.githubusercontent.com\n199.232.68.133                                    avatars3.githubusercontent.com\n199.232.68.133                                    avatars2.githubusercontent.com\n199.232.68.133                                    avatars1.githubusercontent.com\n199.232.68.133                                    avatars0.githubusercontent.com\n# GitHub520 Host End\n```\n\n上面内容会自动定时更新，保证最新有效。数据更新时间：2020-06-02T08:21:56+08:00（内容无变动不会更新）\n\n### 2.1 手动方式\n#### 2.1.1 修改 hosts 文件\nhosts 文件在每个系统的位置不一，详情如下：\n- Windows 系统：`C:\\Windows\\System32\\drivers\\etc\\hosts`\n- Linux 系统：`/etc/hosts`\n- Mac（苹果电脑）系统：`/etc/hosts`\n- Android（安卓）系统：`/system/etc/hosts`\n- iPhone（iOS）系统：`/etc/hosts`\n\n修改方法，把第一步的内容复制到文本末尾：\n\n1. Windows 使用记事本。\n2. Linux、Mac 使用 Root 权限：`sudo vi /etc/hosts`。\n3. iPhone、iPad 须越狱、Android 必须要 root。\n\n#### 2.1.2 激活生效\n大部分情况下是直接生效，如未生效可尝试下面的办法，刷新 DNS：\n\n1. Windows：在 CMD 窗口输入：`ipconfig /flushdns`\n\n2. Linux 命令：`sudo rcnscd restart`\n\n3. Mac 命令：`sudo killall -HUP mDNSResponder`\n\n**Tips：** 上述方法无效可以尝试重启机器。\n\n### 2.2 通过 Hosts 切换工具\n\n**Tip**：推荐 [SwitchHosts](https://github.com/oldj/SwitchHosts) 工具管理 hosts\n\n以 SwitchHosts 为例，看一下怎么使用的，配置参考下面：\n\nTitle: 随意\n\nType: `Remote`\n\nURL: `https://raw.githubusercontent.com/521xueweihan/GitHub520/master/hosts`\n\nAuto Refresh: 最好选 `1 hour`\n\n如图：\n\n![](./img/switch-hosts.png)\n\n这样每次 hots 有更新都能及时进行更新，免去手动更新\n\n## 三、效果对比\n之前的样子：\n\n![](./img/old.png)\n\n修改完 hosts 的样子：\n\n![](./img/new.png)\n\n\n## TODO\n- [x] 定时自动更新 hosts 内容\n- [x] hosts 内容无变动不会更新\n- [ ] 寻到最有 ip 解析结果\n\n\n## 声明\n<a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\"><img alt=\"知识共享许可协议\" style=\"border-width: 0\" src=\"https://licensebuttons.net/l/by-nc-nd/4.0/88x31.png\"></a><br>本作品采用 <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\">署名-非商业性使用-禁止演绎 4.0 国际</a> 进行许可。\n\n","slug":"技术分享/修改hosts加速Github访问","published":1,"_id":"ckiyez6gx0009tvcd1nuzd9fc","layout":"post","photos":[],"link":"","content":"<h2 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h2><p>对 GitHub 说”爱”太难了：访问慢、图片加载不出来。</p>\n<p><em>注：</em> 本项目还处于测试阶段，仅在本机测试通过，如有问题欢迎提 <a href=\"https://github.com/521xueweihan/GitHub520/issues/new\">issues</a></p>\n<hr>\n<p>本项目无需安装任何程序，通过修改本地 hosts 文件，试图解决：</p>\n<ul>\n<li>GitHub 访问速度慢的问题</li>\n<li>GitHub 项目中的图片显示不出的问题</li>\n</ul>\n<p>花 5 分钟时间，让你”爱”上 GitHub。</p>\n<h2 id=\"二、使用方法\"><a href=\"#二、使用方法\" class=\"headerlink\" title=\"二、使用方法\"></a>二、使用方法</h2><h3 id=\"2-1-复制下面的内容\"><a href=\"#2-1-复制下面的内容\" class=\"headerlink\" title=\"2.1 复制下面的内容\"></a>2.1 复制下面的内容</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># GitHub520 Host Start</span><br>185.199.108.154                                   github.githubassets.com<br>199.232.68.133                                    camo.githubusercontent.com<br>199.232.68.133                                    github.map.fastly.net<br>199.232.69.194                                    github.global.ssl.fastly.net<br>140.82.114.4                                      github.com<br>140.82.114.5                                      api.github.com<br>40.65.224.72                                      raw.githubusercontent.com<br>199.232.28.133                                    favicons.githubusercontent.com<br>199.232.68.133                                    avatars5.githubusercontent.com<br>199.232.68.133                                    avatars4.githubusercontent.com<br>199.232.68.133                                    avatars3.githubusercontent.com<br>199.232.68.133                                    avatars2.githubusercontent.com<br>199.232.68.133                                    avatars1.githubusercontent.com<br>199.232.68.133                                    avatars0.githubusercontent.com<br><span class=\"hljs-comment\"># GitHub520 Host End</span><br></code></pre></td></tr></table></figure>\n<p>上面内容会自动定时更新，保证最新有效。数据更新时间：2020-06-02T08:21:56+08:00（内容无变动不会更新）</p>\n<h3 id=\"2-1-手动方式\"><a href=\"#2-1-手动方式\" class=\"headerlink\" title=\"2.1 手动方式\"></a>2.1 手动方式</h3><h4 id=\"2-1-1-修改-hosts-文件\"><a href=\"#2-1-1-修改-hosts-文件\" class=\"headerlink\" title=\"2.1.1 修改 hosts 文件\"></a>2.1.1 修改 hosts 文件</h4><p>hosts 文件在每个系统的位置不一，详情如下：</p>\n<ul>\n<li>Windows 系统：<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li>\n<li>Linux 系统：<code>/etc/hosts</code></li>\n<li>Mac（苹果电脑）系统：<code>/etc/hosts</code></li>\n<li>Android（安卓）系统：<code>/system/etc/hosts</code></li>\n<li>iPhone（iOS）系统：<code>/etc/hosts</code></li>\n</ul>\n<p>修改方法，把第一步的内容复制到文本末尾：</p>\n<ol>\n<li>Windows 使用记事本。</li>\n<li>Linux、Mac 使用 Root 权限：<code>sudo vi /etc/hosts</code>。</li>\n<li>iPhone、iPad 须越狱、Android 必须要 root。</li>\n</ol>\n<h4 id=\"2-1-2-激活生效\"><a href=\"#2-1-2-激活生效\" class=\"headerlink\" title=\"2.1.2 激活生效\"></a>2.1.2 激活生效</h4><p>大部分情况下是直接生效，如未生效可尝试下面的办法，刷新 DNS：</p>\n<ol>\n<li><p>Windows：在 CMD 窗口输入：<code>ipconfig /flushdns</code></p>\n</li>\n<li><p>Linux 命令：<code>sudo rcnscd restart</code></p>\n</li>\n<li><p>Mac 命令：<code>sudo killall -HUP mDNSResponder</code></p>\n</li>\n</ol>\n<p><strong>Tips：</strong> 上述方法无效可以尝试重启机器。</p>\n<h3 id=\"2-2-通过-Hosts-切换工具\"><a href=\"#2-2-通过-Hosts-切换工具\" class=\"headerlink\" title=\"2.2 通过 Hosts 切换工具\"></a>2.2 通过 Hosts 切换工具</h3><p><strong>Tip</strong>：推荐 <a href=\"https://github.com/oldj/SwitchHosts\">SwitchHosts</a> 工具管理 hosts</p>\n<p>以 SwitchHosts 为例，看一下怎么使用的，配置参考下面：</p>\n<p>Title: 随意</p>\n<p>Type: <code>Remote</code></p>\n<p>URL: <code>https://raw.githubusercontent.com/521xueweihan/GitHub520/master/hosts</code></p>\n<p>Auto Refresh: 最好选 <code>1 hour</code></p>\n<p>如图：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"./img/switch-hosts.png\" alt=\"\"></p>\n<p>这样每次 hots 有更新都能及时进行更新，免去手动更新</p>\n<h2 id=\"三、效果对比\"><a href=\"#三、效果对比\" class=\"headerlink\" title=\"三、效果对比\"></a>三、效果对比</h2><p>之前的样子：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"./img/old.png\" alt=\"\"></p>\n<p>修改完 hosts 的样子：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"./img/new.png\" alt=\"\"></p>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 定时自动更新 hosts 内容</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> hosts 内容无变动不会更新</li>\n<li><input disabled=\"\" type=\"checkbox\"> 寻到最有 ip 解析结果</li>\n</ul>\n<h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><p><a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\"><img alt=\"知识共享许可协议\" style=\"border-width: 0\" src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://licensebuttons.net/l/by-nc-nd/4.0/88x31.png\"></a><br>本作品采用 <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\">署名-非商业性使用-禁止演绎 4.0 国际</a> 进行许可。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"一、介绍\"><a href=\"#一、介绍\" class=\"headerlink\" title=\"一、介绍\"></a>一、介绍</h2><p>对 GitHub 说”爱”太难了：访问慢、图片加载不出来。</p>\n<p><em>注：</em> 本项目还处于测试阶段，仅在本机测试通过，如有问题欢迎提 <a href=\"https://github.com/521xueweihan/GitHub520/issues/new\">issues</a></p>\n<hr>\n<p>本项目无需安装任何程序，通过修改本地 hosts 文件，试图解决：</p>\n<ul>\n<li>GitHub 访问速度慢的问题</li>\n<li>GitHub 项目中的图片显示不出的问题</li>\n</ul>\n<p>花 5 分钟时间，让你”爱”上 GitHub。</p>\n<h2 id=\"二、使用方法\"><a href=\"#二、使用方法\" class=\"headerlink\" title=\"二、使用方法\"></a>二、使用方法</h2><h3 id=\"2-1-复制下面的内容\"><a href=\"#2-1-复制下面的内容\" class=\"headerlink\" title=\"2.1 复制下面的内容\"></a>2.1 复制下面的内容</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># GitHub520 Host Start</span><br>185.199.108.154                                   github.githubassets.com<br>199.232.68.133                                    camo.githubusercontent.com<br>199.232.68.133                                    github.map.fastly.net<br>199.232.69.194                                    github.global.ssl.fastly.net<br>140.82.114.4                                      github.com<br>140.82.114.5                                      api.github.com<br>40.65.224.72                                      raw.githubusercontent.com<br>199.232.28.133                                    favicons.githubusercontent.com<br>199.232.68.133                                    avatars5.githubusercontent.com<br>199.232.68.133                                    avatars4.githubusercontent.com<br>199.232.68.133                                    avatars3.githubusercontent.com<br>199.232.68.133                                    avatars2.githubusercontent.com<br>199.232.68.133                                    avatars1.githubusercontent.com<br>199.232.68.133                                    avatars0.githubusercontent.com<br><span class=\"hljs-comment\"># GitHub520 Host End</span><br></code></pre></td></tr></table></figure>\n<p>上面内容会自动定时更新，保证最新有效。数据更新时间：2020-06-02T08:21:56+08:00（内容无变动不会更新）</p>\n<h3 id=\"2-1-手动方式\"><a href=\"#2-1-手动方式\" class=\"headerlink\" title=\"2.1 手动方式\"></a>2.1 手动方式</h3><h4 id=\"2-1-1-修改-hosts-文件\"><a href=\"#2-1-1-修改-hosts-文件\" class=\"headerlink\" title=\"2.1.1 修改 hosts 文件\"></a>2.1.1 修改 hosts 文件</h4><p>hosts 文件在每个系统的位置不一，详情如下：</p>\n<ul>\n<li>Windows 系统：<code>C:\\Windows\\System32\\drivers\\etc\\hosts</code></li>\n<li>Linux 系统：<code>/etc/hosts</code></li>\n<li>Mac（苹果电脑）系统：<code>/etc/hosts</code></li>\n<li>Android（安卓）系统：<code>/system/etc/hosts</code></li>\n<li>iPhone（iOS）系统：<code>/etc/hosts</code></li>\n</ul>\n<p>修改方法，把第一步的内容复制到文本末尾：</p>\n<ol>\n<li>Windows 使用记事本。</li>\n<li>Linux、Mac 使用 Root 权限：<code>sudo vi /etc/hosts</code>。</li>\n<li>iPhone、iPad 须越狱、Android 必须要 root。</li>\n</ol>\n<h4 id=\"2-1-2-激活生效\"><a href=\"#2-1-2-激活生效\" class=\"headerlink\" title=\"2.1.2 激活生效\"></a>2.1.2 激活生效</h4><p>大部分情况下是直接生效，如未生效可尝试下面的办法，刷新 DNS：</p>\n<ol>\n<li><p>Windows：在 CMD 窗口输入：<code>ipconfig /flushdns</code></p>\n</li>\n<li><p>Linux 命令：<code>sudo rcnscd restart</code></p>\n</li>\n<li><p>Mac 命令：<code>sudo killall -HUP mDNSResponder</code></p>\n</li>\n</ol>\n<p><strong>Tips：</strong> 上述方法无效可以尝试重启机器。</p>\n<h3 id=\"2-2-通过-Hosts-切换工具\"><a href=\"#2-2-通过-Hosts-切换工具\" class=\"headerlink\" title=\"2.2 通过 Hosts 切换工具\"></a>2.2 通过 Hosts 切换工具</h3><p><strong>Tip</strong>：推荐 <a href=\"https://github.com/oldj/SwitchHosts\">SwitchHosts</a> 工具管理 hosts</p>\n<p>以 SwitchHosts 为例，看一下怎么使用的，配置参考下面：</p>\n<p>Title: 随意</p>\n<p>Type: <code>Remote</code></p>\n<p>URL: <code>https://raw.githubusercontent.com/521xueweihan/GitHub520/master/hosts</code></p>\n<p>Auto Refresh: 最好选 <code>1 hour</code></p>\n<p>如图：</p>\n<p><img src=\"./img/switch-hosts.png\" alt=\"\"></p>\n<p>这样每次 hots 有更新都能及时进行更新，免去手动更新</p>\n<h2 id=\"三、效果对比\"><a href=\"#三、效果对比\" class=\"headerlink\" title=\"三、效果对比\"></a>三、效果对比</h2><p>之前的样子：</p>\n<p><img src=\"./img/old.png\" alt=\"\"></p>\n<p>修改完 hosts 的样子：</p>\n<p><img src=\"./img/new.png\" alt=\"\"></p>\n<h2 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO\"></a>TODO</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 定时自动更新 hosts 内容</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> hosts 内容无变动不会更新</li>\n<li><input disabled=\"\" type=\"checkbox\"> 寻到最有 ip 解析结果</li>\n</ul>\n<h2 id=\"声明\"><a href=\"#声明\" class=\"headerlink\" title=\"声明\"></a>声明</h2><p><a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\"><img alt=\"知识共享许可协议\" style=\"border-width: 0\" src=\"https://licensebuttons.net/l/by-nc-nd/4.0/88x31.png\"></a><br>本作品采用 <a rel=\"license\" href=\"https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh\">署名-非商业性使用-禁止演绎 4.0 国际</a> 进行许可。</p>\n"},{"title":"Github访问加速设置","abbrlink":41928511,"cover":"https://cdn.tanxz.com/images/category/git-logo.jpg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","date":"2020-12-10T14:33:34.000Z","_content":"\n### 原理概述\n\n众所周知，由于github服务站点在美国，国内访问速度时好时坏，而通过DNS域名解析后速度更慢，所以我们可以直接通过设置hosts的域名对应的实际ip直接访问ip绕过域名解析，速度可以快到飞起，OK，进入正题。\n\n\n\n#### 域名DNS解析IP\n\n##### DNS解析域名对应ip\n\n- 访问https://www.ping.cn/dns/\n\n![image-20201216105335033](../../img/image-20201216105335033.png)\n\n- 找到当前网络运营商、解析时间最小的对应IP\n\n  ![image-20201216105708714](../../img/image-20201216105708714.png)\n\n##### Mac系统下命令查询域名对应ip\n\n_这种方式查询出来的ip，无法保证ip的访问速度，推荐使用第一种方式。_\n\n```\nMacBook-Pro-6:~ tanxinzheng$ nslookup www.github.com\nServer:\t\t114.114.114.114\nAddress:\t114.114.114.114#53\n\nNon-authoritative answer:\nwww.github.com\tcanonical name = github.com.\nName:\tgithub.com\nAddress: 13.250.177.223\n```\n\n#### 修改hosts映射Github域名\n\n管理员模式下编辑hosts\n\n- Mac系统在 /etc/hosts\n\n- Windows系统在 C:/windows/System/etc/hosts\n\n将映射代码添加在hosts文件尾部（该ip为上海地区的最小解析时间，请大家实际情况修改）\n\n_注：若需要加快github访问不只是单纯的需要映射github.com域名_\n\n```\n# github ip\n13.229.188.59 \t\tgithub.com\n52.128.23.153\t\tgithubusercontent.com\n```\n\n#### 刷新本地DNS解析缓存\n\n- Windows\n\n  ```cmd\n  ipconfig /flushdns\n  ```\n\n- Mac\n\n  ```shell\n  sudo killall -HUP mDNSResponder\n  ```\n\n- Linux\n\n  ```shell\n  sudo /etc/init.d/networking restart\n  ```\n\n  ","source":"_posts/技术分享/git/github访问加速.md","raw":"---\ntitle: Github访问加速设置\ntags:\n  - git\n  - github\ncategories: \n  - 技术分享\nabbrlink: 41928511\ncover: https://cdn.tanxz.com/images/category/git-logo.jpg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ndate: 2020-12-10 22:33:34\n---\n\n### 原理概述\n\n众所周知，由于github服务站点在美国，国内访问速度时好时坏，而通过DNS域名解析后速度更慢，所以我们可以直接通过设置hosts的域名对应的实际ip直接访问ip绕过域名解析，速度可以快到飞起，OK，进入正题。\n\n\n\n#### 域名DNS解析IP\n\n##### DNS解析域名对应ip\n\n- 访问https://www.ping.cn/dns/\n\n![image-20201216105335033](../../img/image-20201216105335033.png)\n\n- 找到当前网络运营商、解析时间最小的对应IP\n\n  ![image-20201216105708714](../../img/image-20201216105708714.png)\n\n##### Mac系统下命令查询域名对应ip\n\n_这种方式查询出来的ip，无法保证ip的访问速度，推荐使用第一种方式。_\n\n```\nMacBook-Pro-6:~ tanxinzheng$ nslookup www.github.com\nServer:\t\t114.114.114.114\nAddress:\t114.114.114.114#53\n\nNon-authoritative answer:\nwww.github.com\tcanonical name = github.com.\nName:\tgithub.com\nAddress: 13.250.177.223\n```\n\n#### 修改hosts映射Github域名\n\n管理员模式下编辑hosts\n\n- Mac系统在 /etc/hosts\n\n- Windows系统在 C:/windows/System/etc/hosts\n\n将映射代码添加在hosts文件尾部（该ip为上海地区的最小解析时间，请大家实际情况修改）\n\n_注：若需要加快github访问不只是单纯的需要映射github.com域名_\n\n```\n# github ip\n13.229.188.59 \t\tgithub.com\n52.128.23.153\t\tgithubusercontent.com\n```\n\n#### 刷新本地DNS解析缓存\n\n- Windows\n\n  ```cmd\n  ipconfig /flushdns\n  ```\n\n- Mac\n\n  ```shell\n  sudo killall -HUP mDNSResponder\n  ```\n\n- Linux\n\n  ```shell\n  sudo /etc/init.d/networking restart\n  ```\n\n  ","slug":"技术分享/git/github访问加速","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6gy000btvcdakb76imc","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"原理概述\"><a href=\"#原理概述\" class=\"headerlink\" title=\"原理概述\"></a>原理概述</h3><p>众所周知，由于github服务站点在美国，国内访问速度时好时坏，而通过DNS域名解析后速度更慢，所以我们可以直接通过设置hosts的域名对应的实际ip直接访问ip绕过域名解析，速度可以快到飞起，OK，进入正题。</p>\n<h4 id=\"域名DNS解析IP\"><a href=\"#域名DNS解析IP\" class=\"headerlink\" title=\"域名DNS解析IP\"></a>域名DNS解析IP</h4><h5 id=\"DNS解析域名对应ip\"><a href=\"#DNS解析域名对应ip\" class=\"headerlink\" title=\"DNS解析域名对应ip\"></a>DNS解析域名对应ip</h5><ul>\n<li>访问<a href=\"https://www.ping.cn/dns/\">https://www.ping.cn/dns/</a></li>\n</ul>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/image-20201216105335033.png\" alt=\"image-20201216105335033\"></p>\n<ul>\n<li><p>找到当前网络运营商、解析时间最小的对应IP</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/image-20201216105708714.png\" alt=\"image-20201216105708714\"></p>\n</li>\n</ul>\n<h5 id=\"Mac系统下命令查询域名对应ip\"><a href=\"#Mac系统下命令查询域名对应ip\" class=\"headerlink\" title=\"Mac系统下命令查询域名对应ip\"></a>Mac系统下命令查询域名对应ip</h5><p><em>这种方式查询出来的ip，无法保证ip的访问速度，推荐使用第一种方式。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">MacBook-Pro-6:~ tanxinzheng$ nslookup www.github.com<br>Server:\t\t114.114.114.114<br>Address:\t114.114.114.114#53<br><br>Non-authoritative answer:<br>www.github.com\tcanonical name &#x3D; github.com.<br>Name:\tgithub.com<br>Address: 13.250.177.223<br></code></pre></td></tr></table></figure>\n<h4 id=\"修改hosts映射Github域名\"><a href=\"#修改hosts映射Github域名\" class=\"headerlink\" title=\"修改hosts映射Github域名\"></a>修改hosts映射Github域名</h4><p>管理员模式下编辑hosts</p>\n<ul>\n<li><p>Mac系统在 /etc/hosts</p>\n</li>\n<li><p>Windows系统在 C:/windows/System/etc/hosts</p>\n</li>\n</ul>\n<p>将映射代码添加在hosts文件尾部（该ip为上海地区的最小解析时间，请大家实际情况修改）</p>\n<p><em>注：若需要加快github访问不只是单纯的需要映射github.com域名</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># github ip<br>13.229.188.59 \t\tgithub.com<br>52.128.23.153\t\tgithubusercontent.com<br></code></pre></td></tr></table></figure>\n<h4 id=\"刷新本地DNS解析缓存\"><a href=\"#刷新本地DNS解析缓存\" class=\"headerlink\" title=\"刷新本地DNS解析缓存\"></a>刷新本地DNS解析缓存</h4><ul>\n<li><p>Windows</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\"><span class=\"hljs-built_in\">ipconfig</span> /flushdns<br></code></pre></td></tr></table></figure></li>\n<li><p>Mac</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo killall -HUP mDNSResponder<br></code></pre></td></tr></table></figure></li>\n<li><p>Linux</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo /etc/init.d/networking restart<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h3 id=\"原理概述\"><a href=\"#原理概述\" class=\"headerlink\" title=\"原理概述\"></a>原理概述</h3><p>众所周知，由于github服务站点在美国，国内访问速度时好时坏，而通过DNS域名解析后速度更慢，所以我们可以直接通过设置hosts的域名对应的实际ip直接访问ip绕过域名解析，速度可以快到飞起，OK，进入正题。</p>\n<h4 id=\"域名DNS解析IP\"><a href=\"#域名DNS解析IP\" class=\"headerlink\" title=\"域名DNS解析IP\"></a>域名DNS解析IP</h4><h5 id=\"DNS解析域名对应ip\"><a href=\"#DNS解析域名对应ip\" class=\"headerlink\" title=\"DNS解析域名对应ip\"></a>DNS解析域名对应ip</h5><ul>\n<li>访问<a href=\"https://www.ping.cn/dns/\">https://www.ping.cn/dns/</a></li>\n</ul>\n<p><img src=\"../../img/image-20201216105335033.png\" alt=\"image-20201216105335033\"></p>\n<ul>\n<li><p>找到当前网络运营商、解析时间最小的对应IP</p>\n<p><img src=\"../../img/image-20201216105708714.png\" alt=\"image-20201216105708714\"></p>\n</li>\n</ul>\n<h5 id=\"Mac系统下命令查询域名对应ip\"><a href=\"#Mac系统下命令查询域名对应ip\" class=\"headerlink\" title=\"Mac系统下命令查询域名对应ip\"></a>Mac系统下命令查询域名对应ip</h5><p><em>这种方式查询出来的ip，无法保证ip的访问速度，推荐使用第一种方式。</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">MacBook-Pro-6:~ tanxinzheng$ nslookup www.github.com<br>Server:\t\t114.114.114.114<br>Address:\t114.114.114.114#53<br><br>Non-authoritative answer:<br>www.github.com\tcanonical name &#x3D; github.com.<br>Name:\tgithub.com<br>Address: 13.250.177.223<br></code></pre></td></tr></table></figure>\n<h4 id=\"修改hosts映射Github域名\"><a href=\"#修改hosts映射Github域名\" class=\"headerlink\" title=\"修改hosts映射Github域名\"></a>修改hosts映射Github域名</h4><p>管理员模式下编辑hosts</p>\n<ul>\n<li><p>Mac系统在 /etc/hosts</p>\n</li>\n<li><p>Windows系统在 C:/windows/System/etc/hosts</p>\n</li>\n</ul>\n<p>将映射代码添加在hosts文件尾部（该ip为上海地区的最小解析时间，请大家实际情况修改）</p>\n<p><em>注：若需要加快github访问不只是单纯的需要映射github.com域名</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># github ip<br>13.229.188.59 \t\tgithub.com<br>52.128.23.153\t\tgithubusercontent.com<br></code></pre></td></tr></table></figure>\n<h4 id=\"刷新本地DNS解析缓存\"><a href=\"#刷新本地DNS解析缓存\" class=\"headerlink\" title=\"刷新本地DNS解析缓存\"></a>刷新本地DNS解析缓存</h4><ul>\n<li><p>Windows</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\"><span class=\"hljs-built_in\">ipconfig</span> /flushdns<br></code></pre></td></tr></table></figure></li>\n<li><p>Mac</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo killall -HUP mDNSResponder<br></code></pre></td></tr></table></figure></li>\n<li><p>Linux</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo /etc/init.d/networking restart<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"Windows下git配置ssh密钥","abbrlink":41928510,"cover":"https://cdn.tanxz.com/images/category/git-logo.jpg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","date":"2020-12-10T14:33:34.000Z","_content":"\n\n\n#### 检查用户.SSH目录\n\n若存在则直接使用已生成的ssh公私密钥，跳过生成SSH公私密钥步骤\n\n**若需要免密提交则要保证生成的ssh公私密钥是未输入密码的**\n\n```\nPS C:\\Users\\tanxz\\.ssh> ls\n\n    目录: C:\\Users\\tanxz\\.ssh\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a----        2020/12/16      0:31           1679 id_rsa\n-a----        2020/12/16      0:31            402 id_rsa.pub\n-a----        2020/12/16      0:34            185 known_hosts\n```\n\n#### 生成SSH公私密钥\n\n```c++\nC:\\Users\\tanxz> ssh-keygen -t rsa -C \"tanxinzheng@139.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key (C:\\Users\\tanxz/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in C:\\Users\\tanxz/.ssh/id_rsa.\nYour public key has been saved in C:\\Users\\tanxz/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:9BM2DGD4+BKfyMjWhrP0b4xdHlk4I9JG/dJB0BwR0Nc tanxinzheng@139.com\nThe key's randomart image is:\n+---[RSA 2048]----+\n|     .oo+B=+ .   |\n|    ... .o= . E  |\n|     =  .+=o     |\n|    + =.=o+o     |\n| . = B oS*o      |\n|  B * + +  .     |\n| o = = o .       |\n|  . o + .        |\n|     o.          |\n+----[SHA256]-----+\n```\n\n#### 添加SSH公钥到github和gitee\n\n打开.ssh目录下的id_rsa.pub文件，复制里面的内容，到github和gitee设置中找到的SSH key的信息，添加即可。\n\n#### 测试是否ssh密钥是否有效\n\n```\nC:\\Users\\tanxz\\.ssh> ssh -T git@github.com\nHi tanxinzheng! You've successfully authenticated, but GitHub does not provide shell access.\nPS C:\\Users\\tanxz\\.ssh> ssh -T git@gitee.com\nHi tanxinzheng! You've successfully authenticated, but GITEE.COM does not provide shell access.\n```\n\n若显示以上信息，恭喜你以后终于不用输入密码了！！：）\n\n","source":"_posts/技术分享/git/git添加ssh密钥.md","raw":"---\ntitle: Windows下git配置ssh密钥\ntags:\n  - git\ncategories:\n  - 技术分享\nabbrlink: 41928510\ncover: https://cdn.tanxz.com/images/category/git-logo.jpg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ndate: 2020-12-10 22:33:34\n---\n\n\n\n#### 检查用户.SSH目录\n\n若存在则直接使用已生成的ssh公私密钥，跳过生成SSH公私密钥步骤\n\n**若需要免密提交则要保证生成的ssh公私密钥是未输入密码的**\n\n```\nPS C:\\Users\\tanxz\\.ssh> ls\n\n    目录: C:\\Users\\tanxz\\.ssh\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\n-a----        2020/12/16      0:31           1679 id_rsa\n-a----        2020/12/16      0:31            402 id_rsa.pub\n-a----        2020/12/16      0:34            185 known_hosts\n```\n\n#### 生成SSH公私密钥\n\n```c++\nC:\\Users\\tanxz> ssh-keygen -t rsa -C \"tanxinzheng@139.com\"\nGenerating public/private rsa key pair.\nEnter file in which to save the key (C:\\Users\\tanxz/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in C:\\Users\\tanxz/.ssh/id_rsa.\nYour public key has been saved in C:\\Users\\tanxz/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:9BM2DGD4+BKfyMjWhrP0b4xdHlk4I9JG/dJB0BwR0Nc tanxinzheng@139.com\nThe key's randomart image is:\n+---[RSA 2048]----+\n|     .oo+B=+ .   |\n|    ... .o= . E  |\n|     =  .+=o     |\n|    + =.=o+o     |\n| . = B oS*o      |\n|  B * + +  .     |\n| o = = o .       |\n|  . o + .        |\n|     o.          |\n+----[SHA256]-----+\n```\n\n#### 添加SSH公钥到github和gitee\n\n打开.ssh目录下的id_rsa.pub文件，复制里面的内容，到github和gitee设置中找到的SSH key的信息，添加即可。\n\n#### 测试是否ssh密钥是否有效\n\n```\nC:\\Users\\tanxz\\.ssh> ssh -T git@github.com\nHi tanxinzheng! You've successfully authenticated, but GitHub does not provide shell access.\nPS C:\\Users\\tanxz\\.ssh> ssh -T git@gitee.com\nHi tanxinzheng! You've successfully authenticated, but GITEE.COM does not provide shell access.\n```\n\n若显示以上信息，恭喜你以后终于不用输入密码了！！：）\n\n","slug":"技术分享/git/git添加ssh密钥","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6gz000dtvcd8rb26gkp","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"检查用户-SSH目录\"><a href=\"#检查用户-SSH目录\" class=\"headerlink\" title=\"检查用户.SSH目录\"></a>检查用户.SSH目录</h4><p>若存在则直接使用已生成的ssh公私密钥，跳过生成SSH公私密钥步骤</p>\n<p><strong>若需要免密提交则要保证生成的ssh公私密钥是未输入密码的</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">PS C:\\Users\\tanxz\\.ssh&gt; ls<br><br>    目录: C:\\Users\\tanxz\\.ssh<br><br><br>Mode                 LastWriteTime         Length Name<br>----                 -------------         ------ ----<br>-a----        2020&#x2F;12&#x2F;16      0:31           1679 id_rsa<br>-a----        2020&#x2F;12&#x2F;16      0:31            402 id_rsa.pub<br>-a----        2020&#x2F;12&#x2F;16      0:34            185 known_hosts<br></code></pre></td></tr></table></figure>\n<h4 id=\"生成SSH公私密钥\"><a href=\"#生成SSH公私密钥\" class=\"headerlink\" title=\"生成SSH公私密钥\"></a>生成SSH公私密钥</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">C:\\Users\\tanxz&gt; ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;tanxinzheng@139.com&quot;</span><br>Generating <span class=\"hljs-keyword\">public</span>/<span class=\"hljs-keyword\">private</span> rsa key <span class=\"hljs-built_in\">pair</span>.<br><span class=\"hljs-function\">Enter file in which to save the <span class=\"hljs-title\">key</span> <span class=\"hljs-params\">(C:\\Users\\tanxz/.ssh/id_rsa)</span>:</span><br><span class=\"hljs-function\">Enter <span class=\"hljs-title\">passphrase</span> <span class=\"hljs-params\">(empty <span class=\"hljs-keyword\">for</span> no passphrase)</span>:</span><br><span class=\"hljs-function\">Enter same passphrase again:</span><br>Your identification has been saved in C:\\Users\\tanxz/.ssh/id_rsa.<br>Your <span class=\"hljs-keyword\">public</span> key has been saved in C:\\Users\\tanxz/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>SHA256:<span class=\"hljs-number\">9B</span>M2DGD4+BKfyMjWhrP0b4xdHlk4I9JG/dJB0BwR0Nc tanxinzheng@<span class=\"hljs-number\">139.</span>com<br>The key<span class=\"hljs-number\">&#x27;</span>s randomart image is:<br>+---[RSA <span class=\"hljs-number\">2048</span>]----+<br>|     .oo+B=+ .   |<br>|    ... .o= . E  |<br>|     =  .+=o     |<br>|    + =.=o+o     |<br>| . = B oS*o      |<br>|  B * + +  .     |<br>| o = = o .       |<br>|  . o + .        |<br>|     o.          |<br>+----[SHA256]-----+<br></code></pre></td></tr></table></figure>\n<h4 id=\"添加SSH公钥到github和gitee\"><a href=\"#添加SSH公钥到github和gitee\" class=\"headerlink\" title=\"添加SSH公钥到github和gitee\"></a>添加SSH公钥到github和gitee</h4><p>打开.ssh目录下的id_rsa.pub文件，复制里面的内容，到github和gitee设置中找到的SSH key的信息，添加即可。</p>\n<h4 id=\"测试是否ssh密钥是否有效\"><a href=\"#测试是否ssh密钥是否有效\" class=\"headerlink\" title=\"测试是否ssh密钥是否有效\"></a>测试是否ssh密钥是否有效</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">C:\\Users\\tanxz\\.ssh&gt; ssh -T git@github.com<br>Hi tanxinzheng! You&#39;ve successfully authenticated, but GitHub does not provide shell access.<br>PS C:\\Users\\tanxz\\.ssh&gt; ssh -T git@gitee.com<br>Hi tanxinzheng! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.<br></code></pre></td></tr></table></figure>\n<p>若显示以上信息，恭喜你以后终于不用输入密码了！！：）</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h4 id=\"检查用户-SSH目录\"><a href=\"#检查用户-SSH目录\" class=\"headerlink\" title=\"检查用户.SSH目录\"></a>检查用户.SSH目录</h4><p>若存在则直接使用已生成的ssh公私密钥，跳过生成SSH公私密钥步骤</p>\n<p><strong>若需要免密提交则要保证生成的ssh公私密钥是未输入密码的</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">PS C:\\Users\\tanxz\\.ssh&gt; ls<br><br>    目录: C:\\Users\\tanxz\\.ssh<br><br><br>Mode                 LastWriteTime         Length Name<br>----                 -------------         ------ ----<br>-a----        2020&#x2F;12&#x2F;16      0:31           1679 id_rsa<br>-a----        2020&#x2F;12&#x2F;16      0:31            402 id_rsa.pub<br>-a----        2020&#x2F;12&#x2F;16      0:34            185 known_hosts<br></code></pre></td></tr></table></figure>\n<h4 id=\"生成SSH公私密钥\"><a href=\"#生成SSH公私密钥\" class=\"headerlink\" title=\"生成SSH公私密钥\"></a>生成SSH公私密钥</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">C:\\Users\\tanxz&gt; ssh-keygen -t rsa -C <span class=\"hljs-string\">&quot;tanxinzheng@139.com&quot;</span><br>Generating <span class=\"hljs-keyword\">public</span>/<span class=\"hljs-keyword\">private</span> rsa key <span class=\"hljs-built_in\">pair</span>.<br><span class=\"hljs-function\">Enter file in which to save the <span class=\"hljs-title\">key</span> <span class=\"hljs-params\">(C:\\Users\\tanxz/.ssh/id_rsa)</span>:</span><br><span class=\"hljs-function\">Enter <span class=\"hljs-title\">passphrase</span> <span class=\"hljs-params\">(empty <span class=\"hljs-keyword\">for</span> no passphrase)</span>:</span><br><span class=\"hljs-function\">Enter same passphrase again:</span><br>Your identification has been saved in C:\\Users\\tanxz/.ssh/id_rsa.<br>Your <span class=\"hljs-keyword\">public</span> key has been saved in C:\\Users\\tanxz/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>SHA256:<span class=\"hljs-number\">9B</span>M2DGD4+BKfyMjWhrP0b4xdHlk4I9JG/dJB0BwR0Nc tanxinzheng@<span class=\"hljs-number\">139.</span>com<br>The key<span class=\"hljs-number\">&#x27;</span>s randomart image is:<br>+---[RSA <span class=\"hljs-number\">2048</span>]----+<br>|     .oo+B=+ .   |<br>|    ... .o= . E  |<br>|     =  .+=o     |<br>|    + =.=o+o     |<br>| . = B oS*o      |<br>|  B * + +  .     |<br>| o = = o .       |<br>|  . o + .        |<br>|     o.          |<br>+----[SHA256]-----+<br></code></pre></td></tr></table></figure>\n<h4 id=\"添加SSH公钥到github和gitee\"><a href=\"#添加SSH公钥到github和gitee\" class=\"headerlink\" title=\"添加SSH公钥到github和gitee\"></a>添加SSH公钥到github和gitee</h4><p>打开.ssh目录下的id_rsa.pub文件，复制里面的内容，到github和gitee设置中找到的SSH key的信息，添加即可。</p>\n<h4 id=\"测试是否ssh密钥是否有效\"><a href=\"#测试是否ssh密钥是否有效\" class=\"headerlink\" title=\"测试是否ssh密钥是否有效\"></a>测试是否ssh密钥是否有效</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">C:\\Users\\tanxz\\.ssh&gt; ssh -T git@github.com<br>Hi tanxinzheng! You&#39;ve successfully authenticated, but GitHub does not provide shell access.<br>PS C:\\Users\\tanxz\\.ssh&gt; ssh -T git@gitee.com<br>Hi tanxinzheng! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.<br></code></pre></td></tr></table></figure>\n<p>若显示以上信息，恭喜你以后终于不用输入密码了！！：）</p>\n"},{"title":"Linux之SSH免密登录","abbrlink":2578104319,"date":"2017-08-18T09:59:25.000Z","cover":"https://cdn.tanxz.com/images/category/linux.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","_content":"\n\n\n安装Linux/Ubuntu的阿里云ECS默认情况下是使用账号+密码通过SSH登录的，并且默认账户是root，所以这里难免会有安全隐患。\n因此这里记录一下：Linux/Ubuntu系统怎么设置普通用户（非root用户），本教程以admin用户为例，使用秘钥登录通过SSH登录远程服务器。\n\n# 本地端流程\n## 检查本地SSH Key\n检查本地是否已经存在SSH Key秘钥，输入下面的命令来检查本地是否已经存在秘钥，如果有下面结果则跳过该步，若没有那么接下来的步骤生成秘钥\n\n    $ ls -a ~/.ssh\n    .\t\t..\t\tauthorized_keys\tid_rsa\t\tid_rsa.pub\tknown_hosts\n\n## 生成本地SSH Key秘钥\n输入以下命令，默认会在相应路径下（~/.ssh）生成id_rsa和id_rsa.pub两个文件，如下面代码所示\n\n     # 注：若需要免密码登录则直接回车\n     ~$ ssh-keygen -t rsa -C \"your_email@example.com\"   \n     Enter file in which to save the key (/your_home_path/.ssh/id_rsa): \n     Enter passphrase (empty for no passphrase): \n     Enter same passphrase again: \n     Your identification has been saved in /your_home_path/.ssh/id_rsa.\n     Your public key has been saved in /your_home_path/.ssh/id_rsa.pub.\n     The key fingerprint is:\n     SHA256:YgZkAauw6YCWAWwvfiMgJ7zBGkVbFqgRxQ7hdet5nGY your_email@example.com\n     The key's randomart image is:\n     +---[RSA 2048]----+\n     |BO=++o           |\n     |Bo++. .          |\n     |oOo ..           |\n     |+==...o .        |\n     |X+.  o+ES        |\n     |=X + o+.         |\n     |.oX .            |\n     |..               |\n     |                 |\n     +----[SHA256]-----+\n\n# 服务器端流程\n创建普通用户\n使用root用户操作以下命令创建普通用户：\n## 创建用户并修改密码\n\n    useradd admin\n    passwd admin\n    vi /etc/sudoers                                 # 增加用户su身份，编辑sudoers文件\n    admin ALL=(ALL:ALL) ALL                         # 在最底部加入这一行，保存退出\n\n## 添加ssh key公钥配置\n使用root用户操作以下命令创建存储密钥的文件夹及文件\n> <font color=red>**注意：第三步是最重要的一步！！！**</font>\n\n     mkdir /home/admin/.ssh\n     chmod 700 /home/admin/.ssh                       \n     vi /home/admin/.ssh/authorized_keys            #创建authorized_keys文件，并将本地生成的id_rsa.pub的内容填入authorized_keys\n     chmod 600 /home/admin/.ssh/authorized_keys     #设置authorized_keys权限\n     chown -R admin:admin /home/admin/.ssh/         #修改用户组和用户所有权\n     systemctl stop sshd                            #暂停ssh服务\n     systemctl start sshd                           #启动ssh服务\n\n## 设置SSH登录安全配置（可选步骤）\n> **温馨提示：SSH登录安全配置建议，使用root用户操作以下命令**\n\n     # 编辑SSH配置文件 \n     vi /etc/ssh/sshd_config\n     PermitRootLogin no                             # 禁用root账号登录，该配置可不修改，避免特殊情况下需要用到root\n     PasswordAuthentication no                      # 禁用账号+密码登录\n     # 保存退出后，重启ssh服务\n     systemctl stop sshd\n     systemctl start sshd\n\n# 本地验证登录\n因为每次记ip很麻烦，推荐使用hosts映射ip，使用别名登录。\n## 添加远端ip别名\n\n    vi /etc/hosts\n    xxx.xxx.xxx.xxx   my-remote-server              # 添加远端ip及映射的别名：ip  别名\n\n## 验证ssh免密登录\n\n    ssh admin@xxx.xxx.xxx.xxx                       # ip远程登录\n    ssh admin@my-remote-server                      # 别名远程登录\n\n   \n\n\n","source":"_posts/技术分享/linux/Linux之SSH免密登录.md","raw":"---\ntitle: Linux之SSH免密登录\nabbrlink: 2578104319\ndate: 2017-08-18 17:59:25\ncover: https://cdn.tanxz.com/images/category/linux.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ntags: \n  - Linux\n---\n\n\n\n安装Linux/Ubuntu的阿里云ECS默认情况下是使用账号+密码通过SSH登录的，并且默认账户是root，所以这里难免会有安全隐患。\n因此这里记录一下：Linux/Ubuntu系统怎么设置普通用户（非root用户），本教程以admin用户为例，使用秘钥登录通过SSH登录远程服务器。\n\n# 本地端流程\n## 检查本地SSH Key\n检查本地是否已经存在SSH Key秘钥，输入下面的命令来检查本地是否已经存在秘钥，如果有下面结果则跳过该步，若没有那么接下来的步骤生成秘钥\n\n    $ ls -a ~/.ssh\n    .\t\t..\t\tauthorized_keys\tid_rsa\t\tid_rsa.pub\tknown_hosts\n\n## 生成本地SSH Key秘钥\n输入以下命令，默认会在相应路径下（~/.ssh）生成id_rsa和id_rsa.pub两个文件，如下面代码所示\n\n     # 注：若需要免密码登录则直接回车\n     ~$ ssh-keygen -t rsa -C \"your_email@example.com\"   \n     Enter file in which to save the key (/your_home_path/.ssh/id_rsa): \n     Enter passphrase (empty for no passphrase): \n     Enter same passphrase again: \n     Your identification has been saved in /your_home_path/.ssh/id_rsa.\n     Your public key has been saved in /your_home_path/.ssh/id_rsa.pub.\n     The key fingerprint is:\n     SHA256:YgZkAauw6YCWAWwvfiMgJ7zBGkVbFqgRxQ7hdet5nGY your_email@example.com\n     The key's randomart image is:\n     +---[RSA 2048]----+\n     |BO=++o           |\n     |Bo++. .          |\n     |oOo ..           |\n     |+==...o .        |\n     |X+.  o+ES        |\n     |=X + o+.         |\n     |.oX .            |\n     |..               |\n     |                 |\n     +----[SHA256]-----+\n\n# 服务器端流程\n创建普通用户\n使用root用户操作以下命令创建普通用户：\n## 创建用户并修改密码\n\n    useradd admin\n    passwd admin\n    vi /etc/sudoers                                 # 增加用户su身份，编辑sudoers文件\n    admin ALL=(ALL:ALL) ALL                         # 在最底部加入这一行，保存退出\n\n## 添加ssh key公钥配置\n使用root用户操作以下命令创建存储密钥的文件夹及文件\n> <font color=red>**注意：第三步是最重要的一步！！！**</font>\n\n     mkdir /home/admin/.ssh\n     chmod 700 /home/admin/.ssh                       \n     vi /home/admin/.ssh/authorized_keys            #创建authorized_keys文件，并将本地生成的id_rsa.pub的内容填入authorized_keys\n     chmod 600 /home/admin/.ssh/authorized_keys     #设置authorized_keys权限\n     chown -R admin:admin /home/admin/.ssh/         #修改用户组和用户所有权\n     systemctl stop sshd                            #暂停ssh服务\n     systemctl start sshd                           #启动ssh服务\n\n## 设置SSH登录安全配置（可选步骤）\n> **温馨提示：SSH登录安全配置建议，使用root用户操作以下命令**\n\n     # 编辑SSH配置文件 \n     vi /etc/ssh/sshd_config\n     PermitRootLogin no                             # 禁用root账号登录，该配置可不修改，避免特殊情况下需要用到root\n     PasswordAuthentication no                      # 禁用账号+密码登录\n     # 保存退出后，重启ssh服务\n     systemctl stop sshd\n     systemctl start sshd\n\n# 本地验证登录\n因为每次记ip很麻烦，推荐使用hosts映射ip，使用别名登录。\n## 添加远端ip别名\n\n    vi /etc/hosts\n    xxx.xxx.xxx.xxx   my-remote-server              # 添加远端ip及映射的别名：ip  别名\n\n## 验证ssh免密登录\n\n    ssh admin@xxx.xxx.xxx.xxx                       # ip远程登录\n    ssh admin@my-remote-server                      # 别名远程登录\n\n   \n\n\n","slug":"技术分享/linux/Linux之SSH免密登录","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6h1000htvcd60oyby2f","comments":1,"layout":"post","photos":[],"link":"","content":"<p>安装Linux/Ubuntu的阿里云ECS默认情况下是使用账号+密码通过SSH登录的，并且默认账户是root，所以这里难免会有安全隐患。<br>因此这里记录一下：Linux/Ubuntu系统怎么设置普通用户（非root用户），本教程以admin用户为例，使用秘钥登录通过SSH登录远程服务器。</p>\n<h1 id=\"本地端流程\"><a href=\"#本地端流程\" class=\"headerlink\" title=\"本地端流程\"></a>本地端流程</h1><h2 id=\"检查本地SSH-Key\"><a href=\"#检查本地SSH-Key\" class=\"headerlink\" title=\"检查本地SSH Key\"></a>检查本地SSH Key</h2><p>检查本地是否已经存在SSH Key秘钥，输入下面的命令来检查本地是否已经存在秘钥，如果有下面结果则跳过该步，若没有那么接下来的步骤生成秘钥</p>\n<pre><code>$ ls -a ~/.ssh\n.        ..        authorized_keys    id_rsa        id_rsa.pub    known_hosts</code></pre><h2 id=\"生成本地SSH-Key秘钥\"><a href=\"#生成本地SSH-Key秘钥\" class=\"headerlink\" title=\"生成本地SSH Key秘钥\"></a>生成本地SSH Key秘钥</h2><p>输入以下命令，默认会在相应路径下（~/.ssh）生成id_rsa和id_rsa.pub两个文件，如下面代码所示</p>\n<pre><code># 注：若需要免密码登录则直接回车\n~$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;   \nEnter file in which to save the key (/your_home_path/.ssh/id_rsa): \nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /your_home_path/.ssh/id_rsa.\nYour public key has been saved in /your_home_path/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:YgZkAauw6YCWAWwvfiMgJ7zBGkVbFqgRxQ7hdet5nGY your_email@example.com\nThe key&apos;s randomart image is:\n+---[RSA 2048]----+\n|BO=++o           |\n|Bo++. .          |\n|oOo ..           |\n|+==...o .        |\n|X+.  o+ES        |\n|=X + o+.         |\n|.oX .            |\n|..               |\n|                 |\n+----[SHA256]-----+</code></pre><h1 id=\"服务器端流程\"><a href=\"#服务器端流程\" class=\"headerlink\" title=\"服务器端流程\"></a>服务器端流程</h1><p>创建普通用户<br>使用root用户操作以下命令创建普通用户：</p>\n<h2 id=\"创建用户并修改密码\"><a href=\"#创建用户并修改密码\" class=\"headerlink\" title=\"创建用户并修改密码\"></a>创建用户并修改密码</h2><pre><code>useradd admin\npasswd admin\nvi /etc/sudoers                                 # 增加用户su身份，编辑sudoers文件\nadmin ALL=(ALL:ALL) ALL                         # 在最底部加入这一行，保存退出</code></pre><h2 id=\"添加ssh-key公钥配置\"><a href=\"#添加ssh-key公钥配置\" class=\"headerlink\" title=\"添加ssh key公钥配置\"></a>添加ssh key公钥配置</h2><p>使用root用户操作以下命令创建存储密钥的文件夹及文件</p>\n<blockquote>\n<p><font color=red><strong>注意：第三步是最重要的一步！！！</strong></font></p>\n</blockquote>\n<pre><code>mkdir /home/admin/.ssh\nchmod 700 /home/admin/.ssh                       \nvi /home/admin/.ssh/authorized_keys            #创建authorized_keys文件，并将本地生成的id_rsa.pub的内容填入authorized_keys\nchmod 600 /home/admin/.ssh/authorized_keys     #设置authorized_keys权限\nchown -R admin:admin /home/admin/.ssh/         #修改用户组和用户所有权\nsystemctl stop sshd                            #暂停ssh服务\nsystemctl start sshd                           #启动ssh服务</code></pre><h2 id=\"设置SSH登录安全配置（可选步骤）\"><a href=\"#设置SSH登录安全配置（可选步骤）\" class=\"headerlink\" title=\"设置SSH登录安全配置（可选步骤）\"></a>设置SSH登录安全配置（可选步骤）</h2><blockquote>\n<p><strong>温馨提示：SSH登录安全配置建议，使用root用户操作以下命令</strong></p>\n</blockquote>\n<pre><code># 编辑SSH配置文件 \nvi /etc/ssh/sshd_config\nPermitRootLogin no                             # 禁用root账号登录，该配置可不修改，避免特殊情况下需要用到root\nPasswordAuthentication no                      # 禁用账号+密码登录\n# 保存退出后，重启ssh服务\nsystemctl stop sshd\nsystemctl start sshd</code></pre><h1 id=\"本地验证登录\"><a href=\"#本地验证登录\" class=\"headerlink\" title=\"本地验证登录\"></a>本地验证登录</h1><p>因为每次记ip很麻烦，推荐使用hosts映射ip，使用别名登录。</p>\n<h2 id=\"添加远端ip别名\"><a href=\"#添加远端ip别名\" class=\"headerlink\" title=\"添加远端ip别名\"></a>添加远端ip别名</h2><pre><code>vi /etc/hosts\nxxx.xxx.xxx.xxx   my-remote-server              # 添加远端ip及映射的别名：ip  别名</code></pre><h2 id=\"验证ssh免密登录\"><a href=\"#验证ssh免密登录\" class=\"headerlink\" title=\"验证ssh免密登录\"></a>验证ssh免密登录</h2><pre><code>ssh admin@xxx.xxx.xxx.xxx                       # ip远程登录\nssh admin@my-remote-server                      # 别名远程登录</code></pre>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p>安装Linux/Ubuntu的阿里云ECS默认情况下是使用账号+密码通过SSH登录的，并且默认账户是root，所以这里难免会有安全隐患。<br>因此这里记录一下：Linux/Ubuntu系统怎么设置普通用户（非root用户），本教程以admin用户为例，使用秘钥登录通过SSH登录远程服务器。</p>\n<h1 id=\"本地端流程\"><a href=\"#本地端流程\" class=\"headerlink\" title=\"本地端流程\"></a>本地端流程</h1><h2 id=\"检查本地SSH-Key\"><a href=\"#检查本地SSH-Key\" class=\"headerlink\" title=\"检查本地SSH Key\"></a>检查本地SSH Key</h2><p>检查本地是否已经存在SSH Key秘钥，输入下面的命令来检查本地是否已经存在秘钥，如果有下面结果则跳过该步，若没有那么接下来的步骤生成秘钥</p>\n<pre><code>$ ls -a ~/.ssh\n.        ..        authorized_keys    id_rsa        id_rsa.pub    known_hosts</code></pre><h2 id=\"生成本地SSH-Key秘钥\"><a href=\"#生成本地SSH-Key秘钥\" class=\"headerlink\" title=\"生成本地SSH Key秘钥\"></a>生成本地SSH Key秘钥</h2><p>输入以下命令，默认会在相应路径下（~/.ssh）生成id_rsa和id_rsa.pub两个文件，如下面代码所示</p>\n<pre><code># 注：若需要免密码登录则直接回车\n~$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;   \nEnter file in which to save the key (/your_home_path/.ssh/id_rsa): \nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /your_home_path/.ssh/id_rsa.\nYour public key has been saved in /your_home_path/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:YgZkAauw6YCWAWwvfiMgJ7zBGkVbFqgRxQ7hdet5nGY your_email@example.com\nThe key&apos;s randomart image is:\n+---[RSA 2048]----+\n|BO=++o           |\n|Bo++. .          |\n|oOo ..           |\n|+==...o .        |\n|X+.  o+ES        |\n|=X + o+.         |\n|.oX .            |\n|..               |\n|                 |\n+----[SHA256]-----+</code></pre><h1 id=\"服务器端流程\"><a href=\"#服务器端流程\" class=\"headerlink\" title=\"服务器端流程\"></a>服务器端流程</h1><p>创建普通用户<br>使用root用户操作以下命令创建普通用户：</p>\n<h2 id=\"创建用户并修改密码\"><a href=\"#创建用户并修改密码\" class=\"headerlink\" title=\"创建用户并修改密码\"></a>创建用户并修改密码</h2><pre><code>useradd admin\npasswd admin\nvi /etc/sudoers                                 # 增加用户su身份，编辑sudoers文件\nadmin ALL=(ALL:ALL) ALL                         # 在最底部加入这一行，保存退出</code></pre><h2 id=\"添加ssh-key公钥配置\"><a href=\"#添加ssh-key公钥配置\" class=\"headerlink\" title=\"添加ssh key公钥配置\"></a>添加ssh key公钥配置</h2><p>使用root用户操作以下命令创建存储密钥的文件夹及文件</p>\n<blockquote>\n<p><font color=red><strong>注意：第三步是最重要的一步！！！</strong></font></p>\n</blockquote>\n<pre><code>mkdir /home/admin/.ssh\nchmod 700 /home/admin/.ssh                       \nvi /home/admin/.ssh/authorized_keys            #创建authorized_keys文件，并将本地生成的id_rsa.pub的内容填入authorized_keys\nchmod 600 /home/admin/.ssh/authorized_keys     #设置authorized_keys权限\nchown -R admin:admin /home/admin/.ssh/         #修改用户组和用户所有权\nsystemctl stop sshd                            #暂停ssh服务\nsystemctl start sshd                           #启动ssh服务</code></pre><h2 id=\"设置SSH登录安全配置（可选步骤）\"><a href=\"#设置SSH登录安全配置（可选步骤）\" class=\"headerlink\" title=\"设置SSH登录安全配置（可选步骤）\"></a>设置SSH登录安全配置（可选步骤）</h2><blockquote>\n<p><strong>温馨提示：SSH登录安全配置建议，使用root用户操作以下命令</strong></p>\n</blockquote>\n<pre><code># 编辑SSH配置文件 \nvi /etc/ssh/sshd_config\nPermitRootLogin no                             # 禁用root账号登录，该配置可不修改，避免特殊情况下需要用到root\nPasswordAuthentication no                      # 禁用账号+密码登录\n# 保存退出后，重启ssh服务\nsystemctl stop sshd\nsystemctl start sshd</code></pre><h1 id=\"本地验证登录\"><a href=\"#本地验证登录\" class=\"headerlink\" title=\"本地验证登录\"></a>本地验证登录</h1><p>因为每次记ip很麻烦，推荐使用hosts映射ip，使用别名登录。</p>\n<h2 id=\"添加远端ip别名\"><a href=\"#添加远端ip别名\" class=\"headerlink\" title=\"添加远端ip别名\"></a>添加远端ip别名</h2><pre><code>vi /etc/hosts\nxxx.xxx.xxx.xxx   my-remote-server              # 添加远端ip及映射的别名：ip  别名</code></pre><h2 id=\"验证ssh免密登录\"><a href=\"#验证ssh免密登录\" class=\"headerlink\" title=\"验证ssh免密登录\"></a>验证ssh免密登录</h2><pre><code>ssh admin@xxx.xxx.xxx.xxx                       # ip远程登录\nssh admin@my-remote-server                      # 别名远程登录</code></pre>"},{"title":"Linux查看内存使用情况","abbrlink":1026478353,"cover":"https://cdn.tanxz.com/images/category/linux.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","_content":"\n> 有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。\n\n有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 `free`、`ps`。而另一些命令允许通过多种方式展示系统的性能统计信息，比如 `top`。在这篇文章中，我们将介绍一些命令以帮助你确定当前占用着最多内存资源的用户或者进程。\n\n下面是一些按照进程查看内存使用情况的命令：\n\n### 按照进程查看内存使用情况\n\n#### 使用 top\n\n`top` 是最好的查看内存使用情况的命令之一。为了查看哪个进程使用着最多的内存，一个简单的办法就是启动 `top`，然后按下 `shift+m`，这样便可以查看按照内存占用百分比从高到底排列的进程。当你按下了 `shift+m` ，你的 `top` 应该会得到类似于下面这样的输出结果：\n\n```\n$toptop - 09:39:34 up 5 days, 3 min,  3 users,  load average: 4.77, 4.43, 3.72Tasks: 251 total,   3 running, 247 sleeping,   1 stopped,   0 zombie%Cpu(s): 50.6 us, 35.9 sy,  0.0 ni, 13.4 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    128.9 free,   2509.3 used,   3306.2 buff/cacheMiB Swap:   2048.0 total,   2045.7 free,      2.2 used.   3053.5 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3309580 550188 168372 S   0.3   9.0   1:33.27 Web Content32469 nemo      20   0 3492840 447372 163296 S   7.3   7.3   3:55.60 firefox32542 nemo      20   0 2845732 433388 140984 S   6.0   7.1   4:11.16 Web Content  342 nemo      20   0 2848520 352288 118972 S  10.3   5.8   4:04.89 Web Content 2389 nemo      20   0 1774412 236700  90044 S  39.7   3.9   9:32.64 vlc29527 nemo      20   0 2735792 225980  84744 S   9.6   3.7   3:02.35 gnome-shell30497 nemo      30  10 1088476 159636  88884 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 140952  33128 S   0.0   2.3   0:04.58 gnome-software32533 nemo      20   0 2389088 104712  79544 S   0.0   1.7   0:01.43 WebExtensions 2256 nemo      20   0 1217884 103424  31304 T   0.0   1.7   0:00.28 vlc 1713 nemo      20   0 2374396  79588  61452 S   0.0   1.3   0:00.49 Web Content29306 nemo      20   0  389668  74376  54340 S   2.3   1.2   0:57.25 Xorg32739 nemo      20   0  289528  58900  34480 S   1.0   1.0   1:04.08 RDD Process29732 nemo      20   0  789196  57724  42428 S   0.0   0.9   0:00.38 evolution-alarm 2373 root      20   0  150408  57000   9924 S   0.3   0.9  10:15.35 nessusd\n```\n\n注意 `%MEM` 排序。列表的大小取决于你的窗口大小，但是占据着最多的内存的进程将会显示在列表的顶端。\n\n#### 使用 ps\n\n`ps` 命令中的一列用来展示每个进程的内存使用情况。为了展示和查看哪个进程使用着最多的内存，你可以将 `ps` 命令的结果传递给 `sort` 命令。下面是一个有用的示例：\n\n```\n$ ps aux | sort -rnk 4 | head -5nemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 /usr/lib/firefox/firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts/1  Sl+  09:15  12:21 vlc videos/edge_computing.mp4\n```\n\n在上面的例子中（文中已截断），`sort` 命令使用了 `-r` 选项（反转）、`-n` 选项（数字值）、`-k` 选项（关键字），使 `sort` 命令对 `ps` 命令的结果按照第四列（内存使用情况）中的数字逆序进行排列并输出。如果我们首先显示 `ps` 命令的标题，那么将会便于查看。\n\n```\n$ ps aux | head -1; ps aux | sort -rnk 4 | head -5USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 /usr/lib/firefox/firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts/1  Sl+  09:15  12:21 vlc videos/edge_computing.mp4\n```\n\n如果你喜欢这个命令，你可以用下面的命令为他指定一个别名，如果你想一直使用它，不要忘记把该命令添加到你的 `~/.bashrc` 文件中。\n\n```\n$ alias mem-by-proc=\"ps aux | head -1; ps aux | sort -rnk 4\"\n```\n\n下面是一些根据用户查看内存使用情况的命令：\n\n### 按用户查看内存使用情况\n\n#### 使用 top\n\n按照用户检查内存使用情况会更复杂一些，因为你需要找到一种方法把用户所拥有的所有进程统计为单一的内存使用量。\n\n如果你只想查看单个用户进程使用情况，`top` 命令可以采用与上文中同样的方法进行使用。只需要添加 `-U` 选项并在其后面指定你要查看的用户名，然后按下 `shift+m` 便可以按照内存使用有多到少进行查看。\n\n```\n$ top -U nemotop - 10:16:33 up 5 days, 40 min,  3 users,  load average: 1.91, 1.82, 2.15Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie%Cpu(s): 28.5 us, 36.8 sy,  0.0 ni, 34.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    224.1 free,   2752.9 used,   2967.4 buff/cacheMiB Swap:   2048.0 total,   2042.7 free,      5.2 used.   2812.0 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3315724 623748 165440 S   1.0  10.2   1:48.78 Web Content32469 nemo      20   0 3629380 607492 161688 S   2.3  10.0   6:06.89 firefox32542 nemo      20   0 2886700 404980 136648 S   5.6   6.7   6:50.01 Web Content  342 nemo      20   0 2922248 375784 116096 S  19.5   6.2   8:16.07 Web Content 2389 nemo      20   0 1762960 234644  87452 S   0.0   3.9  13:57.53 vlc29527 nemo      20   0 2736924 227260  86092 S   0.0   3.7   4:09.11 gnome-shell30497 nemo      30  10 1088476 156372  85620 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 138160  30336 S   0.0   2.3   0:04.62 gnome-software32533 nemo      20   0 2389088 102532  76808 S   0.0   1.7   0:01.79 WebExtensions\n```\n\n#### 使用 ps\n\n你依旧可以使用 `ps` 命令通过内存使用情况来排列某个用户的进程。在这个例子中，我们将使用 `grep` 命令来筛选得到某个用户的所有进程。\n\n```\n$ ps aux | head -1; ps aux | grep ^nemo| sort -rnk 4 | moreUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo     32469  7.1 11.5 3724364 701388 ?      Sl   08:54   7:21 /usr/lib/firefox/firefox -new-windownemo       400  2.0  8.9 3308556 543232 ?      Sl   08:59   2:01 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni/usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32542  7.9  7.1 2903084 436196 ?      Sl   08:55   8:07 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342 10.8  7.0 2941056 426484 ?      Rl   08:59  10:45 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 16.9  3.8 1762960 234644 pts/1  Sl+  09:15  13:57 vlc videos/edge_computing.mp4nemo     29527  3.9  3.7 2736924 227448 ?      Ssl  08:50   4:11 /usr/bin/gnome-shell\n```\n\n### 使用 ps 和其他命令的搭配\n\n如果你想比较某个用户与其他用户内存使用情况将会比较复杂。在这种情况中，创建并排序一个按照用户总的内存使用量是一个不错的方法，但是它需要做一些更多的工作，并涉及到许多命令。在下面的脚本中，我们使用 `ps aux | grep -v COMMAND | awk '{print $1}' | sort -u` 命令得到了用户列表。其中包含了系统用户比如 `syslog`。我们对每个任务使用 `awk` 命令以收集每个用户总的内存使用情况。在最后一步中，我们展示每个用户总的内存使用量（按照从大到小的顺序）。\n\n```\n#!/bin/bashstats=””echo \"%   user\"echo \"============\"# collect the datafor user in `ps aux | grep -v COMMAND | awk '{print $1}' | sort -u`do  stats=\"$stats\\n`ps aux | egrep ^$user | awk 'BEGIN{total=0}; \\    {total += $4};END{print total,$1}'`\"done# sort data numerically (largest first)echo -e $stats | grep -v ^$ | sort -rn | head\n```\n\n这个脚本的输出可能如下：\n\n```\n$ ./show_user_mem_usage%   user============69.6 nemo5.8 root0.5 www-data0.3 shs0.2 whoopsie0.2 systemd+0.2 colord0.2 clamav0 syslog0 rtkit\n```\n\n在 Linux 有许多方法可以报告内存使用情况。可以通过一些用心设计的工具和命令，来查看并获得某个进程或者用户占用着最多的内存。","source":"_posts/技术分享/linux/Linux查看内存使用量.md","raw":"---\ntitle: Linux查看内存使用情况\nabbrlink: 1026478353\ntags:\n\t- Linux\ncover: https://cdn.tanxz.com/images/category/linux.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\n---\n\n> 有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。\n\n有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 `free`、`ps`。而另一些命令允许通过多种方式展示系统的性能统计信息，比如 `top`。在这篇文章中，我们将介绍一些命令以帮助你确定当前占用着最多内存资源的用户或者进程。\n\n下面是一些按照进程查看内存使用情况的命令：\n\n### 按照进程查看内存使用情况\n\n#### 使用 top\n\n`top` 是最好的查看内存使用情况的命令之一。为了查看哪个进程使用着最多的内存，一个简单的办法就是启动 `top`，然后按下 `shift+m`，这样便可以查看按照内存占用百分比从高到底排列的进程。当你按下了 `shift+m` ，你的 `top` 应该会得到类似于下面这样的输出结果：\n\n```\n$toptop - 09:39:34 up 5 days, 3 min,  3 users,  load average: 4.77, 4.43, 3.72Tasks: 251 total,   3 running, 247 sleeping,   1 stopped,   0 zombie%Cpu(s): 50.6 us, 35.9 sy,  0.0 ni, 13.4 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    128.9 free,   2509.3 used,   3306.2 buff/cacheMiB Swap:   2048.0 total,   2045.7 free,      2.2 used.   3053.5 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3309580 550188 168372 S   0.3   9.0   1:33.27 Web Content32469 nemo      20   0 3492840 447372 163296 S   7.3   7.3   3:55.60 firefox32542 nemo      20   0 2845732 433388 140984 S   6.0   7.1   4:11.16 Web Content  342 nemo      20   0 2848520 352288 118972 S  10.3   5.8   4:04.89 Web Content 2389 nemo      20   0 1774412 236700  90044 S  39.7   3.9   9:32.64 vlc29527 nemo      20   0 2735792 225980  84744 S   9.6   3.7   3:02.35 gnome-shell30497 nemo      30  10 1088476 159636  88884 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 140952  33128 S   0.0   2.3   0:04.58 gnome-software32533 nemo      20   0 2389088 104712  79544 S   0.0   1.7   0:01.43 WebExtensions 2256 nemo      20   0 1217884 103424  31304 T   0.0   1.7   0:00.28 vlc 1713 nemo      20   0 2374396  79588  61452 S   0.0   1.3   0:00.49 Web Content29306 nemo      20   0  389668  74376  54340 S   2.3   1.2   0:57.25 Xorg32739 nemo      20   0  289528  58900  34480 S   1.0   1.0   1:04.08 RDD Process29732 nemo      20   0  789196  57724  42428 S   0.0   0.9   0:00.38 evolution-alarm 2373 root      20   0  150408  57000   9924 S   0.3   0.9  10:15.35 nessusd\n```\n\n注意 `%MEM` 排序。列表的大小取决于你的窗口大小，但是占据着最多的内存的进程将会显示在列表的顶端。\n\n#### 使用 ps\n\n`ps` 命令中的一列用来展示每个进程的内存使用情况。为了展示和查看哪个进程使用着最多的内存，你可以将 `ps` 命令的结果传递给 `sort` 命令。下面是一个有用的示例：\n\n```\n$ ps aux | sort -rnk 4 | head -5nemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 /usr/lib/firefox/firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts/1  Sl+  09:15  12:21 vlc videos/edge_computing.mp4\n```\n\n在上面的例子中（文中已截断），`sort` 命令使用了 `-r` 选项（反转）、`-n` 选项（数字值）、`-k` 选项（关键字），使 `sort` 命令对 `ps` 命令的结果按照第四列（内存使用情况）中的数字逆序进行排列并输出。如果我们首先显示 `ps` 命令的标题，那么将会便于查看。\n\n```\n$ ps aux | head -1; ps aux | sort -rnk 4 | head -5USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 /usr/lib/firefox/firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts/1  Sl+  09:15  12:21 vlc videos/edge_computing.mp4\n```\n\n如果你喜欢这个命令，你可以用下面的命令为他指定一个别名，如果你想一直使用它，不要忘记把该命令添加到你的 `~/.bashrc` 文件中。\n\n```\n$ alias mem-by-proc=\"ps aux | head -1; ps aux | sort -rnk 4\"\n```\n\n下面是一些根据用户查看内存使用情况的命令：\n\n### 按用户查看内存使用情况\n\n#### 使用 top\n\n按照用户检查内存使用情况会更复杂一些，因为你需要找到一种方法把用户所拥有的所有进程统计为单一的内存使用量。\n\n如果你只想查看单个用户进程使用情况，`top` 命令可以采用与上文中同样的方法进行使用。只需要添加 `-U` 选项并在其后面指定你要查看的用户名，然后按下 `shift+m` 便可以按照内存使用有多到少进行查看。\n\n```\n$ top -U nemotop - 10:16:33 up 5 days, 40 min,  3 users,  load average: 1.91, 1.82, 2.15Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie%Cpu(s): 28.5 us, 36.8 sy,  0.0 ni, 34.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    224.1 free,   2752.9 used,   2967.4 buff/cacheMiB Swap:   2048.0 total,   2042.7 free,      5.2 used.   2812.0 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3315724 623748 165440 S   1.0  10.2   1:48.78 Web Content32469 nemo      20   0 3629380 607492 161688 S   2.3  10.0   6:06.89 firefox32542 nemo      20   0 2886700 404980 136648 S   5.6   6.7   6:50.01 Web Content  342 nemo      20   0 2922248 375784 116096 S  19.5   6.2   8:16.07 Web Content 2389 nemo      20   0 1762960 234644  87452 S   0.0   3.9  13:57.53 vlc29527 nemo      20   0 2736924 227260  86092 S   0.0   3.7   4:09.11 gnome-shell30497 nemo      30  10 1088476 156372  85620 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 138160  30336 S   0.0   2.3   0:04.62 gnome-software32533 nemo      20   0 2389088 102532  76808 S   0.0   1.7   0:01.79 WebExtensions\n```\n\n#### 使用 ps\n\n你依旧可以使用 `ps` 命令通过内存使用情况来排列某个用户的进程。在这个例子中，我们将使用 `grep` 命令来筛选得到某个用户的所有进程。\n\n```\n$ ps aux | head -1; ps aux | grep ^nemo| sort -rnk 4 | moreUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo     32469  7.1 11.5 3724364 701388 ?      Sl   08:54   7:21 /usr/lib/firefox/firefox -new-windownemo       400  2.0  8.9 3308556 543232 ?      Sl   08:59   2:01 /usr/lib/firefox/firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni/usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo     32542  7.9  7.1 2903084 436196 ?      Sl   08:55   8:07 /usr/lib/firefox/firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo       342 10.8  7.0 2941056 426484 ?      Rl   08:59  10:45 /usr/lib/firefox/firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni /usr/lib/firefox/omni.ja -appomni /usr/lib/firefox/browser/omni.ja -appdir /usr/lib/firefox/browser 32469 true tabnemo      2389 16.9  3.8 1762960 234644 pts/1  Sl+  09:15  13:57 vlc videos/edge_computing.mp4nemo     29527  3.9  3.7 2736924 227448 ?      Ssl  08:50   4:11 /usr/bin/gnome-shell\n```\n\n### 使用 ps 和其他命令的搭配\n\n如果你想比较某个用户与其他用户内存使用情况将会比较复杂。在这种情况中，创建并排序一个按照用户总的内存使用量是一个不错的方法，但是它需要做一些更多的工作，并涉及到许多命令。在下面的脚本中，我们使用 `ps aux | grep -v COMMAND | awk '{print $1}' | sort -u` 命令得到了用户列表。其中包含了系统用户比如 `syslog`。我们对每个任务使用 `awk` 命令以收集每个用户总的内存使用情况。在最后一步中，我们展示每个用户总的内存使用量（按照从大到小的顺序）。\n\n```\n#!/bin/bashstats=””echo \"%   user\"echo \"============\"# collect the datafor user in `ps aux | grep -v COMMAND | awk '{print $1}' | sort -u`do  stats=\"$stats\\n`ps aux | egrep ^$user | awk 'BEGIN{total=0}; \\    {total += $4};END{print total,$1}'`\"done# sort data numerically (largest first)echo -e $stats | grep -v ^$ | sort -rn | head\n```\n\n这个脚本的输出可能如下：\n\n```\n$ ./show_user_mem_usage%   user============69.6 nemo5.8 root0.5 www-data0.3 shs0.2 whoopsie0.2 systemd+0.2 colord0.2 clamav0 syslog0 rtkit\n```\n\n在 Linux 有许多方法可以报告内存使用情况。可以通过一些用心设计的工具和命令，来查看并获得某个进程或者用户占用着最多的内存。","slug":"技术分享/linux/Linux查看内存使用量","published":1,"date":"2020-12-21T15:10:33.085Z","updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6h2000itvcdc409cjic","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。</p>\n</blockquote>\n<p>有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 <code>free</code>、<code>ps</code>。而另一些命令允许通过多种方式展示系统的性能统计信息，比如 <code>top</code>。在这篇文章中，我们将介绍一些命令以帮助你确定当前占用着最多内存资源的用户或者进程。</p>\n<p>下面是一些按照进程查看内存使用情况的命令：</p>\n<h3 id=\"按照进程查看内存使用情况\"><a href=\"#按照进程查看内存使用情况\" class=\"headerlink\" title=\"按照进程查看内存使用情况\"></a>按照进程查看内存使用情况</h3><h4 id=\"使用-top\"><a href=\"#使用-top\" class=\"headerlink\" title=\"使用 top\"></a>使用 top</h4><p><code>top</code> 是最好的查看内存使用情况的命令之一。为了查看哪个进程使用着最多的内存，一个简单的办法就是启动 <code>top</code>，然后按下 <code>shift+m</code>，这样便可以查看按照内存占用百分比从高到底排列的进程。当你按下了 <code>shift+m</code> ，你的 <code>top</code> 应该会得到类似于下面这样的输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$toptop - 09:39:34 up 5 days, 3 min,  3 users,  load average: 4.77, 4.43, 3.72Tasks: 251 total,   3 running, 247 sleeping,   1 stopped,   0 zombie%Cpu(s): 50.6 us, 35.9 sy,  0.0 ni, 13.4 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    128.9 free,   2509.3 used,   3306.2 buff&#x2F;cacheMiB Swap:   2048.0 total,   2045.7 free,      2.2 used.   3053.5 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3309580 550188 168372 S   0.3   9.0   1:33.27 Web Content32469 nemo      20   0 3492840 447372 163296 S   7.3   7.3   3:55.60 firefox32542 nemo      20   0 2845732 433388 140984 S   6.0   7.1   4:11.16 Web Content  342 nemo      20   0 2848520 352288 118972 S  10.3   5.8   4:04.89 Web Content 2389 nemo      20   0 1774412 236700  90044 S  39.7   3.9   9:32.64 vlc29527 nemo      20   0 2735792 225980  84744 S   9.6   3.7   3:02.35 gnome-shell30497 nemo      30  10 1088476 159636  88884 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 140952  33128 S   0.0   2.3   0:04.58 gnome-software32533 nemo      20   0 2389088 104712  79544 S   0.0   1.7   0:01.43 WebExtensions 2256 nemo      20   0 1217884 103424  31304 T   0.0   1.7   0:00.28 vlc 1713 nemo      20   0 2374396  79588  61452 S   0.0   1.3   0:00.49 Web Content29306 nemo      20   0  389668  74376  54340 S   2.3   1.2   0:57.25 Xorg32739 nemo      20   0  289528  58900  34480 S   1.0   1.0   1:04.08 RDD Process29732 nemo      20   0  789196  57724  42428 S   0.0   0.9   0:00.38 evolution-alarm 2373 root      20   0  150408  57000   9924 S   0.3   0.9  10:15.35 nessusd<br></code></pre></td></tr></table></figure>\n<p>注意 <code>%MEM</code> 排序。列表的大小取决于你的窗口大小，但是占据着最多的内存的进程将会显示在列表的顶端。</p>\n<h4 id=\"使用-ps\"><a href=\"#使用-ps\" class=\"headerlink\" title=\"使用 ps\"></a>使用 ps</h4><p><code>ps</code> 命令中的一列用来展示每个进程的内存使用情况。为了展示和查看哪个进程使用着最多的内存，你可以将 <code>ps</code> 命令的结果传递给 <code>sort</code> 命令。下面是一个有用的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ ps aux | sort -rnk 4 | head -5nemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4<br></code></pre></td></tr></table></figure>\n<p>在上面的例子中（文中已截断），<code>sort</code> 命令使用了 <code>-r</code> 选项（反转）、<code>-n</code> 选项（数字值）、<code>-k</code> 选项（关键字），使 <code>sort</code> 命令对 <code>ps</code> 命令的结果按照第四列（内存使用情况）中的数字逆序进行排列并输出。如果我们首先显示 <code>ps</code> 命令的标题，那么将会便于查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ ps aux | head -1; ps aux | sort -rnk 4 | head -5USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4<br></code></pre></td></tr></table></figure>\n<p>如果你喜欢这个命令，你可以用下面的命令为他指定一个别名，如果你想一直使用它，不要忘记把该命令添加到你的 <code>~/.bashrc</code> 文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ alias mem-by-proc&#x3D;&quot;ps aux | head -1; ps aux | sort -rnk 4&quot;<br></code></pre></td></tr></table></figure>\n<p>下面是一些根据用户查看内存使用情况的命令：</p>\n<h3 id=\"按用户查看内存使用情况\"><a href=\"#按用户查看内存使用情况\" class=\"headerlink\" title=\"按用户查看内存使用情况\"></a>按用户查看内存使用情况</h3><h4 id=\"使用-top-1\"><a href=\"#使用-top-1\" class=\"headerlink\" title=\"使用 top\"></a>使用 top</h4><p>按照用户检查内存使用情况会更复杂一些，因为你需要找到一种方法把用户所拥有的所有进程统计为单一的内存使用量。</p>\n<p>如果你只想查看单个用户进程使用情况，<code>top</code> 命令可以采用与上文中同样的方法进行使用。只需要添加 <code>-U</code> 选项并在其后面指定你要查看的用户名，然后按下 <code>shift+m</code> 便可以按照内存使用有多到少进行查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ top -U nemotop - 10:16:33 up 5 days, 40 min,  3 users,  load average: 1.91, 1.82, 2.15Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie%Cpu(s): 28.5 us, 36.8 sy,  0.0 ni, 34.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    224.1 free,   2752.9 used,   2967.4 buff&#x2F;cacheMiB Swap:   2048.0 total,   2042.7 free,      5.2 used.   2812.0 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3315724 623748 165440 S   1.0  10.2   1:48.78 Web Content32469 nemo      20   0 3629380 607492 161688 S   2.3  10.0   6:06.89 firefox32542 nemo      20   0 2886700 404980 136648 S   5.6   6.7   6:50.01 Web Content  342 nemo      20   0 2922248 375784 116096 S  19.5   6.2   8:16.07 Web Content 2389 nemo      20   0 1762960 234644  87452 S   0.0   3.9  13:57.53 vlc29527 nemo      20   0 2736924 227260  86092 S   0.0   3.7   4:09.11 gnome-shell30497 nemo      30  10 1088476 156372  85620 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 138160  30336 S   0.0   2.3   0:04.62 gnome-software32533 nemo      20   0 2389088 102532  76808 S   0.0   1.7   0:01.79 WebExtensions<br></code></pre></td></tr></table></figure>\n<h4 id=\"使用-ps-1\"><a href=\"#使用-ps-1\" class=\"headerlink\" title=\"使用 ps\"></a>使用 ps</h4><p>你依旧可以使用 <code>ps</code> 命令通过内存使用情况来排列某个用户的进程。在这个例子中，我们将使用 <code>grep</code> 命令来筛选得到某个用户的所有进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ ps aux | head -1; ps aux | grep ^nemo| sort -rnk 4 | moreUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo     32469  7.1 11.5 3724364 701388 ?      Sl   08:54   7:21 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo       400  2.0  8.9 3308556 543232 ?      Sl   08:59   2:01 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni&#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32542  7.9  7.1 2903084 436196 ?      Sl   08:55   8:07 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342 10.8  7.0 2941056 426484 ?      Rl   08:59  10:45 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 16.9  3.8 1762960 234644 pts&#x2F;1  Sl+  09:15  13:57 vlc videos&#x2F;edge_computing.mp4nemo     29527  3.9  3.7 2736924 227448 ?      Ssl  08:50   4:11 &#x2F;usr&#x2F;bin&#x2F;gnome-shell<br></code></pre></td></tr></table></figure>\n<h3 id=\"使用-ps-和其他命令的搭配\"><a href=\"#使用-ps-和其他命令的搭配\" class=\"headerlink\" title=\"使用 ps 和其他命令的搭配\"></a>使用 ps 和其他命令的搭配</h3><p>如果你想比较某个用户与其他用户内存使用情况将会比较复杂。在这种情况中，创建并排序一个按照用户总的内存使用量是一个不错的方法，但是它需要做一些更多的工作，并涉及到许多命令。在下面的脚本中，我们使用 <code>ps aux | grep -v COMMAND | awk &#39;&#123;print $1&#125;&#39; | sort -u</code> 命令得到了用户列表。其中包含了系统用户比如 <code>syslog</code>。我们对每个任务使用 <code>awk</code> 命令以收集每个用户总的内存使用情况。在最后一步中，我们展示每个用户总的内存使用量（按照从大到小的顺序）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">#!&#x2F;bin&#x2F;bashstats&#x3D;””echo &quot;%   user&quot;echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;# collect the datafor user in &#96;ps aux | grep -v COMMAND | awk &#39;&#123;print $1&#125;&#39; | sort -u&#96;do  stats&#x3D;&quot;$stats\\n&#96;ps aux | egrep ^$user | awk &#39;BEGIN&#123;total&#x3D;0&#125;; \\    &#123;total +&#x3D; $4&#125;;END&#123;print total,$1&#125;&#39;&#96;&quot;done# sort data numerically (largest first)echo -e $stats | grep -v ^$ | sort -rn | head<br></code></pre></td></tr></table></figure>\n<p>这个脚本的输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ .&#x2F;show_user_mem_usage%   user&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;69.6 nemo5.8 root0.5 www-data0.3 shs0.2 whoopsie0.2 systemd+0.2 colord0.2 clamav0 syslog0 rtkit<br></code></pre></td></tr></table></figure>\n<p>在 Linux 有许多方法可以报告内存使用情况。可以通过一些用心设计的工具和命令，来查看并获得某个进程或者用户占用着最多的内存。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<blockquote>\n<p>有一些命令可以用来检查 Linux 系统中的内存使用情况，下面是一些更好的命令。</p>\n</blockquote>\n<p>有许多工具可以查看 Linux 系统中的内存使用情况。一些命令被广泛使用，比如 <code>free</code>、<code>ps</code>。而另一些命令允许通过多种方式展示系统的性能统计信息，比如 <code>top</code>。在这篇文章中，我们将介绍一些命令以帮助你确定当前占用着最多内存资源的用户或者进程。</p>\n<p>下面是一些按照进程查看内存使用情况的命令：</p>\n<h3 id=\"按照进程查看内存使用情况\"><a href=\"#按照进程查看内存使用情况\" class=\"headerlink\" title=\"按照进程查看内存使用情况\"></a>按照进程查看内存使用情况</h3><h4 id=\"使用-top\"><a href=\"#使用-top\" class=\"headerlink\" title=\"使用 top\"></a>使用 top</h4><p><code>top</code> 是最好的查看内存使用情况的命令之一。为了查看哪个进程使用着最多的内存，一个简单的办法就是启动 <code>top</code>，然后按下 <code>shift+m</code>，这样便可以查看按照内存占用百分比从高到底排列的进程。当你按下了 <code>shift+m</code> ，你的 <code>top</code> 应该会得到类似于下面这样的输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$toptop - 09:39:34 up 5 days, 3 min,  3 users,  load average: 4.77, 4.43, 3.72Tasks: 251 total,   3 running, 247 sleeping,   1 stopped,   0 zombie%Cpu(s): 50.6 us, 35.9 sy,  0.0 ni, 13.4 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    128.9 free,   2509.3 used,   3306.2 buff&#x2F;cacheMiB Swap:   2048.0 total,   2045.7 free,      2.2 used.   3053.5 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3309580 550188 168372 S   0.3   9.0   1:33.27 Web Content32469 nemo      20   0 3492840 447372 163296 S   7.3   7.3   3:55.60 firefox32542 nemo      20   0 2845732 433388 140984 S   6.0   7.1   4:11.16 Web Content  342 nemo      20   0 2848520 352288 118972 S  10.3   5.8   4:04.89 Web Content 2389 nemo      20   0 1774412 236700  90044 S  39.7   3.9   9:32.64 vlc29527 nemo      20   0 2735792 225980  84744 S   9.6   3.7   3:02.35 gnome-shell30497 nemo      30  10 1088476 159636  88884 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 140952  33128 S   0.0   2.3   0:04.58 gnome-software32533 nemo      20   0 2389088 104712  79544 S   0.0   1.7   0:01.43 WebExtensions 2256 nemo      20   0 1217884 103424  31304 T   0.0   1.7   0:00.28 vlc 1713 nemo      20   0 2374396  79588  61452 S   0.0   1.3   0:00.49 Web Content29306 nemo      20   0  389668  74376  54340 S   2.3   1.2   0:57.25 Xorg32739 nemo      20   0  289528  58900  34480 S   1.0   1.0   1:04.08 RDD Process29732 nemo      20   0  789196  57724  42428 S   0.0   0.9   0:00.38 evolution-alarm 2373 root      20   0  150408  57000   9924 S   0.3   0.9  10:15.35 nessusd<br></code></pre></td></tr></table></figure>\n<p>注意 <code>%MEM</code> 排序。列表的大小取决于你的窗口大小，但是占据着最多的内存的进程将会显示在列表的顶端。</p>\n<h4 id=\"使用-ps\"><a href=\"#使用-ps\" class=\"headerlink\" title=\"使用 ps\"></a>使用 ps</h4><p><code>ps</code> 命令中的一列用来展示每个进程的内存使用情况。为了展示和查看哪个进程使用着最多的内存，你可以将 <code>ps</code> 命令的结果传递给 <code>sort</code> 命令。下面是一个有用的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ ps aux | sort -rnk 4 | head -5nemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4<br></code></pre></td></tr></table></figure>\n<p>在上面的例子中（文中已截断），<code>sort</code> 命令使用了 <code>-r</code> 选项（反转）、<code>-n</code> 选项（数字值）、<code>-k</code> 选项（关键字），使 <code>sort</code> 命令对 <code>ps</code> 命令的结果按照第四列（内存使用情况）中的数字逆序进行排列并输出。如果我们首先显示 <code>ps</code> 命令的标题，那么将会便于查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ ps aux | head -1; ps aux | sort -rnk 4 | head -5USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo       400  3.4  9.2 3309580 563336 ?      Sl   08:59   1:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32469  8.2  7.7 3492840 469516 ?      Sl   08:54   4:15 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo     32542  8.9  7.6 2875428 462720 ?      Sl   08:55   4:36 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342  9.9  5.9 2854664 363528 ?      Sl   08:59   4:44 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 39.5  3.8 1774412 236116 pts&#x2F;1  Sl+  09:15  12:21 vlc videos&#x2F;edge_computing.mp4<br></code></pre></td></tr></table></figure>\n<p>如果你喜欢这个命令，你可以用下面的命令为他指定一个别名，如果你想一直使用它，不要忘记把该命令添加到你的 <code>~/.bashrc</code> 文件中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ alias mem-by-proc&#x3D;&quot;ps aux | head -1; ps aux | sort -rnk 4&quot;<br></code></pre></td></tr></table></figure>\n<p>下面是一些根据用户查看内存使用情况的命令：</p>\n<h3 id=\"按用户查看内存使用情况\"><a href=\"#按用户查看内存使用情况\" class=\"headerlink\" title=\"按用户查看内存使用情况\"></a>按用户查看内存使用情况</h3><h4 id=\"使用-top-1\"><a href=\"#使用-top-1\" class=\"headerlink\" title=\"使用 top\"></a>使用 top</h4><p>按照用户检查内存使用情况会更复杂一些，因为你需要找到一种方法把用户所拥有的所有进程统计为单一的内存使用量。</p>\n<p>如果你只想查看单个用户进程使用情况，<code>top</code> 命令可以采用与上文中同样的方法进行使用。只需要添加 <code>-U</code> 选项并在其后面指定你要查看的用户名，然后按下 <code>shift+m</code> 便可以按照内存使用有多到少进行查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ top -U nemotop - 10:16:33 up 5 days, 40 min,  3 users,  load average: 1.91, 1.82, 2.15Tasks: 253 total,   2 running, 250 sleeping,   1 stopped,   0 zombie%Cpu(s): 28.5 us, 36.8 sy,  0.0 ni, 34.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stMiB Mem :   5944.4 total,    224.1 free,   2752.9 used,   2967.4 buff&#x2F;cacheMiB Swap:   2048.0 total,   2042.7 free,      5.2 used.   2812.0 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND  400 nemo      20   0 3315724 623748 165440 S   1.0  10.2   1:48.78 Web Content32469 nemo      20   0 3629380 607492 161688 S   2.3  10.0   6:06.89 firefox32542 nemo      20   0 2886700 404980 136648 S   5.6   6.7   6:50.01 Web Content  342 nemo      20   0 2922248 375784 116096 S  19.5   6.2   8:16.07 Web Content 2389 nemo      20   0 1762960 234644  87452 S   0.0   3.9  13:57.53 vlc29527 nemo      20   0 2736924 227260  86092 S   0.0   3.7   4:09.11 gnome-shell30497 nemo      30  10 1088476 156372  85620 S   0.0   2.6   0:11.99 update-manager30058 nemo      20   0 1089464 138160  30336 S   0.0   2.3   0:04.62 gnome-software32533 nemo      20   0 2389088 102532  76808 S   0.0   1.7   0:01.79 WebExtensions<br></code></pre></td></tr></table></figure>\n<h4 id=\"使用-ps-1\"><a href=\"#使用-ps-1\" class=\"headerlink\" title=\"使用 ps\"></a>使用 ps</h4><p>你依旧可以使用 <code>ps</code> 命令通过内存使用情况来排列某个用户的进程。在这个例子中，我们将使用 <code>grep</code> 命令来筛选得到某个用户的所有进程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ ps aux | head -1; ps aux | grep ^nemo| sort -rnk 4 | moreUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDnemo     32469  7.1 11.5 3724364 701388 ?      Sl   08:54   7:21 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -new-windownemo       400  2.0  8.9 3308556 543232 ?      Sl   08:59   2:01 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 6 -isForBrowser -prefsLen 9086 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni&#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo     32542  7.9  7.1 2903084 436196 ?      Sl   08:55   8:07 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 2 -isForBrowser -prefsLen 1 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo       342 10.8  7.0 2941056 426484 ?      Rl   08:59  10:45 &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;firefox -contentproc -childID 5 -isForBrowser -prefsLen 8763 -prefMapSize 210653 -parentBuildID 20200107212822 -greomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;omni.ja -appomni &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser&#x2F;omni.ja -appdir &#x2F;usr&#x2F;lib&#x2F;firefox&#x2F;browser 32469 true tabnemo      2389 16.9  3.8 1762960 234644 pts&#x2F;1  Sl+  09:15  13:57 vlc videos&#x2F;edge_computing.mp4nemo     29527  3.9  3.7 2736924 227448 ?      Ssl  08:50   4:11 &#x2F;usr&#x2F;bin&#x2F;gnome-shell<br></code></pre></td></tr></table></figure>\n<h3 id=\"使用-ps-和其他命令的搭配\"><a href=\"#使用-ps-和其他命令的搭配\" class=\"headerlink\" title=\"使用 ps 和其他命令的搭配\"></a>使用 ps 和其他命令的搭配</h3><p>如果你想比较某个用户与其他用户内存使用情况将会比较复杂。在这种情况中，创建并排序一个按照用户总的内存使用量是一个不错的方法，但是它需要做一些更多的工作，并涉及到许多命令。在下面的脚本中，我们使用 <code>ps aux | grep -v COMMAND | awk &#39;&#123;print $1&#125;&#39; | sort -u</code> 命令得到了用户列表。其中包含了系统用户比如 <code>syslog</code>。我们对每个任务使用 <code>awk</code> 命令以收集每个用户总的内存使用情况。在最后一步中，我们展示每个用户总的内存使用量（按照从大到小的顺序）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">#!&#x2F;bin&#x2F;bashstats&#x3D;””echo &quot;%   user&quot;echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;# collect the datafor user in &#96;ps aux | grep -v COMMAND | awk &#39;&#123;print $1&#125;&#39; | sort -u&#96;do  stats&#x3D;&quot;$stats\\n&#96;ps aux | egrep ^$user | awk &#39;BEGIN&#123;total&#x3D;0&#125;; \\    &#123;total +&#x3D; $4&#125;;END&#123;print total,$1&#125;&#39;&#96;&quot;done# sort data numerically (largest first)echo -e $stats | grep -v ^$ | sort -rn | head<br></code></pre></td></tr></table></figure>\n<p>这个脚本的输出可能如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ .&#x2F;show_user_mem_usage%   user&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;69.6 nemo5.8 root0.5 www-data0.3 shs0.2 whoopsie0.2 systemd+0.2 colord0.2 clamav0 syslog0 rtkit<br></code></pre></td></tr></table></figure>\n<p>在 Linux 有许多方法可以报告内存使用情况。可以通过一些用心设计的工具和命令，来查看并获得某个进程或者用户占用着最多的内存。</p>\n"},{"title":"linux与k8s的区别","abbrlink":2578104314,"date":"2017-08-18T09:59:25.000Z","cover":"https://cdn.tanxz.com/images/category/linux.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","_content":"\n# [10分钟看懂Docker和K8S](https://www.cnblogs.com/itbsl/p/10178698.html)\n\n**本文来源：鲜枣课堂**\n\n2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。\n\n![img](../../img/720430-20181226134250810-1685533200.png)\n\n这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。\n\n![img](../../img/720430-20181226134259735-1931086473.png)\n\nLXC，就是Linux容器虚拟技术（Linux container）\n\n后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。\n\n![img](../../img/720430-20181226134308841-1109691453.png)\n\nDocker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。\n\n正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。\n\n什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。\n\n![img](../../img/720430-20181226134321094-1025894099.png)\n\nOpen Source，开源\n\n有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。\n\n2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134409452-99479785.png)\n\nSolomon Hykes（今年刚从Docker离职）\n\n不开则已，一开惊人。\n\n越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。\n\nDocker的人气迅速攀升，速度之快，令人瞠目结舌。\n\n开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。\n\n此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。\n\nDocker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。\n\nDocker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。\n\n在容器技术之前，业界的网红是虚拟机。**虚拟机**技术的代表，是**VMWare**和**OpenStack**。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134345971-148194642.png)\n\n相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134357583-1178315643.png)\n\n虚拟机，类似于“子电脑”\n\n在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是**相互隔离**的，互不影响。\n\n虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于**轻量级的虚拟化**。\n\n虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。\n\n而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134422660-219996811.png)\n\n沙箱\n\n它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134430830-648875754.png)\n\n容器和虚拟机的对比\n\n正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。\n\n我们具体来看看Docker。\n\n大家需要注意，**Docker本身并不是容器**，它是创建容器的工具，是应用容器引擎。\n\n想要搞懂Docker，其实看它的两句口号就行。\n\n第一句，是“**Build, Ship and Run**”。\n\n![img](linux%E4%B8%8Ek8s%E7%9A%84%E5%8C%BA%E5%88%AB.assets/720430-20181226134440039-355719052.png)\n\n也就是，“搭建、发送、运行”，三板斧。\n\n举个例子：\n\n我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134448189-1614413776.png)\n\n结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。\n\n但是，跑来一个老巫婆，教会我一种魔法。\n\n这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134458048-1632935313.png)\n\n等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134507695-502496013.png)\n\n怎么样？是不是很神奇？\n\n所以，Docker的第二句口号就是：“**Build once，Run anywhere（搭建一次，到处能用）**”。\n\nDocker技术的三大核心概念，分别是：\n\n- **镜像（Image）**\n- **容器（Container）**\n- **仓库（Repository）**\n\n我刚才例子里面，那个放在包里的“镜像”，就是**Docker镜像**。而我的背包，就是**Docker仓库**。我在空地上，用魔法造好的房子，就是一个**Docker容器**。\n\n说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。\n\n每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！\n\n也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。\n\n这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134517561-1517184540.png)\n\n于是乎，就变成了一个大的公共仓库。\n\n负责对Docker镜像进行管理的，是**Docker Registry服务**（类似仓库管理员）。\n\n不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？\n\n所以，Docker Registry服务对镜像的管理是非常严格的。\n\n最常使用的Registry公开服务，是官方的**Docker Hub**，这也是默认的Registry，并拥有大量的高质量的官方镜像。\n\n好了，说完了Docker，我们再把目光转向K8S。\n\n就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。\n\n就在这个时候，K8S出现了。\n\n**K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134529220-885595947.png)\n\nKubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。\n\n和Docker不同，K8S的创造者，是众人皆知的行业巨头——**Google**。\n\n然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的**Borg系统**。\n\nK8S是2014年6月由Google公司正式公布出来并宣布开源的。\n\n同年7月，微软、Red Hat、IBM、Docker、CoreOS、Mesosphere和Saltstack等公司，相继加入K8S。\n\n之后的一年内，VMware、HP、Intel等公司，也陆续加入。\n\n2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。\n\n目前，kubernetes的版本已经发展到V1.13。\n\nK8S的架构，略微有一点复杂，我们简单来看一下。\n\n一个K8S系统，通常称为一个**K8S集群（Cluster）**。\n\n这个集群主要包括两个部分：\n\n- **一个Master节点（主节点）**\n- **一群Node节点（计算节点）**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134539670-1577644922.png)\n\n一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。\n\n深入来看这两种节点。\n\n首先是**Master节点。**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134549651-376208258.png)\n\nMaster节点包括API Server、Scheduler、Controller manager、etcd。\n\nAPI Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。\n\nScheduler负责对集群内部的资源进行调度，相当于“调度室”。\n\nController manager负责管理控制器，相当于“大总管”。\n\n然后是**Node节点**。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134600202-626807958.png)\n\nNode节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是**Pod**。\n\n> Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。\n\nDocker，不用说了，创建容器的。\n\nKubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。\n\nKube-proxy，主要负责为Pod对象提供代理。\n\nFluentd，主要负责日志收集、存储与查询。\n\n是不是有点懵？唉，三言两语真的很难讲清楚，继续跳过吧。\n\nDocker和K8S都介绍完了，然而文章并没有结束。\n\n接下来的部分，是**写给核心网工程师甚至所有通信工程师看的**。\n\n从几十年前的1G，到现在的4G，再到将来的5G，移动通信发生了翻天覆地的变化，核心网亦是如此。\n\n但是，如果你仔细洞察这些变化，会发现，所谓的核心网，其实本质上并没有发生改变，无非就是很多的服务器而已。不同的核心网网元，就是不同的服务器，不同的计算节点。\n\n变化的，是这些“服务器”的形态和接口：形态，从机柜单板，变成机柜刀片，从机柜刀片，变成X86通用刀片服务器；接口，从中继线缆，变成网线，从网线，变成光纤。\n\n就算变来变去，还是服务器，是计算节点，是CPU。\n\n既然是服务器，那么就势必会和IT云计算一样，走上虚拟化的道路。毕竟，虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度，等等。\n\n前几年，大家以为虚拟机是核心网的终极形态。目前看来，更有可能是**容器化**。这几年经常说的NFV（网元功能虚拟化），也有可能改口为NFC（网元功能容器化）。\n\n以VoLTE为例，如果按以前2G/3G的方式，那需要大量的专用设备，分别充当EPC和IMS的不同网元。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134611008-1358657705.png)\n\nVoLTE相关的网元\n\n而采用容器之后，很可能只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同网元的服务程序。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134621637-1646543877.png)\n\n这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。\n\n简直完美！\n\n5G时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成N个专能型。每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134635090-835720705.png)\n\n精细化分工\n\n按照这样的发展趋势，在移动通信系统中，除了天线，剩下的部分都有可能虚拟化。核心网是第一个，但不是最后一个。虚拟化之后的核心网，与其说属于通信，实际上更应该归为IT。核心网的功能，只是容器中普通一个软件功能而已。\n\n至于说在座的各位核心网工程师，恭喜你们，马上就要成功转型啦！","source":"_posts/技术分享/linux/linux与k8s的区别.md","raw":"---\ntitle: linux与k8s的区别\nabbrlink: 2578104314\ndate: 2017-08-18 17:59:25\ncover: https://cdn.tanxz.com/images/category/linux.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ntags: \n  - Docker\n---\n\n# [10分钟看懂Docker和K8S](https://www.cnblogs.com/itbsl/p/10178698.html)\n\n**本文来源：鲜枣课堂**\n\n2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。\n\n![img](../../img/720430-20181226134250810-1685533200.png)\n\n这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。\n\n![img](../../img/720430-20181226134259735-1931086473.png)\n\nLXC，就是Linux容器虚拟技术（Linux container）\n\n后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。\n\n![img](../../img/720430-20181226134308841-1109691453.png)\n\nDocker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。\n\n正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。\n\n什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。\n\n![img](../../img/720430-20181226134321094-1025894099.png)\n\nOpen Source，开源\n\n有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。\n\n2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134409452-99479785.png)\n\nSolomon Hykes（今年刚从Docker离职）\n\n不开则已，一开惊人。\n\n越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。\n\nDocker的人气迅速攀升，速度之快，令人瞠目结舌。\n\n开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。\n\n此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。\n\nDocker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。\n\nDocker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。\n\n在容器技术之前，业界的网红是虚拟机。**虚拟机**技术的代表，是**VMWare**和**OpenStack**。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134345971-148194642.png)\n\n相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134357583-1178315643.png)\n\n虚拟机，类似于“子电脑”\n\n在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是**相互隔离**的，互不影响。\n\n虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于**轻量级的虚拟化**。\n\n虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。\n\n而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134422660-219996811.png)\n\n沙箱\n\n它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134430830-648875754.png)\n\n容器和虚拟机的对比\n\n正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。\n\n我们具体来看看Docker。\n\n大家需要注意，**Docker本身并不是容器**，它是创建容器的工具，是应用容器引擎。\n\n想要搞懂Docker，其实看它的两句口号就行。\n\n第一句，是“**Build, Ship and Run**”。\n\n![img](linux%E4%B8%8Ek8s%E7%9A%84%E5%8C%BA%E5%88%AB.assets/720430-20181226134440039-355719052.png)\n\n也就是，“搭建、发送、运行”，三板斧。\n\n举个例子：\n\n我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134448189-1614413776.png)\n\n结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。\n\n但是，跑来一个老巫婆，教会我一种魔法。\n\n这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134458048-1632935313.png)\n\n等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134507695-502496013.png)\n\n怎么样？是不是很神奇？\n\n所以，Docker的第二句口号就是：“**Build once，Run anywhere（搭建一次，到处能用）**”。\n\nDocker技术的三大核心概念，分别是：\n\n- **镜像（Image）**\n- **容器（Container）**\n- **仓库（Repository）**\n\n我刚才例子里面，那个放在包里的“镜像”，就是**Docker镜像**。而我的背包，就是**Docker仓库**。我在空地上，用魔法造好的房子，就是一个**Docker容器**。\n\n说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。\n\n每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！\n\n也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。\n\n这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134517561-1517184540.png)\n\n于是乎，就变成了一个大的公共仓库。\n\n负责对Docker镜像进行管理的，是**Docker Registry服务**（类似仓库管理员）。\n\n不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？\n\n所以，Docker Registry服务对镜像的管理是非常严格的。\n\n最常使用的Registry公开服务，是官方的**Docker Hub**，这也是默认的Registry，并拥有大量的高质量的官方镜像。\n\n好了，说完了Docker，我们再把目光转向K8S。\n\n就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。\n\n就在这个时候，K8S出现了。\n\n**K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134529220-885595947.png)\n\nKubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。\n\n和Docker不同，K8S的创造者，是众人皆知的行业巨头——**Google**。\n\n然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的**Borg系统**。\n\nK8S是2014年6月由Google公司正式公布出来并宣布开源的。\n\n同年7月，微软、Red Hat、IBM、Docker、CoreOS、Mesosphere和Saltstack等公司，相继加入K8S。\n\n之后的一年内，VMware、HP、Intel等公司，也陆续加入。\n\n2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。\n\n目前，kubernetes的版本已经发展到V1.13。\n\nK8S的架构，略微有一点复杂，我们简单来看一下。\n\n一个K8S系统，通常称为一个**K8S集群（Cluster）**。\n\n这个集群主要包括两个部分：\n\n- **一个Master节点（主节点）**\n- **一群Node节点（计算节点）**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134539670-1577644922.png)\n\n一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。\n\n深入来看这两种节点。\n\n首先是**Master节点。**\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134549651-376208258.png)\n\nMaster节点包括API Server、Scheduler、Controller manager、etcd。\n\nAPI Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。\n\nScheduler负责对集群内部的资源进行调度，相当于“调度室”。\n\nController manager负责管理控制器，相当于“大总管”。\n\n然后是**Node节点**。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134600202-626807958.png)\n\nNode节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是**Pod**。\n\n> Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。\n\nDocker，不用说了，创建容器的。\n\nKubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。\n\nKube-proxy，主要负责为Pod对象提供代理。\n\nFluentd，主要负责日志收集、存储与查询。\n\n是不是有点懵？唉，三言两语真的很难讲清楚，继续跳过吧。\n\nDocker和K8S都介绍完了，然而文章并没有结束。\n\n接下来的部分，是**写给核心网工程师甚至所有通信工程师看的**。\n\n从几十年前的1G，到现在的4G，再到将来的5G，移动通信发生了翻天覆地的变化，核心网亦是如此。\n\n但是，如果你仔细洞察这些变化，会发现，所谓的核心网，其实本质上并没有发生改变，无非就是很多的服务器而已。不同的核心网网元，就是不同的服务器，不同的计算节点。\n\n变化的，是这些“服务器”的形态和接口：形态，从机柜单板，变成机柜刀片，从机柜刀片，变成X86通用刀片服务器；接口，从中继线缆，变成网线，从网线，变成光纤。\n\n就算变来变去，还是服务器，是计算节点，是CPU。\n\n既然是服务器，那么就势必会和IT云计算一样，走上虚拟化的道路。毕竟，虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度，等等。\n\n前几年，大家以为虚拟机是核心网的终极形态。目前看来，更有可能是**容器化**。这几年经常说的NFV（网元功能虚拟化），也有可能改口为NFC（网元功能容器化）。\n\n以VoLTE为例，如果按以前2G/3G的方式，那需要大量的专用设备，分别充当EPC和IMS的不同网元。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134611008-1358657705.png)\n\nVoLTE相关的网元\n\n而采用容器之后，很可能只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同网元的服务程序。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134621637-1646543877.png)\n\n这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。\n\n简直完美！\n\n5G时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成N个专能型。每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。\n\n![img](https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134635090-835720705.png)\n\n精细化分工\n\n按照这样的发展趋势，在移动通信系统中，除了天线，剩下的部分都有可能虚拟化。核心网是第一个，但不是最后一个。虚拟化之后的核心网，与其说属于通信，实际上更应该归为IT。核心网的功能，只是容器中普通一个软件功能而已。\n\n至于说在座的各位核心网工程师，恭喜你们，马上就要成功转型啦！","slug":"技术分享/linux/linux与k8s的区别","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6h3000mtvcdaahzetol","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"10分钟看懂Docker和K8S\"><a href=\"#10分钟看懂Docker和K8S\" class=\"headerlink\" title=\"10分钟看懂Docker和K8S\"></a><a href=\"https://www.cnblogs.com/itbsl/p/10178698.html\">10分钟看懂Docker和K8S</a></h1><p><strong>本文来源：鲜枣课堂</strong></p>\n<p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/720430-20181226134250810-1685533200.png\" alt=\"img\"></p>\n<p>这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/720430-20181226134259735-1931086473.png\" alt=\"img\"></p>\n<p>LXC，就是Linux容器虚拟技术（Linux container）</p>\n<p>后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/720430-20181226134308841-1109691453.png\" alt=\"img\"></p>\n<p>Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p>\n<p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。</p>\n<p>什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/720430-20181226134321094-1025894099.png\" alt=\"img\"></p>\n<p>Open Source，开源</p>\n<p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p>\n<p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134409452-99479785.png\" alt=\"img\"></p>\n<p>Solomon Hykes（今年刚从Docker离职）</p>\n<p>不开则已，一开惊人。</p>\n<p>越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。</p>\n<p>Docker的人气迅速攀升，速度之快，令人瞠目结舌。</p>\n<p>开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p>\n<p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。</p>\n<p>Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。</p>\n<p>Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p>\n<p>在容器技术之前，业界的网红是虚拟机。<strong>虚拟机</strong>技术的代表，是<strong>VMWare</strong>和<strong>OpenStack</strong>。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134345971-148194642.png\" alt=\"img\"></p>\n<p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134357583-1178315643.png\" alt=\"img\"></p>\n<p>虚拟机，类似于“子电脑”</p>\n<p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p>\n<p>虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化</strong>。</p>\n<p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。</p>\n<p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134422660-219996811.png\" alt=\"img\"></p>\n<p>沙箱</p>\n<p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134430830-648875754.png\" alt=\"img\"></p>\n<p>容器和虚拟机的对比</p>\n<p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p>\n<p>我们具体来看看Docker。</p>\n<p>大家需要注意，<strong>Docker本身并不是容器</strong>，它是创建容器的工具，是应用容器引擎。</p>\n<p>想要搞懂Docker，其实看它的两句口号就行。</p>\n<p>第一句，是“<strong>Build, Ship and Run</strong>”。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"linux%E4%B8%8Ek8s%E7%9A%84%E5%8C%BA%E5%88%AB.assets/720430-20181226134440039-355719052.png\" alt=\"img\"></p>\n<p>也就是，“搭建、发送、运行”，三板斧。</p>\n<p>举个例子：</p>\n<p>我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134448189-1614413776.png\" alt=\"img\"></p>\n<p>结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。</p>\n<p>但是，跑来一个老巫婆，教会我一种魔法。</p>\n<p>这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134458048-1632935313.png\" alt=\"img\"></p>\n<p>等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134507695-502496013.png\" alt=\"img\"></p>\n<p>怎么样？是不是很神奇？</p>\n<p>所以，Docker的第二句口号就是：“<strong>Build once，Run anywhere（搭建一次，到处能用）</strong>”。</p>\n<p>Docker技术的三大核心概念，分别是：</p>\n<ul>\n<li><strong>镜像（Image）</strong></li>\n<li><strong>容器（Container）</strong></li>\n<li><strong>仓库（Repository）</strong></li>\n</ul>\n<p>我刚才例子里面，那个放在包里的“镜像”，就是<strong>Docker镜像</strong>。而我的背包，就是<strong>Docker仓库</strong>。我在空地上，用魔法造好的房子，就是一个<strong>Docker容器</strong>。</p>\n<p>说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<p>也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。</p>\n<p>每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！</p>\n<p>也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。</p>\n<p>这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134517561-1517184540.png\" alt=\"img\"></p>\n<p>于是乎，就变成了一个大的公共仓库。</p>\n<p>负责对Docker镜像进行管理的，是<strong>Docker Registry服务</strong>（类似仓库管理员）。</p>\n<p>不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？</p>\n<p>所以，Docker Registry服务对镜像的管理是非常严格的。</p>\n<p>最常使用的Registry公开服务，是官方的<strong>Docker Hub</strong>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p>\n<p>好了，说完了Docker，我们再把目光转向K8S。</p>\n<p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p>\n<p>就在这个时候，K8S出现了。</p>\n<p><strong>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</strong></p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134529220-885595947.png\" alt=\"img\"></p>\n<p>Kubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。</p>\n<p>和Docker不同，K8S的创造者，是众人皆知的行业巨头——<strong>Google</strong>。</p>\n<p>然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的<strong>Borg系统</strong>。</p>\n<p>K8S是2014年6月由Google公司正式公布出来并宣布开源的。</p>\n<p>同年7月，微软、Red Hat、IBM、Docker、CoreOS、Mesosphere和Saltstack等公司，相继加入K8S。</p>\n<p>之后的一年内，VMware、HP、Intel等公司，也陆续加入。</p>\n<p>2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。</p>\n<p>目前，kubernetes的版本已经发展到V1.13。</p>\n<p>K8S的架构，略微有一点复杂，我们简单来看一下。</p>\n<p>一个K8S系统，通常称为一个<strong>K8S集群（Cluster）</strong>。</p>\n<p>这个集群主要包括两个部分：</p>\n<ul>\n<li><strong>一个Master节点（主节点）</strong></li>\n<li><strong>一群Node节点（计算节点）</strong></li>\n</ul>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134539670-1577644922.png\" alt=\"img\"></p>\n<p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p>\n<p>深入来看这两种节点。</p>\n<p>首先是<strong>Master节点。</strong></p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134549651-376208258.png\" alt=\"img\"></p>\n<p>Master节点包括API Server、Scheduler、Controller manager、etcd。</p>\n<p>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</p>\n<p>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</p>\n<p>Controller manager负责管理控制器，相当于“大总管”。</p>\n<p>然后是<strong>Node节点</strong>。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134600202-626807958.png\" alt=\"img\"></p>\n<p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是<strong>Pod</strong>。</p>\n<blockquote>\n<p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。</p>\n</blockquote>\n<p>Docker，不用说了，创建容器的。</p>\n<p>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p>\n<p>Kube-proxy，主要负责为Pod对象提供代理。</p>\n<p>Fluentd，主要负责日志收集、存储与查询。</p>\n<p>是不是有点懵？唉，三言两语真的很难讲清楚，继续跳过吧。</p>\n<p>Docker和K8S都介绍完了，然而文章并没有结束。</p>\n<p>接下来的部分，是<strong>写给核心网工程师甚至所有通信工程师看的</strong>。</p>\n<p>从几十年前的1G，到现在的4G，再到将来的5G，移动通信发生了翻天覆地的变化，核心网亦是如此。</p>\n<p>但是，如果你仔细洞察这些变化，会发现，所谓的核心网，其实本质上并没有发生改变，无非就是很多的服务器而已。不同的核心网网元，就是不同的服务器，不同的计算节点。</p>\n<p>变化的，是这些“服务器”的形态和接口：形态，从机柜单板，变成机柜刀片，从机柜刀片，变成X86通用刀片服务器；接口，从中继线缆，变成网线，从网线，变成光纤。</p>\n<p>就算变来变去，还是服务器，是计算节点，是CPU。</p>\n<p>既然是服务器，那么就势必会和IT云计算一样，走上虚拟化的道路。毕竟，虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度，等等。</p>\n<p>前几年，大家以为虚拟机是核心网的终极形态。目前看来，更有可能是<strong>容器化</strong>。这几年经常说的NFV（网元功能虚拟化），也有可能改口为NFC（网元功能容器化）。</p>\n<p>以VoLTE为例，如果按以前2G/3G的方式，那需要大量的专用设备，分别充当EPC和IMS的不同网元。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134611008-1358657705.png\" alt=\"img\"></p>\n<p>VoLTE相关的网元</p>\n<p>而采用容器之后，很可能只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同网元的服务程序。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134621637-1646543877.png\" alt=\"img\"></p>\n<p>这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。</p>\n<p>简直完美！</p>\n<p>5G时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成N个专能型。每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134635090-835720705.png\" alt=\"img\"></p>\n<p>精细化分工</p>\n<p>按照这样的发展趋势，在移动通信系统中，除了天线，剩下的部分都有可能虚拟化。核心网是第一个，但不是最后一个。虚拟化之后的核心网，与其说属于通信，实际上更应该归为IT。核心网的功能，只是容器中普通一个软件功能而已。</p>\n<p>至于说在座的各位核心网工程师，恭喜你们，马上就要成功转型啦！</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"10分钟看懂Docker和K8S\"><a href=\"#10分钟看懂Docker和K8S\" class=\"headerlink\" title=\"10分钟看懂Docker和K8S\"></a><a href=\"https://www.cnblogs.com/itbsl/p/10178698.html\">10分钟看懂Docker和K8S</a></h1><p><strong>本文来源：鲜枣课堂</strong></p>\n<p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。</p>\n<p><img src=\"../../img/720430-20181226134250810-1685533200.png\" alt=\"img\"></p>\n<p>这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。</p>\n<p><img src=\"../../img/720430-20181226134259735-1931086473.png\" alt=\"img\"></p>\n<p>LXC，就是Linux容器虚拟技术（Linux container）</p>\n<p>后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。</p>\n<p><img src=\"../../img/720430-20181226134308841-1109691453.png\" alt=\"img\"></p>\n<p>Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p>\n<p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。</p>\n<p>什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p>\n<p><img src=\"../../img/720430-20181226134321094-1025894099.png\" alt=\"img\"></p>\n<p>Open Source，开源</p>\n<p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p>\n<p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134409452-99479785.png\" alt=\"img\"></p>\n<p>Solomon Hykes（今年刚从Docker离职）</p>\n<p>不开则已，一开惊人。</p>\n<p>越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。</p>\n<p>Docker的人气迅速攀升，速度之快，令人瞠目结舌。</p>\n<p>开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p>\n<p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。</p>\n<p>Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。</p>\n<p>Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p>\n<p>在容器技术之前，业界的网红是虚拟机。<strong>虚拟机</strong>技术的代表，是<strong>VMWare</strong>和<strong>OpenStack</strong>。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134345971-148194642.png\" alt=\"img\"></p>\n<p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134357583-1178315643.png\" alt=\"img\"></p>\n<p>虚拟机，类似于“子电脑”</p>\n<p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p>\n<p>虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化</strong>。</p>\n<p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。</p>\n<p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134422660-219996811.png\" alt=\"img\"></p>\n<p>沙箱</p>\n<p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134430830-648875754.png\" alt=\"img\"></p>\n<p>容器和虚拟机的对比</p>\n<p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p>\n<p>我们具体来看看Docker。</p>\n<p>大家需要注意，<strong>Docker本身并不是容器</strong>，它是创建容器的工具，是应用容器引擎。</p>\n<p>想要搞懂Docker，其实看它的两句口号就行。</p>\n<p>第一句，是“<strong>Build, Ship and Run</strong>”。</p>\n<p><img src=\"linux%E4%B8%8Ek8s%E7%9A%84%E5%8C%BA%E5%88%AB.assets/720430-20181226134440039-355719052.png\" alt=\"img\"></p>\n<p>也就是，“搭建、发送、运行”，三板斧。</p>\n<p>举个例子：</p>\n<p>我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134448189-1614413776.png\" alt=\"img\"></p>\n<p>结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。</p>\n<p>但是，跑来一个老巫婆，教会我一种魔法。</p>\n<p>这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134458048-1632935313.png\" alt=\"img\"></p>\n<p>等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134507695-502496013.png\" alt=\"img\"></p>\n<p>怎么样？是不是很神奇？</p>\n<p>所以，Docker的第二句口号就是：“<strong>Build once，Run anywhere（搭建一次，到处能用）</strong>”。</p>\n<p>Docker技术的三大核心概念，分别是：</p>\n<ul>\n<li><strong>镜像（Image）</strong></li>\n<li><strong>容器（Container）</strong></li>\n<li><strong>仓库（Repository）</strong></li>\n</ul>\n<p>我刚才例子里面，那个放在包里的“镜像”，就是<strong>Docker镜像</strong>。而我的背包，就是<strong>Docker仓库</strong>。我在空地上，用魔法造好的房子，就是一个<strong>Docker容器</strong>。</p>\n<p>说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<p>也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。</p>\n<p>每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！</p>\n<p>也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。</p>\n<p>这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134517561-1517184540.png\" alt=\"img\"></p>\n<p>于是乎，就变成了一个大的公共仓库。</p>\n<p>负责对Docker镜像进行管理的，是<strong>Docker Registry服务</strong>（类似仓库管理员）。</p>\n<p>不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？</p>\n<p>所以，Docker Registry服务对镜像的管理是非常严格的。</p>\n<p>最常使用的Registry公开服务，是官方的<strong>Docker Hub</strong>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p>\n<p>好了，说完了Docker，我们再把目光转向K8S。</p>\n<p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p>\n<p>就在这个时候，K8S出现了。</p>\n<p><strong>K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134529220-885595947.png\" alt=\"img\"></p>\n<p>Kubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。</p>\n<p>和Docker不同，K8S的创造者，是众人皆知的行业巨头——<strong>Google</strong>。</p>\n<p>然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的<strong>Borg系统</strong>。</p>\n<p>K8S是2014年6月由Google公司正式公布出来并宣布开源的。</p>\n<p>同年7月，微软、Red Hat、IBM、Docker、CoreOS、Mesosphere和Saltstack等公司，相继加入K8S。</p>\n<p>之后的一年内，VMware、HP、Intel等公司，也陆续加入。</p>\n<p>2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。</p>\n<p>目前，kubernetes的版本已经发展到V1.13。</p>\n<p>K8S的架构，略微有一点复杂，我们简单来看一下。</p>\n<p>一个K8S系统，通常称为一个<strong>K8S集群（Cluster）</strong>。</p>\n<p>这个集群主要包括两个部分：</p>\n<ul>\n<li><strong>一个Master节点（主节点）</strong></li>\n<li><strong>一群Node节点（计算节点）</strong></li>\n</ul>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134539670-1577644922.png\" alt=\"img\"></p>\n<p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p>\n<p>深入来看这两种节点。</p>\n<p>首先是<strong>Master节点。</strong></p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134549651-376208258.png\" alt=\"img\"></p>\n<p>Master节点包括API Server、Scheduler、Controller manager、etcd。</p>\n<p>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</p>\n<p>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</p>\n<p>Controller manager负责管理控制器，相当于“大总管”。</p>\n<p>然后是<strong>Node节点</strong>。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134600202-626807958.png\" alt=\"img\"></p>\n<p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是<strong>Pod</strong>。</p>\n<blockquote>\n<p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。</p>\n</blockquote>\n<p>Docker，不用说了，创建容器的。</p>\n<p>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p>\n<p>Kube-proxy，主要负责为Pod对象提供代理。</p>\n<p>Fluentd，主要负责日志收集、存储与查询。</p>\n<p>是不是有点懵？唉，三言两语真的很难讲清楚，继续跳过吧。</p>\n<p>Docker和K8S都介绍完了，然而文章并没有结束。</p>\n<p>接下来的部分，是<strong>写给核心网工程师甚至所有通信工程师看的</strong>。</p>\n<p>从几十年前的1G，到现在的4G，再到将来的5G，移动通信发生了翻天覆地的变化，核心网亦是如此。</p>\n<p>但是，如果你仔细洞察这些变化，会发现，所谓的核心网，其实本质上并没有发生改变，无非就是很多的服务器而已。不同的核心网网元，就是不同的服务器，不同的计算节点。</p>\n<p>变化的，是这些“服务器”的形态和接口：形态，从机柜单板，变成机柜刀片，从机柜刀片，变成X86通用刀片服务器；接口，从中继线缆，变成网线，从网线，变成光纤。</p>\n<p>就算变来变去，还是服务器，是计算节点，是CPU。</p>\n<p>既然是服务器，那么就势必会和IT云计算一样，走上虚拟化的道路。毕竟，虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度，等等。</p>\n<p>前几年，大家以为虚拟机是核心网的终极形态。目前看来，更有可能是<strong>容器化</strong>。这几年经常说的NFV（网元功能虚拟化），也有可能改口为NFC（网元功能容器化）。</p>\n<p>以VoLTE为例，如果按以前2G/3G的方式，那需要大量的专用设备，分别充当EPC和IMS的不同网元。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134611008-1358657705.png\" alt=\"img\"></p>\n<p>VoLTE相关的网元</p>\n<p>而采用容器之后，很可能只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同网元的服务程序。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134621637-1646543877.png\" alt=\"img\"></p>\n<p>这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。</p>\n<p>简直完美！</p>\n<p>5G时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成N个专能型。每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。</p>\n<p><img src=\"https://img2018.cnblogs.com/blog/720430/201812/720430-20181226134635090-835720705.png\" alt=\"img\"></p>\n<p>精细化分工</p>\n<p>按照这样的发展趋势，在移动通信系统中，除了天线，剩下的部分都有可能虚拟化。核心网是第一个，但不是最后一个。虚拟化之后的核心网，与其说属于通信，实际上更应该归为IT。核心网的功能，只是容器中普通一个软件功能而已。</p>\n<p>至于说在座的各位核心网工程师，恭喜你们，马上就要成功转型啦！</p>\n"},{"title":"Spring Cloud 微服务架构全链路实践","cover":"/images/post/1879991184/thumbnail.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","abbrlink":1879991184,"date":"2016-08-15T16:04:12.000Z","_content":"\n# 前言\nJava 微服务框架选型（Dubbo 和 Spring Cloud）\n\n{% asset_img 1.png %}\n\n目前公司使用的 Spring Cloud 整个技术组件，基本包含了上面图中所包含的，不得不说，Spring Cloud 整个生态真的很强大，使用起来也很方便有效。\n\n后面有时间再针对\n\n\n\n个组件进行使用解读，这篇文章主要说下 Spring Cloud 架构的链路图，顺便把自己的思路整理下来，以备查阅。\n\n{% asset_img 2.png %}\n\n# 网关请求流程\n\n在 Spring Cloud 整个组件库中，Spring Cloud Zuul 是最容易被忽视，但也是最重要的，Spring Cloud Zuul 可以和 Eureka 注册中心集成，我们目前使用 Spring Cloud Zuul 的功能如下：\n- Filter 过滤器\n- Router 路由\n- Ribbon 负载均衡\n- Hystrix 熔断\n- Retry 重试\n有些功能是 Spring Cloud Zuul 自带的，比如 Filter 和 Router，有些是结合 Spring Cloud 其他组件，比如 Ribbon 和 Hystrix。\n\n这里重点介绍下 Filter 过滤器，分为四个过滤类型：\n- pre：Zuul 转发请求之前执行，我们目前的实现是AccessTokenFilter，用于 oAuth2.0 JWT 的授权验证。\n- route：Zuul 路由时执行，目前项目没用到。\n- post：Zuul 路由转发后执行，也就是已经请求成功了后端服务，我们目前的实现是CustomResponseFilter，用于统一请求格式的封装，比如 code/msg/data 等。\n- error：以上过滤器发生错误时执行，我们目前的实现是CustomErrorFilter，用于拦截过滤器执行的出现的错误，然后统一格式封装返回，另外，error 过滤器好像并不能捕获后端服务执行出现的错误。\n\n另外，关于 oAuth2.0 JWT 的授权验证，实现的方式有两种：\n- 授权的配置在后端服务中（每个服务都需要当作 Resource Server 进行配置，需要配置公钥，接口的授权具体配置在注解中），Zuul 只做转发，并不进行授权的验证。\n- 授权的配置在 Zuul 中，也就是把 Zuul 当作 Resource Server，后端服务不需要进行任何处理，Zuul 中具体的实现就是AccessTokenFilter，里面的逻辑是手动解析 JWT，然后判断是否正确，以及解析出用户信息/Scope/Role，然后根据当前的请求 API，对授权 Map 中的配置进行匹配，如果匹配错误，直接抛出 401 授权错误。\n我们目前采用的是第二种方式，这两种方式都有利有弊，关键在于自己的取舍，为什么采用第二种方式？目的就是发挥 Zuul 的作用，对外网关进行统一授权验证。\n\n关于授权 Map，里面存储了所有服务接口的配置，示例配置：\n```\nprivate static final Map ROUTE_MAPS;\nstatic {\n    ROUTE_MAPS = new HashMap();\n    ROUTE_MAPS.put(\"eureka-client/home\", \"read:ROLE_ADMIN\");\n    ROUTE_MAPS.put(\"eureka-client/user\", \"read:ROLE_ADMIN\");\n    ROUTE_MAPS.put(\"eureka-client/error\", \"read:ROLE_ADMIN\");\n}\n```\n\n\n这是我们目前的配置，是一个静态的 Map，后面会存储在 Spring Cloud Config 配置中心，Zuul 启动时进行加载，利用 Spring Cloud Bus 动态刷新。\n\n关于 Zuul 网关，其实还有很多需要说的，后面有机会再进行针对说明。\n\n# Eureka 服务治理\n\n{% asset_img 3.png %}\n\nEureka 遵循的是 AP 原则（服务可用性和分区容错性），是服务治理最理想的遵循 CAP 分布式原则。\n\nEureka 集群中的节点是彼此平级，不像 Consul 有 master/worker 之分，集群中的 Eureka 节点彼此两两注册，所以，Eureka 集群最好部署三个节点，这也是我们目前的部署方式。\n\n另外，Eureka 的自我保护机制，可以参考这篇文章。\n\n服务之间的相互调用，负载有两种使用方式：\n- Feign：基于声明式，顾名思义，就是需要定义接口，就像我们平常使用对象调用一样。\n- Ribbon：软负载，通过往 RestTemplate 中注入负载 Handler，然后通过负载算法选取调用（通过 Eureka 获取服务注册信息）。\n我们目前打算使用 Ribbon 负载方式，为什么？看下面代码就知道了：\n\n```\nrestTemplate.getForObject(\"http://eureka-client/hello\", String.class);\n```\n\n# Config 配置中心\n\n{% asset_img 4.png %}\n\n我们目前配置中心使用的是 Spring Cloud Config，当然你也可以使用功能更强大的 Polly（携程开源），但 Config 目前也能满足我们的需求，存储仓库我们现在使用的是 Git。\n\nConfig 配置中心提供了数据加密功能，你可以使用 RSA 的加密方式，这样存储在 Git 中的配置都是密文形式，Config Client 获取加密配置的时候，Config Server 会自动进行解密返回。\n\n配置中心的使用场景，我们目前主要是两个地方：\n\n- 项目启动的配置信息，比如数据库的连接字符串等。\n- 业务服务的配置信息，也就是业务相关的配置。\n\n另外，需要说明的是，默认情况下，如果 Git 中的配置更新了，Config Client 不会进行更新配置，我们目前的解决方式是，使用 Spring Cloud Bus 进行动态刷新配置（Config Server 中配置），具体的流程：\n1. Git 中添加 WebHooks 脚本，比如curl -X POST http://manager1:8180/bus/refresh，当 Git 仓库中的配置更新后，自动执行。\n2. Config Server 中配置 Spring Cloud Bus，接受 Git 的配置刷新请求，然后利用 RabbitMQ 广播通知所有的 Config Client 订阅方，刷新配置信息。\n\n# Hystrix 监控\n\n{% asset_img 5.png %}\n\nHystrix 主要是用于服务熔断/降级/隔离处理，Hystrix 配置在调用方，当被调用方服务不可用时，触发 Hystrix 熔断，会执行指定的 Fallback 方法，进行特殊处理。\n\n我之前以为，Hystrix 熔断的触发条件是服务不可用，也就是服务请求超时（比如服务挂掉了），但我自己测试了下，服务出现 500 错误，也会触发 Hystrix 熔断，而且会自动忽略 Hystrix 的超时时间设置。\n\n我们目前使用 Hystrix，主要有两个地方：\n- 内部服务调用：可以对某个 API 接口进行熔断处理。\n- Zuul 网关使用：就是当 Zuul 路由转发调用时，但有个局限性，就是只能对服务进行熔断，并不能针对某个 API 接口熔断。\n\n上面图中，主要画的是 Hystrix 的监控流程，我们目前主要使用 RabbitMQ 进行采集传输，turbine-server 进行数据流的聚合，hystrix-dashboard 进行图形化的展示。\n\n# 服务调用链路\n\n{% asset_img 6.png %}\n\n服务调用链路的概念，就是当服务请求发起时，记录整个请求链路的数据，以备查询。\n\n目前市面上，几乎所有服务调用链路的实现，理论基础都是基于 Google Dapper 的那篇论文，其中最重要的概念就是 traceId 和 spanId。\ntraceId 记录整个服务链路的 ID，由首次请求方创建，服务链路中唯一。\nspanId 记录当前服务块的 ID，由当前服务方创建。\nparentId 记录上一个请求服务的 spanId。\n下面我描述下，我们目前的服务调用链路过程：\nH5 发起请求，到 Zuul 网关，Zuul 创建全局的 traceId 和自己的 spanId，然后携带这些数据到业务服务 A，并利用 Spring Cloud Sluth 传输到 RabbitMQ。\n业务服务 A，接收到 Zuul 传输的 traceId 和 spanId，然后把 Zuul 的 spanId 设置成 parentId，并生成自己的 spanId，然后携带这些数据到业务服务 B，并利用 Spring Cloud Sluth 传输到 RabbitMQ。\n....\n上面图中，详细说明了整个服务调用链路的过程，这边再说下使用的技术栈：\nSpring Cloud Sluth：和 SkyWalking 的探针概念比较类似，每个服务都进行配置，收集当然服务的请求数据（traceId 和 spanId），然后利用stream-sluth和binder-rabbit组件，将请求数据传输到 RabbitMQ。\nSpring Cloud Zipkin：主要用于请求链路的 UI 展示，Zipkin 会从 RabbitMQ 读取请求数据，然后存储到 ElasticSearch 中，然后下次显示直接从 ElasticSearch 中读取。\nKibana：Kibana 也可以显示 ElasticSearch 中的请求数据，只不过不是图形化的，需要索引配置创建。\n\n# ELK 日志链路\n\n{% asset_img 7.png  %}\n\nELK 可以参考下之前的几篇文章：\nELK 架构之 Elasticsearch 和 Kibana 安装配置\nELK 架构之 Logstash 和 Filebeat 安装配置\nELK 架构之 Logstash 和 Filebeat 配置使用（采集过滤）\nELK 架构之 Elasticsearch、Kibana、Logstash 和 Filebeat 安装配置汇总（6.2.4 版本）\n上面图中已经很详细介绍了下 ELK 的流程，ELK 默认技术栈里是没有 Filebeat 的，Logstash 用作日志收集的时候，CPU 和内存会占用资源比较大，所以我们使用轻量化的 Filebeat 进行日志的收集，Filebeat 部署在每个业务服务所在的服务器，然后将收集到的日志数据传输到 Logstash，Logstash 可以部署两到三台服务器上，用作日志的过滤和分析工作，然后再将处理后的日志数据，传输到 ElasticSearch 存储。\n\n# 统一格式返回\n\n{% asset_img 8.png %}\n\n","source":"_posts/技术实践/spring/spring-cloud-learning.md","raw":"---\ntitle: Spring Cloud 微服务架构全链路实践\ncategories: \n  - 解决方案\ntags:\n  - Spring\n  - Spring Cloud\n  - Java\ncover: /images/post/1879991184/thumbnail.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\n# 文章缩略图\nabbrlink: 1879991184\ndate: 2016-08-16 00:04:12\n---\n\n# 前言\nJava 微服务框架选型（Dubbo 和 Spring Cloud）\n\n{% asset_img 1.png %}\n\n目前公司使用的 Spring Cloud 整个技术组件，基本包含了上面图中所包含的，不得不说，Spring Cloud 整个生态真的很强大，使用起来也很方便有效。\n\n后面有时间再针对\n\n\n\n个组件进行使用解读，这篇文章主要说下 Spring Cloud 架构的链路图，顺便把自己的思路整理下来，以备查阅。\n\n{% asset_img 2.png %}\n\n# 网关请求流程\n\n在 Spring Cloud 整个组件库中，Spring Cloud Zuul 是最容易被忽视，但也是最重要的，Spring Cloud Zuul 可以和 Eureka 注册中心集成，我们目前使用 Spring Cloud Zuul 的功能如下：\n- Filter 过滤器\n- Router 路由\n- Ribbon 负载均衡\n- Hystrix 熔断\n- Retry 重试\n有些功能是 Spring Cloud Zuul 自带的，比如 Filter 和 Router，有些是结合 Spring Cloud 其他组件，比如 Ribbon 和 Hystrix。\n\n这里重点介绍下 Filter 过滤器，分为四个过滤类型：\n- pre：Zuul 转发请求之前执行，我们目前的实现是AccessTokenFilter，用于 oAuth2.0 JWT 的授权验证。\n- route：Zuul 路由时执行，目前项目没用到。\n- post：Zuul 路由转发后执行，也就是已经请求成功了后端服务，我们目前的实现是CustomResponseFilter，用于统一请求格式的封装，比如 code/msg/data 等。\n- error：以上过滤器发生错误时执行，我们目前的实现是CustomErrorFilter，用于拦截过滤器执行的出现的错误，然后统一格式封装返回，另外，error 过滤器好像并不能捕获后端服务执行出现的错误。\n\n另外，关于 oAuth2.0 JWT 的授权验证，实现的方式有两种：\n- 授权的配置在后端服务中（每个服务都需要当作 Resource Server 进行配置，需要配置公钥，接口的授权具体配置在注解中），Zuul 只做转发，并不进行授权的验证。\n- 授权的配置在 Zuul 中，也就是把 Zuul 当作 Resource Server，后端服务不需要进行任何处理，Zuul 中具体的实现就是AccessTokenFilter，里面的逻辑是手动解析 JWT，然后判断是否正确，以及解析出用户信息/Scope/Role，然后根据当前的请求 API，对授权 Map 中的配置进行匹配，如果匹配错误，直接抛出 401 授权错误。\n我们目前采用的是第二种方式，这两种方式都有利有弊，关键在于自己的取舍，为什么采用第二种方式？目的就是发挥 Zuul 的作用，对外网关进行统一授权验证。\n\n关于授权 Map，里面存储了所有服务接口的配置，示例配置：\n```\nprivate static final Map ROUTE_MAPS;\nstatic {\n    ROUTE_MAPS = new HashMap();\n    ROUTE_MAPS.put(\"eureka-client/home\", \"read:ROLE_ADMIN\");\n    ROUTE_MAPS.put(\"eureka-client/user\", \"read:ROLE_ADMIN\");\n    ROUTE_MAPS.put(\"eureka-client/error\", \"read:ROLE_ADMIN\");\n}\n```\n\n\n这是我们目前的配置，是一个静态的 Map，后面会存储在 Spring Cloud Config 配置中心，Zuul 启动时进行加载，利用 Spring Cloud Bus 动态刷新。\n\n关于 Zuul 网关，其实还有很多需要说的，后面有机会再进行针对说明。\n\n# Eureka 服务治理\n\n{% asset_img 3.png %}\n\nEureka 遵循的是 AP 原则（服务可用性和分区容错性），是服务治理最理想的遵循 CAP 分布式原则。\n\nEureka 集群中的节点是彼此平级，不像 Consul 有 master/worker 之分，集群中的 Eureka 节点彼此两两注册，所以，Eureka 集群最好部署三个节点，这也是我们目前的部署方式。\n\n另外，Eureka 的自我保护机制，可以参考这篇文章。\n\n服务之间的相互调用，负载有两种使用方式：\n- Feign：基于声明式，顾名思义，就是需要定义接口，就像我们平常使用对象调用一样。\n- Ribbon：软负载，通过往 RestTemplate 中注入负载 Handler，然后通过负载算法选取调用（通过 Eureka 获取服务注册信息）。\n我们目前打算使用 Ribbon 负载方式，为什么？看下面代码就知道了：\n\n```\nrestTemplate.getForObject(\"http://eureka-client/hello\", String.class);\n```\n\n# Config 配置中心\n\n{% asset_img 4.png %}\n\n我们目前配置中心使用的是 Spring Cloud Config，当然你也可以使用功能更强大的 Polly（携程开源），但 Config 目前也能满足我们的需求，存储仓库我们现在使用的是 Git。\n\nConfig 配置中心提供了数据加密功能，你可以使用 RSA 的加密方式，这样存储在 Git 中的配置都是密文形式，Config Client 获取加密配置的时候，Config Server 会自动进行解密返回。\n\n配置中心的使用场景，我们目前主要是两个地方：\n\n- 项目启动的配置信息，比如数据库的连接字符串等。\n- 业务服务的配置信息，也就是业务相关的配置。\n\n另外，需要说明的是，默认情况下，如果 Git 中的配置更新了，Config Client 不会进行更新配置，我们目前的解决方式是，使用 Spring Cloud Bus 进行动态刷新配置（Config Server 中配置），具体的流程：\n1. Git 中添加 WebHooks 脚本，比如curl -X POST http://manager1:8180/bus/refresh，当 Git 仓库中的配置更新后，自动执行。\n2. Config Server 中配置 Spring Cloud Bus，接受 Git 的配置刷新请求，然后利用 RabbitMQ 广播通知所有的 Config Client 订阅方，刷新配置信息。\n\n# Hystrix 监控\n\n{% asset_img 5.png %}\n\nHystrix 主要是用于服务熔断/降级/隔离处理，Hystrix 配置在调用方，当被调用方服务不可用时，触发 Hystrix 熔断，会执行指定的 Fallback 方法，进行特殊处理。\n\n我之前以为，Hystrix 熔断的触发条件是服务不可用，也就是服务请求超时（比如服务挂掉了），但我自己测试了下，服务出现 500 错误，也会触发 Hystrix 熔断，而且会自动忽略 Hystrix 的超时时间设置。\n\n我们目前使用 Hystrix，主要有两个地方：\n- 内部服务调用：可以对某个 API 接口进行熔断处理。\n- Zuul 网关使用：就是当 Zuul 路由转发调用时，但有个局限性，就是只能对服务进行熔断，并不能针对某个 API 接口熔断。\n\n上面图中，主要画的是 Hystrix 的监控流程，我们目前主要使用 RabbitMQ 进行采集传输，turbine-server 进行数据流的聚合，hystrix-dashboard 进行图形化的展示。\n\n# 服务调用链路\n\n{% asset_img 6.png %}\n\n服务调用链路的概念，就是当服务请求发起时，记录整个请求链路的数据，以备查询。\n\n目前市面上，几乎所有服务调用链路的实现，理论基础都是基于 Google Dapper 的那篇论文，其中最重要的概念就是 traceId 和 spanId。\ntraceId 记录整个服务链路的 ID，由首次请求方创建，服务链路中唯一。\nspanId 记录当前服务块的 ID，由当前服务方创建。\nparentId 记录上一个请求服务的 spanId。\n下面我描述下，我们目前的服务调用链路过程：\nH5 发起请求，到 Zuul 网关，Zuul 创建全局的 traceId 和自己的 spanId，然后携带这些数据到业务服务 A，并利用 Spring Cloud Sluth 传输到 RabbitMQ。\n业务服务 A，接收到 Zuul 传输的 traceId 和 spanId，然后把 Zuul 的 spanId 设置成 parentId，并生成自己的 spanId，然后携带这些数据到业务服务 B，并利用 Spring Cloud Sluth 传输到 RabbitMQ。\n....\n上面图中，详细说明了整个服务调用链路的过程，这边再说下使用的技术栈：\nSpring Cloud Sluth：和 SkyWalking 的探针概念比较类似，每个服务都进行配置，收集当然服务的请求数据（traceId 和 spanId），然后利用stream-sluth和binder-rabbit组件，将请求数据传输到 RabbitMQ。\nSpring Cloud Zipkin：主要用于请求链路的 UI 展示，Zipkin 会从 RabbitMQ 读取请求数据，然后存储到 ElasticSearch 中，然后下次显示直接从 ElasticSearch 中读取。\nKibana：Kibana 也可以显示 ElasticSearch 中的请求数据，只不过不是图形化的，需要索引配置创建。\n\n# ELK 日志链路\n\n{% asset_img 7.png  %}\n\nELK 可以参考下之前的几篇文章：\nELK 架构之 Elasticsearch 和 Kibana 安装配置\nELK 架构之 Logstash 和 Filebeat 安装配置\nELK 架构之 Logstash 和 Filebeat 配置使用（采集过滤）\nELK 架构之 Elasticsearch、Kibana、Logstash 和 Filebeat 安装配置汇总（6.2.4 版本）\n上面图中已经很详细介绍了下 ELK 的流程，ELK 默认技术栈里是没有 Filebeat 的，Logstash 用作日志收集的时候，CPU 和内存会占用资源比较大，所以我们使用轻量化的 Filebeat 进行日志的收集，Filebeat 部署在每个业务服务所在的服务器，然后将收集到的日志数据传输到 Logstash，Logstash 可以部署两到三台服务器上，用作日志的过滤和分析工作，然后再将处理后的日志数据，传输到 ElasticSearch 存储。\n\n# 统一格式返回\n\n{% asset_img 8.png %}\n\n","slug":"技术实践/spring/spring-cloud-learning","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6h4000otvcd2cti17o2","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Java 微服务框架选型（Dubbo 和 Spring Cloud）</p>\n<img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/posts/1879991184/index/1.png\" class=\"\">\n\n<p>目前公司使用的 Spring Cloud 整个技术组件，基本包含了上面图中所包含的，不得不说，Spring Cloud 整个生态真的很强大，使用起来也很方便有效。</p>\n<p>后面有时间再针对</p>\n<p>个组件进行使用解读，这篇文章主要说下 Spring Cloud 架构的链路图，顺便把自己的思路整理下来，以备查阅。</p>\n<img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/posts/1879991184/index/2.png\" class=\"\">\n\n<h1 id=\"网关请求流程\"><a href=\"#网关请求流程\" class=\"headerlink\" title=\"网关请求流程\"></a>网关请求流程</h1><p>在 Spring Cloud 整个组件库中，Spring Cloud Zuul 是最容易被忽视，但也是最重要的，Spring Cloud Zuul 可以和 Eureka 注册中心集成，我们目前使用 Spring Cloud Zuul 的功能如下：</p>\n<ul>\n<li>Filter 过滤器</li>\n<li>Router 路由</li>\n<li>Ribbon 负载均衡</li>\n<li>Hystrix 熔断</li>\n<li>Retry 重试<br>有些功能是 Spring Cloud Zuul 自带的，比如 Filter 和 Router，有些是结合 Spring Cloud 其他组件，比如 Ribbon 和 Hystrix。</li>\n</ul>\n<p>这里重点介绍下 Filter 过滤器，分为四个过滤类型：</p>\n<ul>\n<li>pre：Zuul 转发请求之前执行，我们目前的实现是AccessTokenFilter，用于 oAuth2.0 JWT 的授权验证。</li>\n<li>route：Zuul 路由时执行，目前项目没用到。</li>\n<li>post：Zuul 路由转发后执行，也就是已经请求成功了后端服务，我们目前的实现是CustomResponseFilter，用于统一请求格式的封装，比如 code/msg/data 等。</li>\n<li>error：以上过滤器发生错误时执行，我们目前的实现是CustomErrorFilter，用于拦截过滤器执行的出现的错误，然后统一格式封装返回，另外，error 过滤器好像并不能捕获后端服务执行出现的错误。</li>\n</ul>\n<p>另外，关于 oAuth2.0 JWT 的授权验证，实现的方式有两种：</p>\n<ul>\n<li>授权的配置在后端服务中（每个服务都需要当作 Resource Server 进行配置，需要配置公钥，接口的授权具体配置在注解中），Zuul 只做转发，并不进行授权的验证。</li>\n<li>授权的配置在 Zuul 中，也就是把 Zuul 当作 Resource Server，后端服务不需要进行任何处理，Zuul 中具体的实现就是AccessTokenFilter，里面的逻辑是手动解析 JWT，然后判断是否正确，以及解析出用户信息/Scope/Role，然后根据当前的请求 API，对授权 Map 中的配置进行匹配，如果匹配错误，直接抛出 401 授权错误。<br>我们目前采用的是第二种方式，这两种方式都有利有弊，关键在于自己的取舍，为什么采用第二种方式？目的就是发挥 Zuul 的作用，对外网关进行统一授权验证。</li>\n</ul>\n<p>关于授权 Map，里面存储了所有服务接口的配置，示例配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">private static final Map ROUTE_MAPS;<br>static &#123;<br>    ROUTE_MAPS &#x3D; new HashMap();<br>    ROUTE_MAPS.put(&quot;eureka-client&#x2F;home&quot;, &quot;read:ROLE_ADMIN&quot;);<br>    ROUTE_MAPS.put(&quot;eureka-client&#x2F;user&quot;, &quot;read:ROLE_ADMIN&quot;);<br>    ROUTE_MAPS.put(&quot;eureka-client&#x2F;error&quot;, &quot;read:ROLE_ADMIN&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这是我们目前的配置，是一个静态的 Map，后面会存储在 Spring Cloud Config 配置中心，Zuul 启动时进行加载，利用 Spring Cloud Bus 动态刷新。</p>\n<p>关于 Zuul 网关，其实还有很多需要说的，后面有机会再进行针对说明。</p>\n<h1 id=\"Eureka-服务治理\"><a href=\"#Eureka-服务治理\" class=\"headerlink\" title=\"Eureka 服务治理\"></a>Eureka 服务治理</h1><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/posts/1879991184/index/3.png\" class=\"\">\n\n<p>Eureka 遵循的是 AP 原则（服务可用性和分区容错性），是服务治理最理想的遵循 CAP 分布式原则。</p>\n<p>Eureka 集群中的节点是彼此平级，不像 Consul 有 master/worker 之分，集群中的 Eureka 节点彼此两两注册，所以，Eureka 集群最好部署三个节点，这也是我们目前的部署方式。</p>\n<p>另外，Eureka 的自我保护机制，可以参考这篇文章。</p>\n<p>服务之间的相互调用，负载有两种使用方式：</p>\n<ul>\n<li>Feign：基于声明式，顾名思义，就是需要定义接口，就像我们平常使用对象调用一样。</li>\n<li>Ribbon：软负载，通过往 RestTemplate 中注入负载 Handler，然后通过负载算法选取调用（通过 Eureka 获取服务注册信息）。<br>我们目前打算使用 Ribbon 负载方式，为什么？看下面代码就知道了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">restTemplate.getForObject(&quot;http:&#x2F;&#x2F;eureka-client&#x2F;hello&quot;, String.class);<br></code></pre></td></tr></table></figure>\n<h1 id=\"Config-配置中心\"><a href=\"#Config-配置中心\" class=\"headerlink\" title=\"Config 配置中心\"></a>Config 配置中心</h1><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/posts/1879991184/index/4.png\" class=\"\">\n\n<p>我们目前配置中心使用的是 Spring Cloud Config，当然你也可以使用功能更强大的 Polly（携程开源），但 Config 目前也能满足我们的需求，存储仓库我们现在使用的是 Git。</p>\n<p>Config 配置中心提供了数据加密功能，你可以使用 RSA 的加密方式，这样存储在 Git 中的配置都是密文形式，Config Client 获取加密配置的时候，Config Server 会自动进行解密返回。</p>\n<p>配置中心的使用场景，我们目前主要是两个地方：</p>\n<ul>\n<li>项目启动的配置信息，比如数据库的连接字符串等。</li>\n<li>业务服务的配置信息，也就是业务相关的配置。</li>\n</ul>\n<p>另外，需要说明的是，默认情况下，如果 Git 中的配置更新了，Config Client 不会进行更新配置，我们目前的解决方式是，使用 Spring Cloud Bus 进行动态刷新配置（Config Server 中配置），具体的流程：</p>\n<ol>\n<li>Git 中添加 WebHooks 脚本，比如curl -X POST <a href=\"http://manager1:8180/bus/refresh，当\">http://manager1:8180/bus/refresh，当</a> Git 仓库中的配置更新后，自动执行。</li>\n<li>Config Server 中配置 Spring Cloud Bus，接受 Git 的配置刷新请求，然后利用 RabbitMQ 广播通知所有的 Config Client 订阅方，刷新配置信息。</li>\n</ol>\n<h1 id=\"Hystrix-监控\"><a href=\"#Hystrix-监控\" class=\"headerlink\" title=\"Hystrix 监控\"></a>Hystrix 监控</h1><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/posts/1879991184/index/5.png\" class=\"\">\n\n<p>Hystrix 主要是用于服务熔断/降级/隔离处理，Hystrix 配置在调用方，当被调用方服务不可用时，触发 Hystrix 熔断，会执行指定的 Fallback 方法，进行特殊处理。</p>\n<p>我之前以为，Hystrix 熔断的触发条件是服务不可用，也就是服务请求超时（比如服务挂掉了），但我自己测试了下，服务出现 500 错误，也会触发 Hystrix 熔断，而且会自动忽略 Hystrix 的超时时间设置。</p>\n<p>我们目前使用 Hystrix，主要有两个地方：</p>\n<ul>\n<li>内部服务调用：可以对某个 API 接口进行熔断处理。</li>\n<li>Zuul 网关使用：就是当 Zuul 路由转发调用时，但有个局限性，就是只能对服务进行熔断，并不能针对某个 API 接口熔断。</li>\n</ul>\n<p>上面图中，主要画的是 Hystrix 的监控流程，我们目前主要使用 RabbitMQ 进行采集传输，turbine-server 进行数据流的聚合，hystrix-dashboard 进行图形化的展示。</p>\n<h1 id=\"服务调用链路\"><a href=\"#服务调用链路\" class=\"headerlink\" title=\"服务调用链路\"></a>服务调用链路</h1><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/posts/1879991184/index/6.png\" class=\"\">\n\n<p>服务调用链路的概念，就是当服务请求发起时，记录整个请求链路的数据，以备查询。</p>\n<p>目前市面上，几乎所有服务调用链路的实现，理论基础都是基于 Google Dapper 的那篇论文，其中最重要的概念就是 traceId 和 spanId。<br>traceId 记录整个服务链路的 ID，由首次请求方创建，服务链路中唯一。<br>spanId 记录当前服务块的 ID，由当前服务方创建。<br>parentId 记录上一个请求服务的 spanId。<br>下面我描述下，我们目前的服务调用链路过程：<br>H5 发起请求，到 Zuul 网关，Zuul 创建全局的 traceId 和自己的 spanId，然后携带这些数据到业务服务 A，并利用 Spring Cloud Sluth 传输到 RabbitMQ。<br>业务服务 A，接收到 Zuul 传输的 traceId 和 spanId，然后把 Zuul 的 spanId 设置成 parentId，并生成自己的 spanId，然后携带这些数据到业务服务 B，并利用 Spring Cloud Sluth 传输到 RabbitMQ。<br>….<br>上面图中，详细说明了整个服务调用链路的过程，这边再说下使用的技术栈：<br>Spring Cloud Sluth：和 SkyWalking 的探针概念比较类似，每个服务都进行配置，收集当然服务的请求数据（traceId 和 spanId），然后利用stream-sluth和binder-rabbit组件，将请求数据传输到 RabbitMQ。<br>Spring Cloud Zipkin：主要用于请求链路的 UI 展示，Zipkin 会从 RabbitMQ 读取请求数据，然后存储到 ElasticSearch 中，然后下次显示直接从 ElasticSearch 中读取。<br>Kibana：Kibana 也可以显示 ElasticSearch 中的请求数据，只不过不是图形化的，需要索引配置创建。</p>\n<h1 id=\"ELK-日志链路\"><a href=\"#ELK-日志链路\" class=\"headerlink\" title=\"ELK 日志链路\"></a>ELK 日志链路</h1><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/posts/1879991184/index/7.png\" class=\"\">\n\n<p>ELK 可以参考下之前的几篇文章：<br>ELK 架构之 Elasticsearch 和 Kibana 安装配置<br>ELK 架构之 Logstash 和 Filebeat 安装配置<br>ELK 架构之 Logstash 和 Filebeat 配置使用（采集过滤）<br>ELK 架构之 Elasticsearch、Kibana、Logstash 和 Filebeat 安装配置汇总（6.2.4 版本）<br>上面图中已经很详细介绍了下 ELK 的流程，ELK 默认技术栈里是没有 Filebeat 的，Logstash 用作日志收集的时候，CPU 和内存会占用资源比较大，所以我们使用轻量化的 Filebeat 进行日志的收集，Filebeat 部署在每个业务服务所在的服务器，然后将收集到的日志数据传输到 Logstash，Logstash 可以部署两到三台服务器上，用作日志的过滤和分析工作，然后再将处理后的日志数据，传输到 ElasticSearch 存储。</p>\n<h1 id=\"统一格式返回\"><a href=\"#统一格式返回\" class=\"headerlink\" title=\"统一格式返回\"></a>统一格式返回</h1><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"/posts/1879991184/index/8.png\" class=\"\">\n\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>Java 微服务框架选型（Dubbo 和 Spring Cloud）</p>\n<img src=\"/posts/1879991184/index/1.png\" class=\"\">\n\n<p>目前公司使用的 Spring Cloud 整个技术组件，基本包含了上面图中所包含的，不得不说，Spring Cloud 整个生态真的很强大，使用起来也很方便有效。</p>\n<p>后面有时间再针对</p>\n<p>个组件进行使用解读，这篇文章主要说下 Spring Cloud 架构的链路图，顺便把自己的思路整理下来，以备查阅。</p>\n<img src=\"/posts/1879991184/index/2.png\" class=\"\">\n\n<h1 id=\"网关请求流程\"><a href=\"#网关请求流程\" class=\"headerlink\" title=\"网关请求流程\"></a>网关请求流程</h1><p>在 Spring Cloud 整个组件库中，Spring Cloud Zuul 是最容易被忽视，但也是最重要的，Spring Cloud Zuul 可以和 Eureka 注册中心集成，我们目前使用 Spring Cloud Zuul 的功能如下：</p>\n<ul>\n<li>Filter 过滤器</li>\n<li>Router 路由</li>\n<li>Ribbon 负载均衡</li>\n<li>Hystrix 熔断</li>\n<li>Retry 重试<br>有些功能是 Spring Cloud Zuul 自带的，比如 Filter 和 Router，有些是结合 Spring Cloud 其他组件，比如 Ribbon 和 Hystrix。</li>\n</ul>\n<p>这里重点介绍下 Filter 过滤器，分为四个过滤类型：</p>\n<ul>\n<li>pre：Zuul 转发请求之前执行，我们目前的实现是AccessTokenFilter，用于 oAuth2.0 JWT 的授权验证。</li>\n<li>route：Zuul 路由时执行，目前项目没用到。</li>\n<li>post：Zuul 路由转发后执行，也就是已经请求成功了后端服务，我们目前的实现是CustomResponseFilter，用于统一请求格式的封装，比如 code/msg/data 等。</li>\n<li>error：以上过滤器发生错误时执行，我们目前的实现是CustomErrorFilter，用于拦截过滤器执行的出现的错误，然后统一格式封装返回，另外，error 过滤器好像并不能捕获后端服务执行出现的错误。</li>\n</ul>\n<p>另外，关于 oAuth2.0 JWT 的授权验证，实现的方式有两种：</p>\n<ul>\n<li>授权的配置在后端服务中（每个服务都需要当作 Resource Server 进行配置，需要配置公钥，接口的授权具体配置在注解中），Zuul 只做转发，并不进行授权的验证。</li>\n<li>授权的配置在 Zuul 中，也就是把 Zuul 当作 Resource Server，后端服务不需要进行任何处理，Zuul 中具体的实现就是AccessTokenFilter，里面的逻辑是手动解析 JWT，然后判断是否正确，以及解析出用户信息/Scope/Role，然后根据当前的请求 API，对授权 Map 中的配置进行匹配，如果匹配错误，直接抛出 401 授权错误。<br>我们目前采用的是第二种方式，这两种方式都有利有弊，关键在于自己的取舍，为什么采用第二种方式？目的就是发挥 Zuul 的作用，对外网关进行统一授权验证。</li>\n</ul>\n<p>关于授权 Map，里面存储了所有服务接口的配置，示例配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">private static final Map ROUTE_MAPS;<br>static &#123;<br>    ROUTE_MAPS &#x3D; new HashMap();<br>    ROUTE_MAPS.put(&quot;eureka-client&#x2F;home&quot;, &quot;read:ROLE_ADMIN&quot;);<br>    ROUTE_MAPS.put(&quot;eureka-client&#x2F;user&quot;, &quot;read:ROLE_ADMIN&quot;);<br>    ROUTE_MAPS.put(&quot;eureka-client&#x2F;error&quot;, &quot;read:ROLE_ADMIN&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这是我们目前的配置，是一个静态的 Map，后面会存储在 Spring Cloud Config 配置中心，Zuul 启动时进行加载，利用 Spring Cloud Bus 动态刷新。</p>\n<p>关于 Zuul 网关，其实还有很多需要说的，后面有机会再进行针对说明。</p>\n<h1 id=\"Eureka-服务治理\"><a href=\"#Eureka-服务治理\" class=\"headerlink\" title=\"Eureka 服务治理\"></a>Eureka 服务治理</h1><img src=\"/posts/1879991184/index/3.png\" class=\"\">\n\n<p>Eureka 遵循的是 AP 原则（服务可用性和分区容错性），是服务治理最理想的遵循 CAP 分布式原则。</p>\n<p>Eureka 集群中的节点是彼此平级，不像 Consul 有 master/worker 之分，集群中的 Eureka 节点彼此两两注册，所以，Eureka 集群最好部署三个节点，这也是我们目前的部署方式。</p>\n<p>另外，Eureka 的自我保护机制，可以参考这篇文章。</p>\n<p>服务之间的相互调用，负载有两种使用方式：</p>\n<ul>\n<li>Feign：基于声明式，顾名思义，就是需要定义接口，就像我们平常使用对象调用一样。</li>\n<li>Ribbon：软负载，通过往 RestTemplate 中注入负载 Handler，然后通过负载算法选取调用（通过 Eureka 获取服务注册信息）。<br>我们目前打算使用 Ribbon 负载方式，为什么？看下面代码就知道了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">restTemplate.getForObject(&quot;http:&#x2F;&#x2F;eureka-client&#x2F;hello&quot;, String.class);<br></code></pre></td></tr></table></figure>\n<h1 id=\"Config-配置中心\"><a href=\"#Config-配置中心\" class=\"headerlink\" title=\"Config 配置中心\"></a>Config 配置中心</h1><img src=\"/posts/1879991184/index/4.png\" class=\"\">\n\n<p>我们目前配置中心使用的是 Spring Cloud Config，当然你也可以使用功能更强大的 Polly（携程开源），但 Config 目前也能满足我们的需求，存储仓库我们现在使用的是 Git。</p>\n<p>Config 配置中心提供了数据加密功能，你可以使用 RSA 的加密方式，这样存储在 Git 中的配置都是密文形式，Config Client 获取加密配置的时候，Config Server 会自动进行解密返回。</p>\n<p>配置中心的使用场景，我们目前主要是两个地方：</p>\n<ul>\n<li>项目启动的配置信息，比如数据库的连接字符串等。</li>\n<li>业务服务的配置信息，也就是业务相关的配置。</li>\n</ul>\n<p>另外，需要说明的是，默认情况下，如果 Git 中的配置更新了，Config Client 不会进行更新配置，我们目前的解决方式是，使用 Spring Cloud Bus 进行动态刷新配置（Config Server 中配置），具体的流程：</p>\n<ol>\n<li>Git 中添加 WebHooks 脚本，比如curl -X POST <a href=\"http://manager1:8180/bus/refresh，当\">http://manager1:8180/bus/refresh，当</a> Git 仓库中的配置更新后，自动执行。</li>\n<li>Config Server 中配置 Spring Cloud Bus，接受 Git 的配置刷新请求，然后利用 RabbitMQ 广播通知所有的 Config Client 订阅方，刷新配置信息。</li>\n</ol>\n<h1 id=\"Hystrix-监控\"><a href=\"#Hystrix-监控\" class=\"headerlink\" title=\"Hystrix 监控\"></a>Hystrix 监控</h1><img src=\"/posts/1879991184/index/5.png\" class=\"\">\n\n<p>Hystrix 主要是用于服务熔断/降级/隔离处理，Hystrix 配置在调用方，当被调用方服务不可用时，触发 Hystrix 熔断，会执行指定的 Fallback 方法，进行特殊处理。</p>\n<p>我之前以为，Hystrix 熔断的触发条件是服务不可用，也就是服务请求超时（比如服务挂掉了），但我自己测试了下，服务出现 500 错误，也会触发 Hystrix 熔断，而且会自动忽略 Hystrix 的超时时间设置。</p>\n<p>我们目前使用 Hystrix，主要有两个地方：</p>\n<ul>\n<li>内部服务调用：可以对某个 API 接口进行熔断处理。</li>\n<li>Zuul 网关使用：就是当 Zuul 路由转发调用时，但有个局限性，就是只能对服务进行熔断，并不能针对某个 API 接口熔断。</li>\n</ul>\n<p>上面图中，主要画的是 Hystrix 的监控流程，我们目前主要使用 RabbitMQ 进行采集传输，turbine-server 进行数据流的聚合，hystrix-dashboard 进行图形化的展示。</p>\n<h1 id=\"服务调用链路\"><a href=\"#服务调用链路\" class=\"headerlink\" title=\"服务调用链路\"></a>服务调用链路</h1><img src=\"/posts/1879991184/index/6.png\" class=\"\">\n\n<p>服务调用链路的概念，就是当服务请求发起时，记录整个请求链路的数据，以备查询。</p>\n<p>目前市面上，几乎所有服务调用链路的实现，理论基础都是基于 Google Dapper 的那篇论文，其中最重要的概念就是 traceId 和 spanId。<br>traceId 记录整个服务链路的 ID，由首次请求方创建，服务链路中唯一。<br>spanId 记录当前服务块的 ID，由当前服务方创建。<br>parentId 记录上一个请求服务的 spanId。<br>下面我描述下，我们目前的服务调用链路过程：<br>H5 发起请求，到 Zuul 网关，Zuul 创建全局的 traceId 和自己的 spanId，然后携带这些数据到业务服务 A，并利用 Spring Cloud Sluth 传输到 RabbitMQ。<br>业务服务 A，接收到 Zuul 传输的 traceId 和 spanId，然后把 Zuul 的 spanId 设置成 parentId，并生成自己的 spanId，然后携带这些数据到业务服务 B，并利用 Spring Cloud Sluth 传输到 RabbitMQ。<br>….<br>上面图中，详细说明了整个服务调用链路的过程，这边再说下使用的技术栈：<br>Spring Cloud Sluth：和 SkyWalking 的探针概念比较类似，每个服务都进行配置，收集当然服务的请求数据（traceId 和 spanId），然后利用stream-sluth和binder-rabbit组件，将请求数据传输到 RabbitMQ。<br>Spring Cloud Zipkin：主要用于请求链路的 UI 展示，Zipkin 会从 RabbitMQ 读取请求数据，然后存储到 ElasticSearch 中，然后下次显示直接从 ElasticSearch 中读取。<br>Kibana：Kibana 也可以显示 ElasticSearch 中的请求数据，只不过不是图形化的，需要索引配置创建。</p>\n<h1 id=\"ELK-日志链路\"><a href=\"#ELK-日志链路\" class=\"headerlink\" title=\"ELK 日志链路\"></a>ELK 日志链路</h1><img src=\"/posts/1879991184/index/7.png\" class=\"\">\n\n<p>ELK 可以参考下之前的几篇文章：<br>ELK 架构之 Elasticsearch 和 Kibana 安装配置<br>ELK 架构之 Logstash 和 Filebeat 安装配置<br>ELK 架构之 Logstash 和 Filebeat 配置使用（采集过滤）<br>ELK 架构之 Elasticsearch、Kibana、Logstash 和 Filebeat 安装配置汇总（6.2.4 版本）<br>上面图中已经很详细介绍了下 ELK 的流程，ELK 默认技术栈里是没有 Filebeat 的，Logstash 用作日志收集的时候，CPU 和内存会占用资源比较大，所以我们使用轻量化的 Filebeat 进行日志的收集，Filebeat 部署在每个业务服务所在的服务器，然后将收集到的日志数据传输到 Logstash，Logstash 可以部署两到三台服务器上，用作日志的过滤和分析工作，然后再将处理后的日志数据，传输到 ElasticSearch 存储。</p>\n<h1 id=\"统一格式返回\"><a href=\"#统一格式返回\" class=\"headerlink\" title=\"统一格式返回\"></a>统一格式返回</h1><img src=\"/posts/1879991184/index/8.png\" class=\"\">\n\n"},{"title":"Java【基础篇之HashMap及hashcode】","abbrlink":2936205123,"date":"2019-10-10T02:12:00.000Z","cover":"https://cdn.tanxz.com/images/category/java.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","_content":"## 一、hashcode是什么\n要理解hashcode首先要理解hash表这个概念\n\n1. 哈希表\nhash表也称散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的hashcode是什么记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。\n简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。\n具有快速查找和插入操作的优点\n2. hashcode\nhashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置\n每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode\n## 二、hashcode的作用\n    HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的\n\n    对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。\n\n   在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题\n\n   如何判别在集合中是否已经存在该对象了？\n\n   首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。    此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了。\n\n    这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。\n\n            所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。\n\n## 三、 hashCode()和equals()\nJava的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)\n\n1. equals方法\nObject类中equals()方法实现如下\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。\n\n虽然可以重写equals()方法，但是有一些注意事项；JDK中说明了实现equals()方法应该遵守的约定\n\n自反性：x.equals(x)必须返回true。\n对称性：x.equals(y)与y.equals(x)的返回值必须相等。\n传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。\n一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。\n非null：x不是null，y为null，则x.equals(y)必须为false。\n2. hashCode 方法\nObject类中hashCode()方法的声明如下：\n\npublic native int hashCode();\n可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。\n\n与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：\n\n（1）hashCode()在哈希表中起作用，如java.util.HashMap。\n（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。\n（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。\n（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。\n重写hashcode()的原则\n\n（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。\n（2）hashCode()方法不能太过简单，否则哈希冲突过多。\n（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能\nhashCode()重写方法\n\n《Effective Java》中提出了一种简单通用的hashCode算法：\n\n初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;\n\n选取equals方法中用于比较的所有域（之所以只选择equals()中使用的域，是为了保证上述原则的第1条），然后针对每个域的属性进行计算：\n\n复制代码\n(1) 如果是boolean值，则计算f ? 1:0\n(2) 如果是bytecharshortint,则计算(int)f\n(3) 如果是long值，则计算(int)(f ^ (f >>> 32))\n(4) 如果是float值，则计算Float.floatToIntBits(f)\n(5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int\n(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0\n(7) 如果是数组，那么需要为每个元素当做单独的域来处理。java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上。 \n复制代码\n最后，把每个域的散列码合并到对象的哈希码中。\n\n## 四、HashMap中的hash()函数\nHashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n这段代码类似作用是为了增加hashcode的随机性\n\nkey.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。\n\nhashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个\"与\"操作\n\nstatic int indexFor(int h, int length) { return h & (length-1);}\n这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h & (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。\n  01111010 00111100 00100101\n& 00000000 00000000 00001111\n----------------------------------\n  00000000 00000000 00000101\n  //高位全部归零，只保留末四位 \nbut 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上成个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。\n\n这时候 “hash”函数作用就出来了\n\n右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。\n设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。\n根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。\nhashMap中 MAXIMUM_CAPACITY = 1 << 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）","source":"_posts/理论学习/java/hashcode.md","raw":"---\ntitle: Java【基础篇之HashMap及hashcode】\ntags:\n  - Java\nabbrlink: 2936205123\ndate: 2019-10-10 10:12:00\ncover: https://cdn.tanxz.com/images/category/java.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\n---\n## 一、hashcode是什么\n要理解hashcode首先要理解hash表这个概念\n\n1. 哈希表\nhash表也称散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。\n给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的hashcode是什么记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。\n简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。\n具有快速查找和插入操作的优点\n2. hashcode\nhashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置\n每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode\n## 二、hashcode的作用\n    HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的\n\n    对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。\n\n   在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题\n\n   如何判别在集合中是否已经存在该对象了？\n\n   首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。    此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了。\n\n    这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。\n\n            所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。\n\n## 三、 hashCode()和equals()\nJava的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)\n\n1. equals方法\nObject类中equals()方法实现如下\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。\n\n虽然可以重写equals()方法，但是有一些注意事项；JDK中说明了实现equals()方法应该遵守的约定\n\n自反性：x.equals(x)必须返回true。\n对称性：x.equals(y)与y.equals(x)的返回值必须相等。\n传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。\n一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。\n非null：x不是null，y为null，则x.equals(y)必须为false。\n2. hashCode 方法\nObject类中hashCode()方法的声明如下：\n\npublic native int hashCode();\n可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。\n\n与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：\n\n（1）hashCode()在哈希表中起作用，如java.util.HashMap。\n（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。\n（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。\n（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。\n重写hashcode()的原则\n\n（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。\n（2）hashCode()方法不能太过简单，否则哈希冲突过多。\n（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能\nhashCode()重写方法\n\n《Effective Java》中提出了一种简单通用的hashCode算法：\n\n初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;\n\n选取equals方法中用于比较的所有域（之所以只选择equals()中使用的域，是为了保证上述原则的第1条），然后针对每个域的属性进行计算：\n\n复制代码\n(1) 如果是boolean值，则计算f ? 1:0\n(2) 如果是bytecharshortint,则计算(int)f\n(3) 如果是long值，则计算(int)(f ^ (f >>> 32))\n(4) 如果是float值，则计算Float.floatToIntBits(f)\n(5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int\n(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0\n(7) 如果是数组，那么需要为每个元素当做单独的域来处理。java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上。 \n复制代码\n最后，把每个域的散列码合并到对象的哈希码中。\n\n## 四、HashMap中的hash()函数\nHashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n这段代码类似作用是为了增加hashcode的随机性\n\nkey.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。\n\nhashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个\"与\"操作\n\nstatic int indexFor(int h, int length) { return h & (length-1);}\n这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h & (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。\n  01111010 00111100 00100101\n& 00000000 00000000 00001111\n----------------------------------\n  00000000 00000000 00000101\n  //高位全部归零，只保留末四位 \nbut 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上成个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。\n\n这时候 “hash”函数作用就出来了\n\n右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。\n设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。\n根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。\nhashMap中 MAXIMUM_CAPACITY = 1 << 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）","slug":"理论学习/java/hashcode","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6h6000ttvcddgcad6ut","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、hashcode是什么\"><a href=\"#一、hashcode是什么\" class=\"headerlink\" title=\"一、hashcode是什么\"></a>一、hashcode是什么</h2><p>要理解hashcode首先要理解hash表这个概念</p>\n<ol>\n<li><p>哈希表<br>hash表也称散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的hashcode是什么记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。<br>简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。<br>具有快速查找和插入操作的优点</p>\n</li>\n<li><p>hashcode<br>hashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置<br>每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode</p>\n<h2 id=\"二、hashcode的作用\"><a href=\"#二、hashcode的作用\" class=\"headerlink\" title=\"二、hashcode的作用\"></a>二、hashcode的作用</h2><p> HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p>\n<p> 对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p>\n<p>在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题</p>\n<p>如何判别在集合中是否已经存在该对象了？</p>\n<p>首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。    此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了。</p>\n<p> 这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。</p>\n<pre><code>所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</code></pre></li>\n</ol>\n<h2 id=\"三、-hashCode-和equals\"><a href=\"#三、-hashCode-和equals\" class=\"headerlink\" title=\"三、 hashCode()和equals()\"></a>三、 hashCode()和equals()</h2><p>Java的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)</p>\n<ol>\n<li>equals方法<br>Object类中equals()方法实现如下</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">equals</span><span class=\"hljs-params\">(Object obj)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。</p>\n<p>虽然可以重写equals()方法，但是有一些注意事项；JDK中说明了实现equals()方法应该遵守的约定</p>\n<p>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。<br>2. hashCode 方法<br>Object类中hashCode()方法的声明如下：</p>\n<p>public native int hashCode();<br>可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。</p>\n<p>与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：</p>\n<p>（1）hashCode()在哈希表中起作用，如java.util.HashMap。<br>（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。<br>（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。<br>（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。<br>重写hashcode()的原则</p>\n<p>（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。<br>（2）hashCode()方法不能太过简单，否则哈希冲突过多。<br>（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能<br>hashCode()重写方法</p>\n<p>《Effective Java》中提出了一种简单通用的hashCode算法：</p>\n<p>初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;</p>\n<p>选取equals方法中用于比较的所有域（之所以只选择equals()中使用的域，是为了保证上述原则的第1条），然后针对每个域的属性进行计算：</p>\n<p>复制代码<br>(1) 如果是boolean值，则计算f ? 1:0<br>(2) 如果是bytecharshortint,则计算(int)f<br>(3) 如果是long值，则计算(int)(f ^ (f &gt;&gt;&gt; 32))<br>(4) 如果是float值，则计算Float.floatToIntBits(f)<br>(5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int<br>(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0<br>(7) 如果是数组，那么需要为每个元素当做单独的域来处理。java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上。<br>复制代码<br>最后，把每个域的散列码合并到对象的哈希码中。</p>\n<h2 id=\"四、HashMap中的hash-函数\"><a href=\"#四、HashMap中的hash-函数\" class=\"headerlink\" title=\"四、HashMap中的hash()函数\"></a>四、HashMap中的hash()函数</h2><p>HashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">static final int hash(Object key) &#123;<br>    int h;<br>    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这段代码类似作用是为了增加hashcode的随机性</p>\n<p>key.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>\n<p>hashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个”与”操作</p>\n<p>static int indexFor(int h, int length) { return h &amp; (length-1);}<br>这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h &amp; (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。<br>  01111010 00111100 00100101<br>&amp; 00000000 00000000 00001111</p>\n<hr>\n<p>  00000000 00000000 00000101<br>  //高位全部归零，只保留末四位<br>but 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上成个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。</p>\n<p>这时候 “hash”函数作用就出来了</p>\n<p>右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。<br>设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。<br>根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。<br>hashMap中 MAXIMUM_CAPACITY = 1 &lt;&lt; 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"一、hashcode是什么\"><a href=\"#一、hashcode是什么\" class=\"headerlink\" title=\"一、hashcode是什么\"></a>一、hashcode是什么</h2><p>要理解hashcode首先要理解hash表这个概念</p>\n<ol>\n<li><p>哈希表<br>hash表也称散列表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的hashcode是什么记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。<br>简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。<br>具有快速查找和插入操作的优点</p>\n</li>\n<li><p>hashcode<br>hashcode 通过hash函数计算得到，hashcode就是在hash表中有对应的位置<br>每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode</p>\n<h2 id=\"二、hashcode的作用\"><a href=\"#二、hashcode的作用\" class=\"headerlink\" title=\"二、hashcode的作用\"></a>二、hashcode的作用</h2><p> HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p>\n<p> 对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</p>\n<p>在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题</p>\n<p>如何判别在集合中是否已经存在该对象了？</p>\n<p>首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。    此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了。</p>\n<p> 这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。</p>\n<pre><code>所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</code></pre></li>\n</ol>\n<h2 id=\"三、-hashCode-和equals\"><a href=\"#三、-hashCode-和equals\" class=\"headerlink\" title=\"三、 hashCode()和equals()\"></a>三、 hashCode()和equals()</h2><p>Java的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)</p>\n<ol>\n<li>equals方法<br>Object类中equals()方法实现如下</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">equals</span><span class=\"hljs-params\">(Object obj)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。</p>\n<p>虽然可以重写equals()方法，但是有一些注意事项；JDK中说明了实现equals()方法应该遵守的约定</p>\n<p>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。<br>2. hashCode 方法<br>Object类中hashCode()方法的声明如下：</p>\n<p>public native int hashCode();<br>可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。</p>\n<p>与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：</p>\n<p>（1）hashCode()在哈希表中起作用，如java.util.HashMap。<br>（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。<br>（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。<br>（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。<br>重写hashcode()的原则</p>\n<p>（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。<br>（2）hashCode()方法不能太过简单，否则哈希冲突过多。<br>（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能<br>hashCode()重写方法</p>\n<p>《Effective Java》中提出了一种简单通用的hashCode算法：</p>\n<p>初始化一个整形变量，为此变量赋予一个非零的常数值，比如int result = 17;</p>\n<p>选取equals方法中用于比较的所有域（之所以只选择equals()中使用的域，是为了保证上述原则的第1条），然后针对每个域的属性进行计算：</p>\n<p>复制代码<br>(1) 如果是boolean值，则计算f ? 1:0<br>(2) 如果是bytecharshortint,则计算(int)f<br>(3) 如果是long值，则计算(int)(f ^ (f &gt;&gt;&gt; 32))<br>(4) 如果是float值，则计算Float.floatToIntBits(f)<br>(5) 如果是double值，则计算Double.doubleToLongBits(f)，然后返回的结果是long,再用规则(3)去处理long,得到int<br>(6) 如果是对象应用，如果equals方法中采取递归调用的比较方式，那么hashCode中同样采取递归调用hashCode的方式。否则需要为这个域计算一个范式，比如当这个域的值为null的时候，那么hashCode 值为0<br>(7) 如果是数组，那么需要为每个元素当做单独的域来处理。java.util.Arrays.hashCode方法包含了8种基本类型数组和引用数组的hashCode计算，算法同上。<br>复制代码<br>最后，把每个域的散列码合并到对象的哈希码中。</p>\n<h2 id=\"四、HashMap中的hash-函数\"><a href=\"#四、HashMap中的hash-函数\" class=\"headerlink\" title=\"四、HashMap中的hash()函数\"></a>四、HashMap中的hash()函数</h2><p>HashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">static final int hash(Object key) &#123;<br>    int h;<br>    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这段代码类似作用是为了增加hashcode的随机性</p>\n<p>key.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>\n<p>hashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个”与”操作</p>\n<p>static int indexFor(int h, int length) { return h &amp; (length-1);}<br>这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h &amp; (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。<br>  01111010 00111100 00100101<br>&amp; 00000000 00000000 00001111</p>\n<hr>\n<p>  00000000 00000000 00000101<br>  //高位全部归零，只保留末四位<br>but 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上成个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。</p>\n<p>这时候 “hash”函数作用就出来了</p>\n<p>右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。<br>设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。<br>根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。<br>hashMap中 MAXIMUM_CAPACITY = 1 &lt;&lt; 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）</p>\n"},{"title":"JVM【性能调优篇】","cover":"https://cdn.tanxz.com/images/category/java.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","abbrlink":3097382278,"date":"2016-10-16T03:54:14.000Z","_content":"\n前面我们学习了整个JVM系列，最终目标的不仅仅是了解JVM的基础知识，也是为了进行JVM性能调优做准备。这篇文章带领大家学习JVM性能调优的知识。\n\n### 性能调优\n性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。\n\n架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。\n\n性能调优基本上按照以下步骤进行：明确优化目标、发现性能瓶颈、性能调优、通过监控及数据统计工具获得数据、确认是否达到目标。\n\n### 何时进行JVM调优\n遇到以下情况，就需要考虑进行JVM调优了：\n- Heap内存（老年代）持续上涨达到设置的最大内存值；\n- Full GC 次数频繁；\n- GC 停顿时间过长（超过1秒）；\n- 应用出现OutOfMemory 等内存异常；\n- 应用中有使用本地缓存且占用大量内存空间；\n- 系统吞吐量与响应性能不高或下降。\n\n### JVM调优的基本原则\nJVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：\n\n- 大多数的Java应用不需要进行JVM优化；\n- 大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；\n- 上线之前，应先考虑将机器的JVM参数设置到最优；\n- 减少创建对象的数量（代码层面）；\n- 减少使用全局变量和大对象（代码层面）；\n- 优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；\n- 分析GC情况优化代码比优化JVM参数更好（代码层面）；\n\n通过以上原则，我们发现，其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。\n\n### JVM调优目标\n调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。\njvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。\n\n- 延迟：GC低停顿和GC低频率；\n- 低内存占用；\n- 高吞吐量;\n\n其中，任何一个属性性能的提高，几乎都是以牺牲其他属性性能的损为代价的，不可兼得。具体根据在业务中的重要性确定。\n\n### JVM调优量化目标\n下面展示了一些JVM调优的量化目标参考实例：\n\n- Heap 内存使用率 <= 70%;\n- Old generation内存使用率<= 70%;\n- avgpause <= 1秒;\n- Full gc 次数0 或 avg pause interval >= 24小时 ;\n\n注意：不同应用的JVM调优量化目标是不一样的。\n\n### JVM调优的步骤\n一般情况下，JVM调优可通过以下步骤进行：\n\n- 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；\n- 确定JVM调优量化目标；\n- 确定JVM调优参数（根据历史JVM参数来调整）；\n- 依次调优内存、延迟、吞吐量等指标；\n- 对比观察调优前后的差异；\n- 不断的分析和调整，直到找到合适的JVM参数配置；\n- 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。\n\n### JVM参数\nJVM调优最重要的工具就是JVM参数了。先来了解一下JVM参数相关内容。\n\n-XX 参数被称为不稳定参数，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。如果此类参数设置合理将大大提高JVM的性能及稳定性。\n\n不稳定参数语法规则包含以下内容。\n\n    布尔类型参数值：\n    -XX:+<option> '+'表示启用该选项\n    -XX:-<option> '-'表示关闭该选项\n    数字类型参数值：\n    -XX:<option>=<number>给选项设置一个数字类型值，可跟随单位，例如：'m'或'M'表示兆字节;'k'或'K'千字节;'g'或'G'千兆字节。32K与32768是相同大小的。\n    字符串类型参数值\n    -XX:<option>=<string>给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core\n\n\n### JVM参数解析及调优\n比如以下参数示例：\n\n    -Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15\n\n上面为Java7及以前版本的示例，在Java8中永久代的参数-XX:PermSize和-XX：MaxPermSize已经失效。这在前面章节中已经讲到。\n\n参数解析：\n```\n-Xmx4g：堆内存最大值为4GB。\n-Xms4g：初始化堆内存大小为4GB。\n-Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。\n-Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n-XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n-XX:SurvivorRatio=8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10\n-XX:PermSize=100m：初始化永久代大小为100MB。\n-XX:MaxPermSize=256m：设置持久代大小为256MB。\n-XX:MaxTenuringThreshold=15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n```\n新生代、老生代、永久代的参数，如果不进行指定，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。\n\n可调优参数：\n```\n-Xms：初始化堆内存大小，默认为物理内存的1/64(小于1GB)。\n-Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。\n-Xmn：新生代大小，包括Eden区与2个Survivor区。\n-XX:SurvivorRatio=1：Eden区与一个Survivor区比值为1:1。\n-XX:MaxDirectMemorySize=1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。\n-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。\n-XX:CMSInitiatingOccupancyFraction=60：老年代内存回收阈值，默认值为68。\n-XX:ConcGCThreads=4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。\n-XX:ParallelGCThreads=8：新生代并行收集器的线程数。\n-XX:MaxTenuringThreshold=10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n-XX:CMSFullGCsBeforeCompaction=4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。\n-XX:CMSMaxAbortablePrecleanTime=500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。\n```\n> 注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。\n\n在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。\n\n### 内存优化示例\n当JVM运行稳定之后，触发了FullGC我们一般会拿到如下信息:\n\nimage\n以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。\n\n    java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n    永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。\n    新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n    老年代：2-3倍FullGC后的老年代空间占用。\n\n基于以上规则，则对参数定义如下：\n```\njava -Xms373m -Xmx373m -Xmn140m -XX:PermSize=5m -XX:MaxPermSize=5m\n```\n\n### 延迟优化示例\n对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。\n\n- 应用程序可接受的平均停滞时间: 此时间与测量的Minor\n- GC持续时间进行比较。可接受的Minor GC频率：Minor\n- GC的频率与可容忍的值进行比较。\n- 可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。\n- 可接受的最大停顿发生的频率：基本就是FullGC的频率。\n\n其中，平均停滞时间和最大停顿时间，对用户体验最为重要。对于上面的指标，相关数据采集包括：MinorGC的持续时间、统计MinorGC的次数、FullGC的最差持续时间、最差情况下，FullGC的频率。\n\nimage\n如上图，Minor GC的平均持续时间0.069秒，MinorGC的频率为0.389秒一次。\n\n新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。\n\n这里以减少了新生代空间10%的大小，来减小延迟时间。在此过程中，应该保持老年代和持代的大小不变化。调优后的参数如下变化:\n```\njava -Xms359m -Xmx359m -Xmn126m -XX:PermSize=5m -XX:MaxPermSize=5m\n```\n### 吞吐量调优\n吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于整个应用的需求和测试而衍生出来的。\n\n评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。\n\n> 对于垃圾收集器来说，提升吞吐量的性能调优的目标就是尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。\n\n### 调优工具\n借助GCViewer日志分析工具，可以非常直观地分析出待调优点。可从以下几方面来分析：\n- Memory,分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；\n- Pause，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；","source":"_posts/理论学习/java/jvm.md","raw":"---\ntitle: JVM【性能调优篇】\ntags:\n  - Java\ncover: https://cdn.tanxz.com/images/category/java.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\nabbrlink: 3097382278\ndate: 2016-10-16 11:54:14\n\n---\n\n前面我们学习了整个JVM系列，最终目标的不仅仅是了解JVM的基础知识，也是为了进行JVM性能调优做准备。这篇文章带领大家学习JVM性能调优的知识。\n\n### 性能调优\n性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。\n\n架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。\n\n性能调优基本上按照以下步骤进行：明确优化目标、发现性能瓶颈、性能调优、通过监控及数据统计工具获得数据、确认是否达到目标。\n\n### 何时进行JVM调优\n遇到以下情况，就需要考虑进行JVM调优了：\n- Heap内存（老年代）持续上涨达到设置的最大内存值；\n- Full GC 次数频繁；\n- GC 停顿时间过长（超过1秒）；\n- 应用出现OutOfMemory 等内存异常；\n- 应用中有使用本地缓存且占用大量内存空间；\n- 系统吞吐量与响应性能不高或下降。\n\n### JVM调优的基本原则\nJVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：\n\n- 大多数的Java应用不需要进行JVM优化；\n- 大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；\n- 上线之前，应先考虑将机器的JVM参数设置到最优；\n- 减少创建对象的数量（代码层面）；\n- 减少使用全局变量和大对象（代码层面）；\n- 优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；\n- 分析GC情况优化代码比优化JVM参数更好（代码层面）；\n\n通过以上原则，我们发现，其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。\n\n### JVM调优目标\n调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。\njvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。\n\n- 延迟：GC低停顿和GC低频率；\n- 低内存占用；\n- 高吞吐量;\n\n其中，任何一个属性性能的提高，几乎都是以牺牲其他属性性能的损为代价的，不可兼得。具体根据在业务中的重要性确定。\n\n### JVM调优量化目标\n下面展示了一些JVM调优的量化目标参考实例：\n\n- Heap 内存使用率 <= 70%;\n- Old generation内存使用率<= 70%;\n- avgpause <= 1秒;\n- Full gc 次数0 或 avg pause interval >= 24小时 ;\n\n注意：不同应用的JVM调优量化目标是不一样的。\n\n### JVM调优的步骤\n一般情况下，JVM调优可通过以下步骤进行：\n\n- 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；\n- 确定JVM调优量化目标；\n- 确定JVM调优参数（根据历史JVM参数来调整）；\n- 依次调优内存、延迟、吞吐量等指标；\n- 对比观察调优前后的差异；\n- 不断的分析和调整，直到找到合适的JVM参数配置；\n- 找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。\n\n以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。\n\n### JVM参数\nJVM调优最重要的工具就是JVM参数了。先来了解一下JVM参数相关内容。\n\n-XX 参数被称为不稳定参数，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。如果此类参数设置合理将大大提高JVM的性能及稳定性。\n\n不稳定参数语法规则包含以下内容。\n\n    布尔类型参数值：\n    -XX:+<option> '+'表示启用该选项\n    -XX:-<option> '-'表示关闭该选项\n    数字类型参数值：\n    -XX:<option>=<number>给选项设置一个数字类型值，可跟随单位，例如：'m'或'M'表示兆字节;'k'或'K'千字节;'g'或'G'千兆字节。32K与32768是相同大小的。\n    字符串类型参数值\n    -XX:<option>=<string>给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core\n\n\n### JVM参数解析及调优\n比如以下参数示例：\n\n    -Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15\n\n上面为Java7及以前版本的示例，在Java8中永久代的参数-XX:PermSize和-XX：MaxPermSize已经失效。这在前面章节中已经讲到。\n\n参数解析：\n```\n-Xmx4g：堆内存最大值为4GB。\n-Xms4g：初始化堆内存大小为4GB。\n-Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。\n-Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n-XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n-XX:SurvivorRatio=8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10\n-XX:PermSize=100m：初始化永久代大小为100MB。\n-XX:MaxPermSize=256m：设置持久代大小为256MB。\n-XX:MaxTenuringThreshold=15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n```\n新生代、老生代、永久代的参数，如果不进行指定，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。\n\n可调优参数：\n```\n-Xms：初始化堆内存大小，默认为物理内存的1/64(小于1GB)。\n-Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。\n-Xmn：新生代大小，包括Eden区与2个Survivor区。\n-XX:SurvivorRatio=1：Eden区与一个Survivor区比值为1:1。\n-XX:MaxDirectMemorySize=1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。\n-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。\n-XX:CMSInitiatingOccupancyFraction=60：老年代内存回收阈值，默认值为68。\n-XX:ConcGCThreads=4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。\n-XX:ParallelGCThreads=8：新生代并行收集器的线程数。\n-XX:MaxTenuringThreshold=10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。\n-XX:CMSFullGCsBeforeCompaction=4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。\n-XX:CMSMaxAbortablePrecleanTime=500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。\n```\n> 注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。\n\n在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。\n\n### 内存优化示例\n当JVM运行稳定之后，触发了FullGC我们一般会拿到如下信息:\n\nimage\n以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。\n\n    java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n    永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。\n    新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n    老年代：2-3倍FullGC后的老年代空间占用。\n\n基于以上规则，则对参数定义如下：\n```\njava -Xms373m -Xmx373m -Xmn140m -XX:PermSize=5m -XX:MaxPermSize=5m\n```\n\n### 延迟优化示例\n对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。\n\n- 应用程序可接受的平均停滞时间: 此时间与测量的Minor\n- GC持续时间进行比较。可接受的Minor GC频率：Minor\n- GC的频率与可容忍的值进行比较。\n- 可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。\n- 可接受的最大停顿发生的频率：基本就是FullGC的频率。\n\n其中，平均停滞时间和最大停顿时间，对用户体验最为重要。对于上面的指标，相关数据采集包括：MinorGC的持续时间、统计MinorGC的次数、FullGC的最差持续时间、最差情况下，FullGC的频率。\n\nimage\n如上图，Minor GC的平均持续时间0.069秒，MinorGC的频率为0.389秒一次。\n\n新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。\n\n这里以减少了新生代空间10%的大小，来减小延迟时间。在此过程中，应该保持老年代和持代的大小不变化。调优后的参数如下变化:\n```\njava -Xms359m -Xmx359m -Xmn126m -XX:PermSize=5m -XX:MaxPermSize=5m\n```\n### 吞吐量调优\n吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于整个应用的需求和测试而衍生出来的。\n\n评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。\n\n> 对于垃圾收集器来说，提升吞吐量的性能调优的目标就是尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。\n\n### 调优工具\n借助GCViewer日志分析工具，可以非常直观地分析出待调优点。可从以下几方面来分析：\n- Memory,分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；\n- Pause，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；","slug":"理论学习/java/jvm","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6h7000utvcd1qtx9z3h","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前面我们学习了整个JVM系列，最终目标的不仅仅是了解JVM的基础知识，也是为了进行JVM性能调优做准备。这篇文章带领大家学习JVM性能调优的知识。</p>\n<h3 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h3><p>性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。</p>\n<p>架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。</p>\n<p>性能调优基本上按照以下步骤进行：明确优化目标、发现性能瓶颈、性能调优、通过监控及数据统计工具获得数据、确认是否达到目标。</p>\n<h3 id=\"何时进行JVM调优\"><a href=\"#何时进行JVM调优\" class=\"headerlink\" title=\"何时进行JVM调优\"></a>何时进行JVM调优</h3><p>遇到以下情况，就需要考虑进行JVM调优了：</p>\n<ul>\n<li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li>\n<li>Full GC 次数频繁；</li>\n<li>GC 停顿时间过长（超过1秒）；</li>\n<li>应用出现OutOfMemory 等内存异常；</li>\n<li>应用中有使用本地缓存且占用大量内存空间；</li>\n<li>系统吞吐量与响应性能不高或下降。</li>\n</ul>\n<h3 id=\"JVM调优的基本原则\"><a href=\"#JVM调优的基本原则\" class=\"headerlink\" title=\"JVM调优的基本原则\"></a>JVM调优的基本原则</h3><p>JVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：</p>\n<ul>\n<li>大多数的Java应用不需要进行JVM优化；</li>\n<li>大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；</li>\n<li>上线之前，应先考虑将机器的JVM参数设置到最优；</li>\n<li>减少创建对象的数量（代码层面）；</li>\n<li>减少使用全局变量和大对象（代码层面）；</li>\n<li>优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；</li>\n<li>分析GC情况优化代码比优化JVM参数更好（代码层面）；</li>\n</ul>\n<p>通过以上原则，我们发现，其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。</p>\n<h3 id=\"JVM调优目标\"><a href=\"#JVM调优目标\" class=\"headerlink\" title=\"JVM调优目标\"></a>JVM调优目标</h3><p>调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。<br>jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。</p>\n<ul>\n<li>延迟：GC低停顿和GC低频率；</li>\n<li>低内存占用；</li>\n<li>高吞吐量;</li>\n</ul>\n<p>其中，任何一个属性性能的提高，几乎都是以牺牲其他属性性能的损为代价的，不可兼得。具体根据在业务中的重要性确定。</p>\n<h3 id=\"JVM调优量化目标\"><a href=\"#JVM调优量化目标\" class=\"headerlink\" title=\"JVM调优量化目标\"></a>JVM调优量化目标</h3><p>下面展示了一些JVM调优的量化目标参考实例：</p>\n<ul>\n<li>Heap 内存使用率 &lt;= 70%;</li>\n<li>Old generation内存使用率&lt;= 70%;</li>\n<li>avgpause &lt;= 1秒;</li>\n<li>Full gc 次数0 或 avg pause interval &gt;= 24小时 ;</li>\n</ul>\n<p>注意：不同应用的JVM调优量化目标是不一样的。</p>\n<h3 id=\"JVM调优的步骤\"><a href=\"#JVM调优的步骤\" class=\"headerlink\" title=\"JVM调优的步骤\"></a>JVM调优的步骤</h3><p>一般情况下，JVM调优可通过以下步骤进行：</p>\n<ul>\n<li>分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li>\n<li>确定JVM调优量化目标；</li>\n<li>确定JVM调优参数（根据历史JVM参数来调整）；</li>\n<li>依次调优内存、延迟、吞吐量等指标；</li>\n<li>对比观察调优前后的差异；</li>\n<li>不断的分析和调整，直到找到合适的JVM参数配置；</li>\n<li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li>\n</ul>\n<p>以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。</p>\n<h3 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h3><p>JVM调优最重要的工具就是JVM参数了。先来了解一下JVM参数相关内容。</p>\n<p>-XX 参数被称为不稳定参数，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。如果此类参数设置合理将大大提高JVM的性能及稳定性。</p>\n<p>不稳定参数语法规则包含以下内容。</p>\n<pre><code>布尔类型参数值：\n-XX:+&lt;option&gt; &apos;+&apos;表示启用该选项\n-XX:-&lt;option&gt; &apos;-&apos;表示关闭该选项\n数字类型参数值：\n-XX:&lt;option&gt;=&lt;number&gt;给选项设置一个数字类型值，可跟随单位，例如：&apos;m&apos;或&apos;M&apos;表示兆字节;&apos;k&apos;或&apos;K&apos;千字节;&apos;g&apos;或&apos;G&apos;千兆字节。32K与32768是相同大小的。\n字符串类型参数值\n-XX:&lt;option&gt;=&lt;string&gt;给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core</code></pre><h3 id=\"JVM参数解析及调优\"><a href=\"#JVM参数解析及调优\" class=\"headerlink\" title=\"JVM参数解析及调优\"></a>JVM参数解析及调优</h3><p>比如以下参数示例：</p>\n<pre><code>-Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15</code></pre><p>上面为Java7及以前版本的示例，在Java8中永久代的参数-XX:PermSize和-XX：MaxPermSize已经失效。这在前面章节中已经讲到。</p>\n<p>参数解析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">-Xmx4g：堆内存最大值为4GB。<br>-Xms4g：初始化堆内存大小为4GB。<br>-Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。<br>-Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。<br>-XX:NewRatio&#x3D;4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5<br>-XX:SurvivorRatio&#x3D;8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1&#x2F;10<br>-XX:PermSize&#x3D;100m：初始化永久代大小为100MB。<br>-XX:MaxPermSize&#x3D;256m：设置持久代大小为256MB。<br>-XX:MaxTenuringThreshold&#x3D;15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。<br></code></pre></td></tr></table></figure>\n<p>新生代、老生代、永久代的参数，如果不进行指定，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。</p>\n<p>可调优参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">-Xms：初始化堆内存大小，默认为物理内存的1&#x2F;64(小于1GB)。<br>-Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。<br>-Xmn：新生代大小，包括Eden区与2个Survivor区。<br>-XX:SurvivorRatio&#x3D;1：Eden区与一个Survivor区比值为1:1。<br>-XX:MaxDirectMemorySize&#x3D;1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。<br>-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。<br>-XX:CMSInitiatingOccupancyFraction&#x3D;60：老年代内存回收阈值，默认值为68。<br>-XX:ConcGCThreads&#x3D;4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。<br>-XX:ParallelGCThreads&#x3D;8：新生代并行收集器的线程数。<br>-XX:MaxTenuringThreshold&#x3D;10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。<br>-XX:CMSFullGCsBeforeCompaction&#x3D;4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。<br>-XX:CMSMaxAbortablePrecleanTime&#x3D;500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。</p>\n</blockquote>\n<p>在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。</p>\n<h3 id=\"内存优化示例\"><a href=\"#内存优化示例\" class=\"headerlink\" title=\"内存优化示例\"></a>内存优化示例</h3><p>当JVM运行稳定之后，触发了FullGC我们一般会拿到如下信息:</p>\n<p>image<br>以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。</p>\n<pre><code>java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。\n新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n老年代：2-3倍FullGC后的老年代空间占用。</code></pre><p>基于以上规则，则对参数定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">java -Xms373m -Xmx373m -Xmn140m -XX:PermSize&#x3D;5m -XX:MaxPermSize&#x3D;5m<br></code></pre></td></tr></table></figure>\n<h3 id=\"延迟优化示例\"><a href=\"#延迟优化示例\" class=\"headerlink\" title=\"延迟优化示例\"></a>延迟优化示例</h3><p>对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。</p>\n<ul>\n<li>应用程序可接受的平均停滞时间: 此时间与测量的Minor</li>\n<li>GC持续时间进行比较。可接受的Minor GC频率：Minor</li>\n<li>GC的频率与可容忍的值进行比较。</li>\n<li>可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。</li>\n<li>可接受的最大停顿发生的频率：基本就是FullGC的频率。</li>\n</ul>\n<p>其中，平均停滞时间和最大停顿时间，对用户体验最为重要。对于上面的指标，相关数据采集包括：MinorGC的持续时间、统计MinorGC的次数、FullGC的最差持续时间、最差情况下，FullGC的频率。</p>\n<p>image<br>如上图，Minor GC的平均持续时间0.069秒，MinorGC的频率为0.389秒一次。</p>\n<p>新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。</p>\n<p>这里以减少了新生代空间10%的大小，来减小延迟时间。在此过程中，应该保持老年代和持代的大小不变化。调优后的参数如下变化:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">java -Xms359m -Xmx359m -Xmn126m -XX:PermSize&#x3D;5m -XX:MaxPermSize&#x3D;5m<br></code></pre></td></tr></table></figure>\n<h3 id=\"吞吐量调优\"><a href=\"#吞吐量调优\" class=\"headerlink\" title=\"吞吐量调优\"></a>吞吐量调优</h3><p>吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于整个应用的需求和测试而衍生出来的。</p>\n<p>评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。</p>\n<blockquote>\n<p>对于垃圾收集器来说，提升吞吐量的性能调优的目标就是尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。</p>\n</blockquote>\n<h3 id=\"调优工具\"><a href=\"#调优工具\" class=\"headerlink\" title=\"调优工具\"></a>调优工具</h3><p>借助GCViewer日志分析工具，可以非常直观地分析出待调优点。可从以下几方面来分析：</p>\n<ul>\n<li>Memory,分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；</li>\n<li>Pause，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p>前面我们学习了整个JVM系列，最终目标的不仅仅是了解JVM的基础知识，也是为了进行JVM性能调优做准备。这篇文章带领大家学习JVM性能调优的知识。</p>\n<h3 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h3><p>性能调优包含多个层次，比如：架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。</p>\n<p>架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。</p>\n<p>性能调优基本上按照以下步骤进行：明确优化目标、发现性能瓶颈、性能调优、通过监控及数据统计工具获得数据、确认是否达到目标。</p>\n<h3 id=\"何时进行JVM调优\"><a href=\"#何时进行JVM调优\" class=\"headerlink\" title=\"何时进行JVM调优\"></a>何时进行JVM调优</h3><p>遇到以下情况，就需要考虑进行JVM调优了：</p>\n<ul>\n<li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li>\n<li>Full GC 次数频繁；</li>\n<li>GC 停顿时间过长（超过1秒）；</li>\n<li>应用出现OutOfMemory 等内存异常；</li>\n<li>应用中有使用本地缓存且占用大量内存空间；</li>\n<li>系统吞吐量与响应性能不高或下降。</li>\n</ul>\n<h3 id=\"JVM调优的基本原则\"><a href=\"#JVM调优的基本原则\" class=\"headerlink\" title=\"JVM调优的基本原则\"></a>JVM调优的基本原则</h3><p>JVM调优是一个手段，但并不一定所有问题都可以通过JVM进行调优解决，因此，在进行JVM调优时，我们要遵循一些原则：</p>\n<ul>\n<li>大多数的Java应用不需要进行JVM优化；</li>\n<li>大多数导致GC问题的原因是代码层面的问题导致的（代码层面）；</li>\n<li>上线之前，应先考虑将机器的JVM参数设置到最优；</li>\n<li>减少创建对象的数量（代码层面）；</li>\n<li>减少使用全局变量和大对象（代码层面）；</li>\n<li>优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）；</li>\n<li>分析GC情况优化代码比优化JVM参数更好（代码层面）；</li>\n</ul>\n<p>通过以上原则，我们发现，其实最有效的优化手段是架构和代码层面的优化，而JVM优化则是最后不得已的手段，也可以说是对服务器配置的最后一次“压榨”。</p>\n<h3 id=\"JVM调优目标\"><a href=\"#JVM调优目标\" class=\"headerlink\" title=\"JVM调优目标\"></a>JVM调优目标</h3><p>调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。<br>jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。</p>\n<ul>\n<li>延迟：GC低停顿和GC低频率；</li>\n<li>低内存占用；</li>\n<li>高吞吐量;</li>\n</ul>\n<p>其中，任何一个属性性能的提高，几乎都是以牺牲其他属性性能的损为代价的，不可兼得。具体根据在业务中的重要性确定。</p>\n<h3 id=\"JVM调优量化目标\"><a href=\"#JVM调优量化目标\" class=\"headerlink\" title=\"JVM调优量化目标\"></a>JVM调优量化目标</h3><p>下面展示了一些JVM调优的量化目标参考实例：</p>\n<ul>\n<li>Heap 内存使用率 &lt;= 70%;</li>\n<li>Old generation内存使用率&lt;= 70%;</li>\n<li>avgpause &lt;= 1秒;</li>\n<li>Full gc 次数0 或 avg pause interval &gt;= 24小时 ;</li>\n</ul>\n<p>注意：不同应用的JVM调优量化目标是不一样的。</p>\n<h3 id=\"JVM调优的步骤\"><a href=\"#JVM调优的步骤\" class=\"headerlink\" title=\"JVM调优的步骤\"></a>JVM调优的步骤</h3><p>一般情况下，JVM调优可通过以下步骤进行：</p>\n<ul>\n<li>分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li>\n<li>确定JVM调优量化目标；</li>\n<li>确定JVM调优参数（根据历史JVM参数来调整）；</li>\n<li>依次调优内存、延迟、吞吐量等指标；</li>\n<li>对比观察调优前后的差异；</li>\n<li>不断的分析和调整，直到找到合适的JVM参数配置；</li>\n<li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li>\n</ul>\n<p>以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。</p>\n<h3 id=\"JVM参数\"><a href=\"#JVM参数\" class=\"headerlink\" title=\"JVM参数\"></a>JVM参数</h3><p>JVM调优最重要的工具就是JVM参数了。先来了解一下JVM参数相关内容。</p>\n<p>-XX 参数被称为不稳定参数，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。如果此类参数设置合理将大大提高JVM的性能及稳定性。</p>\n<p>不稳定参数语法规则包含以下内容。</p>\n<pre><code>布尔类型参数值：\n-XX:+&lt;option&gt; &apos;+&apos;表示启用该选项\n-XX:-&lt;option&gt; &apos;-&apos;表示关闭该选项\n数字类型参数值：\n-XX:&lt;option&gt;=&lt;number&gt;给选项设置一个数字类型值，可跟随单位，例如：&apos;m&apos;或&apos;M&apos;表示兆字节;&apos;k&apos;或&apos;K&apos;千字节;&apos;g&apos;或&apos;G&apos;千兆字节。32K与32768是相同大小的。\n字符串类型参数值\n-XX:&lt;option&gt;=&lt;string&gt;给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core</code></pre><h3 id=\"JVM参数解析及调优\"><a href=\"#JVM参数解析及调优\" class=\"headerlink\" title=\"JVM参数解析及调优\"></a>JVM参数解析及调优</h3><p>比如以下参数示例：</p>\n<pre><code>-Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15</code></pre><p>上面为Java7及以前版本的示例，在Java8中永久代的参数-XX:PermSize和-XX：MaxPermSize已经失效。这在前面章节中已经讲到。</p>\n<p>参数解析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">-Xmx4g：堆内存最大值为4GB。<br>-Xms4g：初始化堆内存大小为4GB。<br>-Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3&#x2F;8。<br>-Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。<br>-XX:NewRatio&#x3D;4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1&#x2F;5<br>-XX:SurvivorRatio&#x3D;8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1&#x2F;10<br>-XX:PermSize&#x3D;100m：初始化永久代大小为100MB。<br>-XX:MaxPermSize&#x3D;256m：设置持久代大小为256MB。<br>-XX:MaxTenuringThreshold&#x3D;15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。<br></code></pre></td></tr></table></figure>\n<p>新生代、老生代、永久代的参数，如果不进行指定，虚拟机会自动选择合适的值，同时也会基于系统的开销自动调整。</p>\n<p>可调优参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">-Xms：初始化堆内存大小，默认为物理内存的1&#x2F;64(小于1GB)。<br>-Xmx：堆内存最大值。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。<br>-Xmn：新生代大小，包括Eden区与2个Survivor区。<br>-XX:SurvivorRatio&#x3D;1：Eden区与一个Survivor区比值为1:1。<br>-XX:MaxDirectMemorySize&#x3D;1G：直接内存。报java.lang.OutOfMemoryError: Direct buffer memory异常可以上调这个值。<br>-XX:+DisableExplicitGC：禁止运行期显式地调用System.gc()来触发fulll GC。<br>-XX:CMSInitiatingOccupancyFraction&#x3D;60：老年代内存回收阈值，默认值为68。<br>-XX:ConcGCThreads&#x3D;4：CMS垃圾回收器并行线程线，推荐值为CPU核心数。<br>-XX:ParallelGCThreads&#x3D;8：新生代并行收集器的线程数。<br>-XX:MaxTenuringThreshold&#x3D;10：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。<br>-XX:CMSFullGCsBeforeCompaction&#x3D;4：指定进行多少次fullGC之后，进行tenured区 内存空间压缩。<br>-XX:CMSMaxAbortablePrecleanTime&#x3D;500：当abortable-preclean预清理阶段执行达到这个时间时就会结束。<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>注意: Java RMI的定时GC触发机制可通过配置-Dsun.rmi.dgc.server.gcInterval=86400来控制触发的时间。</p>\n</blockquote>\n<p>在设置的时候，如果关注性能开销的话，应尽量把永久代的初始值与最大值设置为同一值，因为永久代的大小调整需要进行FullGC才能实现。</p>\n<h3 id=\"内存优化示例\"><a href=\"#内存优化示例\" class=\"headerlink\" title=\"内存优化示例\"></a>内存优化示例</h3><p>当JVM运行稳定之后，触发了FullGC我们一般会拿到如下信息:</p>\n<p>image<br>以上gc日志中，在发生fullGC之时，整个应用的堆占用以及GC时间。为了更加精确需多次收集，计算平均值。或者是采用耗时最长的一次FullGC来进行估算。上图中，老年代空间占用在93168kb（约93MB），以此定为老年代空间的活跃数据。则其他堆空间的分配，基于以下规则来进行。</p>\n<pre><code>java heap：参数-Xms和-Xmx，建议扩大至3-4倍FullGC后的老年代空间占用。\n永久代：-XX:PermSize和-XX:MaxPermSize，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。\n新生代：-Xmn，建议扩大至1-1.5倍FullGC之后的老年代空间占用。\n老年代：2-3倍FullGC后的老年代空间占用。</code></pre><p>基于以上规则，则对参数定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">java -Xms373m -Xmx373m -Xmn140m -XX:PermSize&#x3D;5m -XX:MaxPermSize&#x3D;5m<br></code></pre></td></tr></table></figure>\n<h3 id=\"延迟优化示例\"><a href=\"#延迟优化示例\" class=\"headerlink\" title=\"延迟优化示例\"></a>延迟优化示例</h3><p>对延迟性优化，首先需要了解延迟性需求及可调优的指标有哪些。</p>\n<ul>\n<li>应用程序可接受的平均停滞时间: 此时间与测量的Minor</li>\n<li>GC持续时间进行比较。可接受的Minor GC频率：Minor</li>\n<li>GC的频率与可容忍的值进行比较。</li>\n<li>可接受的最大停顿时间:最大停顿时间与最差情况下FullGC的持续时间进行比较。</li>\n<li>可接受的最大停顿发生的频率：基本就是FullGC的频率。</li>\n</ul>\n<p>其中，平均停滞时间和最大停顿时间，对用户体验最为重要。对于上面的指标，相关数据采集包括：MinorGC的持续时间、统计MinorGC的次数、FullGC的最差持续时间、最差情况下，FullGC的频率。</p>\n<p>image<br>如上图，Minor GC的平均持续时间0.069秒，MinorGC的频率为0.389秒一次。</p>\n<p>新生代空间越大，Minor GC的GC时间越长，频率越低。如果想减少其持续时长，就需要减少其空间大小。如果想减小其频率，就需要加大其空间大小。</p>\n<p>这里以减少了新生代空间10%的大小，来减小延迟时间。在此过程中，应该保持老年代和持代的大小不变化。调优后的参数如下变化:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">java -Xms359m -Xmx359m -Xmn126m -XX:PermSize&#x3D;5m -XX:MaxPermSize&#x3D;5m<br></code></pre></td></tr></table></figure>\n<h3 id=\"吞吐量调优\"><a href=\"#吞吐量调优\" class=\"headerlink\" title=\"吞吐量调优\"></a>吞吐量调优</h3><p>吞吐量调优主要是基于应用程序的吞吐量要求而来的，应用程序应该有一个综合的吞吐指标，这个指标基于整个应用的需求和测试而衍生出来的。</p>\n<p>评估当前吞吐量和目标差距是否巨大，如果在20%左右，可以修改参数，加大内存，再次从头调试，如果巨大就需要从整个应用层面来考虑，设计以及目标是否一致了，重新评估吞吐目标。</p>\n<blockquote>\n<p>对于垃圾收集器来说，提升吞吐量的性能调优的目标就是尽可能避免或者很少发生FullGC或者Stop-The-World压缩式垃圾收集（CMS），因为这两种方式都会造成应用程序吞吐降低。尽量在MinorGC 阶段回收更多的对象，避免对象提升过快到老年代。</p>\n</blockquote>\n<h3 id=\"调优工具\"><a href=\"#调优工具\" class=\"headerlink\" title=\"调优工具\"></a>调优工具</h3><p>借助GCViewer日志分析工具，可以非常直观地分析出待调优点。可从以下几方面来分析：</p>\n<ul>\n<li>Memory,分析Totalheap、Tenuredheap、Youngheap内存占用率及其他指标，理论上内存占用率越小越好；</li>\n<li>Pause，分析Gc pause、Fullgc pause、Total pause三个大项中各指标，理论上GC次数越少越好，GC时长越小越好；</li>\n</ul>\n"},{"title":"Mac使用openssl生成pem证书","date":"2018-12-06T16:00:00.000Z","abbrlink":250724270,"cover":"https://cdn.tanxz.com/images/category/macos.png","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","_content":"\n# 参考资料\n\n> [openssl命令详解](https://www.jianshu.com/p/e311a6537467)\n\n------\n\n# 常规方式\n\n- 生成私钥(key文件)\n  `openssl genrsa -out client.key 4096`\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200804191059375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n  ![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gikNX2aZ-1596539441689)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p74)]](https://img-blog.csdnimg.cn/20200804191113618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n- 生成签名请求(csr文件)\n  `openssl req -new -key client.key -out client.csr`\n  ![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lPkpDIT9-1596539441690)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p75)]](https://img-blog.csdnimg.cn/20200804191128743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n- 签发证书\n  `openssl x509 -req -days 365 -in client.csr -signkey client.key -out client.crt`\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200804191353313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n\n------\n\n# 一键生成自签名证书\n\n`openssl req -new -x509 -newkey rsa:4096 -keyout test.key -out test.crt`\n![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jt7UJ692-1596539441692)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p76)]](https://img-blog.csdnimg.cn/20200804191401941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n\n> tips\n> 输入的密码必须大于等于4位。\n> Common Name可以输入：*.yourdomain.com，这种方式生成通配符域名证书。\n> 证书文件crt中存储的是证书信息与公钥信息，key文件存储的是私钥信息，csr是申请证书所需要的中间文件。","source":"_posts/技术分享/mac/Mac命令生成crt证书.md","raw":"---\ntitle: Mac使用openssl生成pem证书\ncategories: \n  \t- 技术实践\ntags:\n\t- RAS\n\t- Mac\ndate: 2018-12-07\nabbrlink: 250724270\ncover: https://cdn.tanxz.com/images/category/macos.png\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\n---\n\n# 参考资料\n\n> [openssl命令详解](https://www.jianshu.com/p/e311a6537467)\n\n------\n\n# 常规方式\n\n- 生成私钥(key文件)\n  `openssl genrsa -out client.key 4096`\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200804191059375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n  ![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gikNX2aZ-1596539441689)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p74)]](https://img-blog.csdnimg.cn/20200804191113618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n- 生成签名请求(csr文件)\n  `openssl req -new -key client.key -out client.csr`\n  ![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lPkpDIT9-1596539441690)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p75)]](https://img-blog.csdnimg.cn/20200804191128743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n- 签发证书\n  `openssl x509 -req -days 365 -in client.csr -signkey client.key -out client.crt`\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200804191353313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n\n------\n\n# 一键生成自签名证书\n\n`openssl req -new -x509 -newkey rsa:4096 -keyout test.key -out test.crt`\n![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jt7UJ692-1596539441692)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p76)]](https://img-blog.csdnimg.cn/20200804191401941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70)\n\n> tips\n> 输入的密码必须大于等于4位。\n> Common Name可以输入：*.yourdomain.com，这种方式生成通配符域名证书。\n> 证书文件crt中存储的是证书信息与公钥信息，key文件存储的是私钥信息，csr是申请证书所需要的中间文件。","slug":"技术分享/mac/Mac命令生成crt证书","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6h8000xtvcd0gfb8l3h","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"https://www.jianshu.com/p/e311a6537467\">openssl命令详解</a></p>\n</blockquote>\n<hr>\n<h1 id=\"常规方式\"><a href=\"#常规方式\" class=\"headerlink\" title=\"常规方式\"></a>常规方式</h1><ul>\n<li>生成私钥(key文件)<br><code>openssl genrsa -out client.key 4096</code><br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200804191059375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200804191113618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gikNX2aZ-1596539441689)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p74)]\"></li>\n<li>生成签名请求(csr文件)<br><code>openssl req -new -key client.key -out client.csr</code><br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200804191128743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lPkpDIT9-1596539441690)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p75)]\"></li>\n<li>签发证书<br><code>openssl x509 -req -days 365 -in client.csr -signkey client.key -out client.crt</code><br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200804191353313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<hr>\n<h1 id=\"一键生成自签名证书\"><a href=\"#一键生成自签名证书\" class=\"headerlink\" title=\"一键生成自签名证书\"></a>一键生成自签名证书</h1><p><code>openssl req -new -x509 -newkey rsa:4096 -keyout test.key -out test.crt</code><br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200804191401941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jt7UJ692-1596539441692)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p76)]\"></p>\n<blockquote>\n<p>tips<br>输入的密码必须大于等于4位。<br>Common Name可以输入：*.yourdomain.com，这种方式生成通配符域名证书。<br>证书文件crt中存储的是证书信息与公钥信息，key文件存储的是私钥信息，csr是申请证书所需要的中间文件。</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"https://www.jianshu.com/p/e311a6537467\">openssl命令详解</a></p>\n</blockquote>\n<hr>\n<h1 id=\"常规方式\"><a href=\"#常规方式\" class=\"headerlink\" title=\"常规方式\"></a>常规方式</h1><ul>\n<li>生成私钥(key文件)<br><code>openssl genrsa -out client.key 4096</code><br><img src=\"https://img-blog.csdnimg.cn/20200804191059375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20200804191113618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gikNX2aZ-1596539441689)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p74)]\"></li>\n<li>生成签名请求(csr文件)<br><code>openssl req -new -key client.key -out client.csr</code><br><img src=\"https://img-blog.csdnimg.cn/20200804191128743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lPkpDIT9-1596539441690)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p75)]\"></li>\n<li>签发证书<br><code>openssl x509 -req -days 365 -in client.csr -signkey client.key -out client.crt</code><br><img src=\"https://img-blog.csdnimg.cn/20200804191353313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<hr>\n<h1 id=\"一键生成自签名证书\"><a href=\"#一键生成自签名证书\" class=\"headerlink\" title=\"一键生成自签名证书\"></a>一键生成自签名证书</h1><p><code>openssl req -new -x509 -newkey rsa:4096 -keyout test.key -out test.crt</code><br><img src=\"https://img-blog.csdnimg.cn/20200804191401941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODc0OTMw,size_16,color_FFFFFF,t_70\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-jt7UJ692-1596539441692)(evernotecid://90B54479-F8FA-4F06-9F90-73E6593C6866/appyinxiangcom/27458002/ENResource/p76)]\"></p>\n<blockquote>\n<p>tips<br>输入的密码必须大于等于4位。<br>Common Name可以输入：*.yourdomain.com，这种方式生成通配符域名证书。<br>证书文件crt中存储的是证书信息与公钥信息，key文件存储的是私钥信息，csr是申请证书所需要的中间文件。</p>\n</blockquote>\n"},{"title":"Mac使用openssl生成pem证书","abbrlink":250724269,"date":"2018-12-06T16:00:00.000Z","cover":"https://cdn.tanxz.com/images/category/macos.png","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","_content":"\n#### 安装\n\nopenssl，若已安装则跳过\n\n```\nbrew install openssl\n```\n\n#### 生成RSA私钥\n\n使用openssl来生成RSA私钥文件，输入如下命令(该命令会生成2048位的私钥)\n\n```\nopenssl genrsa -out rsa_private_key.pem 2048\n```\n\n显示如下结果则生成私钥成功\n\n```\nMacBook-Pro-6:pem tanxinzheng$ openssl genrsa -out rsa_private_key.pem 2048\nGenerating RSA private key, 2048 bit long modulus\n....................+++\n.+++\ne is 65537 (0x10001)\nMacBook-Pro-6:pem tanxinzheng$ ll\ntotal 8\n-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem\n```\n\n查看私钥文件内容，RSA私钥格式如下：\n\n> 注：因太长.....省略部分内容\n\n```\n-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAzVHzaYFDgEDhIllCBZppYKsaLdYaC9D7IdkBMqroteeHRCaW\nrUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX/JsuYCUnqi3M0iqAFYWIyX7sXoKG\np3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdYhImkxzt/njmQRJCLjNl7fHh6sc1R\nG7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0Gn8dObD0G/kuQEWFJpmIBbzT9zizv\n........\n2xYP/ZoYb6wAe4PzYlJTi/rD8vBdLuBqBKInBfHDe4WvUgOv4Xiu1vxs7lDPyPw5\n2RnLAoGBANpHS9MdFlO6CtOVC1HYMifGY4LcxN7mnJJld2LP7v08pRzhwokMaIBu\ncBH/R0utDLsU9nivvdKjeacQ70pLPpAqDLsQWQxLvOXLLCooLC3RJqpsQp1l4g/I\nsqBVHkCKFTWAw7K28sZdchBHtM/ELH5Tbac2uPEEWtDpzBJ8n4on\n-----END RSA PRIVATE KEY-----\n```\n\n#### 生成RSA公钥\n\n使用如下命令生成公钥：\n\n```\nopenssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem\n```\n\n显示如下结果则生成公钥成功\n\n```\nMacBook-Pro-6:pem tanxinzheng$ openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem\nwriting RSA key\nMacBook-Pro-6:pem tanxinzheng$ ll\ntotal 16\n-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem\n-rw-r--r--  1 tanxinzheng  staff   451 Dec 17 18:47 rsa_public_key.pem\n```\n\n查看公钥文件内容，RSA公钥格式如下：\n\n```\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzVHzaYFDgEDhIllCBZpp\nYKsaLdYaC9D7IdkBMqroteeHRCaWrUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX\n/JsuYCUnqi3M0iqAFYWIyX7sXoKGp3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdY\nhImkxzt/njmQRJCLjNl7fHh6sc1RG7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0G\nn8dObD0G/kuQEWFJpmIBbzT9zizvWsI5gc3jl1Ifp3urk+cexWmZpqavCRK08aee\n5+yqXOk3xk8dqjX4zk6J66bDbiEYQXZcZTaCnTDDiZ4/UiqTue9lKZeUoveuwIfX\nWwIDAQAB\n-----END PUBLIC KEY-----\n```\n\n\n\n","source":"_posts/技术分享/mac/Mac命令生成pem证书.md","raw":"---\ntitle: Mac使用openssl生成pem证书\nabbrlink: 250724269\ncategories: \n\t- 技术实践\ntags:\n\t- RAS\n\t- Mac\ndate: 2018-12-07\ncover: https://cdn.tanxz.com/images/category/macos.png\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\n---\n\n#### 安装\n\nopenssl，若已安装则跳过\n\n```\nbrew install openssl\n```\n\n#### 生成RSA私钥\n\n使用openssl来生成RSA私钥文件，输入如下命令(该命令会生成2048位的私钥)\n\n```\nopenssl genrsa -out rsa_private_key.pem 2048\n```\n\n显示如下结果则生成私钥成功\n\n```\nMacBook-Pro-6:pem tanxinzheng$ openssl genrsa -out rsa_private_key.pem 2048\nGenerating RSA private key, 2048 bit long modulus\n....................+++\n.+++\ne is 65537 (0x10001)\nMacBook-Pro-6:pem tanxinzheng$ ll\ntotal 8\n-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem\n```\n\n查看私钥文件内容，RSA私钥格式如下：\n\n> 注：因太长.....省略部分内容\n\n```\n-----BEGIN RSA PRIVATE KEY-----\nMIIEowIBAAKCAQEAzVHzaYFDgEDhIllCBZppYKsaLdYaC9D7IdkBMqroteeHRCaW\nrUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX/JsuYCUnqi3M0iqAFYWIyX7sXoKG\np3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdYhImkxzt/njmQRJCLjNl7fHh6sc1R\nG7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0Gn8dObD0G/kuQEWFJpmIBbzT9zizv\n........\n2xYP/ZoYb6wAe4PzYlJTi/rD8vBdLuBqBKInBfHDe4WvUgOv4Xiu1vxs7lDPyPw5\n2RnLAoGBANpHS9MdFlO6CtOVC1HYMifGY4LcxN7mnJJld2LP7v08pRzhwokMaIBu\ncBH/R0utDLsU9nivvdKjeacQ70pLPpAqDLsQWQxLvOXLLCooLC3RJqpsQp1l4g/I\nsqBVHkCKFTWAw7K28sZdchBHtM/ELH5Tbac2uPEEWtDpzBJ8n4on\n-----END RSA PRIVATE KEY-----\n```\n\n#### 生成RSA公钥\n\n使用如下命令生成公钥：\n\n```\nopenssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem\n```\n\n显示如下结果则生成公钥成功\n\n```\nMacBook-Pro-6:pem tanxinzheng$ openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem\nwriting RSA key\nMacBook-Pro-6:pem tanxinzheng$ ll\ntotal 16\n-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem\n-rw-r--r--  1 tanxinzheng  staff   451 Dec 17 18:47 rsa_public_key.pem\n```\n\n查看公钥文件内容，RSA公钥格式如下：\n\n```\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzVHzaYFDgEDhIllCBZpp\nYKsaLdYaC9D7IdkBMqroteeHRCaWrUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX\n/JsuYCUnqi3M0iqAFYWIyX7sXoKGp3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdY\nhImkxzt/njmQRJCLjNl7fHh6sc1RG7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0G\nn8dObD0G/kuQEWFJpmIBbzT9zizvWsI5gc3jl1Ifp3urk+cexWmZpqavCRK08aee\n5+yqXOk3xk8dqjX4zk6J66bDbiEYQXZcZTaCnTDDiZ4/UiqTue9lKZeUoveuwIfX\nWwIDAQAB\n-----END PUBLIC KEY-----\n```\n\n\n\n","slug":"技术分享/mac/Mac命令生成pem证书","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6h9000ztvcdb7n9dv6k","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>openssl，若已安装则跳过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">brew install openssl<br></code></pre></td></tr></table></figure>\n<h4 id=\"生成RSA私钥\"><a href=\"#生成RSA私钥\" class=\"headerlink\" title=\"生成RSA私钥\"></a>生成RSA私钥</h4><p>使用openssl来生成RSA私钥文件，输入如下命令(该命令会生成2048位的私钥)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">openssl genrsa -out rsa_private_key.pem 2048<br></code></pre></td></tr></table></figure>\n<p>显示如下结果则生成私钥成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">MacBook-Pro-6:pem tanxinzheng$ openssl genrsa -out rsa_private_key.pem 2048<br>Generating RSA private key, 2048 bit long modulus<br>....................+++<br>.+++<br>e is 65537 (0x10001)<br>MacBook-Pro-6:pem tanxinzheng$ ll<br>total 8<br>-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem<br></code></pre></td></tr></table></figure>\n<p>查看私钥文件内容，RSA私钥格式如下：</p>\n<blockquote>\n<p>注：因太长…..省略部分内容</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">-----BEGIN RSA PRIVATE KEY-----<br>MIIEowIBAAKCAQEAzVHzaYFDgEDhIllCBZppYKsaLdYaC9D7IdkBMqroteeHRCaW<br>rUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX&#x2F;JsuYCUnqi3M0iqAFYWIyX7sXoKG<br>p3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdYhImkxzt&#x2F;njmQRJCLjNl7fHh6sc1R<br>G7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0Gn8dObD0G&#x2F;kuQEWFJpmIBbzT9zizv<br>........<br>2xYP&#x2F;ZoYb6wAe4PzYlJTi&#x2F;rD8vBdLuBqBKInBfHDe4WvUgOv4Xiu1vxs7lDPyPw5<br>2RnLAoGBANpHS9MdFlO6CtOVC1HYMifGY4LcxN7mnJJld2LP7v08pRzhwokMaIBu<br>cBH&#x2F;R0utDLsU9nivvdKjeacQ70pLPpAqDLsQWQxLvOXLLCooLC3RJqpsQp1l4g&#x2F;I<br>sqBVHkCKFTWAw7K28sZdchBHtM&#x2F;ELH5Tbac2uPEEWtDpzBJ8n4on<br>-----END RSA PRIVATE KEY-----<br></code></pre></td></tr></table></figure>\n<h4 id=\"生成RSA公钥\"><a href=\"#生成RSA公钥\" class=\"headerlink\" title=\"生成RSA公钥\"></a>生成RSA公钥</h4><p>使用如下命令生成公钥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem<br></code></pre></td></tr></table></figure>\n<p>显示如下结果则生成公钥成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">MacBook-Pro-6:pem tanxinzheng$ openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem<br>writing RSA key<br>MacBook-Pro-6:pem tanxinzheng$ ll<br>total 16<br>-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem<br>-rw-r--r--  1 tanxinzheng  staff   451 Dec 17 18:47 rsa_public_key.pem<br></code></pre></td></tr></table></figure>\n<p>查看公钥文件内容，RSA公钥格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">-----BEGIN PUBLIC KEY-----<br>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzVHzaYFDgEDhIllCBZpp<br>YKsaLdYaC9D7IdkBMqroteeHRCaWrUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX<br>&#x2F;JsuYCUnqi3M0iqAFYWIyX7sXoKGp3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdY<br>hImkxzt&#x2F;njmQRJCLjNl7fHh6sc1RG7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0G<br>n8dObD0G&#x2F;kuQEWFJpmIBbzT9zizvWsI5gc3jl1Ifp3urk+cexWmZpqavCRK08aee<br>5+yqXOk3xk8dqjX4zk6J66bDbiEYQXZcZTaCnTDDiZ4&#x2F;UiqTue9lKZeUoveuwIfX<br>WwIDAQAB<br>-----END PUBLIC KEY-----<br></code></pre></td></tr></table></figure>\n\n\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>openssl，若已安装则跳过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">brew install openssl<br></code></pre></td></tr></table></figure>\n<h4 id=\"生成RSA私钥\"><a href=\"#生成RSA私钥\" class=\"headerlink\" title=\"生成RSA私钥\"></a>生成RSA私钥</h4><p>使用openssl来生成RSA私钥文件，输入如下命令(该命令会生成2048位的私钥)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">openssl genrsa -out rsa_private_key.pem 2048<br></code></pre></td></tr></table></figure>\n<p>显示如下结果则生成私钥成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">MacBook-Pro-6:pem tanxinzheng$ openssl genrsa -out rsa_private_key.pem 2048<br>Generating RSA private key, 2048 bit long modulus<br>....................+++<br>.+++<br>e is 65537 (0x10001)<br>MacBook-Pro-6:pem tanxinzheng$ ll<br>total 8<br>-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem<br></code></pre></td></tr></table></figure>\n<p>查看私钥文件内容，RSA私钥格式如下：</p>\n<blockquote>\n<p>注：因太长…..省略部分内容</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">-----BEGIN RSA PRIVATE KEY-----<br>MIIEowIBAAKCAQEAzVHzaYFDgEDhIllCBZppYKsaLdYaC9D7IdkBMqroteeHRCaW<br>rUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX&#x2F;JsuYCUnqi3M0iqAFYWIyX7sXoKG<br>p3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdYhImkxzt&#x2F;njmQRJCLjNl7fHh6sc1R<br>G7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0Gn8dObD0G&#x2F;kuQEWFJpmIBbzT9zizv<br>........<br>2xYP&#x2F;ZoYb6wAe4PzYlJTi&#x2F;rD8vBdLuBqBKInBfHDe4WvUgOv4Xiu1vxs7lDPyPw5<br>2RnLAoGBANpHS9MdFlO6CtOVC1HYMifGY4LcxN7mnJJld2LP7v08pRzhwokMaIBu<br>cBH&#x2F;R0utDLsU9nivvdKjeacQ70pLPpAqDLsQWQxLvOXLLCooLC3RJqpsQp1l4g&#x2F;I<br>sqBVHkCKFTWAw7K28sZdchBHtM&#x2F;ELH5Tbac2uPEEWtDpzBJ8n4on<br>-----END RSA PRIVATE KEY-----<br></code></pre></td></tr></table></figure>\n<h4 id=\"生成RSA公钥\"><a href=\"#生成RSA公钥\" class=\"headerlink\" title=\"生成RSA公钥\"></a>生成RSA公钥</h4><p>使用如下命令生成公钥：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem<br></code></pre></td></tr></table></figure>\n<p>显示如下结果则生成公钥成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">MacBook-Pro-6:pem tanxinzheng$ openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem<br>writing RSA key<br>MacBook-Pro-6:pem tanxinzheng$ ll<br>total 16<br>-rw-r--r--  1 tanxinzheng  staff  1675 Dec 17 18:45 rsa_private_key.pem<br>-rw-r--r--  1 tanxinzheng  staff   451 Dec 17 18:47 rsa_public_key.pem<br></code></pre></td></tr></table></figure>\n<p>查看公钥文件内容，RSA公钥格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">-----BEGIN PUBLIC KEY-----<br>MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAzVHzaYFDgEDhIllCBZpp<br>YKsaLdYaC9D7IdkBMqroteeHRCaWrUgGa0urV8tLygJ5B+l1YBg9EGXouilMEkuX<br>&#x2F;JsuYCUnqi3M0iqAFYWIyX7sXoKGp3OkXlj9lMYS9mwAm4MqS6n5AmWK9JqlfPdY<br>hImkxzt&#x2F;njmQRJCLjNl7fHh6sc1RG7YzjiZQxDH6xQDQAjXM77OXbTLxNqWWsi0G<br>n8dObD0G&#x2F;kuQEWFJpmIBbzT9zizvWsI5gc3jl1Ifp3urk+cexWmZpqavCRK08aee<br>5+yqXOk3xk8dqjX4zk6J66bDbiEYQXZcZTaCnTDDiZ4&#x2F;UiqTue9lKZeUoveuwIfX<br>WwIDAQAB<br>-----END PUBLIC KEY-----<br></code></pre></td></tr></table></figure>\n\n\n"},{"title":"Mac系统下升级node版本","abbrlink":1345941684,"description":null,"cover":"https://cdn.tanxz.com/images/category/macos.png","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","_content":"\n#### 第一步：使用npm安装n模块\n\nn模块是专门用来管理nodejs版本的，名字就叫n执行命令\n\n````\nnpm install -g n\n````\n#### 第二步：使用n模块升级node\n\n*第一种是升级到最新版本*\n\n```\nsudo n latest\n```\n\n*第二种是升级到稳定版本（建议用稳定版本）*\n\n`sudo n stable`\n\n安装成功！（若版本未切换成功则进入第三步手动修改环境变量）\n\n```\nnode -v\nv11.10.1\n```\n\n最后升级npm到最新版本：\n\n```\nsudo npm install npm@latest -g\n```\n\n#### 第三步：修改NODE_HOME环境变量\n\n```shell\nsudo vi /etc/profile\n+\nexport NODE_HOME=/usr/local/n/versions/node/12.0.0\nexport PATH=$NODE_HOME/bin:$PATH\n```\n\n激活环境变量\n\n```\nsource /etc/profile\n```","source":"_posts/技术分享/mac/Mac系统下升级node版本.md","raw":"---\ntitle: Mac系统下升级node版本\nabbrlink: 1345941684\ncategories:\n\t- 技术实践\ntags:\n\t- mac\n\t- node\ndescription: \ncover: https://cdn.tanxz.com/images/category/macos.png\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\n---\n\n#### 第一步：使用npm安装n模块\n\nn模块是专门用来管理nodejs版本的，名字就叫n执行命令\n\n````\nnpm install -g n\n````\n#### 第二步：使用n模块升级node\n\n*第一种是升级到最新版本*\n\n```\nsudo n latest\n```\n\n*第二种是升级到稳定版本（建议用稳定版本）*\n\n`sudo n stable`\n\n安装成功！（若版本未切换成功则进入第三步手动修改环境变量）\n\n```\nnode -v\nv11.10.1\n```\n\n最后升级npm到最新版本：\n\n```\nsudo npm install npm@latest -g\n```\n\n#### 第三步：修改NODE_HOME环境变量\n\n```shell\nsudo vi /etc/profile\n+\nexport NODE_HOME=/usr/local/n/versions/node/12.0.0\nexport PATH=$NODE_HOME/bin:$PATH\n```\n\n激活环境变量\n\n```\nsource /etc/profile\n```","slug":"技术分享/mac/Mac系统下升级node版本","published":1,"date":"2020-12-21T15:10:33.107Z","updated":"2020-12-24T14:39:35.814Z","_id":"ckiyez6ha0012tvcdcgbyg4m1","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"第一步：使用npm安装n模块\"><a href=\"#第一步：使用npm安装n模块\" class=\"headerlink\" title=\"第一步：使用npm安装n模块\"></a>第一步：使用npm安装n模块</h4><p>n模块是专门用来管理nodejs版本的，名字就叫n执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">npm install -g n<br></code></pre></td></tr></table></figure>\n<h4 id=\"第二步：使用n模块升级node\"><a href=\"#第二步：使用n模块升级node\" class=\"headerlink\" title=\"第二步：使用n模块升级node\"></a>第二步：使用n模块升级node</h4><p><em>第一种是升级到最新版本</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">sudo n latest<br></code></pre></td></tr></table></figure>\n<p><em>第二种是升级到稳定版本（建议用稳定版本）</em></p>\n<p><code>sudo n stable</code></p>\n<p>安装成功！（若版本未切换成功则进入第三步手动修改环境变量）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">node -v<br>v11.10.1<br></code></pre></td></tr></table></figure>\n<p>最后升级npm到最新版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">sudo npm install npm@latest -g<br></code></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改NODE-HOME环境变量\"><a href=\"#第三步：修改NODE-HOME环境变量\" class=\"headerlink\" title=\"第三步：修改NODE_HOME环境变量\"></a>第三步：修改NODE_HOME环境变量</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo vi /etc/profile<br>+<br>export NODE_HOME=/usr/local/n/versions/node/12.0.0<br>export PATH=$NODE_HOME/bin:$PATH<br></code></pre></td></tr></table></figure>\n<p>激活环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">source &#x2F;etc&#x2F;profile<br></code></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h4 id=\"第一步：使用npm安装n模块\"><a href=\"#第一步：使用npm安装n模块\" class=\"headerlink\" title=\"第一步：使用npm安装n模块\"></a>第一步：使用npm安装n模块</h4><p>n模块是专门用来管理nodejs版本的，名字就叫n执行命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">npm install -g n<br></code></pre></td></tr></table></figure>\n<h4 id=\"第二步：使用n模块升级node\"><a href=\"#第二步：使用n模块升级node\" class=\"headerlink\" title=\"第二步：使用n模块升级node\"></a>第二步：使用n模块升级node</h4><p><em>第一种是升级到最新版本</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">sudo n latest<br></code></pre></td></tr></table></figure>\n<p><em>第二种是升级到稳定版本（建议用稳定版本）</em></p>\n<p><code>sudo n stable</code></p>\n<p>安装成功！（若版本未切换成功则进入第三步手动修改环境变量）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">node -v<br>v11.10.1<br></code></pre></td></tr></table></figure>\n<p>最后升级npm到最新版本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">sudo npm install npm@latest -g<br></code></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改NODE-HOME环境变量\"><a href=\"#第三步：修改NODE-HOME环境变量\" class=\"headerlink\" title=\"第三步：修改NODE_HOME环境变量\"></a>第三步：修改NODE_HOME环境变量</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo vi /etc/profile<br>+<br>export NODE_HOME=/usr/local/n/versions/node/12.0.0<br>export PATH=$NODE_HOME/bin:$PATH<br></code></pre></td></tr></table></figure>\n<p>激活环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">source &#x2F;etc&#x2F;profile<br></code></pre></td></tr></table></figure>"},{"title":"Markdown导出带目录的html文件","abbrlink":3058308324,"date":"2017-10-15T04:10:23.000Z","keywords":null,"description":null,"top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","comments":1,"cover":"https://cdn.tanxz.com/images/category/markdown.png","toc":null,"toc_number":true,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"\n## 安装插件\n\n使用下面命令进行全局安装：\n\n```\nnpm install -g i5ting_toc\n```\n\n------\n\n## 插件用法\n\n安装好 i5ting_toc 后，就可以使用简单的命令了。比如输入`i5ting_toc -h`查看插件用法，如下图示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905160156342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n------\n\n## md 文件转 html 文件\n\n**这里我在本地给大家演示一遍。**\n\n- 进入md文件所在目录\n\n如下图示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905160538563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n- 输入命令`i5ting_toc -f index.md -o`\n\n如下图示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905160831569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n命令执行完后，md文件目录下生成了一个preview文件夹，我们需要的html文件夹就在里面，然后直接浏览器打开这个html即可。如下图示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905161030886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905161108879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n希望本文对各位同学能有所帮助！","source":"_posts/理论学习/markdown/Markdown导出带目录的html文件.md","raw":"---\ntitle: Markdown导出带目录的html文件\ncategories: \n  - 技术实践\ntags:\n  - Markdown\nabbrlink: 3058308324\ndate: 2017-10-15 12:10:23\nkeywords:\ndescription:\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ncomments:\ncover: https://cdn.tanxz.com/images/category/markdown.png\ntoc:\ntoc_number: true\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n\n## 安装插件\n\n使用下面命令进行全局安装：\n\n```\nnpm install -g i5ting_toc\n```\n\n------\n\n## 插件用法\n\n安装好 i5ting_toc 后，就可以使用简单的命令了。比如输入`i5ting_toc -h`查看插件用法，如下图示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905160156342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n------\n\n## md 文件转 html 文件\n\n**这里我在本地给大家演示一遍。**\n\n- 进入md文件所在目录\n\n如下图示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905160538563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n- 输入命令`i5ting_toc -f index.md -o`\n\n如下图示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905160831569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n命令执行完后，md文件目录下生成了一个preview文件夹，我们需要的html文件夹就在里面，然后直接浏览器打开这个html即可。如下图示：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905161030886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190905161108879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70)\n\n希望本文对各位同学能有所帮助！","slug":"理论学习/markdown/Markdown导出带目录的html文件","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6hb0014tvcd1rxxgnbt","layout":"post","photos":[],"link":"","content":"<h2 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h2><p>使用下面命令进行全局安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">npm install -g i5ting_toc<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"插件用法\"><a href=\"#插件用法\" class=\"headerlink\" title=\"插件用法\"></a>插件用法</h2><p>安装好 i5ting_toc 后，就可以使用简单的命令了。比如输入<code>i5ting_toc -h</code>查看插件用法，如下图示：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20190905160156342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<hr>\n<h2 id=\"md-文件转-html-文件\"><a href=\"#md-文件转-html-文件\" class=\"headerlink\" title=\"md 文件转 html 文件\"></a>md 文件转 html 文件</h2><p><strong>这里我在本地给大家演示一遍。</strong></p>\n<ul>\n<li>进入md文件所在目录</li>\n</ul>\n<p>如下图示：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20190905160538563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>输入命令<code>i5ting_toc -f index.md -o</code></li>\n</ul>\n<p>如下图示：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20190905160831569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>命令执行完后，md文件目录下生成了一个preview文件夹，我们需要的html文件夹就在里面，然后直接浏览器打开这个html即可。如下图示：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20190905161030886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20190905161108879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>希望本文对各位同学能有所帮助！</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h2><p>使用下面命令进行全局安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">npm install -g i5ting_toc<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"插件用法\"><a href=\"#插件用法\" class=\"headerlink\" title=\"插件用法\"></a>插件用法</h2><p>安装好 i5ting_toc 后，就可以使用简单的命令了。比如输入<code>i5ting_toc -h</code>查看插件用法，如下图示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190905160156342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<hr>\n<h2 id=\"md-文件转-html-文件\"><a href=\"#md-文件转-html-文件\" class=\"headerlink\" title=\"md 文件转 html 文件\"></a>md 文件转 html 文件</h2><p><strong>这里我在本地给大家演示一遍。</strong></p>\n<ul>\n<li>进入md文件所在目录</li>\n</ul>\n<p>如下图示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190905160538563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>输入命令<code>i5ting_toc -f index.md -o</code></li>\n</ul>\n<p>如下图示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190905160831569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>命令执行完后，md文件目录下生成了一个preview文件夹，我们需要的html文件夹就在里面，然后直接浏览器打开这个html即可。如下图示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190905161030886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190905161108879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG56b3VxaQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>希望本文对各位同学能有所帮助！</p>\n"},{"title":"Markdown之Cmd Markdown编辑阅读器","description":"在这篇Markdown文章中，你讲学习到Markdown的各类语法及展示效果","abbrlink":3058308323,"cover":"https://cdn.tanxz.com/images/category/markdown.png","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","date":"2017-03-15T06:10:23.000Z","_content":"\n# 欢迎使用 Cmd Markdown 编辑阅读器\n\n------\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，**Cmd Markdown** 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n> * 整理知识，学习笔记\n> * 发布日记，杂文，所见所想\n> * 撰写发布技术文稿（代码支持）\n> * 撰写发布学术论文（LaTeX 公式支持）\n\n![cmd-markdown-logo](https://www.zybuluo.com/static/img/logo.png)\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\n\n### [Windows/Mac/Linux 全平台客户端](https://www.zybuluo.com/cmd/)\n\n> 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> **新文稿** 或者使用快捷键 `Ctrl+Alt+N`。\n\n------\n\n## 什么是 Markdown\n\nMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，**粗体** 或者 *斜体* 某些文字，更棒的是，它还可以\n\n### 1. 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)\n\n- [ ] 支持以 PDF 格式导出文稿\n- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n- [x] 新增 Todo 列表功能\n- [x] 修复 LaTex 公式渲染问题\n- [x] 新增 LaTex 公式编号功能\n\n### 2. 书写一个质能守恒公式[^LaTeX]\n\n$$E=mc^2$$\n\n### 3. 高亮一段代码[^code]\n\n```python\n@requires_authorization\nclass SomeClass:\n    pass\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n### 4. 高效绘制 [流程图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图)\n\n```flow\nst=>start: Start\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n### 5. 高效绘制 [序列图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图)\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n### 6. 高效绘制 [甘特图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图)\n\n```gantt\n    title 项目开发流程\n    section 项目确定\n        需求分析       :a1, 2016-06-22, 3d\n        可行性报告     :after a1, 5d\n        概念验证       : 5d\n    section 项目实施\n        概要设计      :2016-07-05  , 5d\n        详细设计      :2016-07-08, 10d\n        编码          :2016-07-15, 10d\n        测试          :2016-07-22, 5d\n    section 发布验收\n        发布: 2d\n        验收: 3d\n```\n\n### 7. 绘制表格\n\n| 项目   |   价格 | 数量 |\n| ------ | -----: | :--: |\n| 计算机 | \\$1600 |  5   |\n| 手机   |   \\$12 |  12  |\n| 管线   |    \\$1 | 234  |\n\n### 8. 更详细语法说明\n\n想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。\n\n总而言之，不同于其它 *所见即所得* 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。**Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。** 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n---\n\n## 什么是 Cmd Markdown\n\n您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 **编辑/发布/阅读** Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\n\n### 1. 实时同步预览\n\n我们将 Cmd Markdown 的主界面一分为二，左边为**编辑区**，右边为**预览区**，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n\n### 2. 编辑工具栏\n\n也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 **编辑区** 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n![tool-editor](https://www.zybuluo.com/static/img/toolbar-editor.png)\n\n### 3. 编辑模式\n\n完全心无旁骛的方式编辑文字：点击 **编辑工具栏** 最右侧的拉伸按钮或者按下 `Ctrl + M`，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n\n### 4. 实时的云端文稿\n\n为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 **编辑工具栏** 的最右侧提示 `已保存` 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n\n### 5. 离线模式\n\n在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n\n### 6. 管理工具栏\n\n为了便于管理您的文稿，在 **预览区** 的顶部放置了如下所示的 **管理工具栏**：\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-manager.jpg)\n\n通过管理工具栏可以：\n\n<i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享\n<i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿\n<i class=\"icon-trash\"></i> 删除：删除当前的文稿\n<i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\n<i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作\n<i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式\n\n### 7. 阅读工具栏\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-reader.jpg)\n\n通过 **预览区** 右上角的 **阅读工具栏**，可以查看当前文稿的目录并增强阅读体验。\n\n工具栏上的五个图标依次为：\n\n<i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\n<i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n\n### 8. 阅读模式\n\n在 **阅读工具栏** 点击 <i class=\"icon-desktop\"></i> 或者按下 `Ctrl+Alt+M` 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n\n### 9. 标签、分类和搜索\n\n在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n\n标签： 未分类\n\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n![file-list](https://www.zybuluo.com/static/img/file-list.png)\n\n### 10. 文稿发布和分享\n\n在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n------\n\n再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n\n作者 [@ghosert][3]     \n2016 年 07月 07日    \n\n[^LaTeX]: 支持 **LaTeX** 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。\n\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，**四十一**种主流编程语言。\n\n[1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\n[2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\n[3]: http://weibo.com/ghosert\n[4]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference","source":"_posts/理论学习/markdown/Markdown模板汇总.md","raw":"---\ntitle: Markdown之Cmd Markdown编辑阅读器\ncategories: \n    - 技术分享\ntags:\n\t- Markdown\ndescription: 在这篇Markdown文章中，你讲学习到Markdown的各类语法及展示效果\nabbrlink: 3058308323\ncover: https://cdn.tanxz.com/images/category/markdown.png\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ndate: 2017-03-15 14:10:23\n---\n\n# 欢迎使用 Cmd Markdown 编辑阅读器\n\n------\n\n我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，**Cmd Markdown** 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n\n> * 整理知识，学习笔记\n> * 发布日记，杂文，所见所想\n> * 撰写发布技术文稿（代码支持）\n> * 撰写发布学术论文（LaTeX 公式支持）\n\n![cmd-markdown-logo](https://www.zybuluo.com/static/img/logo.png)\n\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\n\n### [Windows/Mac/Linux 全平台客户端](https://www.zybuluo.com/cmd/)\n\n> 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> **新文稿** 或者使用快捷键 `Ctrl+Alt+N`。\n\n------\n\n## 什么是 Markdown\n\nMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，**粗体** 或者 *斜体* 某些文字，更棒的是，它还可以\n\n### 1. 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)\n\n- [ ] 支持以 PDF 格式导出文稿\n- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n- [x] 新增 Todo 列表功能\n- [x] 修复 LaTex 公式渲染问题\n- [x] 新增 LaTex 公式编号功能\n\n### 2. 书写一个质能守恒公式[^LaTeX]\n\n$$E=mc^2$$\n\n### 3. 高亮一段代码[^code]\n\n```python\n@requires_authorization\nclass SomeClass:\n    pass\nif __name__ == '__main__':\n    # A comment\n    print 'hello world'\n```\n\n### 4. 高效绘制 [流程图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图)\n\n```flow\nst=>start: Start\nop=>operation: Your Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n### 5. 高效绘制 [序列图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图)\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n### 6. 高效绘制 [甘特图](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图)\n\n```gantt\n    title 项目开发流程\n    section 项目确定\n        需求分析       :a1, 2016-06-22, 3d\n        可行性报告     :after a1, 5d\n        概念验证       : 5d\n    section 项目实施\n        概要设计      :2016-07-05  , 5d\n        详细设计      :2016-07-08, 10d\n        编码          :2016-07-15, 10d\n        测试          :2016-07-22, 5d\n    section 发布验收\n        发布: 2d\n        验收: 3d\n```\n\n### 7. 绘制表格\n\n| 项目   |   价格 | 数量 |\n| ------ | -----: | :--: |\n| 计算机 | \\$1600 |  5   |\n| 手机   |   \\$12 |  12  |\n| 管线   |    \\$1 | 234  |\n\n### 8. 更详细语法说明\n\n想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。\n\n总而言之，不同于其它 *所见即所得* 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。**Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。** 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n\n---\n\n## 什么是 Cmd Markdown\n\n您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 **编辑/发布/阅读** Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\n\n### 1. 实时同步预览\n\n我们将 Cmd Markdown 的主界面一分为二，左边为**编辑区**，右边为**预览区**，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n\n### 2. 编辑工具栏\n\n也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 **编辑区** 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n\n![tool-editor](https://www.zybuluo.com/static/img/toolbar-editor.png)\n\n### 3. 编辑模式\n\n完全心无旁骛的方式编辑文字：点击 **编辑工具栏** 最右侧的拉伸按钮或者按下 `Ctrl + M`，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n\n### 4. 实时的云端文稿\n\n为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 **编辑工具栏** 的最右侧提示 `已保存` 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n\n### 5. 离线模式\n\n在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n\n### 6. 管理工具栏\n\n为了便于管理您的文稿，在 **预览区** 的顶部放置了如下所示的 **管理工具栏**：\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-manager.jpg)\n\n通过管理工具栏可以：\n\n<i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享\n<i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿\n<i class=\"icon-trash\"></i> 删除：删除当前的文稿\n<i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\n<i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作\n<i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式\n\n### 7. 阅读工具栏\n\n![tool-manager](https://www.zybuluo.com/static/img/toolbar-reader.jpg)\n\n通过 **预览区** 右上角的 **阅读工具栏**，可以查看当前文稿的目录并增强阅读体验。\n\n工具栏上的五个图标依次为：\n\n<i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\n<i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置\n<i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 **黑色主题**，超炫！\n<i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n<i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n\n### 8. 阅读模式\n\n在 **阅读工具栏** 点击 <i class=\"icon-desktop\"></i> 或者按下 `Ctrl+Alt+M` 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n\n### 9. 标签、分类和搜索\n\n在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n\n标签： 未分类\n\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n\n![file-list](https://www.zybuluo.com/static/img/file-list.png)\n\n### 10. 文稿发布和分享\n\n在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！\n\n------\n\n再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n\n作者 [@ghosert][3]     \n2016 年 07月 07日    \n\n[^LaTeX]: 支持 **LaTeX** 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 [MathJax][4] 参考更多使用方法。\n\n[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，**四十一**种主流编程语言。\n\n[1]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\n[2]: https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\n[3]: http://weibo.com/ghosert\n[4]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference","slug":"理论学习/markdown/Markdown模板汇总","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6hc0015tvcdcwik74nt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"欢迎使用-Cmd-Markdown-编辑阅读器\"><a href=\"#欢迎使用-Cmd-Markdown-编辑阅读器\" class=\"headerlink\" title=\"欢迎使用 Cmd Markdown 编辑阅读器\"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>\n<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>\n<blockquote>\n<ul>\n<li>整理知识，学习笔记</li>\n<li>发布日记，杂文，所见所想</li>\n<li>撰写发布技术文稿（代码支持）</li>\n<li>撰写发布学术论文（LaTeX 公式支持）</li>\n</ul>\n</blockquote>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://www.zybuluo.com/static/img/logo.png\" alt=\"cmd-markdown-logo\"></p>\n<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>\n<h3 id=\"Windows-Mac-Linux-全平台客户端\"><a href=\"#Windows-Mac-Linux-全平台客户端\" class=\"headerlink\" title=\"Windows/Mac/Linux 全平台客户端\"></a><a href=\"https://www.zybuluo.com/cmd/\">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>\n<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>\n</blockquote>\n<hr>\n<h2 id=\"什么是-Markdown\"><a href=\"#什么是-Markdown\" class=\"headerlink\" title=\"什么是 Markdown\"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>\n<h3 id=\"1-制作一份待办事宜-Todo-列表\"><a href=\"#1-制作一份待办事宜-Todo-列表\" class=\"headerlink\" title=\"1. 制作一份待办事宜 Todo 列表\"></a>1. 制作一份待办事宜 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表\">Todo 列表</a></h3><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 支持以 PDF 格式导出文稿</li>\n<li><input disabled=\"\" type=\"checkbox\"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新增 Todo 列表功能</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 修复 LaTex 公式渲染问题</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新增 LaTex 公式编号功能</li>\n</ul>\n<h3 id=\"2-书写一个质能守恒公式-LaTeX\"><a href=\"#2-书写一个质能守恒公式-LaTeX\" class=\"headerlink\" title=\"2. 书写一个质能守恒公式[^LaTeX]\"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>\n<h3 id=\"3-高亮一段代码-code\"><a href=\"#3-高亮一段代码-code\" class=\"headerlink\" title=\"3. 高亮一段代码[^code]\"></a>3. 高亮一段代码[^code]</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">@requires_authorization</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeClass</span>:</span><br>    <span class=\"hljs-keyword\">pass</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    <span class=\"hljs-comment\"># A comment</span><br>    <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"4-高效绘制-流程图\"><a href=\"#4-高效绘制-流程图\" class=\"headerlink\" title=\"4. 高效绘制 流程图\"></a>4. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图\">流程图</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs flow\">st&#x3D;&gt;start: Start<br>op&#x3D;&gt;operation: Your Operation<br>cond&#x3D;&gt;condition: Yes or No?<br>e&#x3D;&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br></code></pre></td></tr></table></figure>\n<h3 id=\"5-高效绘制-序列图\"><a href=\"#5-高效绘制-序列图\" class=\"headerlink\" title=\"5. 高效绘制 序列图\"></a>5. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图\">序列图</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs seq\">Alice-&gt;Bob: Hello Bob, how are you?<br>Note right of Bob: Bob thinks<br>Bob--&gt;Alice: I am good thanks!<br></code></pre></td></tr></table></figure>\n<h3 id=\"6-高效绘制-甘特图\"><a href=\"#6-高效绘制-甘特图\" class=\"headerlink\" title=\"6. 高效绘制 甘特图\"></a>6. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图\">甘特图</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gantt\">title 项目开发流程<br>section 项目确定<br>    需求分析       :a1, 2016-06-22, 3d<br>    可行性报告     :after a1, 5d<br>    概念验证       : 5d<br>section 项目实施<br>    概要设计      :2016-07-05  , 5d<br>    详细设计      :2016-07-08, 10d<br>    编码          :2016-07-15, 10d<br>    测试          :2016-07-22, 5d<br>section 发布验收<br>    发布: 2d<br>    验收: 3d<br></code></pre></td></tr></table></figure>\n<h3 id=\"7-绘制表格\"><a href=\"#7-绘制表格\" class=\"headerlink\" title=\"7. 绘制表格\"></a>7. 绘制表格</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>计算机</td>\n<td align=\"right\">$1600</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td align=\"right\">$12</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td align=\"right\">$1</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<h3 id=\"8-更详细语法说明\"><a href=\"#8-更详细语法说明\" class=\"headerlink\" title=\"8. 更详细语法说明\"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>\n<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>\n<hr>\n<h2 id=\"什么是-Cmd-Markdown\"><a href=\"#什么是-Cmd-Markdown\" class=\"headerlink\" title=\"什么是 Cmd Markdown\"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>\n<h3 id=\"1-实时同步预览\"><a href=\"#1-实时同步预览\" class=\"headerlink\" title=\"1. 实时同步预览\"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>\n<h3 id=\"2-编辑工具栏\"><a href=\"#2-编辑工具栏\" class=\"headerlink\" title=\"2. 编辑工具栏\"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://www.zybuluo.com/static/img/toolbar-editor.png\" alt=\"tool-editor\"></p>\n<h3 id=\"3-编辑模式\"><a href=\"#3-编辑模式\" class=\"headerlink\" title=\"3. 编辑模式\"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>\n<h3 id=\"4-实时的云端文稿\"><a href=\"#4-实时的云端文稿\" class=\"headerlink\" title=\"4. 实时的云端文稿\"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>\n<h3 id=\"5-离线模式\"><a href=\"#5-离线模式\" class=\"headerlink\" title=\"5. 离线模式\"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>\n<h3 id=\"6-管理工具栏\"><a href=\"#6-管理工具栏\" class=\"headerlink\" title=\"6. 管理工具栏\"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://www.zybuluo.com/static/img/toolbar-manager.jpg\" alt=\"tool-manager\"></p>\n<p>通过管理工具栏可以：</p>\n<p><i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿<br><i class=\"icon-trash\"></i> 删除：删除当前的文稿<br><i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>\n<h3 id=\"7-阅读工具栏\"><a href=\"#7-阅读工具栏\" class=\"headerlink\" title=\"7. 阅读工具栏\"></a>7. 阅读工具栏</h3><p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://www.zybuluo.com/static/img/toolbar-reader.jpg\" alt=\"tool-manager\"></p>\n<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>\n<p>工具栏上的五个图标依次为：</p>\n<p><i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>\n<h3 id=\"8-阅读模式\"><a href=\"#8-阅读模式\" class=\"headerlink\" title=\"8. 阅读模式\"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class=\"icon-desktop\"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>\n<h3 id=\"9-标签、分类和搜索\"><a href=\"#9-标签、分类和搜索\" class=\"headerlink\" title=\"9. 标签、分类和搜索\"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>\n<p>标签： 未分类</p>\n<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://www.zybuluo.com/static/img/file-list.png\" alt=\"file-list\"></p>\n<h3 id=\"10-文稿发布和分享\"><a href=\"#10-文稿发布和分享\" class=\"headerlink\" title=\"10. 文稿发布和分享\"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>\n<hr>\n<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>\n<p>作者 <a href=\"http://weibo.com/ghosert\">@ghosert</a><br>2016 年 07月 07日    </p>\n<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">MathJax</a> 参考更多使用方法。</p>\n<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"欢迎使用-Cmd-Markdown-编辑阅读器\"><a href=\"#欢迎使用-Cmd-Markdown-编辑阅读器\" class=\"headerlink\" title=\"欢迎使用 Cmd Markdown 编辑阅读器\"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>\n<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>\n<blockquote>\n<ul>\n<li>整理知识，学习笔记</li>\n<li>发布日记，杂文，所见所想</li>\n<li>撰写发布技术文稿（代码支持）</li>\n<li>撰写发布学术论文（LaTeX 公式支持）</li>\n</ul>\n</blockquote>\n<p><img src=\"https://www.zybuluo.com/static/img/logo.png\" alt=\"cmd-markdown-logo\"></p>\n<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>\n<h3 id=\"Windows-Mac-Linux-全平台客户端\"><a href=\"#Windows-Mac-Linux-全平台客户端\" class=\"headerlink\" title=\"Windows/Mac/Linux 全平台客户端\"></a><a href=\"https://www.zybuluo.com/cmd/\">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>\n<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>\n</blockquote>\n<hr>\n<h2 id=\"什么是-Markdown\"><a href=\"#什么是-Markdown\" class=\"headerlink\" title=\"什么是 Markdown\"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>\n<h3 id=\"1-制作一份待办事宜-Todo-列表\"><a href=\"#1-制作一份待办事宜-Todo-列表\" class=\"headerlink\" title=\"1. 制作一份待办事宜 Todo 列表\"></a>1. 制作一份待办事宜 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表\">Todo 列表</a></h3><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 支持以 PDF 格式导出文稿</li>\n<li><input disabled=\"\" type=\"checkbox\"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新增 Todo 列表功能</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 修复 LaTex 公式渲染问题</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 新增 LaTex 公式编号功能</li>\n</ul>\n<h3 id=\"2-书写一个质能守恒公式-LaTeX\"><a href=\"#2-书写一个质能守恒公式-LaTeX\" class=\"headerlink\" title=\"2. 书写一个质能守恒公式[^LaTeX]\"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>\n<h3 id=\"3-高亮一段代码-code\"><a href=\"#3-高亮一段代码-code\" class=\"headerlink\" title=\"3. 高亮一段代码[^code]\"></a>3. 高亮一段代码[^code]</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">@requires_authorization</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeClass</span>:</span><br>    <span class=\"hljs-keyword\">pass</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    <span class=\"hljs-comment\"># A comment</span><br>    <span class=\"hljs-built_in\">print</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"4-高效绘制-流程图\"><a href=\"#4-高效绘制-流程图\" class=\"headerlink\" title=\"4. 高效绘制 流程图\"></a>4. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图\">流程图</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs flow\">st&#x3D;&gt;start: Start<br>op&#x3D;&gt;operation: Your Operation<br>cond&#x3D;&gt;condition: Yes or No?<br>e&#x3D;&gt;end<br>st-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;op<br></code></pre></td></tr></table></figure>\n<h3 id=\"5-高效绘制-序列图\"><a href=\"#5-高效绘制-序列图\" class=\"headerlink\" title=\"5. 高效绘制 序列图\"></a>5. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图\">序列图</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs seq\">Alice-&gt;Bob: Hello Bob, how are you?<br>Note right of Bob: Bob thinks<br>Bob--&gt;Alice: I am good thanks!<br></code></pre></td></tr></table></figure>\n<h3 id=\"6-高效绘制-甘特图\"><a href=\"#6-高效绘制-甘特图\" class=\"headerlink\" title=\"6. 高效绘制 甘特图\"></a>6. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图\">甘特图</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gantt\">title 项目开发流程<br>section 项目确定<br>    需求分析       :a1, 2016-06-22, 3d<br>    可行性报告     :after a1, 5d<br>    概念验证       : 5d<br>section 项目实施<br>    概要设计      :2016-07-05  , 5d<br>    详细设计      :2016-07-08, 10d<br>    编码          :2016-07-15, 10d<br>    测试          :2016-07-22, 5d<br>section 发布验收<br>    发布: 2d<br>    验收: 3d<br></code></pre></td></tr></table></figure>\n<h3 id=\"7-绘制表格\"><a href=\"#7-绘制表格\" class=\"headerlink\" title=\"7. 绘制表格\"></a>7. 绘制表格</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>计算机</td>\n<td align=\"right\">$1600</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td align=\"right\">$12</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td align=\"right\">$1</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<h3 id=\"8-更详细语法说明\"><a href=\"#8-更详细语法说明\" class=\"headerlink\" title=\"8. 更详细语法说明\"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>\n<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>\n<hr>\n<h2 id=\"什么是-Cmd-Markdown\"><a href=\"#什么是-Cmd-Markdown\" class=\"headerlink\" title=\"什么是 Cmd Markdown\"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>\n<h3 id=\"1-实时同步预览\"><a href=\"#1-实时同步预览\" class=\"headerlink\" title=\"1. 实时同步预览\"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>\n<h3 id=\"2-编辑工具栏\"><a href=\"#2-编辑工具栏\" class=\"headerlink\" title=\"2. 编辑工具栏\"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>\n<p><img src=\"https://www.zybuluo.com/static/img/toolbar-editor.png\" alt=\"tool-editor\"></p>\n<h3 id=\"3-编辑模式\"><a href=\"#3-编辑模式\" class=\"headerlink\" title=\"3. 编辑模式\"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>\n<h3 id=\"4-实时的云端文稿\"><a href=\"#4-实时的云端文稿\" class=\"headerlink\" title=\"4. 实时的云端文稿\"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>\n<h3 id=\"5-离线模式\"><a href=\"#5-离线模式\" class=\"headerlink\" title=\"5. 离线模式\"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>\n<h3 id=\"6-管理工具栏\"><a href=\"#6-管理工具栏\" class=\"headerlink\" title=\"6. 管理工具栏\"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/toolbar-manager.jpg\" alt=\"tool-manager\"></p>\n<p>通过管理工具栏可以：</p>\n<p><i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿<br><i class=\"icon-trash\"></i> 删除：删除当前的文稿<br><i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>\n<h3 id=\"7-阅读工具栏\"><a href=\"#7-阅读工具栏\" class=\"headerlink\" title=\"7. 阅读工具栏\"></a>7. 阅读工具栏</h3><p><img src=\"https://www.zybuluo.com/static/img/toolbar-reader.jpg\" alt=\"tool-manager\"></p>\n<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>\n<p>工具栏上的五个图标依次为：</p>\n<p><i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>\n<h3 id=\"8-阅读模式\"><a href=\"#8-阅读模式\" class=\"headerlink\" title=\"8. 阅读模式\"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class=\"icon-desktop\"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>\n<h3 id=\"9-标签、分类和搜索\"><a href=\"#9-标签、分类和搜索\" class=\"headerlink\" title=\"9. 标签、分类和搜索\"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>\n<p>标签： 未分类</p>\n<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/file-list.png\" alt=\"file-list\"></p>\n<h3 id=\"10-文稿发布和分享\"><a href=\"#10-文稿发布和分享\" class=\"headerlink\" title=\"10. 文稿发布和分享\"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>\n<hr>\n<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>\n<p>作者 <a href=\"http://weibo.com/ghosert\">@ghosert</a><br>2016 年 07月 07日    </p>\n<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">MathJax</a> 参考更多使用方法。</p>\n<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>\n"},{"title":"Hexo搭建博客：如何使用Hexo写作","cover":"https://cdn.tanxz.com/images/category/hexo.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","abbrlink":3878378061,"_content":"\n> 这篇文章将讲解如果使用hexo命令生成页面、文章及如何配置文章模板等操作。\n\n你可以执行下列命令来创建一篇新文章或者新的页面。\n\n```\n$ hexo new [layout] <title>\n```\n\n您可以在命令中指定文章的布局（layout），默认为 `post`，可以通过修改 `_config.yml` 中的 `default_layout` 参数来指定默认布局。\n\n### 布局（Layout）\n\nHexo 有三种默认布局：`post`、`page` 和 `draft`。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 `post` 相同，都将储存到 `source/_posts` 文件夹。\n\n| 布局    | 路径             |\n| :------ | :--------------- |\n| `post`  | `source/_posts`  |\n| `page`  | `source`         |\n| `draft` | `source/_drafts` |\n\n> Disabling layout\n>\n> If you don’t want an article (post/page) to be processed with a theme, set `layout: false` in its front-matter. Refer to [this section](https://hexo.io/zh-cn/docs/front-matter#布局) for more details.\n\n### 文件名称\n\nHexo 默认以标题做为文件名称，但您可编辑 `new_post_name` 参数来改变默认的文件名称，举例来说，设为 `:year-:month-:day-:title.md` 可让您更方便的通过日期来管理文章。\n\n| 变量       | 描述                                |\n| :--------- | :---------------------------------- |\n| `:title`   | 标题（小写，空格将会被替换为短杠）  |\n| `:year`    | 建立的年份，比如， `2015`           |\n| `:month`   | 建立的月份（有前导零），比如， `04` |\n| `:i_month` | 建立的月份（无前导零），比如， `4`  |\n| `:day`     | 建立的日期（有前导零），比如， `07` |\n| `:i_day`   | 建立的日期（无前导零），比如， `7`  |\n\n### 草稿\n\n刚刚提到了 Hexo 的一种特殊布局：`draft`，这种布局在建立时会被保存到 `source/_drafts` 文件夹，您可通过 `publish` 命令将草稿移动到 `source/_posts` 文件夹，该命令的使用方式与 `new` 十分类似，您也可在命令中指定 `layout` 来指定布局。\n\n```\n$ hexo publish [layout] <title>\n```\n\n草稿默认不会显示在页面中，您可在执行时加上 `--draft` 参数，或是把 `render_drafts` 参数设为 `true` 来预览草稿。\n\n### 模版（Scaffold）\n\n在新建文章时，Hexo 会根据 `scaffolds` 文件夹内相对应的文件来建立文件，例如：\n\n```\n$ hexo new photo \"My Gallery\"\n```\n\n在执行这行指令时，Hexo 会尝试在 `scaffolds` 文件夹中寻找 `photo.md`，并根据其内容建立文章，以下是您可以在模版中使用的变量：\n\n| 变量     | 描述         |\n| :------- | :----------- |\n| `layout` | 布局         |\n| `title`  | 标题         |\n| `date`   | 文件建立日期 |\n\n### 支持的格式\n\nHexo 支持以任何格式书写文章，只要安装了相应的渲染插件。\n\n例如，Hexo 默认安装了 `hexo-renderer-marked` 和 `hexo-renderer-ejs`，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 `hexo-renderer-pug`，你甚至可以用 Pug 模板语言书写文章。\n\n只需要将文章的扩展名从 `md` 改成 `ejs`，Hexo 就会使用 `hexo-renderer-ejs` 渲染这个文件，其他格式同理。","source":"_posts/博客教程/hexo/hexo写作.md","raw":"---\ntitle: Hexo搭建博客：如何使用Hexo写作\ncategories: \n  - 博客教程\ntags:\n  - Hexo\ncover: https://cdn.tanxz.com/images/category/hexo.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\nabbrlink: 3878378061\n---\n\n> 这篇文章将讲解如果使用hexo命令生成页面、文章及如何配置文章模板等操作。\n\n你可以执行下列命令来创建一篇新文章或者新的页面。\n\n```\n$ hexo new [layout] <title>\n```\n\n您可以在命令中指定文章的布局（layout），默认为 `post`，可以通过修改 `_config.yml` 中的 `default_layout` 参数来指定默认布局。\n\n### 布局（Layout）\n\nHexo 有三种默认布局：`post`、`page` 和 `draft`。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 `post` 相同，都将储存到 `source/_posts` 文件夹。\n\n| 布局    | 路径             |\n| :------ | :--------------- |\n| `post`  | `source/_posts`  |\n| `page`  | `source`         |\n| `draft` | `source/_drafts` |\n\n> Disabling layout\n>\n> If you don’t want an article (post/page) to be processed with a theme, set `layout: false` in its front-matter. Refer to [this section](https://hexo.io/zh-cn/docs/front-matter#布局) for more details.\n\n### 文件名称\n\nHexo 默认以标题做为文件名称，但您可编辑 `new_post_name` 参数来改变默认的文件名称，举例来说，设为 `:year-:month-:day-:title.md` 可让您更方便的通过日期来管理文章。\n\n| 变量       | 描述                                |\n| :--------- | :---------------------------------- |\n| `:title`   | 标题（小写，空格将会被替换为短杠）  |\n| `:year`    | 建立的年份，比如， `2015`           |\n| `:month`   | 建立的月份（有前导零），比如， `04` |\n| `:i_month` | 建立的月份（无前导零），比如， `4`  |\n| `:day`     | 建立的日期（有前导零），比如， `07` |\n| `:i_day`   | 建立的日期（无前导零），比如， `7`  |\n\n### 草稿\n\n刚刚提到了 Hexo 的一种特殊布局：`draft`，这种布局在建立时会被保存到 `source/_drafts` 文件夹，您可通过 `publish` 命令将草稿移动到 `source/_posts` 文件夹，该命令的使用方式与 `new` 十分类似，您也可在命令中指定 `layout` 来指定布局。\n\n```\n$ hexo publish [layout] <title>\n```\n\n草稿默认不会显示在页面中，您可在执行时加上 `--draft` 参数，或是把 `render_drafts` 参数设为 `true` 来预览草稿。\n\n### 模版（Scaffold）\n\n在新建文章时，Hexo 会根据 `scaffolds` 文件夹内相对应的文件来建立文件，例如：\n\n```\n$ hexo new photo \"My Gallery\"\n```\n\n在执行这行指令时，Hexo 会尝试在 `scaffolds` 文件夹中寻找 `photo.md`，并根据其内容建立文章，以下是您可以在模版中使用的变量：\n\n| 变量     | 描述         |\n| :------- | :----------- |\n| `layout` | 布局         |\n| `title`  | 标题         |\n| `date`   | 文件建立日期 |\n\n### 支持的格式\n\nHexo 支持以任何格式书写文章，只要安装了相应的渲染插件。\n\n例如，Hexo 默认安装了 `hexo-renderer-marked` 和 `hexo-renderer-ejs`，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 `hexo-renderer-pug`，你甚至可以用 Pug 模板语言书写文章。\n\n只需要将文章的扩展名从 `md` 改成 `ejs`，Hexo 就会使用 `hexo-renderer-ejs` 渲染这个文件，其他格式同理。","slug":"博客教程/hexo/hexo写作","published":1,"date":"2020-12-21T15:10:33.055Z","updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6hj0018tvcd4m9i8e14","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>这篇文章将讲解如果使用hexo命令生成页面、文章及如何配置文章模板等操作。</p>\n</blockquote>\n<p>你可以执行下列命令来创建一篇新文章或者新的页面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure>\n<p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>\n<h3 id=\"布局（Layout）\"><a href=\"#布局（Layout）\" class=\"headerlink\" title=\"布局（Layout）\"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">布局</th>\n<th align=\"left\">路径</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>post</code></td>\n<td align=\"left\"><code>source/_posts</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>page</code></td>\n<td align=\"left\"><code>source</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>draft</code></td>\n<td align=\"left\"><code>source/_drafts</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>Disabling layout</p>\n<p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href=\"https://hexo.io/zh-cn/docs/front-matter#布局\">this section</a> for more details.</p>\n</blockquote>\n<h3 id=\"文件名称\"><a href=\"#文件名称\" class=\"headerlink\" title=\"文件名称\"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>:title</code></td>\n<td align=\"left\">标题（小写，空格将会被替换为短杠）</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:year</code></td>\n<td align=\"left\">建立的年份，比如， <code>2015</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:month</code></td>\n<td align=\"left\">建立的月份（有前导零），比如， <code>04</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:i_month</code></td>\n<td align=\"left\">建立的月份（无前导零），比如， <code>4</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:day</code></td>\n<td align=\"left\">建立的日期（有前导零），比如， <code>07</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:i_day</code></td>\n<td align=\"left\">建立的日期（无前导零），比如， <code>7</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure>\n<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p>\n<h3 id=\"模版（Scaffold）\"><a href=\"#模版（Scaffold）\" class=\"headerlink\" title=\"模版（Scaffold）\"></a>模版（Scaffold）</h3><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo new photo &quot;My Gallery&quot;<br></code></pre></td></tr></table></figure>\n<p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>layout</code></td>\n<td align=\"left\">布局</td>\n</tr>\n<tr>\n<td align=\"left\"><code>title</code></td>\n<td align=\"left\">标题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>date</code></td>\n<td align=\"left\">文件建立日期</td>\n</tr>\n</tbody></table>\n<h3 id=\"支持的格式\"><a href=\"#支持的格式\" class=\"headerlink\" title=\"支持的格式\"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p>\n<p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p>\n<p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<blockquote>\n<p>这篇文章将讲解如果使用hexo命令生成页面、文章及如何配置文章模板等操作。</p>\n</blockquote>\n<p>你可以执行下列命令来创建一篇新文章或者新的页面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure>\n<p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>\n<h3 id=\"布局（Layout）\"><a href=\"#布局（Layout）\" class=\"headerlink\" title=\"布局（Layout）\"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">布局</th>\n<th align=\"left\">路径</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>post</code></td>\n<td align=\"left\"><code>source/_posts</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>page</code></td>\n<td align=\"left\"><code>source</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>draft</code></td>\n<td align=\"left\"><code>source/_drafts</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>Disabling layout</p>\n<p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href=\"https://hexo.io/zh-cn/docs/front-matter#布局\">this section</a> for more details.</p>\n</blockquote>\n<h3 id=\"文件名称\"><a href=\"#文件名称\" class=\"headerlink\" title=\"文件名称\"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>:title</code></td>\n<td align=\"left\">标题（小写，空格将会被替换为短杠）</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:year</code></td>\n<td align=\"left\">建立的年份，比如， <code>2015</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:month</code></td>\n<td align=\"left\">建立的月份（有前导零），比如， <code>04</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:i_month</code></td>\n<td align=\"left\">建立的月份（无前导零），比如， <code>4</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:day</code></td>\n<td align=\"left\">建立的日期（有前导零），比如， <code>07</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>:i_day</code></td>\n<td align=\"left\">建立的日期（无前导零），比如， <code>7</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"草稿\"><a href=\"#草稿\" class=\"headerlink\" title=\"草稿\"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo publish [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure>\n<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p>\n<h3 id=\"模版（Scaffold）\"><a href=\"#模版（Scaffold）\" class=\"headerlink\" title=\"模版（Scaffold）\"></a>模版（Scaffold）</h3><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo new photo &quot;My Gallery&quot;<br></code></pre></td></tr></table></figure>\n<p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>layout</code></td>\n<td align=\"left\">布局</td>\n</tr>\n<tr>\n<td align=\"left\"><code>title</code></td>\n<td align=\"left\">标题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>date</code></td>\n<td align=\"left\">文件建立日期</td>\n</tr>\n</tbody></table>\n<h3 id=\"支持的格式\"><a href=\"#支持的格式\" class=\"headerlink\" title=\"支持的格式\"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p>\n<p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p>\n<p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p>\n"},{"title":"Hexo搭建博客：Hexo常用命令","cover":"https://cdn.tanxz.com/images/category/hexo.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","abbrlink":2628717197,"_content":"\n> 本文章将讲解在搭建Hexo博客过程中的常用命令及命令的参数说明\n\n<!-- more -->\n\n## init\n\n```shell\n$ hexo init [folder]\n```\n\n新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\nThis command is a shortcut that runs the following steps:\n\n1. Git clone [hexo-starter](https://github.com/hexojs/hexo-starter) including [hexo-theme-landscape](https://github.com/hexojs/hexo-theme-landscape) into the current directory or a target folder if specified.\n2. Install dependencies using a package manager: [Yarn 1](https://classic.yarnpkg.com/lang/en/), [pnpm](https://pnpm.js.org/) or [npm](https://docs.npmjs.com/cli/install), whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with [Node.js](https://hexo.io/docs/#Install-Node-js) by default.\n\n## new\n\n```xml\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n```\n$ hexo new \"post title with whitespace\"\n```\n\n| 参数              | 描述                                          |\n| :---------------- | :-------------------------------------------- |\n| `-p`, `--path`    | 自定义新文章的路径                            |\n| `-r`, `--replace` | 如果存在同名文章，将其替换                    |\n| `-s`, `--slug`    | 文章的 Slug，作为新文章的文件名和发布后的 URL |\n\n默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 `index.md` 文件。你可以使用 `--path` 参数来覆盖上述行为、自行决定文件的目录：\n\n```\nhexo new page --path about/me \"About me\"\n```\n\n以上命令会创建一个 `source/about/me.md` 文件，同时 Front Matter 中的 title 为 `\"About me\"`\n\n注意！title 是必须指定的！如果你这么做并不能达到你的目的：\n\n```\nhexo new page --path about/me\n```\n\n此时 Hexo 会创建 `source/_posts/about/me.md`，同时 `me.md` 的 Front Matter 中的 title 为 `\"page\"`。这是因为在上述命令中，hexo-cli 将 `page` 视为指定文章的标题、并采用默认的 `layout`。\n\n## generate\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项                  | 描述                                                         |\n| :-------------------- | :----------------------------------------------------------- |\n| `-d`, `--deploy`      | 文件生成后立即部署网站                                       |\n| `-w`, `--watch`       | 监视文件变动                                                 |\n| `-b`, `--bail`        | 生成过程中如果发生任何未处理的异常则抛出异常                 |\n| `-f`, `--force`       | 强制重新生成文件 Hexo 引入了差分机制，如果 `public` 目录存在，那么 `hexo g` 只会重新生成改动的文件。 使用该参数的效果接近 `hexo clean && hexo generate` |\n| `-c`, `--concurrency` | 最大同时生成文件的数量，默认无限制                           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n## publish\n\n```\n$ hexo publish [layout] <filename>\n```\n\n发表草稿。\n\n## server\n\n```\n$ hexo server\n```\n\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n| 选项             | 描述                           |\n| :--------------- | :----------------------------- |\n| `-p`, `--port`   | 重设端口                       |\n| `-s`, `--static` | 只使用静态文件                 |\n| `-l`, `--log`    | 启动日记记录，使用覆盖记录格式 |\n\n## deploy\n\n```\n$ hexo deploy\n```\n\n部署网站。\n\n| 参数               | 描述                     |\n| :----------------- | :----------------------- |\n| `-g`, `--generate` | 部署之前预先生成静态文件 |\n\n该命令可以简写为：\n\n```\n$ hexo d\n```\n\n## render\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n渲染文件。\n\n| 参数             | 描述         |\n| :--------------- | :----------- |\n| `-o`, `--output` | 设置输出路径 |\n\n## migrate\n\n```\n$ hexo migrate <type>\n```\n\n从其他博客系统 [迁移内容](https://hexo.io/zh-cn/docs/migration)。\n\n## clean\n\n```\n$ hexo clean\n```\n\n清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n## list\n\n```\n$ hexo list <type>\n```\n\n列出网站资料。\n\n## version\n\n```\n$ hexo version\n```\n\n显示 Hexo 版本。\n\n## 选项\n\n### 安全模式\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n### 调试模式\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 `debug.log`。当您碰到问题时，可以尝试用调试模式重新执行一次，并 [提交调试信息到 GitHub](https://github.com/hexojs/hexo/issues/new)。\n\n### 简洁模式\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n### 自定义配置文件的路径\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n自定义配置文件的路径，指定这个参数后将不再使用默认的 `_config.yml`。\n你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 `_multiconfig.yml`。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。\n\n### 显示草稿\n\n```\n$ hexo --draft\n```\n\n显示 `source/_drafts` 文件夹中的草稿文章。\n\n### 自定义 CWD\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。","source":"_posts/博客教程/hexo/hexo命令.md","raw":"---\ntitle: Hexo搭建博客：Hexo常用命令\ncategories: \n  - 博客教程\ntags:\n  - Hexo\ncover: https://cdn.tanxz.com/images/category/hexo.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\nabbrlink: 2628717197\n---\n\n> 本文章将讲解在搭建Hexo博客过程中的常用命令及命令的参数说明\n\n<!-- more -->\n\n## init\n\n```shell\n$ hexo init [folder]\n```\n\n新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\nThis command is a shortcut that runs the following steps:\n\n1. Git clone [hexo-starter](https://github.com/hexojs/hexo-starter) including [hexo-theme-landscape](https://github.com/hexojs/hexo-theme-landscape) into the current directory or a target folder if specified.\n2. Install dependencies using a package manager: [Yarn 1](https://classic.yarnpkg.com/lang/en/), [pnpm](https://pnpm.js.org/) or [npm](https://docs.npmjs.com/cli/install), whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with [Node.js](https://hexo.io/docs/#Install-Node-js) by default.\n\n## new\n\n```xml\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n```\n$ hexo new \"post title with whitespace\"\n```\n\n| 参数              | 描述                                          |\n| :---------------- | :-------------------------------------------- |\n| `-p`, `--path`    | 自定义新文章的路径                            |\n| `-r`, `--replace` | 如果存在同名文章，将其替换                    |\n| `-s`, `--slug`    | 文章的 Slug，作为新文章的文件名和发布后的 URL |\n\n默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 `index.md` 文件。你可以使用 `--path` 参数来覆盖上述行为、自行决定文件的目录：\n\n```\nhexo new page --path about/me \"About me\"\n```\n\n以上命令会创建一个 `source/about/me.md` 文件，同时 Front Matter 中的 title 为 `\"About me\"`\n\n注意！title 是必须指定的！如果你这么做并不能达到你的目的：\n\n```\nhexo new page --path about/me\n```\n\n此时 Hexo 会创建 `source/_posts/about/me.md`，同时 `me.md` 的 Front Matter 中的 title 为 `\"page\"`。这是因为在上述命令中，hexo-cli 将 `page` 视为指定文章的标题、并采用默认的 `layout`。\n\n## generate\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项                  | 描述                                                         |\n| :-------------------- | :----------------------------------------------------------- |\n| `-d`, `--deploy`      | 文件生成后立即部署网站                                       |\n| `-w`, `--watch`       | 监视文件变动                                                 |\n| `-b`, `--bail`        | 生成过程中如果发生任何未处理的异常则抛出异常                 |\n| `-f`, `--force`       | 强制重新生成文件 Hexo 引入了差分机制，如果 `public` 目录存在，那么 `hexo g` 只会重新生成改动的文件。 使用该参数的效果接近 `hexo clean && hexo generate` |\n| `-c`, `--concurrency` | 最大同时生成文件的数量，默认无限制                           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n## publish\n\n```\n$ hexo publish [layout] <filename>\n```\n\n发表草稿。\n\n## server\n\n```\n$ hexo server\n```\n\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n| 选项             | 描述                           |\n| :--------------- | :----------------------------- |\n| `-p`, `--port`   | 重设端口                       |\n| `-s`, `--static` | 只使用静态文件                 |\n| `-l`, `--log`    | 启动日记记录，使用覆盖记录格式 |\n\n## deploy\n\n```\n$ hexo deploy\n```\n\n部署网站。\n\n| 参数               | 描述                     |\n| :----------------- | :----------------------- |\n| `-g`, `--generate` | 部署之前预先生成静态文件 |\n\n该命令可以简写为：\n\n```\n$ hexo d\n```\n\n## render\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n渲染文件。\n\n| 参数             | 描述         |\n| :--------------- | :----------- |\n| `-o`, `--output` | 设置输出路径 |\n\n## migrate\n\n```\n$ hexo migrate <type>\n```\n\n从其他博客系统 [迁移内容](https://hexo.io/zh-cn/docs/migration)。\n\n## clean\n\n```\n$ hexo clean\n```\n\n清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n## list\n\n```\n$ hexo list <type>\n```\n\n列出网站资料。\n\n## version\n\n```\n$ hexo version\n```\n\n显示 Hexo 版本。\n\n## 选项\n\n### 安全模式\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n### 调试模式\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 `debug.log`。当您碰到问题时，可以尝试用调试模式重新执行一次，并 [提交调试信息到 GitHub](https://github.com/hexojs/hexo/issues/new)。\n\n### 简洁模式\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n### 自定义配置文件的路径\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n自定义配置文件的路径，指定这个参数后将不再使用默认的 `_config.yml`。\n你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 `_multiconfig.yml`。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。\n\n### 显示草稿\n\n```\n$ hexo --draft\n```\n\n显示 `source/_drafts` 文件夹中的草稿文章。\n\n### 自定义 CWD\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。","slug":"博客教程/hexo/hexo命令","published":1,"date":"2020-12-21T15:10:33.058Z","updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6hj001atvcdevsg18co","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本文章将讲解在搭建Hexo博客过程中的常用命令及命令的参数说明</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> hexo init [folder]</span><br></code></pre></td></tr></table></figure>\n<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>\n<p>This command is a shortcut that runs the following steps:</p>\n<ol>\n<li>Git clone <a href=\"https://github.com/hexojs/hexo-starter\">hexo-starter</a> including <a href=\"https://github.com/hexojs/hexo-theme-landscape\">hexo-theme-landscape</a> into the current directory or a target folder if specified.</li>\n<li>Install dependencies using a package manager: <a href=\"https://classic.yarnpkg.com/lang/en/\">Yarn 1</a>, <a href=\"https://pnpm.js.org/\">pnpm</a> or <a href=\"https://docs.npmjs.com/cli/install\">npm</a>, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with <a href=\"https://hexo.io/docs/#Install-Node-js\">Node.js</a> by default.</li>\n</ol>\n<h2 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">$ hexo new [layout] <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href=\"https://hexo.io/zh-cn/docs/configuration\">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo new &quot;post title with whitespace&quot;<br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--path</code></td>\n<td align=\"left\">自定义新文章的路径</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-r</code>, <code>--replace</code></td>\n<td align=\"left\">如果存在同名文章，将其替换</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--slug</code></td>\n<td align=\"left\">文章的 Slug，作为新文章的文件名和发布后的 URL</td>\n</tr>\n</tbody></table>\n<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">hexo new page --path about&#x2F;me &quot;About me&quot;<br></code></pre></td></tr></table></figure>\n<p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p>\n<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">hexo new page --path about&#x2F;me<br></code></pre></td></tr></table></figure>\n<p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p>\n<h2 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>生成静态文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-d</code>, <code>--deploy</code></td>\n<td align=\"left\">文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-w</code>, <code>--watch</code></td>\n<td align=\"left\">监视文件变动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-b</code>, <code>--bail</code></td>\n<td align=\"left\">生成过程中如果发生任何未处理的异常则抛出异常</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-f</code>, <code>--force</code></td>\n<td align=\"left\">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>-c</code>, <code>--concurrency</code></td>\n<td align=\"left\">最大同时生成文件的数量，默认无限制</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo g<br></code></pre></td></tr></table></figure>\n<h2 id=\"publish\"><a href=\"#publish\" class=\"headerlink\" title=\"publish\"></a>publish</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo publish [layout] &lt;filename&gt;<br></code></pre></td></tr></table></figure>\n<p>发表草稿。</p>\n<h2 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--port</code></td>\n<td align=\"left\">重设端口</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--static</code></td>\n<td align=\"left\">只使用静态文件</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-l</code>, <code>--log</code></td>\n<td align=\"left\">启动日记记录，使用覆盖记录格式</td>\n</tr>\n</tbody></table>\n<h2 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>部署网站。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-g</code>, <code>--generate</code></td>\n<td align=\"left\">部署之前预先生成静态文件</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo d<br></code></pre></td></tr></table></figure>\n<h2 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure>\n<p>渲染文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-o</code>, <code>--output</code></td>\n<td align=\"left\">设置输出路径</td>\n</tr>\n</tbody></table>\n<h2 id=\"migrate\"><a href=\"#migrate\" class=\"headerlink\" title=\"migrate\"></a>migrate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo migrate &lt;type&gt;<br></code></pre></td></tr></table></figure>\n<p>从其他博客系统 <a href=\"https://hexo.io/zh-cn/docs/migration\">迁移内容</a>。</p>\n<h2 id=\"clean\"><a href=\"#clean\" class=\"headerlink\" title=\"clean\"></a>clean</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo clean<br></code></pre></td></tr></table></figure>\n<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>\n<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>\n<h2 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo list &lt;type&gt;<br></code></pre></td></tr></table></figure>\n<p>列出网站资料。</p>\n<h2 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo version<br></code></pre></td></tr></table></figure>\n<p>显示 Hexo 版本。</p>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><h3 id=\"安全模式\"><a href=\"#安全模式\" class=\"headerlink\" title=\"安全模式\"></a>安全模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --safe<br></code></pre></td></tr></table></figure>\n<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>\n<h3 id=\"调试模式\"><a href=\"#调试模式\" class=\"headerlink\" title=\"调试模式\"></a>调试模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --debug<br></code></pre></td></tr></table></figure>\n<p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href=\"https://github.com/hexojs/hexo/issues/new\">提交调试信息到 GitHub</a>。</p>\n<h3 id=\"简洁模式\"><a href=\"#简洁模式\" class=\"headerlink\" title=\"简洁模式\"></a>简洁模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --silent<br></code></pre></td></tr></table></figure>\n<p>隐藏终端信息。</p>\n<h3 id=\"自定义配置文件的路径\"><a href=\"#自定义配置文件的路径\" class=\"headerlink\" title=\"自定义配置文件的路径\"></a>自定义配置文件的路径</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># 使用 custom.yml 代替默认的 _config.yml<br>$ hexo server --config custom.yml<br><br># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure>\n<p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># 使用 custom.yml 代替默认的 _config.yml<br>$ hexo server --config custom.yml<br><br># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure>\n<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>\n<h3 id=\"显示草稿\"><a href=\"#显示草稿\" class=\"headerlink\" title=\"显示草稿\"></a>显示草稿</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --draft<br></code></pre></td></tr></table></figure>\n<p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>\n<h3 id=\"自定义-CWD\"><a href=\"#自定义-CWD\" class=\"headerlink\" title=\"自定义 CWD\"></a>自定义 CWD</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd<br></code></pre></td></tr></table></figure>\n<p>自定义当前工作目录（Current working directory）的路径。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"<blockquote>\n<p>本文章将讲解在搭建Hexo博客过程中的常用命令及命令的参数说明</p>\n</blockquote>","more":"<h2 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">$</span><span class=\"bash\"> hexo init [folder]</span><br></code></pre></td></tr></table></figure>\n<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>\n<p>This command is a shortcut that runs the following steps:</p>\n<ol>\n<li>Git clone <a href=\"https://github.com/hexojs/hexo-starter\">hexo-starter</a> including <a href=\"https://github.com/hexojs/hexo-theme-landscape\">hexo-theme-landscape</a> into the current directory or a target folder if specified.</li>\n<li>Install dependencies using a package manager: <a href=\"https://classic.yarnpkg.com/lang/en/\">Yarn 1</a>, <a href=\"https://pnpm.js.org/\">pnpm</a> or <a href=\"https://docs.npmjs.com/cli/install\">npm</a>, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with <a href=\"https://hexo.io/docs/#Install-Node-js\">Node.js</a> by default.</li>\n</ol>\n<h2 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">$ hexo new [layout] <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href=\"https://hexo.io/zh-cn/docs/configuration\">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo new &quot;post title with whitespace&quot;<br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--path</code></td>\n<td align=\"left\">自定义新文章的路径</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-r</code>, <code>--replace</code></td>\n<td align=\"left\">如果存在同名文章，将其替换</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--slug</code></td>\n<td align=\"left\">文章的 Slug，作为新文章的文件名和发布后的 URL</td>\n</tr>\n</tbody></table>\n<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">hexo new page --path about&#x2F;me &quot;About me&quot;<br></code></pre></td></tr></table></figure>\n<p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p>\n<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">hexo new page --path about&#x2F;me<br></code></pre></td></tr></table></figure>\n<p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p>\n<h2 id=\"generate\"><a href=\"#generate\" class=\"headerlink\" title=\"generate\"></a>generate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo generate<br></code></pre></td></tr></table></figure>\n<p>生成静态文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-d</code>, <code>--deploy</code></td>\n<td align=\"left\">文件生成后立即部署网站</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-w</code>, <code>--watch</code></td>\n<td align=\"left\">监视文件变动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-b</code>, <code>--bail</code></td>\n<td align=\"left\">生成过程中如果发生任何未处理的异常则抛出异常</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-f</code>, <code>--force</code></td>\n<td align=\"left\">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>-c</code>, <code>--concurrency</code></td>\n<td align=\"left\">最大同时生成文件的数量，默认无限制</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo g<br></code></pre></td></tr></table></figure>\n<h2 id=\"publish\"><a href=\"#publish\" class=\"headerlink\" title=\"publish\"></a>publish</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo publish [layout] &lt;filename&gt;<br></code></pre></td></tr></table></figure>\n<p>发表草稿。</p>\n<h2 id=\"server\"><a href=\"#server\" class=\"headerlink\" title=\"server\"></a>server</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo server<br></code></pre></td></tr></table></figure>\n<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">选项</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-p</code>, <code>--port</code></td>\n<td align=\"left\">重设端口</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-s</code>, <code>--static</code></td>\n<td align=\"left\">只使用静态文件</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-l</code>, <code>--log</code></td>\n<td align=\"left\">启动日记记录，使用覆盖记录格式</td>\n</tr>\n</tbody></table>\n<h2 id=\"deploy\"><a href=\"#deploy\" class=\"headerlink\" title=\"deploy\"></a>deploy</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n<p>部署网站。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-g</code>, <code>--generate</code></td>\n<td align=\"left\">部署之前预先生成静态文件</td>\n</tr>\n</tbody></table>\n<p>该命令可以简写为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo d<br></code></pre></td></tr></table></figure>\n<h2 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure>\n<p>渲染文件。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>-o</code>, <code>--output</code></td>\n<td align=\"left\">设置输出路径</td>\n</tr>\n</tbody></table>\n<h2 id=\"migrate\"><a href=\"#migrate\" class=\"headerlink\" title=\"migrate\"></a>migrate</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo migrate &lt;type&gt;<br></code></pre></td></tr></table></figure>\n<p>从其他博客系统 <a href=\"https://hexo.io/zh-cn/docs/migration\">迁移内容</a>。</p>\n<h2 id=\"clean\"><a href=\"#clean\" class=\"headerlink\" title=\"clean\"></a>clean</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo clean<br></code></pre></td></tr></table></figure>\n<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>\n<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>\n<h2 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo list &lt;type&gt;<br></code></pre></td></tr></table></figure>\n<p>列出网站资料。</p>\n<h2 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo version<br></code></pre></td></tr></table></figure>\n<p>显示 Hexo 版本。</p>\n<h2 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h2><h3 id=\"安全模式\"><a href=\"#安全模式\" class=\"headerlink\" title=\"安全模式\"></a>安全模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --safe<br></code></pre></td></tr></table></figure>\n<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>\n<h3 id=\"调试模式\"><a href=\"#调试模式\" class=\"headerlink\" title=\"调试模式\"></a>调试模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --debug<br></code></pre></td></tr></table></figure>\n<p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href=\"https://github.com/hexojs/hexo/issues/new\">提交调试信息到 GitHub</a>。</p>\n<h3 id=\"简洁模式\"><a href=\"#简洁模式\" class=\"headerlink\" title=\"简洁模式\"></a>简洁模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --silent<br></code></pre></td></tr></table></figure>\n<p>隐藏终端信息。</p>\n<h3 id=\"自定义配置文件的路径\"><a href=\"#自定义配置文件的路径\" class=\"headerlink\" title=\"自定义配置文件的路径\"></a>自定义配置文件的路径</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># 使用 custom.yml 代替默认的 _config.yml<br>$ hexo server --config custom.yml<br><br># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure>\n<p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># 使用 custom.yml 代替默认的 _config.yml<br>$ hexo server --config custom.yml<br><br># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure>\n<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>\n<h3 id=\"显示草稿\"><a href=\"#显示草稿\" class=\"headerlink\" title=\"显示草稿\"></a>显示草稿</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --draft<br></code></pre></td></tr></table></figure>\n<p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>\n<h3 id=\"自定义-CWD\"><a href=\"#自定义-CWD\" class=\"headerlink\" title=\"自定义 CWD\"></a>自定义 CWD</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd<br></code></pre></td></tr></table></figure>\n<p>自定义当前工作目录（Current working directory）的路径。</p>"},{"title":"Hexo搭建博客：基于Github Action工作流自动部署Hexo","cover":"https://cdn.tanxz.com/images/category/hexo.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","abbrlink":2231850037,"date":"2020-04-16T03:54:14.000Z","_content":"\n# Hexo搭建\n这段就pass了，只要这篇主要讲解Github Action部署\n\n# 创建github ssh 私钥和公钥\n在本地运行如下命令生成id_rsa和id_rsa.pub文件，一路回车，不要输入密码！！！不要输入密码！！！不要输入密码！！！（被这个坑的我想哭T_T，一直验证不通过）\n```cmd\n$ ssh-keygen -t rsa -C \"tanxinzheng@139.com\" #此处修改为你github的注册邮箱\n```\n\n# Github设置\n- 将id_rsa私钥放入项目的settings/secures配置中\n- 将id_rsa.pub公钥填入账号的settings/SSH keys配置中\n\n# 创建Github Action工作流脚本\n\n在项目该目录下创建~./.github/workflows/main.yml文件，将下面的配置信息填入，并修改自己的信息即可\n\n```yml\nname: CI\n# 触发执行的操作和分支名称\non:\n  push:\n    branches:\n      - generate-source\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout source\n        uses: actions/checkout@v1\n        with:\n          # 分支号\n          ref: generate-source\n      - name: Use Node.js ${{ matrix.node_version }}\n        uses: actions/setup-node@v1\n        with:\n          version: ${{ matrix.node_version }}\n      - name: Setup hexo\n        env:\n          ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_PRI }}\n        run: |\n          mkdir -p ~/.ssh/\n          echo \"$ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n          git config --global user.email \"tanxinzheng@139.com\"\n          git config --global user.name \"tanxinzheng\"\n          npm install hexo-cli -g\n          npm install\n      - name: Hexo deploy\n        run: |\n          hexo clean\n          hexo d\n```\n\n# Github Action执行部署\n在Github Action页面执行即可，push之后会自动部署。","source":"_posts/博客教程/hexo/基于Github Action工作流自动部署Hexo.md","raw":"---\ntitle: Hexo搭建博客：基于Github Action工作流自动部署Hexo\ncategories: \n\t- 技术实践\ntags:\n  - Hexo\n  - Github\ncover: https://cdn.tanxz.com/images/category/hexo.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\nabbrlink: 2231850037\ndate: 2020-04-16 11:54:14\n---\n\n# Hexo搭建\n这段就pass了，只要这篇主要讲解Github Action部署\n\n# 创建github ssh 私钥和公钥\n在本地运行如下命令生成id_rsa和id_rsa.pub文件，一路回车，不要输入密码！！！不要输入密码！！！不要输入密码！！！（被这个坑的我想哭T_T，一直验证不通过）\n```cmd\n$ ssh-keygen -t rsa -C \"tanxinzheng@139.com\" #此处修改为你github的注册邮箱\n```\n\n# Github设置\n- 将id_rsa私钥放入项目的settings/secures配置中\n- 将id_rsa.pub公钥填入账号的settings/SSH keys配置中\n\n# 创建Github Action工作流脚本\n\n在项目该目录下创建~./.github/workflows/main.yml文件，将下面的配置信息填入，并修改自己的信息即可\n\n```yml\nname: CI\n# 触发执行的操作和分支名称\non:\n  push:\n    branches:\n      - generate-source\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout source\n        uses: actions/checkout@v1\n        with:\n          # 分支号\n          ref: generate-source\n      - name: Use Node.js ${{ matrix.node_version }}\n        uses: actions/setup-node@v1\n        with:\n          version: ${{ matrix.node_version }}\n      - name: Setup hexo\n        env:\n          ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_PRI }}\n        run: |\n          mkdir -p ~/.ssh/\n          echo \"$ACTION_DEPLOY_KEY\" > ~/.ssh/id_rsa\n          chmod 600 ~/.ssh/id_rsa\n          ssh-keyscan github.com >> ~/.ssh/known_hosts\n          git config --global user.email \"tanxinzheng@139.com\"\n          git config --global user.name \"tanxinzheng\"\n          npm install hexo-cli -g\n          npm install\n      - name: Hexo deploy\n        run: |\n          hexo clean\n          hexo d\n```\n\n# Github Action执行部署\n在Github Action页面执行即可，push之后会自动部署。","slug":"博客教程/hexo/基于Github Action工作流自动部署Hexo","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6hl001ftvcddvyt1x5c","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Hexo搭建\"><a href=\"#Hexo搭建\" class=\"headerlink\" title=\"Hexo搭建\"></a>Hexo搭建</h1><p>这段就pass了，只要这篇主要讲解Github Action部署</p>\n<h1 id=\"创建github-ssh-私钥和公钥\"><a href=\"#创建github-ssh-私钥和公钥\" class=\"headerlink\" title=\"创建github ssh 私钥和公钥\"></a>创建github ssh 私钥和公钥</h1><p>在本地运行如下命令生成id_rsa和id_rsa.pub文件，一路回车，不要输入密码！！！不要输入密码！！！不要输入密码！！！（被这个坑的我想哭T_T，一直验证不通过）</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">$ ssh-keygen -t rsa -C &quot;tanxinzheng@<span class=\"hljs-number\">139</span>.com&quot; #此处修改为你github的注册邮箱<br></code></pre></td></tr></table></figure>\n<h1 id=\"Github设置\"><a href=\"#Github设置\" class=\"headerlink\" title=\"Github设置\"></a>Github设置</h1><ul>\n<li>将id_rsa私钥放入项目的settings/secures配置中</li>\n<li>将id_rsa.pub公钥填入账号的settings/SSH keys配置中</li>\n</ul>\n<h1 id=\"创建Github-Action工作流脚本\"><a href=\"#创建Github-Action工作流脚本\" class=\"headerlink\" title=\"创建Github Action工作流脚本\"></a>创建Github Action工作流脚本</h1><p>在项目该目录下创建~./.github/workflows/main.yml文件，将下面的配置信息填入，并修改自己的信息即可</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">CI</span><br><span class=\"hljs-comment\"># 触发执行的操作和分支名称</span><br><span class=\"hljs-attr\">on:</span><br>  <span class=\"hljs-attr\">push:</span><br>    <span class=\"hljs-attr\">branches:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">generate-source</span><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">build:</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">source</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v1</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-comment\"># 分支号</span><br>          <span class=\"hljs-attr\">ref:</span> <span class=\"hljs-string\">generate-source</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Use</span> <span class=\"hljs-string\">Node.js</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/setup-node@v1</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Setup</span> <span class=\"hljs-string\">hexo</span><br>        <span class=\"hljs-attr\">env:</span><br>          <span class=\"hljs-attr\">ACTION_DEPLOY_KEY:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">secrets.HEXO_DEPLOY_PRI</span> <span class=\"hljs-string\">&#125;&#125;</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br>          <span class=\"hljs-string\">mkdir</span> <span class=\"hljs-string\">-p</span> <span class=\"hljs-string\">~/.ssh/</span><br>          <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">&quot;$ACTION_DEPLOY_KEY&quot;</span> <span class=\"hljs-string\">&gt;</span> <span class=\"hljs-string\">~/.ssh/id_rsa</span><br>          <span class=\"hljs-string\">chmod</span> <span class=\"hljs-number\">600</span> <span class=\"hljs-string\">~/.ssh/id_rsa</span><br>          <span class=\"hljs-string\">ssh-keyscan</span> <span class=\"hljs-string\">github.com</span> <span class=\"hljs-string\">&gt;&gt;</span> <span class=\"hljs-string\">~/.ssh/known_hosts</span><br>          <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">config</span> <span class=\"hljs-string\">--global</span> <span class=\"hljs-string\">user.email</span> <span class=\"hljs-string\">&quot;tanxinzheng@139.com&quot;</span><br>          <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">config</span> <span class=\"hljs-string\">--global</span> <span class=\"hljs-string\">user.name</span> <span class=\"hljs-string\">&quot;tanxinzheng&quot;</span><br>          <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">hexo-cli</span> <span class=\"hljs-string\">-g</span><br>          <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Hexo</span> <span class=\"hljs-string\">deploy</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br>          <span class=\"hljs-string\">hexo</span> <span class=\"hljs-string\">clean</span><br>          <span class=\"hljs-string\">hexo</span> <span class=\"hljs-string\">d</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"Github-Action执行部署\"><a href=\"#Github-Action执行部署\" class=\"headerlink\" title=\"Github Action执行部署\"></a>Github Action执行部署</h1><p>在Github Action页面执行即可，push之后会自动部署。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Hexo搭建\"><a href=\"#Hexo搭建\" class=\"headerlink\" title=\"Hexo搭建\"></a>Hexo搭建</h1><p>这段就pass了，只要这篇主要讲解Github Action部署</p>\n<h1 id=\"创建github-ssh-私钥和公钥\"><a href=\"#创建github-ssh-私钥和公钥\" class=\"headerlink\" title=\"创建github ssh 私钥和公钥\"></a>创建github ssh 私钥和公钥</h1><p>在本地运行如下命令生成id_rsa和id_rsa.pub文件，一路回车，不要输入密码！！！不要输入密码！！！不要输入密码！！！（被这个坑的我想哭T_T，一直验证不通过）</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmd\">$ ssh-keygen -t rsa -C &quot;tanxinzheng@<span class=\"hljs-number\">139</span>.com&quot; #此处修改为你github的注册邮箱<br></code></pre></td></tr></table></figure>\n<h1 id=\"Github设置\"><a href=\"#Github设置\" class=\"headerlink\" title=\"Github设置\"></a>Github设置</h1><ul>\n<li>将id_rsa私钥放入项目的settings/secures配置中</li>\n<li>将id_rsa.pub公钥填入账号的settings/SSH keys配置中</li>\n</ul>\n<h1 id=\"创建Github-Action工作流脚本\"><a href=\"#创建Github-Action工作流脚本\" class=\"headerlink\" title=\"创建Github Action工作流脚本\"></a>创建Github Action工作流脚本</h1><p>在项目该目录下创建~./.github/workflows/main.yml文件，将下面的配置信息填入，并修改自己的信息即可</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">CI</span><br><span class=\"hljs-comment\"># 触发执行的操作和分支名称</span><br><span class=\"hljs-attr\">on:</span><br>  <span class=\"hljs-attr\">push:</span><br>    <span class=\"hljs-attr\">branches:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">generate-source</span><br><span class=\"hljs-attr\">jobs:</span><br>  <span class=\"hljs-attr\">build:</span><br>    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br><br>    <span class=\"hljs-attr\">steps:</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span> <span class=\"hljs-string\">source</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v1</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-comment\"># 分支号</span><br>          <span class=\"hljs-attr\">ref:</span> <span class=\"hljs-string\">generate-source</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Use</span> <span class=\"hljs-string\">Node.js</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span><br>        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/setup-node@v1</span><br>        <span class=\"hljs-attr\">with:</span><br>          <span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">matrix.node_version</span> <span class=\"hljs-string\">&#125;&#125;</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Setup</span> <span class=\"hljs-string\">hexo</span><br>        <span class=\"hljs-attr\">env:</span><br>          <span class=\"hljs-attr\">ACTION_DEPLOY_KEY:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">secrets.HEXO_DEPLOY_PRI</span> <span class=\"hljs-string\">&#125;&#125;</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br>          <span class=\"hljs-string\">mkdir</span> <span class=\"hljs-string\">-p</span> <span class=\"hljs-string\">~/.ssh/</span><br>          <span class=\"hljs-string\">echo</span> <span class=\"hljs-string\">&quot;$ACTION_DEPLOY_KEY&quot;</span> <span class=\"hljs-string\">&gt;</span> <span class=\"hljs-string\">~/.ssh/id_rsa</span><br>          <span class=\"hljs-string\">chmod</span> <span class=\"hljs-number\">600</span> <span class=\"hljs-string\">~/.ssh/id_rsa</span><br>          <span class=\"hljs-string\">ssh-keyscan</span> <span class=\"hljs-string\">github.com</span> <span class=\"hljs-string\">&gt;&gt;</span> <span class=\"hljs-string\">~/.ssh/known_hosts</span><br>          <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">config</span> <span class=\"hljs-string\">--global</span> <span class=\"hljs-string\">user.email</span> <span class=\"hljs-string\">&quot;tanxinzheng@139.com&quot;</span><br>          <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">config</span> <span class=\"hljs-string\">--global</span> <span class=\"hljs-string\">user.name</span> <span class=\"hljs-string\">&quot;tanxinzheng&quot;</span><br>          <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">hexo-cli</span> <span class=\"hljs-string\">-g</span><br>          <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span><br>      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Hexo</span> <span class=\"hljs-string\">deploy</span><br>        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br>          <span class=\"hljs-string\">hexo</span> <span class=\"hljs-string\">clean</span><br>          <span class=\"hljs-string\">hexo</span> <span class=\"hljs-string\">d</span><br></code></pre></td></tr></table></figure>\n<h1 id=\"Github-Action执行部署\"><a href=\"#Github-Action执行部署\" class=\"headerlink\" title=\"Github Action执行部署\"></a>Github Action执行部署</h1><p>在Github Action页面执行即可，push之后会自动部署。</p>\n"},{"title":"如何申请SSL免费证书","abbrlink":1125805289,"cover":"https://cdn.tanxz.com/images/category/https.jpg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","date":"2020-12-10T13:38:18.000Z","_content":"\n> 搭建https协议网上有许多教程，但各种因为网站的搭建情况都有很多特殊情况导致有些场景出现>  问题，这里分别整理了不同业务场景对应的搭建教程。\n\n<!-- more -->\n\n#### Certbot申请证书\n\n> 适用场景：拥有服务器权限，可命令行操作服务器\n\n请直接参考该文章：[Nginx 通过 certbot 为网站自动配置 SSL 证书并续期](https://blog.51cto.com/wzlinux/2385116)\n\n#### Freessl申请证书\n> 适用场景：服务器在第三方平台，没有操作服务器的权限只有配置证书的权限\n\n之前在使用OSS搭建Hexo博客时由于OSS存储服务器是由阿里云控制的，无法使用certbot的方式安装证书，又不想用阿里云的证书，查找实践许久终于找到了一种靠谱的解决方案，就是使用https://freessl.cn/平台的Keymanager工具，方便快捷有效。\n\n- 首先，注册https://freessl.cn/的账号（注册就不截图了）\n\n- 下载KeyManger工具，下载地址：https://keymanager.trustasia.com/release/KeyManager-Setup-4.4.19.exe\n\n- 安装好之后，登录注册FreeSSL后进入KeyManager，如下图\n\n![image-20201217233631334](../../img/image-20201217233631334.png)\n\n- 申请证书，填写证书信息，如图\n\n![image-20201217233848143](../../img/image-20201217233848143.png)\n\n- 获取DNS验证信息\n\n![image-20201217234030155](../../img/image-20201217234030155.png)\n\n- 将验证信息填入阿里云解析记录，如下图，完成后点击上一步的【我已配置完成】。\n\n![image-20201217232930044](../../img/image-20201217232930044.png)\n\n- 进入证书管理可看到生成的证书，点击证书详情\n\n![image-20201217233140546](../../img/image-20201217233140546.png)\n\n- 获取证书PEM信息，如下图，到这一步就OK了，拿到这个证书，怎么配置就看你怎么用，是直接上传到服务器还是使用OSS证书托管都可以。\n\n![image-20201217233418235](../../img/image-20201217233418235.png)","source":"_posts/各类教程/中间件/https教程.md","raw":"---\ntitle: 如何申请SSL免费证书\ncategories: \n  \t- 技术实践\ntags:\n\t- https\n\t- ssl\nabbrlink: 1125805289\ncover: https://cdn.tanxz.com/images/category/https.jpg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ndate: 2020-12-10 21:38:18\n---\n\n> 搭建https协议网上有许多教程，但各种因为网站的搭建情况都有很多特殊情况导致有些场景出现>  问题，这里分别整理了不同业务场景对应的搭建教程。\n\n<!-- more -->\n\n#### Certbot申请证书\n\n> 适用场景：拥有服务器权限，可命令行操作服务器\n\n请直接参考该文章：[Nginx 通过 certbot 为网站自动配置 SSL 证书并续期](https://blog.51cto.com/wzlinux/2385116)\n\n#### Freessl申请证书\n> 适用场景：服务器在第三方平台，没有操作服务器的权限只有配置证书的权限\n\n之前在使用OSS搭建Hexo博客时由于OSS存储服务器是由阿里云控制的，无法使用certbot的方式安装证书，又不想用阿里云的证书，查找实践许久终于找到了一种靠谱的解决方案，就是使用https://freessl.cn/平台的Keymanager工具，方便快捷有效。\n\n- 首先，注册https://freessl.cn/的账号（注册就不截图了）\n\n- 下载KeyManger工具，下载地址：https://keymanager.trustasia.com/release/KeyManager-Setup-4.4.19.exe\n\n- 安装好之后，登录注册FreeSSL后进入KeyManager，如下图\n\n![image-20201217233631334](../../img/image-20201217233631334.png)\n\n- 申请证书，填写证书信息，如图\n\n![image-20201217233848143](../../img/image-20201217233848143.png)\n\n- 获取DNS验证信息\n\n![image-20201217234030155](../../img/image-20201217234030155.png)\n\n- 将验证信息填入阿里云解析记录，如下图，完成后点击上一步的【我已配置完成】。\n\n![image-20201217232930044](../../img/image-20201217232930044.png)\n\n- 进入证书管理可看到生成的证书，点击证书详情\n\n![image-20201217233140546](../../img/image-20201217233140546.png)\n\n- 获取证书PEM信息，如下图，到这一步就OK了，拿到这个证书，怎么配置就看你怎么用，是直接上传到服务器还是使用OSS证书托管都可以。\n\n![image-20201217233418235](../../img/image-20201217233418235.png)","slug":"各类教程/中间件/https教程","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6hm001itvcdf1dpgo61","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>搭建https协议网上有许多教程，但各种因为网站的搭建情况都有很多特殊情况导致有些场景出现&gt;  问题，这里分别整理了不同业务场景对应的搭建教程。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h4 id=\"Certbot申请证书\"><a href=\"#Certbot申请证书\" class=\"headerlink\" title=\"Certbot申请证书\"></a>Certbot申请证书</h4><blockquote>\n<p>适用场景：拥有服务器权限，可命令行操作服务器</p>\n</blockquote>\n<p>请直接参考该文章：<a href=\"https://blog.51cto.com/wzlinux/2385116\">Nginx 通过 certbot 为网站自动配置 SSL 证书并续期</a></p>\n<h4 id=\"Freessl申请证书\"><a href=\"#Freessl申请证书\" class=\"headerlink\" title=\"Freessl申请证书\"></a>Freessl申请证书</h4><blockquote>\n<p>适用场景：服务器在第三方平台，没有操作服务器的权限只有配置证书的权限</p>\n</blockquote>\n<p>之前在使用OSS搭建Hexo博客时由于OSS存储服务器是由阿里云控制的，无法使用certbot的方式安装证书，又不想用阿里云的证书，查找实践许久终于找到了一种靠谱的解决方案，就是使用<a href=\"https://freessl.cn/平台的Keymanager工具，方便快捷有效。\">https://freessl.cn/平台的Keymanager工具，方便快捷有效。</a></p>\n<ul>\n<li><p>首先，注册<a href=\"https://freessl.cn/的账号（注册就不截图了）\">https://freessl.cn/的账号（注册就不截图了）</a></p>\n</li>\n<li><p>下载KeyManger工具，下载地址：<a href=\"https://keymanager.trustasia.com/release/KeyManager-Setup-4.4.19.exe\">https://keymanager.trustasia.com/release/KeyManager-Setup-4.4.19.exe</a></p>\n</li>\n<li><p>安装好之后，登录注册FreeSSL后进入KeyManager，如下图</p>\n</li>\n</ul>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/image-20201217233631334.png\" alt=\"image-20201217233631334\"></p>\n<ul>\n<li>申请证书，填写证书信息，如图</li>\n</ul>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/image-20201217233848143.png\" alt=\"image-20201217233848143\"></p>\n<ul>\n<li>获取DNS验证信息</li>\n</ul>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/image-20201217234030155.png\" alt=\"image-20201217234030155\"></p>\n<ul>\n<li>将验证信息填入阿里云解析记录，如下图，完成后点击上一步的【我已配置完成】。</li>\n</ul>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/image-20201217232930044.png\" alt=\"image-20201217232930044\"></p>\n<ul>\n<li>进入证书管理可看到生成的证书，点击证书详情</li>\n</ul>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/image-20201217233140546.png\" alt=\"image-20201217233140546\"></p>\n<ul>\n<li>获取证书PEM信息，如下图，到这一步就OK了，拿到这个证书，怎么配置就看你怎么用，是直接上传到服务器还是使用OSS证书托管都可以。</li>\n</ul>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"../../img/image-20201217233418235.png\" alt=\"image-20201217233418235\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"<blockquote>\n<p>搭建https协议网上有许多教程，但各种因为网站的搭建情况都有很多特殊情况导致有些场景出现&gt;  问题，这里分别整理了不同业务场景对应的搭建教程。</p>\n</blockquote>","more":"<h4 id=\"Certbot申请证书\"><a href=\"#Certbot申请证书\" class=\"headerlink\" title=\"Certbot申请证书\"></a>Certbot申请证书</h4><blockquote>\n<p>适用场景：拥有服务器权限，可命令行操作服务器</p>\n</blockquote>\n<p>请直接参考该文章：<a href=\"https://blog.51cto.com/wzlinux/2385116\">Nginx 通过 certbot 为网站自动配置 SSL 证书并续期</a></p>\n<h4 id=\"Freessl申请证书\"><a href=\"#Freessl申请证书\" class=\"headerlink\" title=\"Freessl申请证书\"></a>Freessl申请证书</h4><blockquote>\n<p>适用场景：服务器在第三方平台，没有操作服务器的权限只有配置证书的权限</p>\n</blockquote>\n<p>之前在使用OSS搭建Hexo博客时由于OSS存储服务器是由阿里云控制的，无法使用certbot的方式安装证书，又不想用阿里云的证书，查找实践许久终于找到了一种靠谱的解决方案，就是使用<a href=\"https://freessl.cn/平台的Keymanager工具，方便快捷有效。\">https://freessl.cn/平台的Keymanager工具，方便快捷有效。</a></p>\n<ul>\n<li><p>首先，注册<a href=\"https://freessl.cn/的账号（注册就不截图了）\">https://freessl.cn/的账号（注册就不截图了）</a></p>\n</li>\n<li><p>下载KeyManger工具，下载地址：<a href=\"https://keymanager.trustasia.com/release/KeyManager-Setup-4.4.19.exe\">https://keymanager.trustasia.com/release/KeyManager-Setup-4.4.19.exe</a></p>\n</li>\n<li><p>安装好之后，登录注册FreeSSL后进入KeyManager，如下图</p>\n</li>\n</ul>\n<p><img src=\"../../img/image-20201217233631334.png\" alt=\"image-20201217233631334\"></p>\n<ul>\n<li>申请证书，填写证书信息，如图</li>\n</ul>\n<p><img src=\"../../img/image-20201217233848143.png\" alt=\"image-20201217233848143\"></p>\n<ul>\n<li>获取DNS验证信息</li>\n</ul>\n<p><img src=\"../../img/image-20201217234030155.png\" alt=\"image-20201217234030155\"></p>\n<ul>\n<li>将验证信息填入阿里云解析记录，如下图，完成后点击上一步的【我已配置完成】。</li>\n</ul>\n<p><img src=\"../../img/image-20201217232930044.png\" alt=\"image-20201217232930044\"></p>\n<ul>\n<li>进入证书管理可看到生成的证书，点击证书详情</li>\n</ul>\n<p><img src=\"../../img/image-20201217233140546.png\" alt=\"image-20201217233140546\"></p>\n<ul>\n<li>获取证书PEM信息，如下图，到这一步就OK了，拿到这个证书，怎么配置就看你怎么用，是直接上传到服务器还是使用OSS证书托管都可以。</li>\n</ul>\n<p><img src=\"../../img/image-20201217233418235.png\" alt=\"image-20201217233418235\"></p>"},{"title":"Linux命令killall","abbrlink":1026478353,"cover":"https://cdn.tanxz.com/images/category/linux.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","_content":"\n# Linux命令killall\n\n[![Linux 命令大全](https://www.runoob.com/images/up.gif) Linux 命令大全](https://www.runoob.com/linux/linux-command-manual.html)\n\nLinux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。\n\nkill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。\n\n### 语法\n\n```shell\n  killall [选项]  name\n```\n\n**参数说明**：\n\n- name ： 进程名\n\n\n\n选项包含如下几个参数：\n\n\n\n- -e | --exact ： 进程需要和名字完全相符\n- -I | --ignore-case ：忽略大小写\n- -g | --process-group ：结束进程组\n- -i | --interactive ：结束之前询问\n- -l | --list ：列出所有的信号名称\n- -q | --quite ：进程没有结束时，不输出任何信息\n- -r | --regexp ：将进程名模式解释为扩展的正则表达式。\n- -s | --signal ：发送指定信号\n- -u | --user ：结束指定用户的进程\n- -v | --verbose ：显示详细执行过程\n- -w | --wait ：等待所有的进程都结束\n- -V |--version ：显示版本信息\n- --help ：显示帮助信息\n\n### 实例\n\n```shell\n# killall -9 php-fpm          //结束所有的 php-fpm 进程\n```","source":"_posts/技术分享/linux/linux命令/Linux命令killall.md","raw":"---\ntitle: Linux命令killall\nabbrlink: 1026478353\ncover: https://cdn.tanxz.com/images/category/linux.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\n---\n\n# Linux命令killall\n\n[![Linux 命令大全](https://www.runoob.com/images/up.gif) Linux 命令大全](https://www.runoob.com/linux/linux-command-manual.html)\n\nLinux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。\n\nkill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。\n\n### 语法\n\n```shell\n  killall [选项]  name\n```\n\n**参数说明**：\n\n- name ： 进程名\n\n\n\n选项包含如下几个参数：\n\n\n\n- -e | --exact ： 进程需要和名字完全相符\n- -I | --ignore-case ：忽略大小写\n- -g | --process-group ：结束进程组\n- -i | --interactive ：结束之前询问\n- -l | --list ：列出所有的信号名称\n- -q | --quite ：进程没有结束时，不输出任何信息\n- -r | --regexp ：将进程名模式解释为扩展的正则表达式。\n- -s | --signal ：发送指定信号\n- -u | --user ：结束指定用户的进程\n- -v | --verbose ：显示详细执行过程\n- -w | --wait ：等待所有的进程都结束\n- -V |--version ：显示版本信息\n- --help ：显示帮助信息\n\n### 实例\n\n```shell\n# killall -9 php-fpm          //结束所有的 php-fpm 进程\n```","slug":"技术分享/linux/linux命令/Linux命令killall","published":1,"date":"2020-12-21T15:10:33.093Z","updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6hn001ntvcdbnbwhtqz","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Linux命令killall\"><a href=\"#Linux命令killall\" class=\"headerlink\" title=\"Linux命令killall\"></a>Linux命令killall</h1><p><a href=\"https://www.runoob.com/linux/linux-command-manual.html\"><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://www.runoob.com/images/up.gif\" alt=\"Linux 命令大全\"> Linux 命令大全</a></p>\n<p>Linux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。</p>\n<p>kill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">killall [选项]  name<br></code></pre></td></tr></table></figure>\n<p><strong>参数说明</strong>：</p>\n<ul>\n<li>name ： 进程名</li>\n</ul>\n<p>选项包含如下几个参数：</p>\n<ul>\n<li>-e | –exact ： 进程需要和名字完全相符</li>\n<li>-I | –ignore-case ：忽略大小写</li>\n<li>-g | –process-group ：结束进程组</li>\n<li>-i | –interactive ：结束之前询问</li>\n<li>-l | –list ：列出所有的信号名称</li>\n<li>-q | –quite ：进程没有结束时，不输出任何信息</li>\n<li>-r | –regexp ：将进程名模式解释为扩展的正则表达式。</li>\n<li>-s | –signal ：发送指定信号</li>\n<li>-u | –user ：结束指定用户的进程</li>\n<li>-v | –verbose ：显示详细执行过程</li>\n<li>-w | –wait ：等待所有的进程都结束</li>\n<li>-V |–version ：显示版本信息</li>\n<li>–help ：显示帮助信息</li>\n</ul>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> killall -9 php-fpm          //结束所有的 php-fpm 进程</span><br></code></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Linux命令killall\"><a href=\"#Linux命令killall\" class=\"headerlink\" title=\"Linux命令killall\"></a>Linux命令killall</h1><p><a href=\"https://www.runoob.com/linux/linux-command-manual.html\"><img src=\"https://www.runoob.com/images/up.gif\" alt=\"Linux 命令大全\"> Linux 命令大全</a></p>\n<p>Linux killall 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程。</p>\n<p>kill 命令杀死指定进程 PID，需要配合 ps 使用，而 killall 直接对进程对名字进行操作，更加方便。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">killall [选项]  name<br></code></pre></td></tr></table></figure>\n<p><strong>参数说明</strong>：</p>\n<ul>\n<li>name ： 进程名</li>\n</ul>\n<p>选项包含如下几个参数：</p>\n<ul>\n<li>-e | –exact ： 进程需要和名字完全相符</li>\n<li>-I | –ignore-case ：忽略大小写</li>\n<li>-g | –process-group ：结束进程组</li>\n<li>-i | –interactive ：结束之前询问</li>\n<li>-l | –list ：列出所有的信号名称</li>\n<li>-q | –quite ：进程没有结束时，不输出任何信息</li>\n<li>-r | –regexp ：将进程名模式解释为扩展的正则表达式。</li>\n<li>-s | –signal ：发送指定信号</li>\n<li>-u | –user ：结束指定用户的进程</li>\n<li>-v | –verbose ：显示详细执行过程</li>\n<li>-w | –wait ：等待所有的进程都结束</li>\n<li>-V |–version ：显示版本信息</li>\n<li>–help ：显示帮助信息</li>\n</ul>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> killall -9 php-fpm          //结束所有的 php-fpm 进程</span><br></code></pre></td></tr></table></figure>"},{"title":"【MySQL】索引及分页详解","abbrlink":780159822,"cover":"https://cdn.tanxz.com/images/category/mysql.png","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","date":"2018-07-19T13:38:18.000Z","_content":"\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdxUoEZiaQErySl2YPCNnF0ddmMVvCrSyBfkSEuEwbh3AmmqZgVrX1PJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**01**\n\n**为啥BAT大厂，在数据库上都喜欢深入的问索引呢？**\n\n\n\n一线大厂，是很多人梦寐以求的盛典天堂。因为存在的无限的可能，可以帮你实现自己的远大抱负。大平台机会、视野、格局往往都比小厂多很多。但随之而来也是那高挑的技术门槛需等你迈过。好事物大家都喜欢，但毕竟僧多粥少。外加任务有难度，如果你没过硬的本领，那很难踏入平台，领会一览众山小的风采。不知你心里有没有小九九？\n\n\n\n------\n\n\n\n大厂产品大多数都成型很久，数据库里面存储的数据都以海量计算，如何在这种规模下的数据中做到快速筛选呢？那就需要你来答。\n\n大家思路肯定和我一样，话不多说，加索引再说！索引为的就是提高数据的检索效率，进而减少请求的响应时间。\n\n**这时，有内涵的人可能会反问你啦？**\n\n那你说说索引有哪些类型？索引底层实现是什么结构？B+Tree的优点？聚簇索引和非聚簇的区别？索引一次读读取多少数据合适？为什么说索引会降低插入、删除、修改等维护任务的速度？\n\n这一套组合拳，可能虐的你是体无完肤。让人招教不住，心理一万个xxx省略。送他一个微笑，然后再尴尬而不失优雅的离去。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_jpg/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdBsMmPCcTSTbU914ibhsnXVFSZgMQ1d8GHqyYM1Gvo5vxHNrhVwUwJUw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n大家可能都知道查询慢了加索引，那为啥加？在哪些字段上加？以及索引的数据结构特点。索引优化、优点啥的都比较模糊或者不知道。\n\n今天将是对索引来一次灵魂的拷问，在进一步对索引优化、常见大厂面试问题、SQL优化等内容进行分享。这是个大工程，大家得关注再看。深，那就得深出高度。MOG！太深啦\n\n\n\n# **02**\n\n# **用索引，那你得知道索引是什么？**\n\n> 百度百科定义：索引是数据表中一列或多列的值进行排序的一种数据结构\n\n故此，索引本质就是数据结构。这也是为什么每次数据表建立索引都需要设置在列字段上的原因。那常见数据结构有哪些？ \n\n\n\n常见数据结构大致可分为三大类，如下所示\n\n- 线性表：顺序表、链表、栈和队列；\n- 树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；\n- 图存储结构\n\n但在数据库中常用数据结构为**B+Tree、Hash索引**。\n\n对于此，有人可能觉得有了Hash和那么多树结构（红黑树、B树、完全平衡二叉（AVL）树、B+树），为啥Mysql唯独喜欢B+树？\n\n请听如下分解：\n\n> 首先上场的是顽固不变Hash索引，这Hash索引又是什么？\n\n**哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才能生效额**。切记！切记！切记！\n\n哈希的思路很简单，以键-值（ key-value ）存储数据的结构，对于待查找每一行的数据值,用一个哈希函数把数据值换算成一个确定的位置即 key，位置就是哈希码，并且不同键值的行计算出来的哈希码也不一样。然后在 value 上存放每个数据行的指针。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdFt84gHyIgUVpkwk9cOvVtd1254ibS2iccOKXKpabe1sKibrMzXd3GjqQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**对这样的索引结构，执行如下sql语句的过程是什么呢？**\n\n- \n\n```\nselect * from nezha where name='lianhua'\n```\n\nMySQL首先计算'lianhua'的哈希值，并使用该值寻找对应的记录指针。然后根据指针寻找对应的数据，最后一步是比较读取的值是否为'lianhua', 从而来确保就是要查找的行。\n\n那如果改变为范围性查找就会存在问题。还记得上面的切记吗？因为它不支持范围匹配，只支持等值匹配。例如：\n\n- \n\n```\nselect * from nezha where name like '%lianhua'\n```\n\n> 那像Hash这种等值查询还有哪些场景？\n\nHash故名思议体现的就是（key-value）结构。所以像 Redis、Memcached 及其他一些 NoSQL 引擎（如 Memory）。\n\n> 那有没有既能快速查找，又可以支持范围型查找呢？\n\n自然有，**有序数组在等值查询和范围查询场景中的性能就都非常OK**，足以满足你的口味。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdELGVqYfcP9ket3E7DwdiaEYkiaOzRZII14nfssVAWKcuAbhhP8icLMEibg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n那它就好的没天理啦？不，世上没得十全十美的！\n\n有序数组索引只适用于静态存储引擎，因为数组的空间必须是连续的，这就造成数组在内存中分配空间时必须找到一块连续的内存空间。**所以新增、删除、修改数据时就会改变它的结构。**\n\n> 一下掉入无底洞，这在业务场景上怎样使用？\n\n静态数据简单点可以理解为不会在变化的数据，那你就可以用于历史归档性的业务。比如你去年酷狗歌单、每上月的支付记录等，这类不会再修改的数据。\n\n> 接下来上场的是层次不齐的树结构\n\n树结构基础就是普通二叉树，其它树结构都是基于它演进产生。二叉树会根据元素值的大小来创建树形结构。所以它是有序的，并支持范围查找。具体可查看数据结构相关书籍。\n\n但普通二叉树，**有个问题，就是当元素是递增或递减时，它就会退化为线性表。**\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdy02r1jxR2HibcPUgB9do3AhoWBNQCmMYlmCJJGLRhaNbBmemI2RlUdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n为了解决这个问题，就出现了我们的完全平衡二叉树。**可为何数据库没选择它呢**？\n\n数据库操作都是在内存里面完成的，但最终还是要落地到磁盘。如果数据多了，树会变得很高。然而查询数据时，那都是从磁盘里面把数据读取出来放入到内存中。这样I/O操作成本就会随着树的高度而增加。这也是常说完全平衡二叉树具有高瘦特点。\n\n> 好像女孩子都喜欢这样的吧！\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdEypcZesGvKgkMJ4ociaA3AmJazfMs0LMZE3TaoAqzNexYl97NWJUFag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n一般为节约成本，很多公司服务器采用的还是机械硬盘，这样一次千万级别的查询差不多就要10秒，这还不算网络传输、业务处理、CPU的执行时间，一但汇总那谁顶得住？\n\n那这怎么解决呢？不可能一直让让它变高吧! 可使用B-Tree。\n\nB-Tree的特征就是矮胖，也称为多叉树，就是在树的同一高度上开辟多个分叉来容纳元素。从而树在横向上面变宽了。这样减少了磁盘I/O的查询查找次数，从而提升了效率。\n\nB-Tree的特点简写：\n\n- 每个节点中的元素（关键字）从小到大排列。\n- 每个节点都保存有数据\n\n\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdVWibDic4qoYy7C63ckZict4ichoOvbWib5ATW8ryx28BvJtob9UyP0r08kA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n> 那为什么最终数据库选择了B+Tree，而不是B-Tree呢？\n\nB+Tree自然保持了B-Tree的矮胖特征，但它还做了升级的处理。**就是让叶子节点保存数据，而非叶子节点保存关键字即可，并且会有指针指向下一个叶子节点。**这样的好处是**为了提高范围查找的效率**。找到数据后直接根据指针向后读取即可，而B-Tree就不行，当它读取下一个数据，还需要再一次的进行索引树的查找。\n\n![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n\n\n**B+Tree特点：**\n\n- 所有的非叶子节点只存储关键字信息 \n- 只有叶子节点存储数据\n- 所有叶子节点之间都有一个链指针\n\n**小结**：最终MySQL选用B+Tree作为索引，从而提高检索索引时的磁盘IO效率，并且提高范围查询的效率，整个B+树里的元素也是有序的。因为B+Tree默认就是按照主键索引来构建的树结构。那你说呢？\n\n​    **03**\n\n#    **索引是怎么构建的？**\n\n开发过程中，MySQL都首先B+Tree。在MySQL下还拥有Hash索引，也就是它拥有2大索引类型。具体选择用什么，可在创建表时进行选择。\n\n![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n> 那这索引到底是怎么创建出来的？\n\n那还得分情况而定，分为以下2种\n\n> 建表建索引\n\n创建表的时候，先把索引字段建立好。如：\n\n- \n- \n- \n- \n- \n\n```\n create table nezha(id int unsigned   AUTO_INCREMENT PRIMARY KEY, phone int not null,name varchar(16),index (phone))engine=InnoDB;\n```\n\n当添加数据时，数据库就会自动先去创建好索引结构，然后创建数据。最终在落地到磁盘上。\n\n> 先建表，后添索引\n\n这种情况需要注意，因为先建表，那可能你数据表已经拥有了大量数据，这时候你在添加索引，那你的整个数据库肯定会阻塞，因为数据库需要根据表中数据建立索引，这都是由数据库后台线程来完成。\n\n这也是为什么线上数据库不要轻易变动索引，需根据用户低峰时间来操作。所以索引创建过多，那也算是需要耗费资源的。\n\n一般还需要维护表和索引，你这里有什么建议吗？不妨留言说说你的提议，优化就留到下次。\n\n\n\n所以当你的大表需要导入到其它数据库时，需在新数据库上先关闭索引，然后再添上索引，要不然效率就太低了。\n\n# **04**\n\n# **索引的表现类型代表作有哪些?**\n\n乖乖，索引还有表现种类，这神马情况？\n\n\n\n大家都知道B+Tree、Hash索引，但这些都底层实现的数据结构，而表现种类在明面上，我们常说的，例如：聚簇索引、非聚簇索引等，都包含了对应的数据结构。\n\n> 问最多算聚簇索引、非聚簇索引，那它们是什么呢？\n\n**聚簇索引：索引和数据都存储在一起，代表作Innodb**\n\n**非聚簇索引：索引和数据分开存储，代表\\**作\\**MyIASM**\n\n上述的特性，也和它们的物理存储文件有关系。文件放在数据库安装目录下的data目录中\n\n- \n\n```\n/mysql-57/data/mysql\n```\n\nMyISAM结构如下：\n\n.frm为表结构文件，存储像create alter等语句  .MYD为存储数据文件  .MYI为存储索引文件\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdSws7tibFzZpQI32Q39KoRyKU34hwpkPWYOnicdhmp056aMo9iaObAqicEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\nInnoDb结构如下：\n\n.frm为表结构文件，.ibd为数据+索引文件\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdjicNicU6yOUrAGB57Im3O74LMKLQeLmrTjPDJlASs4gibyacxkjvPIWqg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n\n\n**在InnoDB存储引擎中,就一定都是聚簇索引吗？**\n\n\n\n并不是，**只有主键索引被称为聚簇索引（ clusteredindex ）。除开主键以外的字段上创建的索引被称为非主键索引**，非主键索引也被称为**二级索引**（ secondary index ）。\n\n> 注：现在你该知道，为啥面试都不问你什么唯一、普通、联合索引了吧，那都是属于二级索引呢\n\n那这两者之间有什么区别吗？区别在**非主键索引的叶子节点内容是主键，当找到主键后，还需要根据主键再一次的进行索引树的查找，这个过程称之为回表。**\n\n\n\n例如：\n\n如果语句是 select * from nezha  where ID=7 ，即主键查询方式，那它只需搜索 ID 这棵 B+ 树；\n\n\n\n如果语句是 select * from nezha  where name = '哪吒' ，即普通索引查询方式，则需要先搜索 name 索引树，得到 ID的值为 7，再到 ID 索引树搜索一次。这就是所谓的**回表**。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdMwWCYWWwTY712lXR54qjD6AeYwyVpnrxnNbm2YVf4S6icRzVfYdbAjQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n> 那这个问题怎么解决呀！\n\n> 内心独白：哎呀！咋这么多问题，烦不烦。 \n\n这个好办，刚才我们是 select * ，查询所有记录，如果查询字段上只出现主键索引与**创建索引的字段**，那就不需要回表了。因为走二级索引时，就已经包含了你需要的字段列啦，那就不需要在**回表**了。**这就被称之为索引覆盖，即索引已经包含了查询操作的值。**\n\n这也是为什么，当有多个字段需创建索引时，会创建联合索引，**也是为了更好支持索引覆盖。**\n\n**瞬间飞过，\"我怎么这么好看，这么好看怎么办\"**\n\n\n\n# **05** \n\n# **数据库内部利用索引是如何读取数据的？**\n\n> 搞了这么久，那这个索引查找数据的时候，是怎么个读取原理又是什么？\n\n那这首先得说数据库中的读取数据单位，数据库中的数据是按照页读取的。默认一页的数据为16KB。而磁盘块（OS）默认为4KB\n\n- \n\n```\n show global variables like 'innodb_page%';\n```\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdElkEAp3jWbRbeiammCjeoJ8I6Bibxp5NLhmCCe9ts8JYY9ZDBGSNmicLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n\n\n那索引和数据都保存在节点里面，这个数据怎么个读法？\n\n\n\n上面说到，数据库读取数据是根据页为单位，**并且读的数据不满足1页或超过1页，那么也会读满1页。这也叫做预读**\n\n也就是说节点读取数据的大小应该控制在1页、2页、3页、4页等倍数页大小最为合适。\n\n\n\n那你说说这个页吧！\n\n![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdwxA1h3BQ2SibFEkYK4fEU0ibNF5ibWNPUdqlwiaCRGj9IH27Iubs9SCehg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n\n\n**每个数据页中的数据**，采用**单向链表**的形式进行连接。\n\n**各个页之间采用双向链表链接**。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfd7PS37qU5XZEnRC9YdNwh8Ssdb6a3RYCaGuY7ibFMkFVA4cZhGu9VtIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n查找数据时是根据页内分组定义的。首先在插入数据时就会根据主键大小做好排序结构，并按照最大和最小进行分组。\n\n最小虚拟数据独自一组，它拥有一条数据，就是最小数据。然后剩下的数据再分成一组，即最大数据为另一组。当进行数据插入的时，都是先插入到最大数据组，**当最大数据组装满后在进行分裂**。 \n\n\n\n分组确立后，在进行数据查找的时就是根据**二分查找法确定对应数据所在的槽位置**，然后在使用记录头信息的next_record一条条进行查找。\n\n\n\n**当以(非主键)作为搜索条件**：只能从最小虚拟数据记录，开始**依次遍历单链表中的每条记录**。\n\n\n\n```\n所以，当写\n```\n\n- \n\n```\n select * from nezha where name='nezha'\n 这样没有进行任何优化的sql语句，默认会这样做：\n```\n\n- 读取记录所在页的范围\n- 根据双向链表，找到所在页\n- 从所在页中查找相应的记录\n- 由于不是主键查询，就遍历所在页的单链表\n\n\n\n# **06**\n\n# **索引就不命中？前提你得知道规则**\n\n\n\n使用索引当中，最核心的就是最左匹配原则，索引命中都是根据它来定义的。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdV9DYMLbqDoZEq9qaheoJ4hia8xPR7wvPN6cKcjMiafDpiah2G3feqTpsA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**最左匹配原则**：\n\n- 索引可以的简单如单列 (a)，也可以复杂如多列 (a,b,c,d)，即**联合索引**。\n\n- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，遇到范围查询 (>、<、BETWEEN、LIKE)等就**不能进一步匹配**了，后续退化为线性查找。因此，**列的排列顺序决定了可命中索引的列数**。\n\n- 索引列不能是表达式的一部分，那样无法命中索引，例如\n\n- - \n\n  ```\n  ：SELECT  *   FROM  nezha  WHERE  id + 1 = 5;   date(create_time)='2020-03-05'\n  ```\n\n**例如：**\n\n- 如有索引 (a,b,c,d)，查询条件 a=7 and b=8 and c>15 and d=32，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d就没办法进行对比查找了)\n\n\n\n**总结：**\n\n索引在数据库中是一个**非常**重要的内容！\n\n- **最左前缀匹配原则**。这是非常重要的原则，SQL查询都是基于它来。MySQL会一直向右匹配，直到遇到范围查询 （>,<,BETWEEN,LIKE）就停止匹配。\n- **页**也需要了解下，这个是数据库在内部的工作机制。\n- 索引的表现形式针对于不同的存储引擎，表现也不一样，并且2者之间的存储引擎区别也要掌握了解\n- 索引创建方式来自于建表前还是建表后。重点都是数据库再用后台线程创建与维护索引\n- B+Tree和Hash这2个特点还是需要注意，并且它们之间区别还未细讲。后面会针对面试问题，给大家补上来。","source":"_posts/技术分享/mysql-index-learning.md","raw":"---\ntitle: 【MySQL】索引及分页详解\ntags:\n  - MySQL\nabbrlink: 780159822\ncover: https://cdn.tanxz.com/images/category/mysql.png\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ndate: 2018-07-19 21:38:18\n---\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdxUoEZiaQErySl2YPCNnF0ddmMVvCrSyBfkSEuEwbh3AmmqZgVrX1PJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**01**\n\n**为啥BAT大厂，在数据库上都喜欢深入的问索引呢？**\n\n\n\n一线大厂，是很多人梦寐以求的盛典天堂。因为存在的无限的可能，可以帮你实现自己的远大抱负。大平台机会、视野、格局往往都比小厂多很多。但随之而来也是那高挑的技术门槛需等你迈过。好事物大家都喜欢，但毕竟僧多粥少。外加任务有难度，如果你没过硬的本领，那很难踏入平台，领会一览众山小的风采。不知你心里有没有小九九？\n\n\n\n------\n\n\n\n大厂产品大多数都成型很久，数据库里面存储的数据都以海量计算，如何在这种规模下的数据中做到快速筛选呢？那就需要你来答。\n\n大家思路肯定和我一样，话不多说，加索引再说！索引为的就是提高数据的检索效率，进而减少请求的响应时间。\n\n**这时，有内涵的人可能会反问你啦？**\n\n那你说说索引有哪些类型？索引底层实现是什么结构？B+Tree的优点？聚簇索引和非聚簇的区别？索引一次读读取多少数据合适？为什么说索引会降低插入、删除、修改等维护任务的速度？\n\n这一套组合拳，可能虐的你是体无完肤。让人招教不住，心理一万个xxx省略。送他一个微笑，然后再尴尬而不失优雅的离去。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_jpg/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdBsMmPCcTSTbU914ibhsnXVFSZgMQ1d8GHqyYM1Gvo5vxHNrhVwUwJUw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n大家可能都知道查询慢了加索引，那为啥加？在哪些字段上加？以及索引的数据结构特点。索引优化、优点啥的都比较模糊或者不知道。\n\n今天将是对索引来一次灵魂的拷问，在进一步对索引优化、常见大厂面试问题、SQL优化等内容进行分享。这是个大工程，大家得关注再看。深，那就得深出高度。MOG！太深啦\n\n\n\n# **02**\n\n# **用索引，那你得知道索引是什么？**\n\n> 百度百科定义：索引是数据表中一列或多列的值进行排序的一种数据结构\n\n故此，索引本质就是数据结构。这也是为什么每次数据表建立索引都需要设置在列字段上的原因。那常见数据结构有哪些？ \n\n\n\n常见数据结构大致可分为三大类，如下所示\n\n- 线性表：顺序表、链表、栈和队列；\n- 树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；\n- 图存储结构\n\n但在数据库中常用数据结构为**B+Tree、Hash索引**。\n\n对于此，有人可能觉得有了Hash和那么多树结构（红黑树、B树、完全平衡二叉（AVL）树、B+树），为啥Mysql唯独喜欢B+树？\n\n请听如下分解：\n\n> 首先上场的是顽固不变Hash索引，这Hash索引又是什么？\n\n**哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才能生效额**。切记！切记！切记！\n\n哈希的思路很简单，以键-值（ key-value ）存储数据的结构，对于待查找每一行的数据值,用一个哈希函数把数据值换算成一个确定的位置即 key，位置就是哈希码，并且不同键值的行计算出来的哈希码也不一样。然后在 value 上存放每个数据行的指针。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdFt84gHyIgUVpkwk9cOvVtd1254ibS2iccOKXKpabe1sKibrMzXd3GjqQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**对这样的索引结构，执行如下sql语句的过程是什么呢？**\n\n- \n\n```\nselect * from nezha where name='lianhua'\n```\n\nMySQL首先计算'lianhua'的哈希值，并使用该值寻找对应的记录指针。然后根据指针寻找对应的数据，最后一步是比较读取的值是否为'lianhua', 从而来确保就是要查找的行。\n\n那如果改变为范围性查找就会存在问题。还记得上面的切记吗？因为它不支持范围匹配，只支持等值匹配。例如：\n\n- \n\n```\nselect * from nezha where name like '%lianhua'\n```\n\n> 那像Hash这种等值查询还有哪些场景？\n\nHash故名思议体现的就是（key-value）结构。所以像 Redis、Memcached 及其他一些 NoSQL 引擎（如 Memory）。\n\n> 那有没有既能快速查找，又可以支持范围型查找呢？\n\n自然有，**有序数组在等值查询和范围查询场景中的性能就都非常OK**，足以满足你的口味。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdELGVqYfcP9ket3E7DwdiaEYkiaOzRZII14nfssVAWKcuAbhhP8icLMEibg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n那它就好的没天理啦？不，世上没得十全十美的！\n\n有序数组索引只适用于静态存储引擎，因为数组的空间必须是连续的，这就造成数组在内存中分配空间时必须找到一块连续的内存空间。**所以新增、删除、修改数据时就会改变它的结构。**\n\n> 一下掉入无底洞，这在业务场景上怎样使用？\n\n静态数据简单点可以理解为不会在变化的数据，那你就可以用于历史归档性的业务。比如你去年酷狗歌单、每上月的支付记录等，这类不会再修改的数据。\n\n> 接下来上场的是层次不齐的树结构\n\n树结构基础就是普通二叉树，其它树结构都是基于它演进产生。二叉树会根据元素值的大小来创建树形结构。所以它是有序的，并支持范围查找。具体可查看数据结构相关书籍。\n\n但普通二叉树，**有个问题，就是当元素是递增或递减时，它就会退化为线性表。**\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdy02r1jxR2HibcPUgB9do3AhoWBNQCmMYlmCJJGLRhaNbBmemI2RlUdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n为了解决这个问题，就出现了我们的完全平衡二叉树。**可为何数据库没选择它呢**？\n\n数据库操作都是在内存里面完成的，但最终还是要落地到磁盘。如果数据多了，树会变得很高。然而查询数据时，那都是从磁盘里面把数据读取出来放入到内存中。这样I/O操作成本就会随着树的高度而增加。这也是常说完全平衡二叉树具有高瘦特点。\n\n> 好像女孩子都喜欢这样的吧！\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdEypcZesGvKgkMJ4ociaA3AmJazfMs0LMZE3TaoAqzNexYl97NWJUFag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n一般为节约成本，很多公司服务器采用的还是机械硬盘，这样一次千万级别的查询差不多就要10秒，这还不算网络传输、业务处理、CPU的执行时间，一但汇总那谁顶得住？\n\n那这怎么解决呢？不可能一直让让它变高吧! 可使用B-Tree。\n\nB-Tree的特征就是矮胖，也称为多叉树，就是在树的同一高度上开辟多个分叉来容纳元素。从而树在横向上面变宽了。这样减少了磁盘I/O的查询查找次数，从而提升了效率。\n\nB-Tree的特点简写：\n\n- 每个节点中的元素（关键字）从小到大排列。\n- 每个节点都保存有数据\n\n\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdVWibDic4qoYy7C63ckZict4ichoOvbWib5ATW8ryx28BvJtob9UyP0r08kA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n> 那为什么最终数据库选择了B+Tree，而不是B-Tree呢？\n\nB+Tree自然保持了B-Tree的矮胖特征，但它还做了升级的处理。**就是让叶子节点保存数据，而非叶子节点保存关键字即可，并且会有指针指向下一个叶子节点。**这样的好处是**为了提高范围查找的效率**。找到数据后直接根据指针向后读取即可，而B-Tree就不行，当它读取下一个数据，还需要再一次的进行索引树的查找。\n\n![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n\n\n**B+Tree特点：**\n\n- 所有的非叶子节点只存储关键字信息 \n- 只有叶子节点存储数据\n- 所有叶子节点之间都有一个链指针\n\n**小结**：最终MySQL选用B+Tree作为索引，从而提高检索索引时的磁盘IO效率，并且提高范围查询的效率，整个B+树里的元素也是有序的。因为B+Tree默认就是按照主键索引来构建的树结构。那你说呢？\n\n​    **03**\n\n#    **索引是怎么构建的？**\n\n开发过程中，MySQL都首先B+Tree。在MySQL下还拥有Hash索引，也就是它拥有2大索引类型。具体选择用什么，可在创建表时进行选择。\n\n![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n> 那这索引到底是怎么创建出来的？\n\n那还得分情况而定，分为以下2种\n\n> 建表建索引\n\n创建表的时候，先把索引字段建立好。如：\n\n- \n- \n- \n- \n- \n\n```\n create table nezha(id int unsigned   AUTO_INCREMENT PRIMARY KEY, phone int not null,name varchar(16),index (phone))engine=InnoDB;\n```\n\n当添加数据时，数据库就会自动先去创建好索引结构，然后创建数据。最终在落地到磁盘上。\n\n> 先建表，后添索引\n\n这种情况需要注意，因为先建表，那可能你数据表已经拥有了大量数据，这时候你在添加索引，那你的整个数据库肯定会阻塞，因为数据库需要根据表中数据建立索引，这都是由数据库后台线程来完成。\n\n这也是为什么线上数据库不要轻易变动索引，需根据用户低峰时间来操作。所以索引创建过多，那也算是需要耗费资源的。\n\n一般还需要维护表和索引，你这里有什么建议吗？不妨留言说说你的提议，优化就留到下次。\n\n\n\n所以当你的大表需要导入到其它数据库时，需在新数据库上先关闭索引，然后再添上索引，要不然效率就太低了。\n\n# **04**\n\n# **索引的表现类型代表作有哪些?**\n\n乖乖，索引还有表现种类，这神马情况？\n\n\n\n大家都知道B+Tree、Hash索引，但这些都底层实现的数据结构，而表现种类在明面上，我们常说的，例如：聚簇索引、非聚簇索引等，都包含了对应的数据结构。\n\n> 问最多算聚簇索引、非聚簇索引，那它们是什么呢？\n\n**聚簇索引：索引和数据都存储在一起，代表作Innodb**\n\n**非聚簇索引：索引和数据分开存储，代表\\**作\\**MyIASM**\n\n上述的特性，也和它们的物理存储文件有关系。文件放在数据库安装目录下的data目录中\n\n- \n\n```\n/mysql-57/data/mysql\n```\n\nMyISAM结构如下：\n\n.frm为表结构文件，存储像create alter等语句  .MYD为存储数据文件  .MYI为存储索引文件\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdSws7tibFzZpQI32Q39KoRyKU34hwpkPWYOnicdhmp056aMo9iaObAqicEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\nInnoDb结构如下：\n\n.frm为表结构文件，.ibd为数据+索引文件\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdjicNicU6yOUrAGB57Im3O74LMKLQeLmrTjPDJlASs4gibyacxkjvPIWqg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n\n\n**在InnoDB存储引擎中,就一定都是聚簇索引吗？**\n\n\n\n并不是，**只有主键索引被称为聚簇索引（ clusteredindex ）。除开主键以外的字段上创建的索引被称为非主键索引**，非主键索引也被称为**二级索引**（ secondary index ）。\n\n> 注：现在你该知道，为啥面试都不问你什么唯一、普通、联合索引了吧，那都是属于二级索引呢\n\n那这两者之间有什么区别吗？区别在**非主键索引的叶子节点内容是主键，当找到主键后，还需要根据主键再一次的进行索引树的查找，这个过程称之为回表。**\n\n\n\n例如：\n\n如果语句是 select * from nezha  where ID=7 ，即主键查询方式，那它只需搜索 ID 这棵 B+ 树；\n\n\n\n如果语句是 select * from nezha  where name = '哪吒' ，即普通索引查询方式，则需要先搜索 name 索引树，得到 ID的值为 7，再到 ID 索引树搜索一次。这就是所谓的**回表**。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdMwWCYWWwTY712lXR54qjD6AeYwyVpnrxnNbm2YVf4S6icRzVfYdbAjQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n> 那这个问题怎么解决呀！\n\n> 内心独白：哎呀！咋这么多问题，烦不烦。 \n\n这个好办，刚才我们是 select * ，查询所有记录，如果查询字段上只出现主键索引与**创建索引的字段**，那就不需要回表了。因为走二级索引时，就已经包含了你需要的字段列啦，那就不需要在**回表**了。**这就被称之为索引覆盖，即索引已经包含了查询操作的值。**\n\n这也是为什么，当有多个字段需创建索引时，会创建联合索引，**也是为了更好支持索引覆盖。**\n\n**瞬间飞过，\"我怎么这么好看，这么好看怎么办\"**\n\n\n\n# **05** \n\n# **数据库内部利用索引是如何读取数据的？**\n\n> 搞了这么久，那这个索引查找数据的时候，是怎么个读取原理又是什么？\n\n那这首先得说数据库中的读取数据单位，数据库中的数据是按照页读取的。默认一页的数据为16KB。而磁盘块（OS）默认为4KB\n\n- \n\n```\n show global variables like 'innodb_page%';\n```\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdElkEAp3jWbRbeiammCjeoJ8I6Bibxp5NLhmCCe9ts8JYY9ZDBGSNmicLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n\n\n那索引和数据都保存在节点里面，这个数据怎么个读法？\n\n\n\n上面说到，数据库读取数据是根据页为单位，**并且读的数据不满足1页或超过1页，那么也会读满1页。这也叫做预读**\n\n也就是说节点读取数据的大小应该控制在1页、2页、3页、4页等倍数页大小最为合适。\n\n\n\n那你说说这个页吧！\n\n![img](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdwxA1h3BQ2SibFEkYK4fEU0ibNF5ibWNPUdqlwiaCRGj9IH27Iubs9SCehg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n\n\n**每个数据页中的数据**，采用**单向链表**的形式进行连接。\n\n**各个页之间采用双向链表链接**。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfd7PS37qU5XZEnRC9YdNwh8Ssdb6a3RYCaGuY7ibFMkFVA4cZhGu9VtIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n查找数据时是根据页内分组定义的。首先在插入数据时就会根据主键大小做好排序结构，并按照最大和最小进行分组。\n\n最小虚拟数据独自一组，它拥有一条数据，就是最小数据。然后剩下的数据再分成一组，即最大数据为另一组。当进行数据插入的时，都是先插入到最大数据组，**当最大数据组装满后在进行分裂**。 \n\n\n\n分组确立后，在进行数据查找的时就是根据**二分查找法确定对应数据所在的槽位置**，然后在使用记录头信息的next_record一条条进行查找。\n\n\n\n**当以(非主键)作为搜索条件**：只能从最小虚拟数据记录，开始**依次遍历单链表中的每条记录**。\n\n\n\n```\n所以，当写\n```\n\n- \n\n```\n select * from nezha where name='nezha'\n 这样没有进行任何优化的sql语句，默认会这样做：\n```\n\n- 读取记录所在页的范围\n- 根据双向链表，找到所在页\n- 从所在页中查找相应的记录\n- 由于不是主键查询，就遍历所在页的单链表\n\n\n\n# **06**\n\n# **索引就不命中？前提你得知道规则**\n\n\n\n使用索引当中，最核心的就是最左匹配原则，索引命中都是根据它来定义的。\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdV9DYMLbqDoZEq9qaheoJ4hia8xPR7wvPN6cKcjMiafDpiah2G3feqTpsA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**最左匹配原则**：\n\n- 索引可以的简单如单列 (a)，也可以复杂如多列 (a,b,c,d)，即**联合索引**。\n\n- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，遇到范围查询 (>、<、BETWEEN、LIKE)等就**不能进一步匹配**了，后续退化为线性查找。因此，**列的排列顺序决定了可命中索引的列数**。\n\n- 索引列不能是表达式的一部分，那样无法命中索引，例如\n\n- - \n\n  ```\n  ：SELECT  *   FROM  nezha  WHERE  id + 1 = 5;   date(create_time)='2020-03-05'\n  ```\n\n**例如：**\n\n- 如有索引 (a,b,c,d)，查询条件 a=7 and b=8 and c>15 and d=32，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d就没办法进行对比查找了)\n\n\n\n**总结：**\n\n索引在数据库中是一个**非常**重要的内容！\n\n- **最左前缀匹配原则**。这是非常重要的原则，SQL查询都是基于它来。MySQL会一直向右匹配，直到遇到范围查询 （>,<,BETWEEN,LIKE）就停止匹配。\n- **页**也需要了解下，这个是数据库在内部的工作机制。\n- 索引的表现形式针对于不同的存储引擎，表现也不一样，并且2者之间的存储引擎区别也要掌握了解\n- 索引创建方式来自于建表前还是建表后。重点都是数据库再用后台线程创建与维护索引\n- B+Tree和Hash这2个特点还是需要注意，并且它们之间区别还未细讲。后面会针对面试问题，给大家补上来。","slug":"技术分享/mysql-index-learning","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6i2003dtvcd5oyxgzym","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdxUoEZiaQErySl2YPCNnF0ddmMVvCrSyBfkSEuEwbh3AmmqZgVrX1PJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>01</strong></p>\n<p><strong>为啥BAT大厂，在数据库上都喜欢深入的问索引呢？</strong></p>\n<p>一线大厂，是很多人梦寐以求的盛典天堂。因为存在的无限的可能，可以帮你实现自己的远大抱负。大平台机会、视野、格局往往都比小厂多很多。但随之而来也是那高挑的技术门槛需等你迈过。好事物大家都喜欢，但毕竟僧多粥少。外加任务有难度，如果你没过硬的本领，那很难踏入平台，领会一览众山小的风采。不知你心里有没有小九九？</p>\n<hr>\n<p>大厂产品大多数都成型很久，数据库里面存储的数据都以海量计算，如何在这种规模下的数据中做到快速筛选呢？那就需要你来答。</p>\n<p>大家思路肯定和我一样，话不多说，加索引再说！索引为的就是提高数据的检索效率，进而减少请求的响应时间。</p>\n<p><strong>这时，有内涵的人可能会反问你啦？</strong></p>\n<p>那你说说索引有哪些类型？索引底层实现是什么结构？B+Tree的优点？聚簇索引和非聚簇的区别？索引一次读读取多少数据合适？为什么说索引会降低插入、删除、修改等维护任务的速度？</p>\n<p>这一套组合拳，可能虐的你是体无完肤。让人招教不住，心理一万个xxx省略。送他一个微笑，然后再尴尬而不失优雅的离去。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdBsMmPCcTSTbU914ibhsnXVFSZgMQ1d8GHqyYM1Gvo5vxHNrhVwUwJUw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>大家可能都知道查询慢了加索引，那为啥加？在哪些字段上加？以及索引的数据结构特点。索引优化、优点啥的都比较模糊或者不知道。</p>\n<p>今天将是对索引来一次灵魂的拷问，在进一步对索引优化、常见大厂面试问题、SQL优化等内容进行分享。这是个大工程，大家得关注再看。深，那就得深出高度。MOG！太深啦</p>\n<h1 id=\"02\"><a href=\"#02\" class=\"headerlink\" title=\"02\"></a><strong>02</strong></h1><h1 id=\"用索引，那你得知道索引是什么？\"><a href=\"#用索引，那你得知道索引是什么？\" class=\"headerlink\" title=\"用索引，那你得知道索引是什么？\"></a><strong>用索引，那你得知道索引是什么？</strong></h1><blockquote>\n<p>百度百科定义：索引是数据表中一列或多列的值进行排序的一种数据结构</p>\n</blockquote>\n<p>故此，索引本质就是数据结构。这也是为什么每次数据表建立索引都需要设置在列字段上的原因。那常见数据结构有哪些？ </p>\n<p>常见数据结构大致可分为三大类，如下所示</p>\n<ul>\n<li>线性表：顺序表、链表、栈和队列；</li>\n<li>树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；</li>\n<li>图存储结构</li>\n</ul>\n<p>但在数据库中常用数据结构为<strong>B+Tree、Hash索引</strong>。</p>\n<p>对于此，有人可能觉得有了Hash和那么多树结构（红黑树、B树、完全平衡二叉（AVL）树、B+树），为啥Mysql唯独喜欢B+树？</p>\n<p>请听如下分解：</p>\n<blockquote>\n<p>首先上场的是顽固不变Hash索引，这Hash索引又是什么？</p>\n</blockquote>\n<p><strong>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才能生效额</strong>。切记！切记！切记！</p>\n<p>哈希的思路很简单，以键-值（ key-value ）存储数据的结构，对于待查找每一行的数据值,用一个哈希函数把数据值换算成一个确定的位置即 key，位置就是哈希码，并且不同键值的行计算出来的哈希码也不一样。然后在 value 上存放每个数据行的指针。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdFt84gHyIgUVpkwk9cOvVtd1254ibS2iccOKXKpabe1sKibrMzXd3GjqQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>对这样的索引结构，执行如下sql语句的过程是什么呢？</strong></p>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">select * from nezha where name&#x3D;&#39;lianhua&#39;<br></code></pre></td></tr></table></figure>\n<p>MySQL首先计算’lianhua’的哈希值，并使用该值寻找对应的记录指针。然后根据指针寻找对应的数据，最后一步是比较读取的值是否为’lianhua’, 从而来确保就是要查找的行。</p>\n</li>\n</ul>\n<p>那如果改变为范围性查找就会存在问题。还记得上面的切记吗？因为它不支持范围匹配，只支持等值匹配。例如：</p>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">select * from nezha where name like &#39;%lianhua&#39;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>那像Hash这种等值查询还有哪些场景？</p>\n</blockquote>\n</li>\n</ul>\n<p>Hash故名思议体现的就是（key-value）结构。所以像 Redis、Memcached 及其他一些 NoSQL 引擎（如 Memory）。</p>\n<blockquote>\n<p>那有没有既能快速查找，又可以支持范围型查找呢？</p>\n</blockquote>\n<p>自然有，<strong>有序数组在等值查询和范围查询场景中的性能就都非常OK</strong>，足以满足你的口味。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdELGVqYfcP9ket3E7DwdiaEYkiaOzRZII14nfssVAWKcuAbhhP8icLMEibg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>那它就好的没天理啦？不，世上没得十全十美的！</p>\n<p>有序数组索引只适用于静态存储引擎，因为数组的空间必须是连续的，这就造成数组在内存中分配空间时必须找到一块连续的内存空间。<strong>所以新增、删除、修改数据时就会改变它的结构。</strong></p>\n<blockquote>\n<p>一下掉入无底洞，这在业务场景上怎样使用？</p>\n</blockquote>\n<p>静态数据简单点可以理解为不会在变化的数据，那你就可以用于历史归档性的业务。比如你去年酷狗歌单、每上月的支付记录等，这类不会再修改的数据。</p>\n<blockquote>\n<p>接下来上场的是层次不齐的树结构</p>\n</blockquote>\n<p>树结构基础就是普通二叉树，其它树结构都是基于它演进产生。二叉树会根据元素值的大小来创建树形结构。所以它是有序的，并支持范围查找。具体可查看数据结构相关书籍。</p>\n<p>但普通二叉树，<strong>有个问题，就是当元素是递增或递减时，它就会退化为线性表。</strong></p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdy02r1jxR2HibcPUgB9do3AhoWBNQCmMYlmCJJGLRhaNbBmemI2RlUdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>为了解决这个问题，就出现了我们的完全平衡二叉树。<strong>可为何数据库没选择它呢</strong>？</p>\n<p>数据库操作都是在内存里面完成的，但最终还是要落地到磁盘。如果数据多了，树会变得很高。然而查询数据时，那都是从磁盘里面把数据读取出来放入到内存中。这样I/O操作成本就会随着树的高度而增加。这也是常说完全平衡二叉树具有高瘦特点。</p>\n<blockquote>\n<p>好像女孩子都喜欢这样的吧！</p>\n</blockquote>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdEypcZesGvKgkMJ4ociaA3AmJazfMs0LMZE3TaoAqzNexYl97NWJUFag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>一般为节约成本，很多公司服务器采用的还是机械硬盘，这样一次千万级别的查询差不多就要10秒，这还不算网络传输、业务处理、CPU的执行时间，一但汇总那谁顶得住？</p>\n<p>那这怎么解决呢？不可能一直让让它变高吧! 可使用B-Tree。</p>\n<p>B-Tree的特征就是矮胖，也称为多叉树，就是在树的同一高度上开辟多个分叉来容纳元素。从而树在横向上面变宽了。这样减少了磁盘I/O的查询查找次数，从而提升了效率。</p>\n<p>B-Tree的特点简写：</p>\n<ul>\n<li>每个节点中的元素（关键字）从小到大排列。</li>\n<li>每个节点都保存有数据</li>\n</ul>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdVWibDic4qoYy7C63ckZict4ichoOvbWib5ATW8ryx28BvJtob9UyP0r08kA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<blockquote>\n<p>那为什么最终数据库选择了B+Tree，而不是B-Tree呢？</p>\n</blockquote>\n<p>B+Tree自然保持了B-Tree的矮胖特征，但它还做了升级的处理。<strong>就是让叶子节点保存数据，而非叶子节点保存关键字即可，并且会有指针指向下一个叶子节点。</strong>这样的好处是<strong>为了提高范围查找的效率</strong>。找到数据后直接根据指针向后读取即可，而B-Tree就不行，当它读取下一个数据，还需要再一次的进行索引树的查找。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><strong>B+Tree特点：</strong></p>\n<ul>\n<li>所有的非叶子节点只存储关键字信息 </li>\n<li>只有叶子节点存储数据</li>\n<li>所有叶子节点之间都有一个链指针</li>\n</ul>\n<p><strong>小结</strong>：最终MySQL选用B+Tree作为索引，从而提高检索索引时的磁盘IO效率，并且提高范围查询的效率，整个B+树里的元素也是有序的。因为B+Tree默认就是按照主键索引来构建的树结构。那你说呢？</p>\n<p>​    <strong>03</strong></p>\n<h1 id=\"索引是怎么构建的？\"><a href=\"#索引是怎么构建的？\" class=\"headerlink\" title=\"索引是怎么构建的？\"></a><strong>索引是怎么构建的？</strong></h1><p>开发过程中，MySQL都首先B+Tree。在MySQL下还拥有Hash索引，也就是它拥有2大索引类型。具体选择用什么，可在创建表时进行选择。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<blockquote>\n<p>那这索引到底是怎么创建出来的？</p>\n</blockquote>\n<p>那还得分情况而定，分为以下2种</p>\n<blockquote>\n<p>建表建索引</p>\n</blockquote>\n<p>创建表的时候，先把索引字段建立好。如：</p>\n<ul>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">create table nezha(id int unsigned   AUTO_INCREMENT PRIMARY KEY, phone int not null,name varchar(16),index (phone))engine&#x3D;InnoDB;<br></code></pre></td></tr></table></figure>\n<p>当添加数据时，数据库就会自动先去创建好索引结构，然后创建数据。最终在落地到磁盘上。</p>\n<blockquote>\n<p>先建表，后添索引</p>\n</blockquote>\n<p>这种情况需要注意，因为先建表，那可能你数据表已经拥有了大量数据，这时候你在添加索引，那你的整个数据库肯定会阻塞，因为数据库需要根据表中数据建立索引，这都是由数据库后台线程来完成。</p>\n<p>这也是为什么线上数据库不要轻易变动索引，需根据用户低峰时间来操作。所以索引创建过多，那也算是需要耗费资源的。</p>\n<p>一般还需要维护表和索引，你这里有什么建议吗？不妨留言说说你的提议，优化就留到下次。</p>\n<p>所以当你的大表需要导入到其它数据库时，需在新数据库上先关闭索引，然后再添上索引，要不然效率就太低了。</p>\n<h1 id=\"04\"><a href=\"#04\" class=\"headerlink\" title=\"04\"></a><strong>04</strong></h1><h1 id=\"索引的表现类型代表作有哪些\"><a href=\"#索引的表现类型代表作有哪些\" class=\"headerlink\" title=\"索引的表现类型代表作有哪些?\"></a><strong>索引的表现类型代表作有哪些?</strong></h1><p>乖乖，索引还有表现种类，这神马情况？</p>\n<p>大家都知道B+Tree、Hash索引，但这些都底层实现的数据结构，而表现种类在明面上，我们常说的，例如：聚簇索引、非聚簇索引等，都包含了对应的数据结构。</p>\n<blockquote>\n<p>问最多算聚簇索引、非聚簇索引，那它们是什么呢？</p>\n</blockquote>\n<p><strong>聚簇索引：索引和数据都存储在一起，代表作Innodb</strong></p>\n<p><strong>非聚簇索引：索引和数据分开存储，代表\\</strong>作*<em>MyIASM*</em></p>\n<p>上述的特性，也和它们的物理存储文件有关系。文件放在数据库安装目录下的data目录中</p>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;mysql-57&#x2F;data&#x2F;mysql<br></code></pre></td></tr></table></figure>\n<p>MyISAM结构如下：</p>\n</li>\n</ul>\n<p>.frm为表结构文件，存储像create alter等语句  .MYD为存储数据文件  .MYI为存储索引文件</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdSws7tibFzZpQI32Q39KoRyKU34hwpkPWYOnicdhmp056aMo9iaObAqicEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>InnoDb结构如下：</p>\n<p>.frm为表结构文件，.ibd为数据+索引文件</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdjicNicU6yOUrAGB57Im3O74LMKLQeLmrTjPDJlASs4gibyacxkjvPIWqg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>在InnoDB存储引擎中,就一定都是聚簇索引吗？</strong></p>\n<p>并不是，<strong>只有主键索引被称为聚簇索引（ clusteredindex ）。除开主键以外的字段上创建的索引被称为非主键索引</strong>，非主键索引也被称为<strong>二级索引</strong>（ secondary index ）。</p>\n<blockquote>\n<p>注：现在你该知道，为啥面试都不问你什么唯一、普通、联合索引了吧，那都是属于二级索引呢</p>\n</blockquote>\n<p>那这两者之间有什么区别吗？区别在<strong>非主键索引的叶子节点内容是主键，当找到主键后，还需要根据主键再一次的进行索引树的查找，这个过程称之为回表。</strong></p>\n<p>例如：</p>\n<p>如果语句是 select * from nezha  where ID=7 ，即主键查询方式，那它只需搜索 ID 这棵 B+ 树；</p>\n<p>如果语句是 select * from nezha  where name = ‘哪吒’ ，即普通索引查询方式，则需要先搜索 name 索引树，得到 ID的值为 7，再到 ID 索引树搜索一次。这就是所谓的<strong>回表</strong>。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdMwWCYWWwTY712lXR54qjD6AeYwyVpnrxnNbm2YVf4S6icRzVfYdbAjQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<blockquote>\n<p>那这个问题怎么解决呀！</p>\n</blockquote>\n<blockquote>\n<p>内心独白：哎呀！咋这么多问题，烦不烦。 </p>\n</blockquote>\n<p>这个好办，刚才我们是 select * ，查询所有记录，如果查询字段上只出现主键索引与<strong>创建索引的字段</strong>，那就不需要回表了。因为走二级索引时，就已经包含了你需要的字段列啦，那就不需要在<strong>回表</strong>了。<strong>这就被称之为索引覆盖，即索引已经包含了查询操作的值。</strong></p>\n<p>这也是为什么，当有多个字段需创建索引时，会创建联合索引，<strong>也是为了更好支持索引覆盖。</strong></p>\n<p><strong>瞬间飞过，”我怎么这么好看，这么好看怎么办”</strong></p>\n<h1 id=\"05\"><a href=\"#05\" class=\"headerlink\" title=\"05\"></a><strong>05</strong></h1><h1 id=\"数据库内部利用索引是如何读取数据的？\"><a href=\"#数据库内部利用索引是如何读取数据的？\" class=\"headerlink\" title=\"数据库内部利用索引是如何读取数据的？\"></a><strong>数据库内部利用索引是如何读取数据的？</strong></h1><blockquote>\n<p>搞了这么久，那这个索引查找数据的时候，是怎么个读取原理又是什么？</p>\n</blockquote>\n<p>那这首先得说数据库中的读取数据单位，数据库中的数据是按照页读取的。默认一页的数据为16KB。而磁盘块（OS）默认为4KB</p>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">show global variables like &#39;innodb_page%&#39;;<br></code></pre></td></tr></table></figure>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdElkEAp3jWbRbeiammCjeoJ8I6Bibxp5NLhmCCe9ts8JYY9ZDBGSNmicLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n</li>\n</ul>\n<p>那索引和数据都保存在节点里面，这个数据怎么个读法？</p>\n<p>上面说到，数据库读取数据是根据页为单位，<strong>并且读的数据不满足1页或超过1页，那么也会读满1页。这也叫做预读</strong></p>\n<p>也就是说节点读取数据的大小应该控制在1页、2页、3页、4页等倍数页大小最为合适。</p>\n<p>那你说说这个页吧！</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdwxA1h3BQ2SibFEkYK4fEU0ibNF5ibWNPUdqlwiaCRGj9IH27Iubs9SCehg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>每个数据页中的数据</strong>，采用<strong>单向链表</strong>的形式进行连接。</p>\n<p><strong>各个页之间采用双向链表链接</strong>。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfd7PS37qU5XZEnRC9YdNwh8Ssdb6a3RYCaGuY7ibFMkFVA4cZhGu9VtIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>查找数据时是根据页内分组定义的。首先在插入数据时就会根据主键大小做好排序结构，并按照最大和最小进行分组。</p>\n<p>最小虚拟数据独自一组，它拥有一条数据，就是最小数据。然后剩下的数据再分成一组，即最大数据为另一组。当进行数据插入的时，都是先插入到最大数据组，<strong>当最大数据组装满后在进行分裂</strong>。 </p>\n<p>分组确立后，在进行数据查找的时就是根据<strong>二分查找法确定对应数据所在的槽位置</strong>，然后在使用记录头信息的next_record一条条进行查找。</p>\n<p><strong>当以(非主键)作为搜索条件</strong>：只能从最小虚拟数据记录，开始<strong>依次遍历单链表中的每条记录</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">所以，当写<br></code></pre></td></tr></table></figure>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">select * from nezha where name&#x3D;&#39;nezha&#39;<br>这样没有进行任何优化的sql语句，默认会这样做：<br></code></pre></td></tr></table></figure></li>\n<li><p>读取记录所在页的范围</p>\n</li>\n<li><p>根据双向链表，找到所在页</p>\n</li>\n<li><p>从所在页中查找相应的记录</p>\n</li>\n<li><p>由于不是主键查询，就遍历所在页的单链表</p>\n</li>\n</ul>\n<h1 id=\"06\"><a href=\"#06\" class=\"headerlink\" title=\"06\"></a><strong>06</strong></h1><h1 id=\"索引就不命中？前提你得知道规则\"><a href=\"#索引就不命中？前提你得知道规则\" class=\"headerlink\" title=\"索引就不命中？前提你得知道规则\"></a><strong>索引就不命中？前提你得知道规则</strong></h1><p>使用索引当中，最核心的就是最左匹配原则，索引命中都是根据它来定义的。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdV9DYMLbqDoZEq9qaheoJ4hia8xPR7wvPN6cKcjMiafDpiah2G3feqTpsA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>最左匹配原则</strong>：</p>\n<ul>\n<li><p>索引可以的简单如单列 (a)，也可以复杂如多列 (a,b,c,d)，即<strong>联合索引</strong>。</p>\n</li>\n<li><p>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否<strong>存在（相等）</strong>，遇到范围查询 (&gt;、&lt;、BETWEEN、LIKE)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</p>\n</li>\n<li><p>索引列不能是表达式的一部分，那样无法命中索引，例如</p>\n</li>\n<li><ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">：SELECT  *   FROM  nezha  WHERE  id + 1 &#x3D; 5;   date(create_time)&#x3D;&#39;2020-03-05&#39;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p><strong>例如：</strong></p>\n<ul>\n<li>如有索引 (a,b,c,d)，查询条件 a=7 and b=8 and c&gt;15 and d=32，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d就没办法进行对比查找了)</li>\n</ul>\n<p><strong>总结：</strong></p>\n<p>索引在数据库中是一个<strong>非常</strong>重要的内容！</p>\n<ul>\n<li><strong>最左前缀匹配原则</strong>。这是非常重要的原则，SQL查询都是基于它来。MySQL会一直向右匹配，直到遇到范围查询 （&gt;,&lt;,BETWEEN,LIKE）就停止匹配。</li>\n<li><strong>页</strong>也需要了解下，这个是数据库在内部的工作机制。</li>\n<li>索引的表现形式针对于不同的存储引擎，表现也不一样，并且2者之间的存储引擎区别也要掌握了解</li>\n<li>索引创建方式来自于建表前还是建表后。重点都是数据库再用后台线程创建与维护索引</li>\n<li>B+Tree和Hash这2个特点还是需要注意，并且它们之间区别还未细讲。后面会针对面试问题，给大家补上来。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdxUoEZiaQErySl2YPCNnF0ddmMVvCrSyBfkSEuEwbh3AmmqZgVrX1PJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>01</strong></p>\n<p><strong>为啥BAT大厂，在数据库上都喜欢深入的问索引呢？</strong></p>\n<p>一线大厂，是很多人梦寐以求的盛典天堂。因为存在的无限的可能，可以帮你实现自己的远大抱负。大平台机会、视野、格局往往都比小厂多很多。但随之而来也是那高挑的技术门槛需等你迈过。好事物大家都喜欢，但毕竟僧多粥少。外加任务有难度，如果你没过硬的本领，那很难踏入平台，领会一览众山小的风采。不知你心里有没有小九九？</p>\n<hr>\n<p>大厂产品大多数都成型很久，数据库里面存储的数据都以海量计算，如何在这种规模下的数据中做到快速筛选呢？那就需要你来答。</p>\n<p>大家思路肯定和我一样，话不多说，加索引再说！索引为的就是提高数据的检索效率，进而减少请求的响应时间。</p>\n<p><strong>这时，有内涵的人可能会反问你啦？</strong></p>\n<p>那你说说索引有哪些类型？索引底层实现是什么结构？B+Tree的优点？聚簇索引和非聚簇的区别？索引一次读读取多少数据合适？为什么说索引会降低插入、删除、修改等维护任务的速度？</p>\n<p>这一套组合拳，可能虐的你是体无完肤。让人招教不住，心理一万个xxx省略。送他一个微笑，然后再尴尬而不失优雅的离去。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_jpg/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdBsMmPCcTSTbU914ibhsnXVFSZgMQ1d8GHqyYM1Gvo5vxHNrhVwUwJUw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>大家可能都知道查询慢了加索引，那为啥加？在哪些字段上加？以及索引的数据结构特点。索引优化、优点啥的都比较模糊或者不知道。</p>\n<p>今天将是对索引来一次灵魂的拷问，在进一步对索引优化、常见大厂面试问题、SQL优化等内容进行分享。这是个大工程，大家得关注再看。深，那就得深出高度。MOG！太深啦</p>\n<h1 id=\"02\"><a href=\"#02\" class=\"headerlink\" title=\"02\"></a><strong>02</strong></h1><h1 id=\"用索引，那你得知道索引是什么？\"><a href=\"#用索引，那你得知道索引是什么？\" class=\"headerlink\" title=\"用索引，那你得知道索引是什么？\"></a><strong>用索引，那你得知道索引是什么？</strong></h1><blockquote>\n<p>百度百科定义：索引是数据表中一列或多列的值进行排序的一种数据结构</p>\n</blockquote>\n<p>故此，索引本质就是数据结构。这也是为什么每次数据表建立索引都需要设置在列字段上的原因。那常见数据结构有哪些？ </p>\n<p>常见数据结构大致可分为三大类，如下所示</p>\n<ul>\n<li>线性表：顺序表、链表、栈和队列；</li>\n<li>树结构：二叉树，堆、线索二叉树、红黑树、B-Tree等；</li>\n<li>图存储结构</li>\n</ul>\n<p>但在数据库中常用数据结构为<strong>B+Tree、Hash索引</strong>。</p>\n<p>对于此，有人可能觉得有了Hash和那么多树结构（红黑树、B树、完全平衡二叉（AVL）树、B+树），为啥Mysql唯独喜欢B+树？</p>\n<p>请听如下分解：</p>\n<blockquote>\n<p>首先上场的是顽固不变Hash索引，这Hash索引又是什么？</p>\n</blockquote>\n<p><strong>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才能生效额</strong>。切记！切记！切记！</p>\n<p>哈希的思路很简单，以键-值（ key-value ）存储数据的结构，对于待查找每一行的数据值,用一个哈希函数把数据值换算成一个确定的位置即 key，位置就是哈希码，并且不同键值的行计算出来的哈希码也不一样。然后在 value 上存放每个数据行的指针。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdFt84gHyIgUVpkwk9cOvVtd1254ibS2iccOKXKpabe1sKibrMzXd3GjqQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>对这样的索引结构，执行如下sql语句的过程是什么呢？</strong></p>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">select * from nezha where name&#x3D;&#39;lianhua&#39;<br></code></pre></td></tr></table></figure>\n<p>MySQL首先计算’lianhua’的哈希值，并使用该值寻找对应的记录指针。然后根据指针寻找对应的数据，最后一步是比较读取的值是否为’lianhua’, 从而来确保就是要查找的行。</p>\n</li>\n</ul>\n<p>那如果改变为范围性查找就会存在问题。还记得上面的切记吗？因为它不支持范围匹配，只支持等值匹配。例如：</p>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">select * from nezha where name like &#39;%lianhua&#39;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>那像Hash这种等值查询还有哪些场景？</p>\n</blockquote>\n</li>\n</ul>\n<p>Hash故名思议体现的就是（key-value）结构。所以像 Redis、Memcached 及其他一些 NoSQL 引擎（如 Memory）。</p>\n<blockquote>\n<p>那有没有既能快速查找，又可以支持范围型查找呢？</p>\n</blockquote>\n<p>自然有，<strong>有序数组在等值查询和范围查询场景中的性能就都非常OK</strong>，足以满足你的口味。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdELGVqYfcP9ket3E7DwdiaEYkiaOzRZII14nfssVAWKcuAbhhP8icLMEibg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>那它就好的没天理啦？不，世上没得十全十美的！</p>\n<p>有序数组索引只适用于静态存储引擎，因为数组的空间必须是连续的，这就造成数组在内存中分配空间时必须找到一块连续的内存空间。<strong>所以新增、删除、修改数据时就会改变它的结构。</strong></p>\n<blockquote>\n<p>一下掉入无底洞，这在业务场景上怎样使用？</p>\n</blockquote>\n<p>静态数据简单点可以理解为不会在变化的数据，那你就可以用于历史归档性的业务。比如你去年酷狗歌单、每上月的支付记录等，这类不会再修改的数据。</p>\n<blockquote>\n<p>接下来上场的是层次不齐的树结构</p>\n</blockquote>\n<p>树结构基础就是普通二叉树，其它树结构都是基于它演进产生。二叉树会根据元素值的大小来创建树形结构。所以它是有序的，并支持范围查找。具体可查看数据结构相关书籍。</p>\n<p>但普通二叉树，<strong>有个问题，就是当元素是递增或递减时，它就会退化为线性表。</strong></p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdy02r1jxR2HibcPUgB9do3AhoWBNQCmMYlmCJJGLRhaNbBmemI2RlUdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>为了解决这个问题，就出现了我们的完全平衡二叉树。<strong>可为何数据库没选择它呢</strong>？</p>\n<p>数据库操作都是在内存里面完成的，但最终还是要落地到磁盘。如果数据多了，树会变得很高。然而查询数据时，那都是从磁盘里面把数据读取出来放入到内存中。这样I/O操作成本就会随着树的高度而增加。这也是常说完全平衡二叉树具有高瘦特点。</p>\n<blockquote>\n<p>好像女孩子都喜欢这样的吧！</p>\n</blockquote>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdEypcZesGvKgkMJ4ociaA3AmJazfMs0LMZE3TaoAqzNexYl97NWJUFag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>一般为节约成本，很多公司服务器采用的还是机械硬盘，这样一次千万级别的查询差不多就要10秒，这还不算网络传输、业务处理、CPU的执行时间，一但汇总那谁顶得住？</p>\n<p>那这怎么解决呢？不可能一直让让它变高吧! 可使用B-Tree。</p>\n<p>B-Tree的特征就是矮胖，也称为多叉树，就是在树的同一高度上开辟多个分叉来容纳元素。从而树在横向上面变宽了。这样减少了磁盘I/O的查询查找次数，从而提升了效率。</p>\n<p>B-Tree的特点简写：</p>\n<ul>\n<li>每个节点中的元素（关键字）从小到大排列。</li>\n<li>每个节点都保存有数据</li>\n</ul>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdVWibDic4qoYy7C63ckZict4ichoOvbWib5ATW8ryx28BvJtob9UyP0r08kA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<blockquote>\n<p>那为什么最终数据库选择了B+Tree，而不是B-Tree呢？</p>\n</blockquote>\n<p>B+Tree自然保持了B-Tree的矮胖特征，但它还做了升级的处理。<strong>就是让叶子节点保存数据，而非叶子节点保存关键字即可，并且会有指针指向下一个叶子节点。</strong>这样的好处是<strong>为了提高范围查找的效率</strong>。找到数据后直接根据指针向后读取即可，而B-Tree就不行，当它读取下一个数据，还需要再一次的进行索引树的查找。</p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><strong>B+Tree特点：</strong></p>\n<ul>\n<li>所有的非叶子节点只存储关键字信息 </li>\n<li>只有叶子节点存储数据</li>\n<li>所有叶子节点之间都有一个链指针</li>\n</ul>\n<p><strong>小结</strong>：最终MySQL选用B+Tree作为索引，从而提高检索索引时的磁盘IO效率，并且提高范围查询的效率，整个B+树里的元素也是有序的。因为B+Tree默认就是按照主键索引来构建的树结构。那你说呢？</p>\n<p>​    <strong>03</strong></p>\n<h1 id=\"索引是怎么构建的？\"><a href=\"#索引是怎么构建的？\" class=\"headerlink\" title=\"索引是怎么构建的？\"></a><strong>索引是怎么构建的？</strong></h1><p>开发过程中，MySQL都首先B+Tree。在MySQL下还拥有Hash索引，也就是它拥有2大索引类型。具体选择用什么，可在创建表时进行选择。</p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<blockquote>\n<p>那这索引到底是怎么创建出来的？</p>\n</blockquote>\n<p>那还得分情况而定，分为以下2种</p>\n<blockquote>\n<p>建表建索引</p>\n</blockquote>\n<p>创建表的时候，先把索引字段建立好。如：</p>\n<ul>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n<li></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">create table nezha(id int unsigned   AUTO_INCREMENT PRIMARY KEY, phone int not null,name varchar(16),index (phone))engine&#x3D;InnoDB;<br></code></pre></td></tr></table></figure>\n<p>当添加数据时，数据库就会自动先去创建好索引结构，然后创建数据。最终在落地到磁盘上。</p>\n<blockquote>\n<p>先建表，后添索引</p>\n</blockquote>\n<p>这种情况需要注意，因为先建表，那可能你数据表已经拥有了大量数据，这时候你在添加索引，那你的整个数据库肯定会阻塞，因为数据库需要根据表中数据建立索引，这都是由数据库后台线程来完成。</p>\n<p>这也是为什么线上数据库不要轻易变动索引，需根据用户低峰时间来操作。所以索引创建过多，那也算是需要耗费资源的。</p>\n<p>一般还需要维护表和索引，你这里有什么建议吗？不妨留言说说你的提议，优化就留到下次。</p>\n<p>所以当你的大表需要导入到其它数据库时，需在新数据库上先关闭索引，然后再添上索引，要不然效率就太低了。</p>\n<h1 id=\"04\"><a href=\"#04\" class=\"headerlink\" title=\"04\"></a><strong>04</strong></h1><h1 id=\"索引的表现类型代表作有哪些\"><a href=\"#索引的表现类型代表作有哪些\" class=\"headerlink\" title=\"索引的表现类型代表作有哪些?\"></a><strong>索引的表现类型代表作有哪些?</strong></h1><p>乖乖，索引还有表现种类，这神马情况？</p>\n<p>大家都知道B+Tree、Hash索引，但这些都底层实现的数据结构，而表现种类在明面上，我们常说的，例如：聚簇索引、非聚簇索引等，都包含了对应的数据结构。</p>\n<blockquote>\n<p>问最多算聚簇索引、非聚簇索引，那它们是什么呢？</p>\n</blockquote>\n<p><strong>聚簇索引：索引和数据都存储在一起，代表作Innodb</strong></p>\n<p><strong>非聚簇索引：索引和数据分开存储，代表\\</strong>作*<em>MyIASM*</em></p>\n<p>上述的特性，也和它们的物理存储文件有关系。文件放在数据库安装目录下的data目录中</p>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;mysql-57&#x2F;data&#x2F;mysql<br></code></pre></td></tr></table></figure>\n<p>MyISAM结构如下：</p>\n</li>\n</ul>\n<p>.frm为表结构文件，存储像create alter等语句  .MYD为存储数据文件  .MYI为存储索引文件</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdSws7tibFzZpQI32Q39KoRyKU34hwpkPWYOnicdhmp056aMo9iaObAqicEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>InnoDb结构如下：</p>\n<p>.frm为表结构文件，.ibd为数据+索引文件</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdjicNicU6yOUrAGB57Im3O74LMKLQeLmrTjPDJlASs4gibyacxkjvPIWqg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>在InnoDB存储引擎中,就一定都是聚簇索引吗？</strong></p>\n<p>并不是，<strong>只有主键索引被称为聚簇索引（ clusteredindex ）。除开主键以外的字段上创建的索引被称为非主键索引</strong>，非主键索引也被称为<strong>二级索引</strong>（ secondary index ）。</p>\n<blockquote>\n<p>注：现在你该知道，为啥面试都不问你什么唯一、普通、联合索引了吧，那都是属于二级索引呢</p>\n</blockquote>\n<p>那这两者之间有什么区别吗？区别在<strong>非主键索引的叶子节点内容是主键，当找到主键后，还需要根据主键再一次的进行索引树的查找，这个过程称之为回表。</strong></p>\n<p>例如：</p>\n<p>如果语句是 select * from nezha  where ID=7 ，即主键查询方式，那它只需搜索 ID 这棵 B+ 树；</p>\n<p>如果语句是 select * from nezha  where name = ‘哪吒’ ，即普通索引查询方式，则需要先搜索 name 索引树，得到 ID的值为 7，再到 ID 索引树搜索一次。这就是所谓的<strong>回表</strong>。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdMwWCYWWwTY712lXR54qjD6AeYwyVpnrxnNbm2YVf4S6icRzVfYdbAjQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<blockquote>\n<p>那这个问题怎么解决呀！</p>\n</blockquote>\n<blockquote>\n<p>内心独白：哎呀！咋这么多问题，烦不烦。 </p>\n</blockquote>\n<p>这个好办，刚才我们是 select * ，查询所有记录，如果查询字段上只出现主键索引与<strong>创建索引的字段</strong>，那就不需要回表了。因为走二级索引时，就已经包含了你需要的字段列啦，那就不需要在<strong>回表</strong>了。<strong>这就被称之为索引覆盖，即索引已经包含了查询操作的值。</strong></p>\n<p>这也是为什么，当有多个字段需创建索引时，会创建联合索引，<strong>也是为了更好支持索引覆盖。</strong></p>\n<p><strong>瞬间飞过，”我怎么这么好看，这么好看怎么办”</strong></p>\n<h1 id=\"05\"><a href=\"#05\" class=\"headerlink\" title=\"05\"></a><strong>05</strong></h1><h1 id=\"数据库内部利用索引是如何读取数据的？\"><a href=\"#数据库内部利用索引是如何读取数据的？\" class=\"headerlink\" title=\"数据库内部利用索引是如何读取数据的？\"></a><strong>数据库内部利用索引是如何读取数据的？</strong></h1><blockquote>\n<p>搞了这么久，那这个索引查找数据的时候，是怎么个读取原理又是什么？</p>\n</blockquote>\n<p>那这首先得说数据库中的读取数据单位，数据库中的数据是按照页读取的。默认一页的数据为16KB。而磁盘块（OS）默认为4KB</p>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">show global variables like &#39;innodb_page%&#39;;<br></code></pre></td></tr></table></figure>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdElkEAp3jWbRbeiammCjeoJ8I6Bibxp5NLhmCCe9ts8JYY9ZDBGSNmicLQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n</li>\n</ul>\n<p>那索引和数据都保存在节点里面，这个数据怎么个读法？</p>\n<p>上面说到，数据库读取数据是根据页为单位，<strong>并且读的数据不满足1页或超过1页，那么也会读满1页。这也叫做预读</strong></p>\n<p>也就是说节点读取数据的大小应该控制在1页、2页、3页、4页等倍数页大小最为合适。</p>\n<p>那你说说这个页吧！</p>\n<p><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdwxA1h3BQ2SibFEkYK4fEU0ibNF5ibWNPUdqlwiaCRGj9IH27Iubs9SCehg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>每个数据页中的数据</strong>，采用<strong>单向链表</strong>的形式进行连接。</p>\n<p><strong>各个页之间采用双向链表链接</strong>。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfd7PS37qU5XZEnRC9YdNwh8Ssdb6a3RYCaGuY7ibFMkFVA4cZhGu9VtIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>查找数据时是根据页内分组定义的。首先在插入数据时就会根据主键大小做好排序结构，并按照最大和最小进行分组。</p>\n<p>最小虚拟数据独自一组，它拥有一条数据，就是最小数据。然后剩下的数据再分成一组，即最大数据为另一组。当进行数据插入的时，都是先插入到最大数据组，<strong>当最大数据组装满后在进行分裂</strong>。 </p>\n<p>分组确立后，在进行数据查找的时就是根据<strong>二分查找法确定对应数据所在的槽位置</strong>，然后在使用记录头信息的next_record一条条进行查找。</p>\n<p><strong>当以(非主键)作为搜索条件</strong>：只能从最小虚拟数据记录，开始<strong>依次遍历单链表中的每条记录</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">所以，当写<br></code></pre></td></tr></table></figure>\n<ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">select * from nezha where name&#x3D;&#39;nezha&#39;<br>这样没有进行任何优化的sql语句，默认会这样做：<br></code></pre></td></tr></table></figure></li>\n<li><p>读取记录所在页的范围</p>\n</li>\n<li><p>根据双向链表，找到所在页</p>\n</li>\n<li><p>从所在页中查找相应的记录</p>\n</li>\n<li><p>由于不是主键查询，就遍历所在页的单链表</p>\n</li>\n</ul>\n<h1 id=\"06\"><a href=\"#06\" class=\"headerlink\" title=\"06\"></a><strong>06</strong></h1><h1 id=\"索引就不命中？前提你得知道规则\"><a href=\"#索引就不命中？前提你得知道规则\" class=\"headerlink\" title=\"索引就不命中？前提你得知道规则\"></a><strong>索引就不命中？前提你得知道规则</strong></h1><p>使用索引当中，最核心的就是最左匹配原则，索引命中都是根据它来定义的。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/qCdL7oaDDpHsPpjgibVVbzS988e4lImfdV9DYMLbqDoZEq9qaheoJ4hia8xPR7wvPN6cKcjMiafDpiah2G3feqTpsA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p><strong>最左匹配原则</strong>：</p>\n<ul>\n<li><p>索引可以的简单如单列 (a)，也可以复杂如多列 (a,b,c,d)，即<strong>联合索引</strong>。</p>\n</li>\n<li><p>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否<strong>存在（相等）</strong>，遇到范围查询 (&gt;、&lt;、BETWEEN、LIKE)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</p>\n</li>\n<li><p>索引列不能是表达式的一部分，那样无法命中索引，例如</p>\n</li>\n<li><ul>\n<li><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">：SELECT  *   FROM  nezha  WHERE  id + 1 &#x3D; 5;   date(create_time)&#x3D;&#39;2020-03-05&#39;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p><strong>例如：</strong></p>\n<ul>\n<li>如有索引 (a,b,c,d)，查询条件 a=7 and b=8 and c&gt;15 and d=32，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d就没办法进行对比查找了)</li>\n</ul>\n<p><strong>总结：</strong></p>\n<p>索引在数据库中是一个<strong>非常</strong>重要的内容！</p>\n<ul>\n<li><strong>最左前缀匹配原则</strong>。这是非常重要的原则，SQL查询都是基于它来。MySQL会一直向右匹配，直到遇到范围查询 （&gt;,&lt;,BETWEEN,LIKE）就停止匹配。</li>\n<li><strong>页</strong>也需要了解下，这个是数据库在内部的工作机制。</li>\n<li>索引的表现形式针对于不同的存储引擎，表现也不一样，并且2者之间的存储引擎区别也要掌握了解</li>\n<li>索引创建方式来自于建表前还是建表后。重点都是数据库再用后台线程创建与维护索引</li>\n<li>B+Tree和Hash这2个特点还是需要注意，并且它们之间区别还未细讲。后面会针对面试问题，给大家补上来。</li>\n</ul>\n"},{"title":"正则表达式大全","abbrlink":2413522498,"date":"2020-12-21T02:02:41.000Z","updated":"2020-12-24T14:39:35.813Z","keywords":["正则表达式","regex"],"description":null,"top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","comments":1,"cover":"https://cdn.tanxz.com/images/category/regex.jpg","toc":null,"toc_number":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"\n## 什么是正则表达式\n\n\n\n\n\n正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。\n\n\n\n![什么是正则表达式](https://atts.w3cschool.cn/attachments/day_160822/201608221705481933.jpg)\n\n\n\n\n\n给定一个正则表达式和另一个字符串，我们可以达到如下的目的：\n\n\n\n1. 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）；\n2. 可以通过正则表达式，从字符串中获取我们想要的特定部分。\n\n\n\n\n\n## 正则表达式的特点\n\n\n\n1. 灵活性、逻辑性和功能性非常的强；\n2. 可以迅速地用极简单的方式达到字符串的复杂控制。\n3. 对于刚接触的人来说，比较晦涩难懂。\n\n\n\n\n\n由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。\n\n\n\n## 正则表达式的标准\n\n大体来讲，正则表达式的文法分为3种标准：\n\n- BRE\n- ERE\n- ARE\n\n\n\n## 正则表达式的基础语法\n\n正则表达式是由普通字符（如字符A到字符Z）和特殊字符（称为元字符）组成。该模式描述在查找文字主题时要匹配的一个或多个字符串。正则表达式作为一个模板，将一个字符模式与搜索的字符串相匹配。如：\n\n| JScript          | VBScript         | 匹配                                                         |\n| ---------------- | ---------------- | ------------------------------------------------------------ |\n| /^[ \\t]*$/*      | \"^[ \\t]$\"        | 匹配一个空白行。                                             |\n| /\\d{2}-\\d{5}/    | \"\\d{2}-\\d{5}\"    | 验证一个ID 号码是否由一个2位数字，一个连字符以及一个5位数字组成。 |\n| /<(.*)>.*<\\/\\1>/ | \"<(.*)>.*<\\/\\1>\" | 匹配一个 HTML 标记。                                         |\n\n\n下表是元字符及其在正则表达式上下文中的行为的一个完整列表：\n\n| 字符          | 描述                                                         |\n| ------------- | ------------------------------------------------------------ |\n| \\             | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 \"n\"。'\\n' 匹配一个换行符。序列 '\\' 匹配 \"\\\" 而 \"(\" 则匹配 \"(\"。 |\n| ^             | 匹配输入字符串的开始位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 |\n| $             | 匹配输入字符串的结束位置。如果设置了**RegExp** 对象的 **Multiline** 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 |\n| *             | 匹配前面的子表达式零次或多次。例如，zo 能匹配 \"z\" 以及 \"zoo\"。 *等价于{0,}。* |\n| +             | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 |\n| ?             | 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 中的\"do\" 。? 等价于 {0,1}。 |\n| {*n*}         | *n* 是一个非负整数。匹配确定的 *n* 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 |\n| {*n*,}        | *n* 是一个非负整数。至少匹配*n* 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o'。 |\n| {*n*,*m*}     | *m* 和 *n* 均为非负整数，其中*n* <= *m*。最少匹配 *n* 次且最多匹配 *m* 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |\n| ?             | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {\\*n*}, {\\*n*,}, {\\*n*,\\*m*}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。* |\n| .             | 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。 |\n| (*pattern*)   | 匹配 *pattern* 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 **SubMatches** 集合，在JScript 中则使用 **$0**…**$9** 属性。要匹配圆括号字符，请使用 '(' 或 ')'。 |\n| (?:*pattern*) | 匹配 *pattern* 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (\\|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\\|ies) 就是一个比 'industry\\|industries' 更简略的表达式。 |\n| (?=*pattern*) | 正向预查，在任何匹配 *pattern* 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95\\|98\\|NT\\|2000)' 能匹配 \"Windows 2000\" 中的 \"Windows\" ，但不能匹配 \"Windows 3.1\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |\n| (?!*pattern*) | 负向预查，在任何不匹配 *pattern* 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95\\|98\\|NT\\|2000)' 能匹配 \"Windows 3.1\" 中的 \"Windows\"，但不能匹配 \"Windows 2000\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |\n| *x*\\|*y*      | 匹配 *x* 或 *y*。例如，'z\\|food' 能匹配 \"z\" 或 \"food\"。'(z\\|f)ood' 则匹配 \"zood\" 或 \"food\"。 |\n| [*xyz*]       | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 \"plain\" 中的 'a'。 |\n| [^*xyz*]      | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 \"plain\" 中的'p'。 |\n| [*a-z*]       | 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 |\n| [^*a-z*]      | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 |\n| \\b            | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。 |\n| \\B            | 匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。 |\n| \\c*x*         | 匹配由 *x* 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。*x* 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |\n| \\d            | 匹配一个数字字符。等价于 [0-9]。                             |\n| \\D            | 匹配一个非数字字符。等价于 [^0-9]。                          |\n| \\f            | 匹配一个换页符。等价于 \\x0c 和 \\cL。                         |\n| \\n            | 匹配一个换行符。等价于 \\x0a 和 \\cJ。                         |\n| \\r            | 匹配一个回车符。等价于 \\x0d 和 \\cM。                         |\n| \\s            | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 |\n| \\S            | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。                  |\n| \\t            | 匹配一个制表符。等价于 \\x09 和 \\cI。                         |\n| \\v            | 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。                     |\n| \\w            | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9*]'。*        |\n| \\W            | 匹配任何非单词字符。等价于 '[^A-Za-z0-9]'。                  |\n| \\x*n*         | 匹配 *n*，其中 *n* 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\\x41' 匹配 \"A\"。'\\x041' 则等价于 '\\x04' & \"1\"。正则表达式中可以使用 ASCII 编码。. |\n| \\*num*        | 匹配 *num*，其中 *num* 是一个正整数。对所获取的匹配的引用。例如，'(.)\\1' 匹配两个连续的相同字符。 |\n| \\*n*          | 标识一个八进制转义值或一个向后引用。如果 \\*n* 之前至少 *n* 个获取的子表达式，则 *n* 为向后引用。否则，如果 *n* 为八进制数字 (0-7)，则 *n* 为一个八进制转义值。 |\n| \\*nm*         | 标识一个八进制转义值或一个向后引用。如果 \\*nm* 之前至少有 *nm* 个获得子表达式，则 *nm* 为向后引用。如果 \\*nm* 之前至少有 *n* 个获取，则 *n* 为一个后跟文字 *m* 的向后引用。如果前面的条件都不满足，若*n* 和 *m* 均为八进制数字 (0-7)，则 \\*nm* 将匹配八进制转义值 *nm*。 |\n| \\*nml*        | 如果 *n* 为八进制数字 (0-3)，且 *m* 和 *l* 均为八进制数字 (0-7)，则匹配八进制转义值 *nml。* |\n| \\u*n*         | 匹配 *n*，其中 *n* 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (©)。 |\n\n\n\n\n下面看几个例子：\n\n```\n\"^The\"：表示所有以\"The\"开始的字符串（\"There\"，\"The cat\"等）； \n\"of despair$\"：表示所以以\"of despair\"结尾的字符串； \n\"^abc$\"：表示开始和结尾都是\"abc\"的字符串——呵呵，只有\"abc\"自己了； \n\"notice\"：表示任何包含\"notice\"的字符串。 \n```\n\n\n''，'+'和'?'这三个符号，表示一个或一序列字符重复出现的次数。它们分别表示“没有或更多”，“一次或更多”还有“没有或一次”。下面是几个例子：\n\n```\n\"ab\"：表示一个字符串有一个a后面跟着零个或若干个b。（\"a\", \"ab\", \"abbb\",……）； \n\"ab+\"：表示一个字符串有一个a后面跟着至少一个b或者更多； \n\"ab?\"：表示一个字符串有一个a后面跟着零个或者一个b； \n\"a?b+$\"：表示在字符串的末尾有零个或一个a跟着一个或几个b。\n也可以使用范围，用大括号括起，用以表示重复次数的范围。\n\"ab{2}\"：表示一个字符串有一个a跟着2个b（\"abb\"）； \n\"ab{2,}\"：表示一个字符串有一个a跟着至少2个b； \n\"ab{3,5}\"：表示一个字符串有一个a跟着3到5个b。\n请注意，你必须指定范围的下限（如：\"{0,2}\"而不是\"{,2}\"）。还有，你可能注意到了，''，'+'和'?'相当于\"{0,}\"，\"{1,}\"和\"{0,1}\"。 \n```\n\n\n还有一个'¦'，表示“或”操作：\n\n```\n\"hi¦hello\"：表示一个字符串里有\"hi\"或者\"hello\"； \n\"(b¦cd)ef\"：表示\"bef\"或\"cdef\"； \n\"(a¦b)c\"：表示一串\"a\"\"b\"混合的字符串后面跟一个\"c\"；\n```\n\n'.'可以替代任何字符：\n\n```\n\"a.[0-9]\"：表示一个字符串有一个\"a\"后面跟着一个任意字符和一个数字； \n\"^.{3}$\"：表示有任意三个字符的字符串（长度为3个字符）；\n方括号表示某些字符允许在一个字符串中的某一特定位置出现：\n\"[ab]\"：表示一个字符串有一个\"a\"或\"b\"（相当于\"a¦b\"）； \n\"[a-d]\"：表示一个字符串包含小写的'a'到'd'中的一个（相当于\"a¦b¦c¦d\"或者\"[abcd]\"）； \n\"^[a-zA-Z]\"：表示一个以字母开头的字符串； \n\"[0-9]%\"：表示一个百分号前有一位的数字； \n\",[a-zA-Z0-9]$\"：表示一个字符串以一个逗号后面跟着一个字母或数字结束。\n```\n\n\n\n你也可以在方括号里用'^'表示不希望出现的字符，'^'应在方括号里的第一位。（如：\"%[^a-zA-Z]%\"表示两个百分号中不应该出现字母）。\n\n为了逐字表达，必须在\"^.$()¦+?{\\\"这些字符前加上转义字符'\\'。\n\n请注意在方括号中，不需要转义字符。\n\n\n\n## 校验数字的表达式\n\n```\n数字：^[0-9]*$\nn位的数字：^\\d{n}$\n至少n位的数字：^\\d{n,}$\nm-n位的数字：^\\d{m,n}$\n零和非零开头的数字：^(0|[1-9][0-9]*)$\n非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$\n正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$\n有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\n非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$\n非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$\n非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$\n正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\n负浮点数：\n^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ \n或 \n^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\n```\n\n\n\n## 校验字符的表达式\n\n```\n汉字：^[\\u4e00-\\u9fa5]{0,}$\n英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n长度为3-20的所有字符：^.{3,20}$\n由26个英文字母组成的字符串：^[A-Za-z]+$\n由26个大写英文字母组成的字符串：^[A-Z]+$\n由26个小写英文字母组成的字符串：^[a-z]+$\n由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+\n禁止输入含有~的字符：[^~\\x22]+\n```\n\n\n\n## 特殊需求表达式\n\n```\nEmail地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\nInternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\n手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\\d{8}$ (由于工信部放号段不定时，所以建议使用泛解析[1][3,4,5,6,7,8,9])\\d{9}$)\n电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ \n国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} \n18位身份证号码(数字、字母x结尾)：^((\\d{18})|([0-9x]{18})|([0-9X]{18}))$\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$  \n日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ \n钱的输入格式：\n   1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ \n   2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ \n   3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ \n   4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ \n   5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$ \n   6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ \n   7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ \n   8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ \n   备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\nxml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$\n中文字符的正则表达式：[\\u4e00-\\u9fa5]\n双字节字符：[^\\x00-\\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n空白行的正则表达式：\\n\\s*\\r    (可以用来删除空白行)\nHTML标记的正则表达式：<(\\S*?)[^>]*>.*?</\\1>|<.*? />    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)\n中国邮政编码：[1-9]\\d{5}(?!\\d)    (中国邮政编码为6位数字)\nIP地址：\\d+\\.\\d+\\.\\d+\\.\\d+    (提取IP地址时有用)\nIP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))\n```\n\n## 参考文献\n\n[w3cschool正则表达式](https://www.w3cschool.cn/regexp/tfua1pq5.html)\n\n\n\n","source":"_posts/技术分享/正则表达式大全.md","raw":"---\ntitle: 正则表达式大全\nabbrlink: 2413522498\ndate: 2020-12-21 10:02:41\nupdated:\ntags:\n   - 正则表达式\n   - regex\ncategories:\n   - 技术分享\nkeywords:\n   - 正则表达式\n   - regex\ndescription:\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ncomments:\ncover: https://cdn.tanxz.com/images/category/regex.jpg\ntoc:\ntoc_number:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n\n## 什么是正则表达式\n\n\n\n\n\n正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。\n\n\n\n![什么是正则表达式](https://atts.w3cschool.cn/attachments/day_160822/201608221705481933.jpg)\n\n\n\n\n\n给定一个正则表达式和另一个字符串，我们可以达到如下的目的：\n\n\n\n1. 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）；\n2. 可以通过正则表达式，从字符串中获取我们想要的特定部分。\n\n\n\n\n\n## 正则表达式的特点\n\n\n\n1. 灵活性、逻辑性和功能性非常的强；\n2. 可以迅速地用极简单的方式达到字符串的复杂控制。\n3. 对于刚接触的人来说，比较晦涩难懂。\n\n\n\n\n\n由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。\n\n\n\n## 正则表达式的标准\n\n大体来讲，正则表达式的文法分为3种标准：\n\n- BRE\n- ERE\n- ARE\n\n\n\n## 正则表达式的基础语法\n\n正则表达式是由普通字符（如字符A到字符Z）和特殊字符（称为元字符）组成。该模式描述在查找文字主题时要匹配的一个或多个字符串。正则表达式作为一个模板，将一个字符模式与搜索的字符串相匹配。如：\n\n| JScript          | VBScript         | 匹配                                                         |\n| ---------------- | ---------------- | ------------------------------------------------------------ |\n| /^[ \\t]*$/*      | \"^[ \\t]$\"        | 匹配一个空白行。                                             |\n| /\\d{2}-\\d{5}/    | \"\\d{2}-\\d{5}\"    | 验证一个ID 号码是否由一个2位数字，一个连字符以及一个5位数字组成。 |\n| /<(.*)>.*<\\/\\1>/ | \"<(.*)>.*<\\/\\1>\" | 匹配一个 HTML 标记。                                         |\n\n\n下表是元字符及其在正则表达式上下文中的行为的一个完整列表：\n\n| 字符          | 描述                                                         |\n| ------------- | ------------------------------------------------------------ |\n| \\             | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 \"n\"。'\\n' 匹配一个换行符。序列 '\\' 匹配 \"\\\" 而 \"(\" 则匹配 \"(\"。 |\n| ^             | 匹配输入字符串的开始位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 |\n| $             | 匹配输入字符串的结束位置。如果设置了**RegExp** 对象的 **Multiline** 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 |\n| *             | 匹配前面的子表达式零次或多次。例如，zo 能匹配 \"z\" 以及 \"zoo\"。 *等价于{0,}。* |\n| +             | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 |\n| ?             | 匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 中的\"do\" 。? 等价于 {0,1}。 |\n| {*n*}         | *n* 是一个非负整数。匹配确定的 *n* 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。 |\n| {*n*,}        | *n* 是一个非负整数。至少匹配*n* 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o'。 |\n| {*n*,*m*}     | *m* 和 *n* 均为非负整数，其中*n* <= *m*。最少匹配 *n* 次且最多匹配 *m* 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |\n| ?             | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {\\*n*}, {\\*n*,}, {\\*n*,\\*m*}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。* |\n| .             | 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' 的模式。 |\n| (*pattern*)   | 匹配 *pattern* 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 **SubMatches** 集合，在JScript 中则使用 **$0**…**$9** 属性。要匹配圆括号字符，请使用 '(' 或 ')'。 |\n| (?:*pattern*) | 匹配 *pattern* 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (\\|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\\|ies) 就是一个比 'industry\\|industries' 更简略的表达式。 |\n| (?=*pattern*) | 正向预查，在任何匹配 *pattern* 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95\\|98\\|NT\\|2000)' 能匹配 \"Windows 2000\" 中的 \"Windows\" ，但不能匹配 \"Windows 3.1\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |\n| (?!*pattern*) | 负向预查，在任何不匹配 *pattern* 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95\\|98\\|NT\\|2000)' 能匹配 \"Windows 3.1\" 中的 \"Windows\"，但不能匹配 \"Windows 2000\" 中的 \"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |\n| *x*\\|*y*      | 匹配 *x* 或 *y*。例如，'z\\|food' 能匹配 \"z\" 或 \"food\"。'(z\\|f)ood' 则匹配 \"zood\" 或 \"food\"。 |\n| [*xyz*]       | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 \"plain\" 中的 'a'。 |\n| [^*xyz*]      | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 \"plain\" 中的'p'。 |\n| [*a-z*]       | 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 |\n| [^*a-z*]      | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 |\n| \\b            | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。 |\n| \\B            | 匹配非单词边界。'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。 |\n| \\c*x*         | 匹配由 *x* 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。*x* 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |\n| \\d            | 匹配一个数字字符。等价于 [0-9]。                             |\n| \\D            | 匹配一个非数字字符。等价于 [^0-9]。                          |\n| \\f            | 匹配一个换页符。等价于 \\x0c 和 \\cL。                         |\n| \\n            | 匹配一个换行符。等价于 \\x0a 和 \\cJ。                         |\n| \\r            | 匹配一个回车符。等价于 \\x0d 和 \\cM。                         |\n| \\s            | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 |\n| \\S            | 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。                  |\n| \\t            | 匹配一个制表符。等价于 \\x09 和 \\cI。                         |\n| \\v            | 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。                     |\n| \\w            | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9*]'。*        |\n| \\W            | 匹配任何非单词字符。等价于 '[^A-Za-z0-9]'。                  |\n| \\x*n*         | 匹配 *n*，其中 *n* 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\\x41' 匹配 \"A\"。'\\x041' 则等价于 '\\x04' & \"1\"。正则表达式中可以使用 ASCII 编码。. |\n| \\*num*        | 匹配 *num*，其中 *num* 是一个正整数。对所获取的匹配的引用。例如，'(.)\\1' 匹配两个连续的相同字符。 |\n| \\*n*          | 标识一个八进制转义值或一个向后引用。如果 \\*n* 之前至少 *n* 个获取的子表达式，则 *n* 为向后引用。否则，如果 *n* 为八进制数字 (0-7)，则 *n* 为一个八进制转义值。 |\n| \\*nm*         | 标识一个八进制转义值或一个向后引用。如果 \\*nm* 之前至少有 *nm* 个获得子表达式，则 *nm* 为向后引用。如果 \\*nm* 之前至少有 *n* 个获取，则 *n* 为一个后跟文字 *m* 的向后引用。如果前面的条件都不满足，若*n* 和 *m* 均为八进制数字 (0-7)，则 \\*nm* 将匹配八进制转义值 *nm*。 |\n| \\*nml*        | 如果 *n* 为八进制数字 (0-3)，且 *m* 和 *l* 均为八进制数字 (0-7)，则匹配八进制转义值 *nml。* |\n| \\u*n*         | 匹配 *n*，其中 *n* 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (©)。 |\n\n\n\n\n下面看几个例子：\n\n```\n\"^The\"：表示所有以\"The\"开始的字符串（\"There\"，\"The cat\"等）； \n\"of despair$\"：表示所以以\"of despair\"结尾的字符串； \n\"^abc$\"：表示开始和结尾都是\"abc\"的字符串——呵呵，只有\"abc\"自己了； \n\"notice\"：表示任何包含\"notice\"的字符串。 \n```\n\n\n''，'+'和'?'这三个符号，表示一个或一序列字符重复出现的次数。它们分别表示“没有或更多”，“一次或更多”还有“没有或一次”。下面是几个例子：\n\n```\n\"ab\"：表示一个字符串有一个a后面跟着零个或若干个b。（\"a\", \"ab\", \"abbb\",……）； \n\"ab+\"：表示一个字符串有一个a后面跟着至少一个b或者更多； \n\"ab?\"：表示一个字符串有一个a后面跟着零个或者一个b； \n\"a?b+$\"：表示在字符串的末尾有零个或一个a跟着一个或几个b。\n也可以使用范围，用大括号括起，用以表示重复次数的范围。\n\"ab{2}\"：表示一个字符串有一个a跟着2个b（\"abb\"）； \n\"ab{2,}\"：表示一个字符串有一个a跟着至少2个b； \n\"ab{3,5}\"：表示一个字符串有一个a跟着3到5个b。\n请注意，你必须指定范围的下限（如：\"{0,2}\"而不是\"{,2}\"）。还有，你可能注意到了，''，'+'和'?'相当于\"{0,}\"，\"{1,}\"和\"{0,1}\"。 \n```\n\n\n还有一个'¦'，表示“或”操作：\n\n```\n\"hi¦hello\"：表示一个字符串里有\"hi\"或者\"hello\"； \n\"(b¦cd)ef\"：表示\"bef\"或\"cdef\"； \n\"(a¦b)c\"：表示一串\"a\"\"b\"混合的字符串后面跟一个\"c\"；\n```\n\n'.'可以替代任何字符：\n\n```\n\"a.[0-9]\"：表示一个字符串有一个\"a\"后面跟着一个任意字符和一个数字； \n\"^.{3}$\"：表示有任意三个字符的字符串（长度为3个字符）；\n方括号表示某些字符允许在一个字符串中的某一特定位置出现：\n\"[ab]\"：表示一个字符串有一个\"a\"或\"b\"（相当于\"a¦b\"）； \n\"[a-d]\"：表示一个字符串包含小写的'a'到'd'中的一个（相当于\"a¦b¦c¦d\"或者\"[abcd]\"）； \n\"^[a-zA-Z]\"：表示一个以字母开头的字符串； \n\"[0-9]%\"：表示一个百分号前有一位的数字； \n\",[a-zA-Z0-9]$\"：表示一个字符串以一个逗号后面跟着一个字母或数字结束。\n```\n\n\n\n你也可以在方括号里用'^'表示不希望出现的字符，'^'应在方括号里的第一位。（如：\"%[^a-zA-Z]%\"表示两个百分号中不应该出现字母）。\n\n为了逐字表达，必须在\"^.$()¦+?{\\\"这些字符前加上转义字符'\\'。\n\n请注意在方括号中，不需要转义字符。\n\n\n\n## 校验数字的表达式\n\n```\n数字：^[0-9]*$\nn位的数字：^\\d{n}$\n至少n位的数字：^\\d{n,}$\nm-n位的数字：^\\d{m,n}$\n零和非零开头的数字：^(0|[1-9][0-9]*)$\n非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$\n带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$\n正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$\n有两位小数的正实数：^[0-9]+(.[0-9]{2})?$\n有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$\n非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$\n非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$\n非负整数：^\\d+$ 或 ^[1-9]\\d*|0$\n非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$\n非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$\n非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$\n正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$\n负浮点数：\n^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ \n或 \n^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$\n浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$\n```\n\n\n\n## 校验字符的表达式\n\n```\n汉字：^[\\u4e00-\\u9fa5]{0,}$\n英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$\n长度为3-20的所有字符：^.{3,20}$\n由26个英文字母组成的字符串：^[A-Za-z]+$\n由26个大写英文字母组成的字符串：^[A-Z]+$\n由26个小写英文字母组成的字符串：^[a-z]+$\n由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$\n由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$\n中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$\n中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$\n可以输入含有^%&',;=?$\\\"等字符：[^%&',;=?$\\x22]+\n禁止输入含有~的字符：[^~\\x22]+\n```\n\n\n\n## 特殊需求表达式\n\n```\nEmail地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?\nInternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$\n手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\\d{8}$ (由于工信部放号段不定时，所以建议使用泛解析[1][3,4,5,6,7,8,9])\\d{9}$)\n电话号码(\"XXX-XXXXXXX\"、\"XXXX-XXXXXXXX\"、\"XXX-XXXXXXX\"、\"XXX-XXXXXXXX\"、\"XXXXXXX\"和\"XXXXXXXX)：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ \n国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} \n18位身份证号码(数字、字母x结尾)：^((\\d{18})|([0-9x]{18})|([0-9X]{18}))$\n帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$\n密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$\n强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$  \n日期格式：^\\d{4}-\\d{1,2}-\\d{1,2}\n一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$\n一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ \n钱的输入格式：\n   1.有四种钱的表示形式我们可以接受:\"10000.00\" 和 \"10,000.00\", 和没有 \"分\" 的 \"10000\" 和 \"10,000\"：^[1-9][0-9]*$ \n   2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符\"0\"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ \n   3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ \n   4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ \n   5.必须说明的是,小数点后面至少应该有1位数,所以\"10.\"是不通过的,但是 \"10\" 和 \"10.2\" 是通过的：^[0-9]+(.[0-9]{2})?$ \n   6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ \n   7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ \n   8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ \n   备注：这就是最终结果了,别忘了\"+\"可以用\"*\"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里\nxml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$\n中文字符的正则表达式：[\\u4e00-\\u9fa5]\n双字节字符：[^\\x00-\\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))\n空白行的正则表达式：\\n\\s*\\r    (可以用来删除空白行)\nHTML标记的正则表达式：<(\\S*?)[^>]*>.*?</\\1>|<.*? />    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)\n首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)\n腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)\n中国邮政编码：[1-9]\\d{5}(?!\\d)    (中国邮政编码为6位数字)\nIP地址：\\d+\\.\\d+\\.\\d+\\.\\d+    (提取IP地址时有用)\nIP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))\n```\n\n## 参考文献\n\n[w3cschool正则表达式](https://www.w3cschool.cn/regexp/tfua1pq5.html)\n\n\n\n","slug":"技术分享/正则表达式大全","published":1,"_id":"ckiyez6i4003etvcddryw5knn","layout":"post","photos":[],"link":"","content":"<h2 id=\"什么是正则表达式\"><a href=\"#什么是正则表达式\" class=\"headerlink\" title=\"什么是正则表达式\"></a>什么是正则表达式</h2><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://atts.w3cschool.cn/attachments/day_160822/201608221705481933.jpg\" alt=\"什么是正则表达式\"></p>\n<p>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：</p>\n<ol>\n<li>给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）；</li>\n<li>可以通过正则表达式，从字符串中获取我们想要的特定部分。</li>\n</ol>\n<h2 id=\"正则表达式的特点\"><a href=\"#正则表达式的特点\" class=\"headerlink\" title=\"正则表达式的特点\"></a>正则表达式的特点</h2><ol>\n<li>灵活性、逻辑性和功能性非常的强；</li>\n<li>可以迅速地用极简单的方式达到字符串的复杂控制。</li>\n<li>对于刚接触的人来说，比较晦涩难懂。</li>\n</ol>\n<p>由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。</p>\n<h2 id=\"正则表达式的标准\"><a href=\"#正则表达式的标准\" class=\"headerlink\" title=\"正则表达式的标准\"></a>正则表达式的标准</h2><p>大体来讲，正则表达式的文法分为3种标准：</p>\n<ul>\n<li>BRE</li>\n<li>ERE</li>\n<li>ARE</li>\n</ul>\n<h2 id=\"正则表达式的基础语法\"><a href=\"#正则表达式的基础语法\" class=\"headerlink\" title=\"正则表达式的基础语法\"></a>正则表达式的基础语法</h2><p>正则表达式是由普通字符（如字符A到字符Z）和特殊字符（称为元字符）组成。该模式描述在查找文字主题时要匹配的一个或多个字符串。正则表达式作为一个模板，将一个字符模式与搜索的字符串相匹配。如：</p>\n<table>\n<thead>\n<tr>\n<th>JScript</th>\n<th>VBScript</th>\n<th>匹配</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>/^[ \\t]<em>$/</em></td>\n<td>“^[ \\t]$”</td>\n<td>匹配一个空白行。</td>\n</tr>\n<tr>\n<td>/\\d{2}-\\d{5}/</td>\n<td>“\\d{2}-\\d{5}”</td>\n<td>验证一个ID 号码是否由一个2位数字，一个连字符以及一个5位数字组成。</td>\n</tr>\n<tr>\n<td>/&lt;(.<em>)&gt;.</em>&lt;/\\1&gt;/</td>\n<td>“&lt;(.<em>)&gt;.</em>&lt;/\\1&gt;”</td>\n<td>匹配一个 HTML 标记。</td>\n</tr>\n</tbody></table>\n<p>下表是元字符及其在正则表达式上下文中的行为的一个完整列表：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\</td>\n<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘&#39; 匹配 “&quot; 而 “(“ 则匹配 “(“。</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入字符串的开始位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配输入字符串的结束位置。如果设置了<strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 <em>等价于{0,}。</em></td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td>\n</tr>\n<tr>\n<td>{<em>n</em>}</td>\n<td><em>n</em> 是一个非负整数。匹配确定的 <em>n</em> 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>{<em>n</em>,}</td>\n<td><em>n</em> 是一个非负整数。至少匹配<em>n</em> 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o’。</td>\n</tr>\n<tr>\n<td>{<em>n</em>,<em>m</em>}</td>\n<td><em>m</em> 和 <em>n</em> 均为非负整数，其中<em>n</em> &lt;= <em>m</em>。最少匹配 <em>n</em> 次且最多匹配 <em>m</em> 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>当该字符紧跟在任何一个其他限制符 (<em>, +, ?, {*n</em>}, {*n<em>,}, {*n</em>,*m<em>}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</em></td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。</td>\n</tr>\n<tr>\n<td>(<em>pattern</em>)</td>\n<td>匹配 <em>pattern</em> 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 <strong>SubMatches</strong> 集合，在JScript 中则使用 <strong>$0</strong>…<strong>$9</strong> 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)’。</td>\n</tr>\n<tr>\n<td>(?:<em>pattern</em>)</td>\n<td>匹配 <em>pattern</em> 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td>\n</tr>\n<tr>\n<td>(?=<em>pattern</em>)</td>\n<td>正向预查，在任何匹配 <em>pattern</em> 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>\n</tr>\n<tr>\n<td>(?!<em>pattern</em>)</td>\n<td>负向预查，在任何不匹配 <em>pattern</em> 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>\n</tr>\n<tr>\n<td><em>x</em>|<em>y</em></td>\n<td>匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td>\n</tr>\n<tr>\n<td>[<em>xyz</em>]</td>\n<td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>\n</tr>\n<tr>\n<td>[^<em>xyz</em>]</td>\n<td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td>\n</tr>\n<tr>\n<td>[<em>a-z</em>]</td>\n<td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td>\n</tr>\n<tr>\n<td>[^<em>a-z</em>]</td>\n<td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>\n</tr>\n<tr>\n<td>\\c<em>x</em></td>\n<td>匹配由 <em>x</em> 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。<em>x</em> 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字字符。等价于 [0-9]。</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配一个非数字字符。等价于 [^0-9]。</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>匹配一个换页符。等价于 \\x0c 和 \\cL。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符。等价于 \\x0a 和 \\cJ。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符。等价于 \\x0d 和 \\cM。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个制表符。等价于 \\x09 和 \\cI。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符。等价于 \\x0b 和 \\cK。</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9<em>]’。</em></td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配任何非单词字符。等价于 ‘[^A-Za-z0-9]’。</td>\n</tr>\n<tr>\n<td>\\x<em>n</em></td>\n<td>匹配 <em>n</em>，其中 <em>n</em> 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。.</td>\n</tr>\n<tr>\n<td>*num*</td>\n<td>匹配 <em>num*，其中 *num</em> 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。</td>\n</tr>\n<tr>\n<td>*n*</td>\n<td>标识一个八进制转义值或一个向后引用。如果 *n* 之前至少 <em>n</em> 个获取的子表达式，则 <em>n</em> 为向后引用。否则，如果 <em>n</em> 为八进制数字 (0-7)，则 <em>n</em> 为一个八进制转义值。</td>\n</tr>\n<tr>\n<td>*nm*</td>\n<td>标识一个八进制转义值或一个向后引用。如果 *nm* 之前至少有 <em>nm</em> 个获得子表达式，则 <em>nm</em> 为向后引用。如果 *nm* 之前至少有 <em>n</em> 个获取，则 <em>n</em> 为一个后跟文字 <em>m</em> 的向后引用。如果前面的条件都不满足，若<em>n</em> 和 <em>m</em> 均为八进制数字 (0-7)，则 *nm* 将匹配八进制转义值 <em>nm</em>。</td>\n</tr>\n<tr>\n<td>*nml*</td>\n<td>如果 <em>n</em> 为八进制数字 (0-3)，且 <em>m</em> 和 <em>l</em> 均为八进制数字 (0-7)，则匹配八进制转义值 <em>nml。</em></td>\n</tr>\n<tr>\n<td>\\u<em>n</em></td>\n<td>匹配 <em>n</em>，其中 <em>n</em> 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (©)。</td>\n</tr>\n</tbody></table>\n<p>下面看几个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&quot;^The&quot;：表示所有以&quot;The&quot;开始的字符串（&quot;There&quot;，&quot;The cat&quot;等）； <br>&quot;of despair$&quot;：表示所以以&quot;of despair&quot;结尾的字符串； <br>&quot;^abc$&quot;：表示开始和结尾都是&quot;abc&quot;的字符串——呵呵，只有&quot;abc&quot;自己了； <br>&quot;notice&quot;：表示任何包含&quot;notice&quot;的字符串。 <br></code></pre></td></tr></table></figure>\n\n<p>‘’，’+’和’?’这三个符号，表示一个或一序列字符重复出现的次数。它们分别表示“没有或更多”，“一次或更多”还有“没有或一次”。下面是几个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&quot;ab&quot;：表示一个字符串有一个a后面跟着零个或若干个b。（&quot;a&quot;, &quot;ab&quot;, &quot;abbb&quot;,……）； <br>&quot;ab+&quot;：表示一个字符串有一个a后面跟着至少一个b或者更多； <br>&quot;ab?&quot;：表示一个字符串有一个a后面跟着零个或者一个b； <br>&quot;a?b+$&quot;：表示在字符串的末尾有零个或一个a跟着一个或几个b。<br>也可以使用范围，用大括号括起，用以表示重复次数的范围。<br>&quot;ab&#123;2&#125;&quot;：表示一个字符串有一个a跟着2个b（&quot;abb&quot;）； <br>&quot;ab&#123;2,&#125;&quot;：表示一个字符串有一个a跟着至少2个b； <br>&quot;ab&#123;3,5&#125;&quot;：表示一个字符串有一个a跟着3到5个b。<br>请注意，你必须指定范围的下限（如：&quot;&#123;0,2&#125;&quot;而不是&quot;&#123;,2&#125;&quot;）。还有，你可能注意到了，&#39;&#39;，&#39;+&#39;和&#39;?&#39;相当于&quot;&#123;0,&#125;&quot;，&quot;&#123;1,&#125;&quot;和&quot;&#123;0,1&#125;&quot;。 <br></code></pre></td></tr></table></figure>\n\n<p>还有一个’¦’，表示“或”操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&quot;hi¦hello&quot;：表示一个字符串里有&quot;hi&quot;或者&quot;hello&quot;； <br>&quot;(b¦cd)ef&quot;：表示&quot;bef&quot;或&quot;cdef&quot;； <br>&quot;(a¦b)c&quot;：表示一串&quot;a&quot;&quot;b&quot;混合的字符串后面跟一个&quot;c&quot;；<br></code></pre></td></tr></table></figure>\n<p>‘.’可以替代任何字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&quot;a.[0-9]&quot;：表示一个字符串有一个&quot;a&quot;后面跟着一个任意字符和一个数字； <br>&quot;^.&#123;3&#125;$&quot;：表示有任意三个字符的字符串（长度为3个字符）；<br>方括号表示某些字符允许在一个字符串中的某一特定位置出现：<br>&quot;[ab]&quot;：表示一个字符串有一个&quot;a&quot;或&quot;b&quot;（相当于&quot;a¦b&quot;）； <br>&quot;[a-d]&quot;：表示一个字符串包含小写的&#39;a&#39;到&#39;d&#39;中的一个（相当于&quot;a¦b¦c¦d&quot;或者&quot;[abcd]&quot;）； <br>&quot;^[a-zA-Z]&quot;：表示一个以字母开头的字符串； <br>&quot;[0-9]%&quot;：表示一个百分号前有一位的数字； <br>&quot;,[a-zA-Z0-9]$&quot;：表示一个字符串以一个逗号后面跟着一个字母或数字结束。<br></code></pre></td></tr></table></figure>\n\n\n<p>你也可以在方括号里用’^’表示不希望出现的字符，’^’应在方括号里的第一位。（如：”%[^a-zA-Z]%”表示两个百分号中不应该出现字母）。</p>\n<p>为了逐字表达，必须在”^.$()¦+?{&quot;这些字符前加上转义字符’&#39;。</p>\n<p>请注意在方括号中，不需要转义字符。</p>\n<h2 id=\"校验数字的表达式\"><a href=\"#校验数字的表达式\" class=\"headerlink\" title=\"校验数字的表达式\"></a>校验数字的表达式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">数字：^[0-9]*$<br>n位的数字：^\\d&#123;n&#125;$<br>至少n位的数字：^\\d&#123;n,&#125;$<br>m-n位的数字：^\\d&#123;m,n&#125;$<br>零和非零开头的数字：^(0|[1-9][0-9]*)$<br>非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$<br>带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$<br>正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$<br>有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$<br>有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$<br>非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$<br>非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$<br>非负整数：^\\d+$ 或 ^[1-9]\\d*|0$<br>非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$<br>非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$<br>非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$<br>正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$<br>负浮点数：<br>^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ <br>或 <br>^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$<br>浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"校验字符的表达式\"><a href=\"#校验字符的表达式\" class=\"headerlink\" title=\"校验字符的表达式\"></a>校验字符的表达式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$<br>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$<br>长度为3-20的所有字符：^.&#123;3,20&#125;$<br>由26个英文字母组成的字符串：^[A-Za-z]+$<br>由26个大写英文字母组成的字符串：^[A-Z]+$<br>由26个小写英文字母组成的字符串：^[a-z]+$<br>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$<br>由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$<br>中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$<br>中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$<br>可以输入含有^%&amp;&#39;,;&#x3D;?$\\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\\x22]+<br>禁止输入含有~的字符：[^~\\x22]+<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"特殊需求表达式\"><a href=\"#特殊需求表达式\" class=\"headerlink\" title=\"特殊需求表达式\"></a>特殊需求表达式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$<br>域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?<br>InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\\s]* 或 ^http:&#x2F;&#x2F;([\\w-]+\\.)+[\\w-]+(&#x2F;[\\w-.&#x2F;?%&amp;&#x3D;]*)?$<br>手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\\d&#123;8&#125;$ (由于工信部放号段不定时，所以建议使用泛解析[1][3,4,5,6,7,8,9])\\d&#123;9&#125;$)<br>电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ <br>国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; <br>18位身份证号码(数字、字母x结尾)：^((\\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$<br>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$<br>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$<br>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$  <br>日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;<br>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$<br>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ <br>钱的输入格式：<br>   1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ <br>   2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ <br>   3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ <br>   4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ <br>   5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ <br>   6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ <br>   7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ <br>   8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ <br>   备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里<br>xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$<br>中文字符的正则表达式：[\\u4e00-\\u9fa5]<br>双字节字符：[^\\x00-\\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))<br>空白行的正则表达式：\\n\\s*\\r    (可以用来删除空白行)<br>HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;&#x2F;\\1&gt;|&lt;.*? &#x2F;&gt;    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)<br>首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)<br>腾讯QQ号：[1-9][0-9]&#123;4,&#125;    (腾讯QQ号从10000开始)<br>中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d)    (中国邮政编码为6位数字)<br>IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+    (提取IP地址时有用)<br>IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))<br></code></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.w3cschool.cn/regexp/tfua1pq5.html\">w3cschool正则表达式</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"什么是正则表达式\"><a href=\"#什么是正则表达式\" class=\"headerlink\" title=\"什么是正则表达式\"></a>什么是正则表达式</h2><p>正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>\n<p><img src=\"https://atts.w3cschool.cn/attachments/day_160822/201608221705481933.jpg\" alt=\"什么是正则表达式\"></p>\n<p>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：</p>\n<ol>\n<li>给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）；</li>\n<li>可以通过正则表达式，从字符串中获取我们想要的特定部分。</li>\n</ol>\n<h2 id=\"正则表达式的特点\"><a href=\"#正则表达式的特点\" class=\"headerlink\" title=\"正则表达式的特点\"></a>正则表达式的特点</h2><ol>\n<li>灵活性、逻辑性和功能性非常的强；</li>\n<li>可以迅速地用极简单的方式达到字符串的复杂控制。</li>\n<li>对于刚接触的人来说，比较晦涩难懂。</li>\n</ol>\n<p>由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。</p>\n<h2 id=\"正则表达式的标准\"><a href=\"#正则表达式的标准\" class=\"headerlink\" title=\"正则表达式的标准\"></a>正则表达式的标准</h2><p>大体来讲，正则表达式的文法分为3种标准：</p>\n<ul>\n<li>BRE</li>\n<li>ERE</li>\n<li>ARE</li>\n</ul>\n<h2 id=\"正则表达式的基础语法\"><a href=\"#正则表达式的基础语法\" class=\"headerlink\" title=\"正则表达式的基础语法\"></a>正则表达式的基础语法</h2><p>正则表达式是由普通字符（如字符A到字符Z）和特殊字符（称为元字符）组成。该模式描述在查找文字主题时要匹配的一个或多个字符串。正则表达式作为一个模板，将一个字符模式与搜索的字符串相匹配。如：</p>\n<table>\n<thead>\n<tr>\n<th>JScript</th>\n<th>VBScript</th>\n<th>匹配</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>/^[ \\t]<em>$/</em></td>\n<td>“^[ \\t]$”</td>\n<td>匹配一个空白行。</td>\n</tr>\n<tr>\n<td>/\\d{2}-\\d{5}/</td>\n<td>“\\d{2}-\\d{5}”</td>\n<td>验证一个ID 号码是否由一个2位数字，一个连字符以及一个5位数字组成。</td>\n</tr>\n<tr>\n<td>/&lt;(.<em>)&gt;.</em>&lt;/\\1&gt;/</td>\n<td>“&lt;(.<em>)&gt;.</em>&lt;/\\1&gt;”</td>\n<td>匹配一个 HTML 标记。</td>\n</tr>\n</tbody></table>\n<p>下表是元字符及其在正则表达式上下文中的行为的一个完整列表：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\</td>\n<td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘&#39; 匹配 “&quot; 而 “(“ 则匹配 “(“。</td>\n</tr>\n<tr>\n<td>^</td>\n<td>匹配输入字符串的开始位置。如果设置了 <strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。</td>\n</tr>\n<tr>\n<td>$</td>\n<td>匹配输入字符串的结束位置。如果设置了<strong>RegExp</strong> 对象的 <strong>Multiline</strong> 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 <em>等价于{0,}。</em></td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td>\n</tr>\n<tr>\n<td>{<em>n</em>}</td>\n<td><em>n</em> 是一个非负整数。匹配确定的 <em>n</em> 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>{<em>n</em>,}</td>\n<td><em>n</em> 是一个非负整数。至少匹配<em>n</em> 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o’。</td>\n</tr>\n<tr>\n<td>{<em>n</em>,<em>m</em>}</td>\n<td><em>m</em> 和 <em>n</em> 均为非负整数，其中<em>n</em> &lt;= <em>m</em>。最少匹配 <em>n</em> 次且最多匹配 <em>m</em> 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>\n</tr>\n<tr>\n<td>?</td>\n<td>当该字符紧跟在任何一个其他限制符 (<em>, +, ?, {*n</em>}, {*n<em>,}, {*n</em>,*m<em>}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</em></td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。</td>\n</tr>\n<tr>\n<td>(<em>pattern</em>)</td>\n<td>匹配 <em>pattern</em> 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 <strong>SubMatches</strong> 集合，在JScript 中则使用 <strong>$0</strong>…<strong>$9</strong> 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)’。</td>\n</tr>\n<tr>\n<td>(?:<em>pattern</em>)</td>\n<td>匹配 <em>pattern</em> 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td>\n</tr>\n<tr>\n<td>(?=<em>pattern</em>)</td>\n<td>正向预查，在任何匹配 <em>pattern</em> 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>\n</tr>\n<tr>\n<td>(?!<em>pattern</em>)</td>\n<td>负向预查，在任何不匹配 <em>pattern</em> 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>\n</tr>\n<tr>\n<td><em>x</em>|<em>y</em></td>\n<td>匹配 <em>x</em> 或 <em>y</em>。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td>\n</tr>\n<tr>\n<td>[<em>xyz</em>]</td>\n<td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td>\n</tr>\n<tr>\n<td>[^<em>xyz</em>]</td>\n<td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td>\n</tr>\n<tr>\n<td>[<em>a-z</em>]</td>\n<td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td>\n</tr>\n<tr>\n<td>[^<em>a-z</em>]</td>\n<td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>\n</tr>\n<tr>\n<td>\\B</td>\n<td>匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>\n</tr>\n<tr>\n<td>\\c<em>x</em></td>\n<td>匹配由 <em>x</em> 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。<em>x</em> 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>匹配一个数字字符。等价于 [0-9]。</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>匹配一个非数字字符。等价于 [^0-9]。</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>匹配一个换页符。等价于 \\x0c 和 \\cL。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>匹配一个换行符。等价于 \\x0a 和 \\cJ。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>匹配一个回车符。等价于 \\x0d 和 \\cM。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>匹配一个制表符。等价于 \\x09 和 \\cI。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>匹配一个垂直制表符。等价于 \\x0b 和 \\cK。</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9<em>]’。</em></td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>匹配任何非单词字符。等价于 ‘[^A-Za-z0-9]’。</td>\n</tr>\n<tr>\n<td>\\x<em>n</em></td>\n<td>匹配 <em>n</em>，其中 <em>n</em> 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。.</td>\n</tr>\n<tr>\n<td>*num*</td>\n<td>匹配 <em>num*，其中 *num</em> 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。</td>\n</tr>\n<tr>\n<td>*n*</td>\n<td>标识一个八进制转义值或一个向后引用。如果 *n* 之前至少 <em>n</em> 个获取的子表达式，则 <em>n</em> 为向后引用。否则，如果 <em>n</em> 为八进制数字 (0-7)，则 <em>n</em> 为一个八进制转义值。</td>\n</tr>\n<tr>\n<td>*nm*</td>\n<td>标识一个八进制转义值或一个向后引用。如果 *nm* 之前至少有 <em>nm</em> 个获得子表达式，则 <em>nm</em> 为向后引用。如果 *nm* 之前至少有 <em>n</em> 个获取，则 <em>n</em> 为一个后跟文字 <em>m</em> 的向后引用。如果前面的条件都不满足，若<em>n</em> 和 <em>m</em> 均为八进制数字 (0-7)，则 *nm* 将匹配八进制转义值 <em>nm</em>。</td>\n</tr>\n<tr>\n<td>*nml*</td>\n<td>如果 <em>n</em> 为八进制数字 (0-3)，且 <em>m</em> 和 <em>l</em> 均为八进制数字 (0-7)，则匹配八进制转义值 <em>nml。</em></td>\n</tr>\n<tr>\n<td>\\u<em>n</em></td>\n<td>匹配 <em>n</em>，其中 <em>n</em> 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (©)。</td>\n</tr>\n</tbody></table>\n<p>下面看几个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&quot;^The&quot;：表示所有以&quot;The&quot;开始的字符串（&quot;There&quot;，&quot;The cat&quot;等）； <br>&quot;of despair$&quot;：表示所以以&quot;of despair&quot;结尾的字符串； <br>&quot;^abc$&quot;：表示开始和结尾都是&quot;abc&quot;的字符串——呵呵，只有&quot;abc&quot;自己了； <br>&quot;notice&quot;：表示任何包含&quot;notice&quot;的字符串。 <br></code></pre></td></tr></table></figure>\n\n<p>‘’，’+’和’?’这三个符号，表示一个或一序列字符重复出现的次数。它们分别表示“没有或更多”，“一次或更多”还有“没有或一次”。下面是几个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&quot;ab&quot;：表示一个字符串有一个a后面跟着零个或若干个b。（&quot;a&quot;, &quot;ab&quot;, &quot;abbb&quot;,……）； <br>&quot;ab+&quot;：表示一个字符串有一个a后面跟着至少一个b或者更多； <br>&quot;ab?&quot;：表示一个字符串有一个a后面跟着零个或者一个b； <br>&quot;a?b+$&quot;：表示在字符串的末尾有零个或一个a跟着一个或几个b。<br>也可以使用范围，用大括号括起，用以表示重复次数的范围。<br>&quot;ab&#123;2&#125;&quot;：表示一个字符串有一个a跟着2个b（&quot;abb&quot;）； <br>&quot;ab&#123;2,&#125;&quot;：表示一个字符串有一个a跟着至少2个b； <br>&quot;ab&#123;3,5&#125;&quot;：表示一个字符串有一个a跟着3到5个b。<br>请注意，你必须指定范围的下限（如：&quot;&#123;0,2&#125;&quot;而不是&quot;&#123;,2&#125;&quot;）。还有，你可能注意到了，&#39;&#39;，&#39;+&#39;和&#39;?&#39;相当于&quot;&#123;0,&#125;&quot;，&quot;&#123;1,&#125;&quot;和&quot;&#123;0,1&#125;&quot;。 <br></code></pre></td></tr></table></figure>\n\n<p>还有一个’¦’，表示“或”操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&quot;hi¦hello&quot;：表示一个字符串里有&quot;hi&quot;或者&quot;hello&quot;； <br>&quot;(b¦cd)ef&quot;：表示&quot;bef&quot;或&quot;cdef&quot;； <br>&quot;(a¦b)c&quot;：表示一串&quot;a&quot;&quot;b&quot;混合的字符串后面跟一个&quot;c&quot;；<br></code></pre></td></tr></table></figure>\n<p>‘.’可以替代任何字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&quot;a.[0-9]&quot;：表示一个字符串有一个&quot;a&quot;后面跟着一个任意字符和一个数字； <br>&quot;^.&#123;3&#125;$&quot;：表示有任意三个字符的字符串（长度为3个字符）；<br>方括号表示某些字符允许在一个字符串中的某一特定位置出现：<br>&quot;[ab]&quot;：表示一个字符串有一个&quot;a&quot;或&quot;b&quot;（相当于&quot;a¦b&quot;）； <br>&quot;[a-d]&quot;：表示一个字符串包含小写的&#39;a&#39;到&#39;d&#39;中的一个（相当于&quot;a¦b¦c¦d&quot;或者&quot;[abcd]&quot;）； <br>&quot;^[a-zA-Z]&quot;：表示一个以字母开头的字符串； <br>&quot;[0-9]%&quot;：表示一个百分号前有一位的数字； <br>&quot;,[a-zA-Z0-9]$&quot;：表示一个字符串以一个逗号后面跟着一个字母或数字结束。<br></code></pre></td></tr></table></figure>\n\n\n<p>你也可以在方括号里用’^’表示不希望出现的字符，’^’应在方括号里的第一位。（如：”%[^a-zA-Z]%”表示两个百分号中不应该出现字母）。</p>\n<p>为了逐字表达，必须在”^.$()¦+?{&quot;这些字符前加上转义字符’&#39;。</p>\n<p>请注意在方括号中，不需要转义字符。</p>\n<h2 id=\"校验数字的表达式\"><a href=\"#校验数字的表达式\" class=\"headerlink\" title=\"校验数字的表达式\"></a>校验数字的表达式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">数字：^[0-9]*$<br>n位的数字：^\\d&#123;n&#125;$<br>至少n位的数字：^\\d&#123;n,&#125;$<br>m-n位的数字：^\\d&#123;m,n&#125;$<br>零和非零开头的数字：^(0|[1-9][0-9]*)$<br>非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$<br>带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$<br>正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$<br>有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$<br>有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$<br>非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$<br>非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$<br>非负整数：^\\d+$ 或 ^[1-9]\\d*|0$<br>非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$<br>非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$<br>非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$<br>正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$<br>负浮点数：<br>^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ <br>或 <br>^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$<br>浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"校验字符的表达式\"><a href=\"#校验字符的表达式\" class=\"headerlink\" title=\"校验字符的表达式\"></a>校验字符的表达式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$<br>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$<br>长度为3-20的所有字符：^.&#123;3,20&#125;$<br>由26个英文字母组成的字符串：^[A-Za-z]+$<br>由26个大写英文字母组成的字符串：^[A-Z]+$<br>由26个小写英文字母组成的字符串：^[a-z]+$<br>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$<br>由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$<br>中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$<br>中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$<br>可以输入含有^%&amp;&#39;,;&#x3D;?$\\&quot;等字符：[^%&amp;&#39;,;&#x3D;?$\\x22]+<br>禁止输入含有~的字符：[^~\\x22]+<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"特殊需求表达式\"><a href=\"#特殊需求表达式\" class=\"headerlink\" title=\"特殊需求表达式\"></a>特殊需求表达式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$<br>域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?<br>InternetURL：[a-zA-z]+:&#x2F;&#x2F;[^\\s]* 或 ^http:&#x2F;&#x2F;([\\w-]+\\.)+[\\w-]+(&#x2F;[\\w-.&#x2F;?%&amp;&#x3D;]*)?$<br>手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\\d&#123;8&#125;$ (由于工信部放号段不定时，所以建议使用泛解析[1][3,4,5,6,7,8,9])\\d&#123;9&#125;$)<br>电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ <br>国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; <br>18位身份证号码(数字、字母x结尾)：^((\\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$<br>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$<br>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$<br>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?&#x3D;.*\\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$  <br>日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;<br>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$<br>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ <br>钱的输入格式：<br>   1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ <br>   2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ <br>   3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ <br>   4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ <br>   5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ <br>   6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ <br>   7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ <br>   8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ <br>   备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里<br>xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$<br>中文字符的正则表达式：[\\u4e00-\\u9fa5]<br>双字节字符：[^\\x00-\\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))<br>空白行的正则表达式：\\n\\s*\\r    (可以用来删除空白行)<br>HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;&#x2F;\\1&gt;|&lt;.*? &#x2F;&gt;    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)<br>首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)<br>腾讯QQ号：[1-9][0-9]&#123;4,&#125;    (腾讯QQ号从10000开始)<br>中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d)    (中国邮政编码为6位数字)<br>IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+    (提取IP地址时有用)<br>IP地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))<br></code></pre></td></tr></table></figure>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.w3cschool.cn/regexp/tfua1pq5.html\">w3cschool正则表达式</a></p>\n"},{"title":"Hexo搭建博客：NexT主题配置","keywords":["hexo","next主题","next theme"],"cover":"https://cdn.tanxz.com/images/category/hexo.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","description":"在这篇文章中，你将学习到如何搭建Hexo博客以及如何使用NexT主题美化博客","abbrlink":3878378062,"_content":"\n# 1. 前言\n\n前文：[Windows下通过GitHub+Hexo搭建个人博客的步骤](https://blog.csdn.net/weixin_39345384/article/details/80095883)；\n博主的个人博客：https://hunter1023.github.io/ 按照本篇博客美化。\n\n在 Hexo 中有**2份**主要的配置文件，其名称都是`_config.yml`。 其中，一份位于**博客根目录下**，主要包含 **Hexo 本身的配置**；另一份位于`themes/next/`目录下，用于配置**主题相关的选项**。\n\n------\n\n# 2. 基础设置\n\n## 2.1 设置站点名、作者昵称和站点描述等内容\n\n打开**根目录下的`_config.yml`**\n\n```\n# Site\ntitle: 特叔服务\nsubtitle: \nkeywords:\nauthor: Hunter\ndescription: Tough times never last, but tough people do.\n```\n\n------\n\n## 2.2. NexT主题的安装\n\n顾名思义，所谓主题就是界面的展示样式。Hexo安装主题，只需要将主题文件拷贝至博客所在目录的`themes`目录下，修改相关配置文件即可生效。\n\n博客所在目录下打开`git bash`，再通过`Git clone https://github.com/theme-next/hexo-theme-next themes/next`即可完成。\n\n------\n\n## 2.3 启用主题\n\n打开**根目录下的`_config.yml`**,查找`theme`字段，将字段改为`theme: next`(**冒号`:`之后要有空格分隔，否则无效**) ，之后通过`hexo g`和`hexo s`，再在浏览器中访问`localhost:4000`即可本地预览主题效果。\n\n------\n\n# 3. 主题设定\n\n## 3.1 选择scheme\n\n打开`themes/next/`下的`_config.yml`,查找`scheme`，可以看到如下四种不同的风格方案：\n\n```\nscheme: Muse\n#scheme: Mist\n#scheme: Pisces\n#scheme: Gemini\n```\n\n去掉`#`注释，即启用对应的scheme，博主采用Muse主题，大家可以依次测试效果，选择自己喜欢的scheme。\n\n------\n\n## 3.2 设置语言\n\n博客框架默认的语言是英文，前往`/themes/next/languages`，查看当前NexT版本简体中文对照文件的名称是`zh-Hans`还是`zh-CN`。\n\n再前往根目录下的`_config.yml`，查找`language`，设置成`language: zh-Hans`或`language: zh-CN`，即显示简体中文。\n\n------\n\n## 3.3 设置菜单及对应页面\n\n- 打开`themes/next/`下的`_config.yml`，查找`menu`\n\n  ```\n  menu:\n    home: / || home\n    #about: /about/ || user\n    tags: /tags/ || tags\n    categories: /categories/ || th\n    archives: /archives/ || archive\n    #schedule: /schedule/ || calendar\n    #sitemap: /sitemap.xml || sitemap\n    #commonweal: /404/ || heartbeat\n  ```\n\n  去掉`#`注释即可显示对应的菜单项，也可自定义新的菜单项。 `||`之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。\n\n- 新添加的菜单需要翻译对应的中文\n  打开`hexo/theme/next/languages/zh-CN.yml`，在menu下自定义，如：\n\n  ```\n  menu:\n    resources: 资源\n  ```\n\n- `hexo new page \"categories\"`\n  此时在根目录的`source`文件夹下会生成一个categories文件，文件中有一个`index.md`文件，修改内容如下\n\n  ```\n  ---\n  title: 分类\n  date: 2017-12-14 13:05:38\n  type: \"categories\"\n  comments: false\n  ---\n  ```\n\n  注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。\n\n------\n\n## 3.4 设定站点建立时间\n\n打开**`themes/next/`下的`_config.yml`**，查找`since`\n\n```\nfooter:\n  # Specify the date when the site was setup.\n  # If not defined, current year will be used.\n  #since: 2015\n```\n\n**如果不设置，默认显示当前年份**。\n\n------\n\n# 4. 美化\n\n## 4.1 设置头像\n\n打开`themes/next/`下的`_config.yml`，查找`avatar`\n\n```\n# Sidebar Avatar\n# in theme directory(source/images): /images/avatar.gif\n# in site  directory(source/uploads): /uploads/avatar.gif\navatar: http://XXXXXXXXX\n```\n\n`avatar`的值是**图片的链接地址**(完整的URI 或者 站内的相对地址皆可)\n\n| 地址       | 值                                                           |\n| ---------- | ------------------------------------------------------------ |\n| 完整的URI  | http://example.com/avatar.png                                |\n| 站点内地址 | 图片放至`themes/next/source/images/`配置为：`avatar: /images/图片名` |\n| 站点内地址 | 图片放至**根目录下**`source/uploads/`(初始无uploads文件夹，自行创建)目录下配置为：`avatar: /uploads/图片名` |\n\n**之后创建博文，对图片的引用 同样可以按照上述地址获取**。\n\n------\n\n## 4.2 网站图标设置\n\n- 图标素材网站：[iconfont](https://www.iconfont.cn/)；[easyicon](https://www.easyicon.net/)\n\n- 下载16x16以及32x32大小的**PNG格式图标**，置于`/themes/next/source/images/`下\n\n- 打开**\n\n  ```\n  themes/next/\n  ```\n\n  下的\n\n  ```\n  _config.yml\n  ```\n\n  **，查找\n\n  ```\n  favicon\n  ```\n\n  ```\n  favicon:\n    small: /images/favicon-16x16-next.png\n    medium: /images/favicon-32x32-next.png\n    apple_touch_icon: /images/apple-touch-icon-next.png\n    safari_pinned_tab: /images/logo.svg\n    #android_manifest: /images/manifest.json\n    #ms_browserconfig: /images/browserconfig.xml\n  ```\n\n  修改small和medium的路径为下载的图标路径\n\n------\n\n## 4.3 背景动画\n\n### 4.3.1 [Canvas-nest风格](https://blog.csdn.net/weixin_39345384/article/details/80544660)\n\n### 4.3.2 JavaScript 3D library风格\n\n1. 进入theme/next目录\n2. 执行命令：`git clone https://github.com/theme-next/theme-next-three source/lib/three`\n3. 将`themes/next/_config.yml`中查找`theme-next-three`，将想要的效果改为true即可：\n\n```\n# three_waves\nthree_waves: false\n# canvas_lines\ncanvas_lines: true\n# canvas_sphere\ncanvas_sphere: false\n```\n\n------\n\n## 4.4 背景图片/顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色\n\n打开`theme/next/source/css/_custom/custom.styl`，添加以下代码\n\n```\n//背景图片\nbody{   \n        background:url(图片链接);\n        background-size:cover;\n        background-repeat:no-repeat;\n        background-attachment:fixed;\n        background-position:center;\n}\n//顶栏图片\n.header {\n          background:url(图片链接) none repeat scroll !important;\n}\n//底栏背景色\n.footer {\n          background:rgba(颜色rgb,透明度) none repeat scroll !important;\n}\n//侧栏图片及内部文字颜色修改\n#sidebar {\n            background:url(图片链接);\n            background-size: cover;\n            background-position:center;\n            background-repeat:no-repeat;\n            p,span,a {color: 颜色代码;}\n}\n```\n\n其中的css样式属性都可以根据图片修改，以达到满意的效果。\n\n------\n\n## 4.5 侧栏置于左侧，修改控制按钮样式\n\n默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。打开`themes/next/`下的`_config.yml`，查找`sidebar`\n\n### 4.5.1 设置侧栏在左侧/右侧\n\n- Pisces或Gemini方案\n\n  ```\n  sidebar:\n  position: left\n  #position: right\n  ```\n\n- Mist或Muse方案\n\n1. 打开`next/source/js/src/motion.js`，查找`paddingRight`，把所有（2个）`PaddingRight`更改为`paddingLeft`即可。\n\n2. 打开\n\n   ```\n   next/source/css/_custom/custom.styl\n   ```\n\n   ，添加如下内容：\n\n   ```\n   //侧边栏置于左侧\n   .sidebar {\n     left: 0;\n   }\n   //侧栏开关置于左侧\n   .sidebar-toggle {\n     left: $b2t-position-right;\n   }\n   ```\n\n3. 打开`next/source/css/_common/components/back-to-top.styl`，将`right: $b2t-position-right;`改为`left: $b2t-position-right;`\n\n### 4.5.2 显示侧边栏的时机\n\n```\n\t#post - 默认行为，在文章页面（拥有目录列表）时显示\n\t#always - 在所有页面中都显示\n\t#hide - 在所有页面中都隐藏（可以手动展开）\n\t#remove - 完全移除\n\tdisplay: post\n\t#display: always\n\t#display: hide\n\t#display: remove\n```\n\n------\n\n### 4.5.3 侧边栏控制按钮样式修改\n\n打开`themes/next/layout/source/js/src/motion.js`，找到如下代码处，更换close的内容\n\n```\nvar sidebarToggleLine1st = new SidebarToggleLine({\n    el: '.sidebar-toggle-line-first',\n    status: {\n      arrow: {width: '50%', rotateZ: '45deg', top: '2px', left: '6px'},\n      // close: {width: '100%', rotateZ: '-45deg', top: '5px', left: '0px'} //X形\n      close: {width: '50%', rotateZ: '-45deg', top: '2px', left: '0px'} //箭头形\n    }\n  });\n  var sidebarToggleLine2nd = new SidebarToggleLine({\n    el: '.sidebar-toggle-line-middle',\n    status: {\n      arrow: {width: '90%'},\n      // close: {opacity: 0} //X形\n      close: {width: '90%'} //箭头形\n    }\n  });\n  var sidebarToggleLine3rd = new SidebarToggleLine({\n    el: '.sidebar-toggle-line-last',\n    status: {\n      arrow: {width: '50%', rotateZ: '-45deg', top: '-2px', left: '6px'},\n      // close: {width: '100%', rotateZ: '45deg', top: '-5px', left: '0px'} //X形\n      close: {width: '50%', rotateZ: '45deg', top: '-2px', left: '0px'} //箭头形\n    }\n  });\n```\n\n------\n\n## 4.6 文章底部标签显示的优化\n\n修改`/themes/next/layout/_macro/post.swig`，搜索 `rel=\"tag\">#`，将 `#` 换成 `<i class=\"fa fa-tag\"></i>`\n\n## 4.7 文章添加阴影、透明效果\n\n打开`theme/next/source/css/_custom/custom.styl`，添加以下代码\n\n```\n// 主页文章添加阴影效果\n.post {\n   margin-top: 60px;\n   margin-bottom: 60px;\n   padding: 25px;\n   background:rgba(255,255,255,0.9) none repeat scroll !important;\n   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);\n   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);\n}\n```\n\n------\n\n## 4.8 Hexo添加文章时自动打开编辑器\n\n- 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。\n  如果没有这个scripts目录，则新建一个。\n- scripts目录新建的JavaScript脚本文件可以任意取名。\n\n通过这个脚本，我们用其来监听`hexo new`这个动作，并在检测到`hexo new`之后，执行编辑器打开的命令。\n\n- 如果你是windows平台的Hexo用户，则将下列内容写入你的脚本：\n\n```\nvar spawn = require('child_process').exec;\nhexo.on('new', function(data){\n  spawn('start  \"markdown编辑器绝对路径.exe\" ' + data.path);\n});\n```\n\n如果你是Mac平台Hexo用户，则将下列内容写入你的脚本：\n\n```\nvar exec = require('child_process').exec;\nhexo.on('new', function(data){\n    exec('open -a \"markdown编辑器绝对路径.app\" ' + data.path);\n});\n```\n\n------\n\n## 4.9 点击侧栏头像回到首页\n\n修改`/themes/next/layout/_macro/sidebar.swig`，找到如下代码：\n\n```\n<img class=\"site-author-image\" itemprop=\"image\"\n    src=\"{{ url_for( theme.avatar | default(theme.images + '/avatar.gif') ) }}\"\n    alt=\"{{ theme.author }}\" />\n```\n\n在其前后加上`<a href=\"/\"></a>`即可，如下：\n\n```\n<a href=\"/\">\n   <img class=\"site-author-image\" itemprop=\"image\"\n       src=\"{{ url_for( theme.avatar | default(theme.images + '/avatar.gif') ) }}\"\n       alt=\"{{ theme.author }}\" />\n</a>\n```\n\n------\n\n## 4.10 修改中文字体\n\n1. 前往[Google Fonts](https://fonts.google.com/)查看合适的字体\n\n2. 打开\n\n   ```\n   themes/next/\n   ```\n\n   下的\n\n   ```\n   _config.yml\n   ```\n\n   ，查找\n\n   ```\n   font\n   ```\n\n   ```\n   font:\n   \tenable: true\n   \t # Uri of fonts host. E.g. //fonts.googleapis.com (Default). 修改为墙内镜像\n   \thost: https://fonts.loli.net\n   \tglobal:\n   \t\texternal: true\n   \t\tfamily: Noto Serif SC // 挑选的字体\n   \t\tsize: 16\n   ```\n\n   1. 修改`/themes/next/source/css/_variables/base.styl`\n      将\n\n   ```\n   $font-family-monospace    = consolas, Menlo, $font-family-chinese, monospace\n   $font-family-monospace    = get_font_family('codes'), consolas, Menlo, $font-family-chinese, monospace if get_font_family('codes')\n   ```\n\n   改为\n\n   ```\n   $font-family-monospace    = consolas, Menlo, $font-family-base, monospace\n   $font-family-monospace    = get_font_family('codes'), consolas, Menlo, $font-family-base, monospace if get_font_family('codes')\n   ```\n\n------\n\n## 4.11 新建文章时，在相同目录下创建同名文件夹（便于图片管理）\n\n- 打开站点配置文件`_config.yml`，搜索`post_asset_folder`字段，设置其值为`true`\n- 安装hexo-asset-image：`npm install hexo-asset-image --save`\n- 此时`hexo new \"fileName\"`会在`/source/_posts`目录下创建同名的文件夹\n- 只需在 md 文件里使用 `![title](图片名.jpg)` ，无需路径名就可以插入图片。\n\n------\n\n## 4.12 首页显示文章摘要（阅读全文）及配图（文章内不重复显示）\n\n1. 打开\n\n   ```\n   themes/next/\n   ```\n\n   下的\n\n   ```\n   _config.yml\n   ```\n\n   ，查找\n\n   ```\n   excerpt\n   ```\n\n   ```\n   auto_excerpt: //自动摘录\n     enable: true\n     length: 150 //摘录字数\n   read_more_btn: true //显示全文按钮\n   ```\n\n2. 打开\n\n   ```\n   themes\\next\\layout\\_macro\\post.swig\n   ```\n\n   ，在\n\n   ```\n   {% if is_index %}\n   ```\n\n   和\n\n   ```\n   {% if post.description and theme.excerpt_description %}\n   ```\n\n   之间添加如下内容\n\n   ```\n   {% if post.images %}\n   \t<div class=\"out-img-topic\">\n   \t\t<img src={{ post.images }} class=\"img-topic\">\n   \t</div>\n   {% endif %}\n   ```\n\n3. 向\n\n   ```\n   themes\\next\\source\\css\\_custom\\custom.styl\n   ```\n\n   中添加如下内容\n\n   ```\n   //文章摘要配图\n   //图片外部的容器方框，限制图片大小\n   .out-img-topic {\n     display: block;\n     max-height:500px;\n     margin-bottom: 24px;\n     overflow: hidden;\n   }\n   //图片\n   img.img-topic {\n     display: block ;\n     margin-left: .7em;\n     margin-right: .7em;\n     padding: 0;\n     float: right;\n     clear: right;\n   }\n   ```\n\n4. 将摘要图片储存于\n\n   ```\n   themes\\next\\source\\images\n   ```\n\n   中，建议\n\n   在此路径下\n\n   单独建一个文件夹存放摘要图片，\n\n   这个图片和文章中插图的存放路径不同，不是一个概念\n\n   。然后在文章YAML头信息中添加images字段，将值填为\n\n   ```\n   /images/imagename.jpg\n   ```\n\n   。\n\n   ```\n   images: \"images/文章摘要配图/Win10桌面.png\"\n   ```\n\n------\n\n## 4.13 给页面、侧边栏添加背景图片\n\n打开`theme/next/source/css/_custom/custom.styl`，添加以下代码：\n\n```\nbody {\n  background: url(/images/blogbk.jpg) no-repeat;\n  /* 背景图垂直、水平均居中 */\n  background-position: center center;\n  /* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */\n  background-attachment: fixed;\n  /* 让背景图基于容器大小伸缩 */\n  background-size: cover;\n  /* 设置背景颜色，背景图加载过程中会显示背景色 */\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.sidebar {\n            background:url(/images/sidebar.jpg);\n            background-size: cover;\n            background-position:center;\n            background-repeat:no-repeat;\n            p,span,a {color: rgba(255, 255, 255, 1);}\n}\n```\n\n------\n\n## 4.14 文字背景以及半透明的设置\n\n打开`theme/next/source/css/_custom/custom.styl`，添加以下代码：\n\n```\n.content {\n\tborder-radius: 20px; //文章背景设置圆角\n\tpadding: 30px 60px 30px 60px;\n\tbackground:rgba(255, 255, 255, 0.8) none repeat scroll !important;\n}\n```\n\n------\n\n## 4.15 去除NexT主题Markdown分割线渲染效果\n\n修改`/source/css/_common/scaffolding/base.styl`，注释或删除以下内容：\n\n```\nbackground-image: repeating-linear-gradient(\n    -45deg,\n    white,\n    white 4px,\n    transparent 4px,\n    transparent 8px\n  );\n1234567\n```\n\n------\n\n## 4.16 图片可点击放大查看，放大后可关闭\n\n- 打开站点配置文件`_config.yml`，搜索`fancybox`字段，设置其值为`true`\n- 进入到`theme/text/`文件夹下，打开`git bash`\n- `git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox`\n\n------\n\n## 4.17 博客总访问量统计\n\n- 打开\n\n  ```\n  themes/next/\n  ```\n\n  下的\n\n  ```\n  _config.yml\n  ```\n\n  ，查找\n\n  ```\n  busuanzi\n  ```\n\n  ```\n  busuanzi_count:\n    enable: true\n    total_visitors: false\n    total_visitors_icon: user\n    total_views: false\n    total_views_icon: eye\n    post_views: true\n    post_views_icon: eye\n  ```\n\n当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动\n\n- 打开\n\n  ```\n  /themes/next/layout/_partials/footer.swig\n  ```\n\n  ，在最后添加如下内容：\n\n  ```\n  <span id=\"busuanzi_container_site_uv\">\n    本站访问次数：<span class=\"busuanzi-value\" id=\"busuanzi_value_site_pv\"></span>\n  </span>\n  ```\n\n## 4.18 文章末尾添加版权声明\n\n**效果：**\n![这里写图片描述](https://img-blog.csdn.net/2018062323493260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTM0NTM4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n**配置：**\n查找主题配置文件`themes/next/_config.yml`中的`creative_commons`\n\n```\ncreative_commons:\n  license: by-nc-sa\n  sidebar: false\n  post: true  # 将false改为true即可显示版权信息\n  language:\n```\n\n------\n\n## 4.19 本地搜索（其余搜索方案的劣势只有收费）\n\n- `npm install hexo-generator-search`\n\n- 查找主题配置文件\n\n  ```\n  themes/next/_config.yml\n  ```\n\n  中的\n\n  ```\n  local_search\n  ```\n\n  ```\n  local_search:\n    enable: true\n  ```\n\n------\n\n## 4.20 图床和上传工具\n\n[盘点一下免费好用的图床](https://zhuanlan.zhihu.com/p/35270383)\n\n## 4.21 文章置顶\n\n[Hexo博客彻底解决置顶问题](http://wangwlj.com/2018/01/09/blog_pin_post/)\n效果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190329140445995.png)\n注：若有多篇文章需要置顶，排序方式为 在需要置顶的文章的`Front-matter`的`top:`填写阿拉伯数字即可，数越大，排序越靠前。\n\n## 4.22 添加粒子时钟\n\n博客应用canvas粒子时钟的操作步骤：\n\n在`\\themes\\next\\layout\\_custom\\`目录下，新建`clock.swig`文件，内容如下：\n\n```\n<div style=\"\">\n  <canvas id=\"canvas\" style=\"width:60%;\">当前浏览器不支持canvas，请更换浏览器后再试</canvas>\n</div>\n<script>\n(function(){\n\n   var digit=\n    [\n        [\n            [0,0,1,1,1,0,0],\n            [0,1,1,0,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,0,1,1,0],\n            [0,0,1,1,1,0,0]\n        ],//0\n        [\n            [0,0,0,1,1,0,0],\n            [0,1,1,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [1,1,1,1,1,1,1]\n        ],//1\n        [\n            [0,1,1,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,0,0],\n            [0,0,1,1,0,0,0],\n            [0,1,1,0,0,0,0],\n            [1,1,0,0,0,0,0],\n            [1,1,0,0,0,1,1],\n            [1,1,1,1,1,1,1]\n        ],//2\n        [\n            [1,1,1,1,1,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,0,0,1,1,0],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0]\n        ],//3\n        [\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,1,0],\n            [0,0,1,1,1,1,0],\n            [0,1,1,0,1,1,0],\n            [1,1,0,0,1,1,0],\n            [1,1,1,1,1,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,0,1,1,0],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,1,1]\n        ],//4\n        [\n            [1,1,1,1,1,1,1],\n            [1,1,0,0,0,0,0],\n            [1,1,0,0,0,0,0],\n            [1,1,1,1,1,1,0],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0]\n        ],//5\n        [\n            [0,0,0,0,1,1,0],\n            [0,0,1,1,0,0,0],\n            [0,1,1,0,0,0,0],\n            [1,1,0,0,0,0,0],\n            [1,1,0,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0]\n        ],//6\n        [\n            [1,1,1,1,1,1,1],\n            [1,1,0,0,0,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,1,1,0,0,0],\n            [0,0,1,1,0,0,0],\n            [0,0,1,1,0,0,0],\n            [0,0,1,1,0,0,0]\n        ],//7\n        [\n            [0,1,1,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0]\n        ],//8\n        [\n            [0,1,1,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,0,0],\n            [0,1,1,0,0,0,0]\n        ],//9\n        [\n            [0,0,0,0,0,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,0,0,0,0,0],\n            [0,0,0,0,0,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,0,0,0,0,0]\n        ]//:\n    ];\n\nvar canvas = document.getElementById('canvas');\n\nif(canvas.getContext){\n    var cxt = canvas.getContext('2d');\n    //声明canvas的宽高\n    var H = 100,W = 700;\n    canvas.height = H;\n    canvas.width = W;\n    cxt.fillStyle = '#f00';\n    cxt.fillRect(10,10,50,50);\n\n    //存储时间数据\n    var data = [];\n    //存储运动的小球\n    var balls = [];\n    //设置粒子半径\n    var R = canvas.height/20-1;\n    (function(){\n        var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date());\n        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成\n        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);\n    })();\n\n    /*生成点阵数字*/\n    function renderDigit(index,num){\n        for(var i = 0; i < digit[num].length; i++){\n            for(var j = 0; j < digit[num][i].length; j++){\n                if(digit[num][i][j] == 1){\n                    cxt.beginPath();\n                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);\n                    cxt.closePath();\n                    cxt.fill();\n                }\n            }\n        }\n    }\n\n    /*更新时钟*/\n    function updateDigitTime(){\n        var changeNumArray = [];\n        var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date());\n        var NewData = [];\n        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);\n        for(var i = data.length-1; i >=0 ; i--){\n            //时间发生变化\n            if(NewData[i] !== data[i]){\n                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中\n                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);\n            }\n        }\n        //增加小球\n        for(var i = 0; i< changeNumArray.length; i++){\n            addBalls.apply(this,changeNumArray[i].split('_'));\n        }\n        data = NewData.concat();\n    }\n\n    /*更新小球状态*/\n    function updateBalls(){\n        for(var i = 0; i < balls.length; i++){\n            balls[i].stepY += balls[i].disY;\n            balls[i].x += balls[i].stepX;\n            balls[i].y += balls[i].stepY;\n            if(balls[i].x > W + R || balls[i].y > H + R){\n                balls.splice(i,1);\n                i--;\n            }\n        }\n    }\n\n    /*增加要运动的小球*/\n    function addBalls(index,num){\n        var numArray = [1,2,3];\n        var colorArray =  [\"#3BE\",\"#09C\",\"#A6C\",\"#93C\",\"#9C0\",\"#690\",\"#FB3\",\"#F80\",\"#F44\",\"#C00\"];\n        for(var i = 0; i < digit[num].length; i++){\n            for(var j = 0; j < digit[num][i].length; j++){\n                if(digit[num][i][j] == 1){\n                    var ball = {\n                        x:14*(R+2)*index + j*2*(R+1)+(R+1),\n                        y:i*2*(R+1)+(R+1),\n                        stepX:Math.floor(Math.random() * 4 -2),\n                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],\n                        color:colorArray[Math.floor(Math.random()*colorArray.length)],\n                        disY:1\n                    };\n                    balls.push(ball);\n                }\n            }\n        }\n    }\n\n    /*渲染*/\n    function render(){\n        //重置画布宽度，达到清空画布的效果\n        canvas.height = 100;\n        //渲染时钟\n        for(var i = 0; i < data.length; i++){\n            renderDigit(i,data[i]);\n        }\n        //渲染小球\n        for(var i = 0; i < balls.length; i++){\n            cxt.beginPath();\n            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);\n            cxt.fillStyle = balls[i].color;\n            cxt.closePath();\n            cxt.fill();\n        }\n    }\n\n    clearInterval(oTimer);\n    var oTimer = setInterval(function(){\n        //更新时钟\n        updateDigitTime();\n        //更新小球状态\n        updateBalls();\n        //渲染\n        render();\n    },50);\n}\n\n})();\n</script>\n```\n\n- 引用代码\n\n直接引用或者通过配置文件配置，二选一\n\n- 直接引用\n\n在`博客目录\\themes\\next\\layout\\_macro\\sidebar.swig`尾部中引入：\n\n```\n{% include '../_custom/clock.swig' %}\n```\n\n示意图如下：\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9jay5wbmc?x-oss-process=image/format,png)\n\n> 注：代码块要放置在`sider-inner`的`div`块中，放在`div`块的位置决定时钟样式的展示位置。我选择放置在尾部，看着效果好点。\n\n- 通过配置文件配置\n\n1、在`博客目录\\themes\\next\\layout\\_macro\\sidebar.swig`尾部中引入：\n\n```\n        {% if theme.diy_time.clock %}\n          <!-- canvas粒子时钟 -->\n          {% include '../_custom/clock.swig' %}\n        {% endif %}\n```\n\n示意图如下：\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9ja19pZi5wbmc?x-oss-process=image/format,png)\n\n> 注：代码块要放置在`sider-inner`的`div`块中，放在`div`块的位置决定时钟样式的展示位置。\n\n2、在主题的配置文件中加入应用代码，配置文件位置是`博客目录\\themes\\next\\_config.yml`：\n\n```\n# 侧栏粒子时钟\ndiy_time:\n  runtime: true \n  clock: true # 粒子时钟\n```\n\n## 4.23 添加近期文章\n\n添加配置参数 **~/theme/next/_config.yml** ，添加如下配置：\n\n```\nrecent_posts:\n  enable: true\n  recent_posts_title: 最新发表文章\n```\n\n首先我们找到侧边栏模块 **next/layout/_macro/sidebar.swig** ,这个负责渲染侧边栏\n在我们想要放置**最新文章模块**的地方添加如下代码：\n\n```\n{% if theme.recent_posts.enable %}\n  <aside class=\"sidebar sidebar-ads sidebar-posts\">\n    <div>\n      <div class=\"recent_posts_title\">\n        {{ theme.recent_posts.recent_posts_title }}\n      </div>\n      <ul class=\"links-of-blogroll-list\">\n        {% set posts = site.posts.sort('-date') %}\n        {% set bg_colors = ['rgb(31, 216, 210)', 'rgb(4, 166, 247)', 'rgb(70, 101, 226)', 'rgb(94, 137, 229)', 'rgb(0, 206, 123)'] %}\n        {% for post in posts.slice('0', '5') %}\n          <li>\n            <div class=\"text-img\" style=\"background:{{bg_colors[loop.index - 1]}};\">{{ post.title.substr(0, 3) }}</div>\n            <div class=\"post-name\">\n              <div>{{ date(post.date, config.date_format) }}</div>\n              <div><a href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" >{{ post.title }}</a></div>\n            </div>\n          </li>\n        {% endfor %}\n      </ul>\n    </div>\n  </aside>\n  {% endif %}\n```\n\n最后重新执行\n\n```\nhexo clean\nhexo g\n```\n\n\n\n最后我们得到的效果是\n\n## Google统计\n\n## Sitemap网站地图\n\n## 提交谷歌收录本站 Google Search\n\n\n\n## [文章阅读量统计](https://blog.csdn.net/weixin_39345384/article/details/80787998)\n\n------\n\n------\n\n参考：\n\n- [HEXO+NEXT主题个性化配置](http://mashirosorata.vicp.io/HEXO-NEXT主题个性化配置.html)\n- [打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化](https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html)\n- [[EasyHexo 专栏\\] #2 - 魔改 Next 不完全教程](https://juejin.im/post/5c45a503f265da616b10fe4e#heading-28)\n- [基于Hexo+Node.js+github+coding搭建个人博客——进阶篇(从入门到入土)](https://blog.csdn.net/MasterAnt_D/article/details/56839222#t50)\n- [Hexo博客Next主题优化总结](http://www.shaoyance.com/2018/01/26/Hexo博客Next主题优化总结/)\n- [为NexT主题添加文章阅读量统计功能](https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html)\n- [2017年最新基于hexo搭建个人免费博客——自定义页面样式一](http://www.cduyzh.com/hexo-settings-3/)\n- [Hexo添加文章时自动打开编辑器](https://notes.doublemine.me/2015-06-29-Hexo添加文章时自动打开编辑器.html)\n- [next主题下点击侧边栏头像回到博客首页](https://blog.yleao.com/2018/0901/hexo-next主题下的美化.html#next主题下点击侧边栏头像回到博客首页)\n- [Google Fonts 已支持思源宋体！](https://reuixiy.github.io/beautiful/share/2018/12/11/noto-serif-sc-added-on-google-fonts.html)\n- [弃暗投明-Hexo更换next主题](https://www.bluelzy.com/articles/change_to_next_theme.html)\n- [hexo博客NEXT主题美化](https://www.feiwuuz.com.cn/archives/5483aa06.html)\n- [在hexo博客中插入图片，音乐，视频](http://chant00.com/2015/11/04/在hexo博客中插入图片，音乐，视屏，公式/)","source":"_posts/博客教程/hexo/NexT主题自定义配置.md","raw":"---\ntitle: Hexo搭建博客：NexT主题配置\ncategories: \n  - 博客教程\ntags:\n  - Hexo\n  - NexT\nkeywords:\n  - hexo\n  - next主题\n  - next theme\ncover: https://cdn.tanxz.com/images/category/hexo.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ndescription: 在这篇文章中，你将学习到如何搭建Hexo博客以及如何使用NexT主题美化博客\nabbrlink: 3878378062\n---\n\n# 1. 前言\n\n前文：[Windows下通过GitHub+Hexo搭建个人博客的步骤](https://blog.csdn.net/weixin_39345384/article/details/80095883)；\n博主的个人博客：https://hunter1023.github.io/ 按照本篇博客美化。\n\n在 Hexo 中有**2份**主要的配置文件，其名称都是`_config.yml`。 其中，一份位于**博客根目录下**，主要包含 **Hexo 本身的配置**；另一份位于`themes/next/`目录下，用于配置**主题相关的选项**。\n\n------\n\n# 2. 基础设置\n\n## 2.1 设置站点名、作者昵称和站点描述等内容\n\n打开**根目录下的`_config.yml`**\n\n```\n# Site\ntitle: 特叔服务\nsubtitle: \nkeywords:\nauthor: Hunter\ndescription: Tough times never last, but tough people do.\n```\n\n------\n\n## 2.2. NexT主题的安装\n\n顾名思义，所谓主题就是界面的展示样式。Hexo安装主题，只需要将主题文件拷贝至博客所在目录的`themes`目录下，修改相关配置文件即可生效。\n\n博客所在目录下打开`git bash`，再通过`Git clone https://github.com/theme-next/hexo-theme-next themes/next`即可完成。\n\n------\n\n## 2.3 启用主题\n\n打开**根目录下的`_config.yml`**,查找`theme`字段，将字段改为`theme: next`(**冒号`:`之后要有空格分隔，否则无效**) ，之后通过`hexo g`和`hexo s`，再在浏览器中访问`localhost:4000`即可本地预览主题效果。\n\n------\n\n# 3. 主题设定\n\n## 3.1 选择scheme\n\n打开`themes/next/`下的`_config.yml`,查找`scheme`，可以看到如下四种不同的风格方案：\n\n```\nscheme: Muse\n#scheme: Mist\n#scheme: Pisces\n#scheme: Gemini\n```\n\n去掉`#`注释，即启用对应的scheme，博主采用Muse主题，大家可以依次测试效果，选择自己喜欢的scheme。\n\n------\n\n## 3.2 设置语言\n\n博客框架默认的语言是英文，前往`/themes/next/languages`，查看当前NexT版本简体中文对照文件的名称是`zh-Hans`还是`zh-CN`。\n\n再前往根目录下的`_config.yml`，查找`language`，设置成`language: zh-Hans`或`language: zh-CN`，即显示简体中文。\n\n------\n\n## 3.3 设置菜单及对应页面\n\n- 打开`themes/next/`下的`_config.yml`，查找`menu`\n\n  ```\n  menu:\n    home: / || home\n    #about: /about/ || user\n    tags: /tags/ || tags\n    categories: /categories/ || th\n    archives: /archives/ || archive\n    #schedule: /schedule/ || calendar\n    #sitemap: /sitemap.xml || sitemap\n    #commonweal: /404/ || heartbeat\n  ```\n\n  去掉`#`注释即可显示对应的菜单项，也可自定义新的菜单项。 `||`之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。\n\n- 新添加的菜单需要翻译对应的中文\n  打开`hexo/theme/next/languages/zh-CN.yml`，在menu下自定义，如：\n\n  ```\n  menu:\n    resources: 资源\n  ```\n\n- `hexo new page \"categories\"`\n  此时在根目录的`source`文件夹下会生成一个categories文件，文件中有一个`index.md`文件，修改内容如下\n\n  ```\n  ---\n  title: 分类\n  date: 2017-12-14 13:05:38\n  type: \"categories\"\n  comments: false\n  ---\n  ```\n\n  注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。\n\n------\n\n## 3.4 设定站点建立时间\n\n打开**`themes/next/`下的`_config.yml`**，查找`since`\n\n```\nfooter:\n  # Specify the date when the site was setup.\n  # If not defined, current year will be used.\n  #since: 2015\n```\n\n**如果不设置，默认显示当前年份**。\n\n------\n\n# 4. 美化\n\n## 4.1 设置头像\n\n打开`themes/next/`下的`_config.yml`，查找`avatar`\n\n```\n# Sidebar Avatar\n# in theme directory(source/images): /images/avatar.gif\n# in site  directory(source/uploads): /uploads/avatar.gif\navatar: http://XXXXXXXXX\n```\n\n`avatar`的值是**图片的链接地址**(完整的URI 或者 站内的相对地址皆可)\n\n| 地址       | 值                                                           |\n| ---------- | ------------------------------------------------------------ |\n| 完整的URI  | http://example.com/avatar.png                                |\n| 站点内地址 | 图片放至`themes/next/source/images/`配置为：`avatar: /images/图片名` |\n| 站点内地址 | 图片放至**根目录下**`source/uploads/`(初始无uploads文件夹，自行创建)目录下配置为：`avatar: /uploads/图片名` |\n\n**之后创建博文，对图片的引用 同样可以按照上述地址获取**。\n\n------\n\n## 4.2 网站图标设置\n\n- 图标素材网站：[iconfont](https://www.iconfont.cn/)；[easyicon](https://www.easyicon.net/)\n\n- 下载16x16以及32x32大小的**PNG格式图标**，置于`/themes/next/source/images/`下\n\n- 打开**\n\n  ```\n  themes/next/\n  ```\n\n  下的\n\n  ```\n  _config.yml\n  ```\n\n  **，查找\n\n  ```\n  favicon\n  ```\n\n  ```\n  favicon:\n    small: /images/favicon-16x16-next.png\n    medium: /images/favicon-32x32-next.png\n    apple_touch_icon: /images/apple-touch-icon-next.png\n    safari_pinned_tab: /images/logo.svg\n    #android_manifest: /images/manifest.json\n    #ms_browserconfig: /images/browserconfig.xml\n  ```\n\n  修改small和medium的路径为下载的图标路径\n\n------\n\n## 4.3 背景动画\n\n### 4.3.1 [Canvas-nest风格](https://blog.csdn.net/weixin_39345384/article/details/80544660)\n\n### 4.3.2 JavaScript 3D library风格\n\n1. 进入theme/next目录\n2. 执行命令：`git clone https://github.com/theme-next/theme-next-three source/lib/three`\n3. 将`themes/next/_config.yml`中查找`theme-next-three`，将想要的效果改为true即可：\n\n```\n# three_waves\nthree_waves: false\n# canvas_lines\ncanvas_lines: true\n# canvas_sphere\ncanvas_sphere: false\n```\n\n------\n\n## 4.4 背景图片/顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色\n\n打开`theme/next/source/css/_custom/custom.styl`，添加以下代码\n\n```\n//背景图片\nbody{   \n        background:url(图片链接);\n        background-size:cover;\n        background-repeat:no-repeat;\n        background-attachment:fixed;\n        background-position:center;\n}\n//顶栏图片\n.header {\n          background:url(图片链接) none repeat scroll !important;\n}\n//底栏背景色\n.footer {\n          background:rgba(颜色rgb,透明度) none repeat scroll !important;\n}\n//侧栏图片及内部文字颜色修改\n#sidebar {\n            background:url(图片链接);\n            background-size: cover;\n            background-position:center;\n            background-repeat:no-repeat;\n            p,span,a {color: 颜色代码;}\n}\n```\n\n其中的css样式属性都可以根据图片修改，以达到满意的效果。\n\n------\n\n## 4.5 侧栏置于左侧，修改控制按钮样式\n\n默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。打开`themes/next/`下的`_config.yml`，查找`sidebar`\n\n### 4.5.1 设置侧栏在左侧/右侧\n\n- Pisces或Gemini方案\n\n  ```\n  sidebar:\n  position: left\n  #position: right\n  ```\n\n- Mist或Muse方案\n\n1. 打开`next/source/js/src/motion.js`，查找`paddingRight`，把所有（2个）`PaddingRight`更改为`paddingLeft`即可。\n\n2. 打开\n\n   ```\n   next/source/css/_custom/custom.styl\n   ```\n\n   ，添加如下内容：\n\n   ```\n   //侧边栏置于左侧\n   .sidebar {\n     left: 0;\n   }\n   //侧栏开关置于左侧\n   .sidebar-toggle {\n     left: $b2t-position-right;\n   }\n   ```\n\n3. 打开`next/source/css/_common/components/back-to-top.styl`，将`right: $b2t-position-right;`改为`left: $b2t-position-right;`\n\n### 4.5.2 显示侧边栏的时机\n\n```\n\t#post - 默认行为，在文章页面（拥有目录列表）时显示\n\t#always - 在所有页面中都显示\n\t#hide - 在所有页面中都隐藏（可以手动展开）\n\t#remove - 完全移除\n\tdisplay: post\n\t#display: always\n\t#display: hide\n\t#display: remove\n```\n\n------\n\n### 4.5.3 侧边栏控制按钮样式修改\n\n打开`themes/next/layout/source/js/src/motion.js`，找到如下代码处，更换close的内容\n\n```\nvar sidebarToggleLine1st = new SidebarToggleLine({\n    el: '.sidebar-toggle-line-first',\n    status: {\n      arrow: {width: '50%', rotateZ: '45deg', top: '2px', left: '6px'},\n      // close: {width: '100%', rotateZ: '-45deg', top: '5px', left: '0px'} //X形\n      close: {width: '50%', rotateZ: '-45deg', top: '2px', left: '0px'} //箭头形\n    }\n  });\n  var sidebarToggleLine2nd = new SidebarToggleLine({\n    el: '.sidebar-toggle-line-middle',\n    status: {\n      arrow: {width: '90%'},\n      // close: {opacity: 0} //X形\n      close: {width: '90%'} //箭头形\n    }\n  });\n  var sidebarToggleLine3rd = new SidebarToggleLine({\n    el: '.sidebar-toggle-line-last',\n    status: {\n      arrow: {width: '50%', rotateZ: '-45deg', top: '-2px', left: '6px'},\n      // close: {width: '100%', rotateZ: '45deg', top: '-5px', left: '0px'} //X形\n      close: {width: '50%', rotateZ: '45deg', top: '-2px', left: '0px'} //箭头形\n    }\n  });\n```\n\n------\n\n## 4.6 文章底部标签显示的优化\n\n修改`/themes/next/layout/_macro/post.swig`，搜索 `rel=\"tag\">#`，将 `#` 换成 `<i class=\"fa fa-tag\"></i>`\n\n## 4.7 文章添加阴影、透明效果\n\n打开`theme/next/source/css/_custom/custom.styl`，添加以下代码\n\n```\n// 主页文章添加阴影效果\n.post {\n   margin-top: 60px;\n   margin-bottom: 60px;\n   padding: 25px;\n   background:rgba(255,255,255,0.9) none repeat scroll !important;\n   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);\n   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);\n}\n```\n\n------\n\n## 4.8 Hexo添加文章时自动打开编辑器\n\n- 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。\n  如果没有这个scripts目录，则新建一个。\n- scripts目录新建的JavaScript脚本文件可以任意取名。\n\n通过这个脚本，我们用其来监听`hexo new`这个动作，并在检测到`hexo new`之后，执行编辑器打开的命令。\n\n- 如果你是windows平台的Hexo用户，则将下列内容写入你的脚本：\n\n```\nvar spawn = require('child_process').exec;\nhexo.on('new', function(data){\n  spawn('start  \"markdown编辑器绝对路径.exe\" ' + data.path);\n});\n```\n\n如果你是Mac平台Hexo用户，则将下列内容写入你的脚本：\n\n```\nvar exec = require('child_process').exec;\nhexo.on('new', function(data){\n    exec('open -a \"markdown编辑器绝对路径.app\" ' + data.path);\n});\n```\n\n------\n\n## 4.9 点击侧栏头像回到首页\n\n修改`/themes/next/layout/_macro/sidebar.swig`，找到如下代码：\n\n```\n<img class=\"site-author-image\" itemprop=\"image\"\n    src=\"{{ url_for( theme.avatar | default(theme.images + '/avatar.gif') ) }}\"\n    alt=\"{{ theme.author }}\" />\n```\n\n在其前后加上`<a href=\"/\"></a>`即可，如下：\n\n```\n<a href=\"/\">\n   <img class=\"site-author-image\" itemprop=\"image\"\n       src=\"{{ url_for( theme.avatar | default(theme.images + '/avatar.gif') ) }}\"\n       alt=\"{{ theme.author }}\" />\n</a>\n```\n\n------\n\n## 4.10 修改中文字体\n\n1. 前往[Google Fonts](https://fonts.google.com/)查看合适的字体\n\n2. 打开\n\n   ```\n   themes/next/\n   ```\n\n   下的\n\n   ```\n   _config.yml\n   ```\n\n   ，查找\n\n   ```\n   font\n   ```\n\n   ```\n   font:\n   \tenable: true\n   \t # Uri of fonts host. E.g. //fonts.googleapis.com (Default). 修改为墙内镜像\n   \thost: https://fonts.loli.net\n   \tglobal:\n   \t\texternal: true\n   \t\tfamily: Noto Serif SC // 挑选的字体\n   \t\tsize: 16\n   ```\n\n   1. 修改`/themes/next/source/css/_variables/base.styl`\n      将\n\n   ```\n   $font-family-monospace    = consolas, Menlo, $font-family-chinese, monospace\n   $font-family-monospace    = get_font_family('codes'), consolas, Menlo, $font-family-chinese, monospace if get_font_family('codes')\n   ```\n\n   改为\n\n   ```\n   $font-family-monospace    = consolas, Menlo, $font-family-base, monospace\n   $font-family-monospace    = get_font_family('codes'), consolas, Menlo, $font-family-base, monospace if get_font_family('codes')\n   ```\n\n------\n\n## 4.11 新建文章时，在相同目录下创建同名文件夹（便于图片管理）\n\n- 打开站点配置文件`_config.yml`，搜索`post_asset_folder`字段，设置其值为`true`\n- 安装hexo-asset-image：`npm install hexo-asset-image --save`\n- 此时`hexo new \"fileName\"`会在`/source/_posts`目录下创建同名的文件夹\n- 只需在 md 文件里使用 `![title](图片名.jpg)` ，无需路径名就可以插入图片。\n\n------\n\n## 4.12 首页显示文章摘要（阅读全文）及配图（文章内不重复显示）\n\n1. 打开\n\n   ```\n   themes/next/\n   ```\n\n   下的\n\n   ```\n   _config.yml\n   ```\n\n   ，查找\n\n   ```\n   excerpt\n   ```\n\n   ```\n   auto_excerpt: //自动摘录\n     enable: true\n     length: 150 //摘录字数\n   read_more_btn: true //显示全文按钮\n   ```\n\n2. 打开\n\n   ```\n   themes\\next\\layout\\_macro\\post.swig\n   ```\n\n   ，在\n\n   ```\n   {% if is_index %}\n   ```\n\n   和\n\n   ```\n   {% if post.description and theme.excerpt_description %}\n   ```\n\n   之间添加如下内容\n\n   ```\n   {% if post.images %}\n   \t<div class=\"out-img-topic\">\n   \t\t<img src={{ post.images }} class=\"img-topic\">\n   \t</div>\n   {% endif %}\n   ```\n\n3. 向\n\n   ```\n   themes\\next\\source\\css\\_custom\\custom.styl\n   ```\n\n   中添加如下内容\n\n   ```\n   //文章摘要配图\n   //图片外部的容器方框，限制图片大小\n   .out-img-topic {\n     display: block;\n     max-height:500px;\n     margin-bottom: 24px;\n     overflow: hidden;\n   }\n   //图片\n   img.img-topic {\n     display: block ;\n     margin-left: .7em;\n     margin-right: .7em;\n     padding: 0;\n     float: right;\n     clear: right;\n   }\n   ```\n\n4. 将摘要图片储存于\n\n   ```\n   themes\\next\\source\\images\n   ```\n\n   中，建议\n\n   在此路径下\n\n   单独建一个文件夹存放摘要图片，\n\n   这个图片和文章中插图的存放路径不同，不是一个概念\n\n   。然后在文章YAML头信息中添加images字段，将值填为\n\n   ```\n   /images/imagename.jpg\n   ```\n\n   。\n\n   ```\n   images: \"images/文章摘要配图/Win10桌面.png\"\n   ```\n\n------\n\n## 4.13 给页面、侧边栏添加背景图片\n\n打开`theme/next/source/css/_custom/custom.styl`，添加以下代码：\n\n```\nbody {\n  background: url(/images/blogbk.jpg) no-repeat;\n  /* 背景图垂直、水平均居中 */\n  background-position: center center;\n  /* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */\n  background-attachment: fixed;\n  /* 让背景图基于容器大小伸缩 */\n  background-size: cover;\n  /* 设置背景颜色，背景图加载过程中会显示背景色 */\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.sidebar {\n            background:url(/images/sidebar.jpg);\n            background-size: cover;\n            background-position:center;\n            background-repeat:no-repeat;\n            p,span,a {color: rgba(255, 255, 255, 1);}\n}\n```\n\n------\n\n## 4.14 文字背景以及半透明的设置\n\n打开`theme/next/source/css/_custom/custom.styl`，添加以下代码：\n\n```\n.content {\n\tborder-radius: 20px; //文章背景设置圆角\n\tpadding: 30px 60px 30px 60px;\n\tbackground:rgba(255, 255, 255, 0.8) none repeat scroll !important;\n}\n```\n\n------\n\n## 4.15 去除NexT主题Markdown分割线渲染效果\n\n修改`/source/css/_common/scaffolding/base.styl`，注释或删除以下内容：\n\n```\nbackground-image: repeating-linear-gradient(\n    -45deg,\n    white,\n    white 4px,\n    transparent 4px,\n    transparent 8px\n  );\n1234567\n```\n\n------\n\n## 4.16 图片可点击放大查看，放大后可关闭\n\n- 打开站点配置文件`_config.yml`，搜索`fancybox`字段，设置其值为`true`\n- 进入到`theme/text/`文件夹下，打开`git bash`\n- `git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox`\n\n------\n\n## 4.17 博客总访问量统计\n\n- 打开\n\n  ```\n  themes/next/\n  ```\n\n  下的\n\n  ```\n  _config.yml\n  ```\n\n  ，查找\n\n  ```\n  busuanzi\n  ```\n\n  ```\n  busuanzi_count:\n    enable: true\n    total_visitors: false\n    total_visitors_icon: user\n    total_views: false\n    total_views_icon: eye\n    post_views: true\n    post_views_icon: eye\n  ```\n\n当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动\n\n- 打开\n\n  ```\n  /themes/next/layout/_partials/footer.swig\n  ```\n\n  ，在最后添加如下内容：\n\n  ```\n  <span id=\"busuanzi_container_site_uv\">\n    本站访问次数：<span class=\"busuanzi-value\" id=\"busuanzi_value_site_pv\"></span>\n  </span>\n  ```\n\n## 4.18 文章末尾添加版权声明\n\n**效果：**\n![这里写图片描述](https://img-blog.csdn.net/2018062323493260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTM0NTM4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n**配置：**\n查找主题配置文件`themes/next/_config.yml`中的`creative_commons`\n\n```\ncreative_commons:\n  license: by-nc-sa\n  sidebar: false\n  post: true  # 将false改为true即可显示版权信息\n  language:\n```\n\n------\n\n## 4.19 本地搜索（其余搜索方案的劣势只有收费）\n\n- `npm install hexo-generator-search`\n\n- 查找主题配置文件\n\n  ```\n  themes/next/_config.yml\n  ```\n\n  中的\n\n  ```\n  local_search\n  ```\n\n  ```\n  local_search:\n    enable: true\n  ```\n\n------\n\n## 4.20 图床和上传工具\n\n[盘点一下免费好用的图床](https://zhuanlan.zhihu.com/p/35270383)\n\n## 4.21 文章置顶\n\n[Hexo博客彻底解决置顶问题](http://wangwlj.com/2018/01/09/blog_pin_post/)\n效果：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190329140445995.png)\n注：若有多篇文章需要置顶，排序方式为 在需要置顶的文章的`Front-matter`的`top:`填写阿拉伯数字即可，数越大，排序越靠前。\n\n## 4.22 添加粒子时钟\n\n博客应用canvas粒子时钟的操作步骤：\n\n在`\\themes\\next\\layout\\_custom\\`目录下，新建`clock.swig`文件，内容如下：\n\n```\n<div style=\"\">\n  <canvas id=\"canvas\" style=\"width:60%;\">当前浏览器不支持canvas，请更换浏览器后再试</canvas>\n</div>\n<script>\n(function(){\n\n   var digit=\n    [\n        [\n            [0,0,1,1,1,0,0],\n            [0,1,1,0,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,0,1,1,0],\n            [0,0,1,1,1,0,0]\n        ],//0\n        [\n            [0,0,0,1,1,0,0],\n            [0,1,1,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [1,1,1,1,1,1,1]\n        ],//1\n        [\n            [0,1,1,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,0,0],\n            [0,0,1,1,0,0,0],\n            [0,1,1,0,0,0,0],\n            [1,1,0,0,0,0,0],\n            [1,1,0,0,0,1,1],\n            [1,1,1,1,1,1,1]\n        ],//2\n        [\n            [1,1,1,1,1,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,0,0,1,1,0],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0]\n        ],//3\n        [\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,1,0],\n            [0,0,1,1,1,1,0],\n            [0,1,1,0,1,1,0],\n            [1,1,0,0,1,1,0],\n            [1,1,1,1,1,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,0,1,1,0],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,1,1]\n        ],//4\n        [\n            [1,1,1,1,1,1,1],\n            [1,1,0,0,0,0,0],\n            [1,1,0,0,0,0,0],\n            [1,1,1,1,1,1,0],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0]\n        ],//5\n        [\n            [0,0,0,0,1,1,0],\n            [0,0,1,1,0,0,0],\n            [0,1,1,0,0,0,0],\n            [1,1,0,0,0,0,0],\n            [1,1,0,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0]\n        ],//6\n        [\n            [1,1,1,1,1,1,1],\n            [1,1,0,0,0,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,0,0],\n            [0,0,0,1,1,0,0],\n            [0,0,1,1,0,0,0],\n            [0,0,1,1,0,0,0],\n            [0,0,1,1,0,0,0],\n            [0,0,1,1,0,0,0]\n        ],//7\n        [\n            [0,1,1,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,1,1,0]\n        ],//8\n        [\n            [0,1,1,1,1,1,0],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [1,1,0,0,0,1,1],\n            [0,1,1,1,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,0,1,1],\n            [0,0,0,0,1,1,0],\n            [0,0,0,1,1,0,0],\n            [0,1,1,0,0,0,0]\n        ],//9\n        [\n            [0,0,0,0,0,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,0,0,0,0,0],\n            [0,0,0,0,0,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,1,1,1,0,0],\n            [0,0,0,0,0,0,0]\n        ]//:\n    ];\n\nvar canvas = document.getElementById('canvas');\n\nif(canvas.getContext){\n    var cxt = canvas.getContext('2d');\n    //声明canvas的宽高\n    var H = 100,W = 700;\n    canvas.height = H;\n    canvas.width = W;\n    cxt.fillStyle = '#f00';\n    cxt.fillRect(10,10,50,50);\n\n    //存储时间数据\n    var data = [];\n    //存储运动的小球\n    var balls = [];\n    //设置粒子半径\n    var R = canvas.height/20-1;\n    (function(){\n        var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date());\n        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成\n        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);\n    })();\n\n    /*生成点阵数字*/\n    function renderDigit(index,num){\n        for(var i = 0; i < digit[num].length; i++){\n            for(var j = 0; j < digit[num][i].length; j++){\n                if(digit[num][i][j] == 1){\n                    cxt.beginPath();\n                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);\n                    cxt.closePath();\n                    cxt.fill();\n                }\n            }\n        }\n    }\n\n    /*更新时钟*/\n    function updateDigitTime(){\n        var changeNumArray = [];\n        var temp = /(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)/.exec(new Date());\n        var NewData = [];\n        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);\n        for(var i = data.length-1; i >=0 ; i--){\n            //时间发生变化\n            if(NewData[i] !== data[i]){\n                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中\n                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);\n            }\n        }\n        //增加小球\n        for(var i = 0; i< changeNumArray.length; i++){\n            addBalls.apply(this,changeNumArray[i].split('_'));\n        }\n        data = NewData.concat();\n    }\n\n    /*更新小球状态*/\n    function updateBalls(){\n        for(var i = 0; i < balls.length; i++){\n            balls[i].stepY += balls[i].disY;\n            balls[i].x += balls[i].stepX;\n            balls[i].y += balls[i].stepY;\n            if(balls[i].x > W + R || balls[i].y > H + R){\n                balls.splice(i,1);\n                i--;\n            }\n        }\n    }\n\n    /*增加要运动的小球*/\n    function addBalls(index,num){\n        var numArray = [1,2,3];\n        var colorArray =  [\"#3BE\",\"#09C\",\"#A6C\",\"#93C\",\"#9C0\",\"#690\",\"#FB3\",\"#F80\",\"#F44\",\"#C00\"];\n        for(var i = 0; i < digit[num].length; i++){\n            for(var j = 0; j < digit[num][i].length; j++){\n                if(digit[num][i][j] == 1){\n                    var ball = {\n                        x:14*(R+2)*index + j*2*(R+1)+(R+1),\n                        y:i*2*(R+1)+(R+1),\n                        stepX:Math.floor(Math.random() * 4 -2),\n                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],\n                        color:colorArray[Math.floor(Math.random()*colorArray.length)],\n                        disY:1\n                    };\n                    balls.push(ball);\n                }\n            }\n        }\n    }\n\n    /*渲染*/\n    function render(){\n        //重置画布宽度，达到清空画布的效果\n        canvas.height = 100;\n        //渲染时钟\n        for(var i = 0; i < data.length; i++){\n            renderDigit(i,data[i]);\n        }\n        //渲染小球\n        for(var i = 0; i < balls.length; i++){\n            cxt.beginPath();\n            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);\n            cxt.fillStyle = balls[i].color;\n            cxt.closePath();\n            cxt.fill();\n        }\n    }\n\n    clearInterval(oTimer);\n    var oTimer = setInterval(function(){\n        //更新时钟\n        updateDigitTime();\n        //更新小球状态\n        updateBalls();\n        //渲染\n        render();\n    },50);\n}\n\n})();\n</script>\n```\n\n- 引用代码\n\n直接引用或者通过配置文件配置，二选一\n\n- 直接引用\n\n在`博客目录\\themes\\next\\layout\\_macro\\sidebar.swig`尾部中引入：\n\n```\n{% include '../_custom/clock.swig' %}\n```\n\n示意图如下：\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9jay5wbmc?x-oss-process=image/format,png)\n\n> 注：代码块要放置在`sider-inner`的`div`块中，放在`div`块的位置决定时钟样式的展示位置。我选择放置在尾部，看着效果好点。\n\n- 通过配置文件配置\n\n1、在`博客目录\\themes\\next\\layout\\_macro\\sidebar.swig`尾部中引入：\n\n```\n        {% if theme.diy_time.clock %}\n          <!-- canvas粒子时钟 -->\n          {% include '../_custom/clock.swig' %}\n        {% endif %}\n```\n\n示意图如下：\n![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9ja19pZi5wbmc?x-oss-process=image/format,png)\n\n> 注：代码块要放置在`sider-inner`的`div`块中，放在`div`块的位置决定时钟样式的展示位置。\n\n2、在主题的配置文件中加入应用代码，配置文件位置是`博客目录\\themes\\next\\_config.yml`：\n\n```\n# 侧栏粒子时钟\ndiy_time:\n  runtime: true \n  clock: true # 粒子时钟\n```\n\n## 4.23 添加近期文章\n\n添加配置参数 **~/theme/next/_config.yml** ，添加如下配置：\n\n```\nrecent_posts:\n  enable: true\n  recent_posts_title: 最新发表文章\n```\n\n首先我们找到侧边栏模块 **next/layout/_macro/sidebar.swig** ,这个负责渲染侧边栏\n在我们想要放置**最新文章模块**的地方添加如下代码：\n\n```\n{% if theme.recent_posts.enable %}\n  <aside class=\"sidebar sidebar-ads sidebar-posts\">\n    <div>\n      <div class=\"recent_posts_title\">\n        {{ theme.recent_posts.recent_posts_title }}\n      </div>\n      <ul class=\"links-of-blogroll-list\">\n        {% set posts = site.posts.sort('-date') %}\n        {% set bg_colors = ['rgb(31, 216, 210)', 'rgb(4, 166, 247)', 'rgb(70, 101, 226)', 'rgb(94, 137, 229)', 'rgb(0, 206, 123)'] %}\n        {% for post in posts.slice('0', '5') %}\n          <li>\n            <div class=\"text-img\" style=\"background:{{bg_colors[loop.index - 1]}};\">{{ post.title.substr(0, 3) }}</div>\n            <div class=\"post-name\">\n              <div>{{ date(post.date, config.date_format) }}</div>\n              <div><a href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" >{{ post.title }}</a></div>\n            </div>\n          </li>\n        {% endfor %}\n      </ul>\n    </div>\n  </aside>\n  {% endif %}\n```\n\n最后重新执行\n\n```\nhexo clean\nhexo g\n```\n\n\n\n最后我们得到的效果是\n\n## Google统计\n\n## Sitemap网站地图\n\n## 提交谷歌收录本站 Google Search\n\n\n\n## [文章阅读量统计](https://blog.csdn.net/weixin_39345384/article/details/80787998)\n\n------\n\n------\n\n参考：\n\n- [HEXO+NEXT主题个性化配置](http://mashirosorata.vicp.io/HEXO-NEXT主题个性化配置.html)\n- [打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化](https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html)\n- [[EasyHexo 专栏\\] #2 - 魔改 Next 不完全教程](https://juejin.im/post/5c45a503f265da616b10fe4e#heading-28)\n- [基于Hexo+Node.js+github+coding搭建个人博客——进阶篇(从入门到入土)](https://blog.csdn.net/MasterAnt_D/article/details/56839222#t50)\n- [Hexo博客Next主题优化总结](http://www.shaoyance.com/2018/01/26/Hexo博客Next主题优化总结/)\n- [为NexT主题添加文章阅读量统计功能](https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html)\n- [2017年最新基于hexo搭建个人免费博客——自定义页面样式一](http://www.cduyzh.com/hexo-settings-3/)\n- [Hexo添加文章时自动打开编辑器](https://notes.doublemine.me/2015-06-29-Hexo添加文章时自动打开编辑器.html)\n- [next主题下点击侧边栏头像回到博客首页](https://blog.yleao.com/2018/0901/hexo-next主题下的美化.html#next主题下点击侧边栏头像回到博客首页)\n- [Google Fonts 已支持思源宋体！](https://reuixiy.github.io/beautiful/share/2018/12/11/noto-serif-sc-added-on-google-fonts.html)\n- [弃暗投明-Hexo更换next主题](https://www.bluelzy.com/articles/change_to_next_theme.html)\n- [hexo博客NEXT主题美化](https://www.feiwuuz.com.cn/archives/5483aa06.html)\n- [在hexo博客中插入图片，音乐，视频](http://chant00.com/2015/11/04/在hexo博客中插入图片，音乐，视屏，公式/)","slug":"博客教程/hexo/NexT主题自定义配置","published":1,"date":"2020-12-21T15:10:33.051Z","updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6i4003gtvcde17ee5dy","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>前文：<a href=\"https://blog.csdn.net/weixin_39345384/article/details/80095883\">Windows下通过GitHub+Hexo搭建个人博客的步骤</a>；<br>博主的个人博客：<a href=\"https://hunter1023.github.io/\">https://hunter1023.github.io/</a> 按照本篇博客美化。</p>\n<p>在 Hexo 中有<strong>2份</strong>主要的配置文件，其名称都是<code>_config.yml</code>。 其中，一份位于<strong>博客根目录下</strong>，主要包含 <strong>Hexo 本身的配置</strong>；另一份位于<code>themes/next/</code>目录下，用于配置<strong>主题相关的选项</strong>。</p>\n<hr>\n<h1 id=\"2-基础设置\"><a href=\"#2-基础设置\" class=\"headerlink\" title=\"2. 基础设置\"></a>2. 基础设置</h1><h2 id=\"2-1-设置站点名、作者昵称和站点描述等内容\"><a href=\"#2-1-设置站点名、作者昵称和站点描述等内容\" class=\"headerlink\" title=\"2.1 设置站点名、作者昵称和站点描述等内容\"></a>2.1 设置站点名、作者昵称和站点描述等内容</h2><p>打开<strong>根目录下的<code>_config.yml</code></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># Site<br>title: 特叔服务<br>subtitle: <br>keywords:<br>author: Hunter<br>description: Tough times never last, but tough people do.<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2-2-NexT主题的安装\"><a href=\"#2-2-NexT主题的安装\" class=\"headerlink\" title=\"2.2. NexT主题的安装\"></a>2.2. NexT主题的安装</h2><p>顾名思义，所谓主题就是界面的展示样式。Hexo安装主题，只需要将主题文件拷贝至博客所在目录的<code>themes</code>目录下，修改相关配置文件即可生效。</p>\n<p>博客所在目录下打开<code>git bash</code>，再通过<code>Git clone https://github.com/theme-next/hexo-theme-next themes/next</code>即可完成。</p>\n<hr>\n<h2 id=\"2-3-启用主题\"><a href=\"#2-3-启用主题\" class=\"headerlink\" title=\"2.3 启用主题\"></a>2.3 启用主题</h2><p>打开<strong>根目录下的<code>_config.yml</code></strong>,查找<code>theme</code>字段，将字段改为<code>theme: next</code>(<strong>冒号<code>:</code>之后要有空格分隔，否则无效</strong>) ，之后通过<code>hexo g</code>和<code>hexo s</code>，再在浏览器中访问<code>localhost:4000</code>即可本地预览主题效果。</p>\n<hr>\n<h1 id=\"3-主题设定\"><a href=\"#3-主题设定\" class=\"headerlink\" title=\"3. 主题设定\"></a>3. 主题设定</h1><h2 id=\"3-1-选择scheme\"><a href=\"#3-1-选择scheme\" class=\"headerlink\" title=\"3.1 选择scheme\"></a>3.1 选择scheme</h2><p>打开<code>themes/next/</code>下的<code>_config.yml</code>,查找<code>scheme</code>，可以看到如下四种不同的风格方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">scheme: Muse<br>#scheme: Mist<br>#scheme: Pisces<br>#scheme: Gemini<br></code></pre></td></tr></table></figure>\n<p>去掉<code>#</code>注释，即启用对应的scheme，博主采用Muse主题，大家可以依次测试效果，选择自己喜欢的scheme。</p>\n<hr>\n<h2 id=\"3-2-设置语言\"><a href=\"#3-2-设置语言\" class=\"headerlink\" title=\"3.2 设置语言\"></a>3.2 设置语言</h2><p>博客框架默认的语言是英文，前往<code>/themes/next/languages</code>，查看当前NexT版本简体中文对照文件的名称是<code>zh-Hans</code>还是<code>zh-CN</code>。</p>\n<p>再前往根目录下的<code>_config.yml</code>，查找<code>language</code>，设置成<code>language: zh-Hans</code>或<code>language: zh-CN</code>，即显示简体中文。</p>\n<hr>\n<h2 id=\"3-3-设置菜单及对应页面\"><a href=\"#3-3-设置菜单及对应页面\" class=\"headerlink\" title=\"3.3 设置菜单及对应页面\"></a>3.3 设置菜单及对应页面</h2><ul>\n<li><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>menu</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">menu:<br>  home: &#x2F; || home<br>  #about: &#x2F;about&#x2F; || user<br>  tags: &#x2F;tags&#x2F; || tags<br>  categories: &#x2F;categories&#x2F; || th<br>  archives: &#x2F;archives&#x2F; || archive<br>  #schedule: &#x2F;schedule&#x2F; || calendar<br>  #sitemap: &#x2F;sitemap.xml || sitemap<br>  #commonweal: &#x2F;404&#x2F; || heartbeat<br></code></pre></td></tr></table></figure>\n<p>去掉<code>#</code>注释即可显示对应的菜单项，也可自定义新的菜单项。 <code>||</code>之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。</p>\n</li>\n<li><p>新添加的菜单需要翻译对应的中文<br>打开<code>hexo/theme/next/languages/zh-CN.yml</code>，在menu下自定义，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">menu:<br>  resources: 资源<br></code></pre></td></tr></table></figure></li>\n<li><p><code>hexo new page &quot;categories&quot;</code><br>此时在根目录的<code>source</code>文件夹下会生成一个categories文件，文件中有一个<code>index.md</code>文件，修改内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">---<br>title: 分类<br>date: 2017-12-14 13:05:38<br>type: &quot;categories&quot;<br>comments: false<br>---<br></code></pre></td></tr></table></figure>\n<p>注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-4-设定站点建立时间\"><a href=\"#3-4-设定站点建立时间\" class=\"headerlink\" title=\"3.4 设定站点建立时间\"></a>3.4 设定站点建立时间</h2><p>打开<strong><code>themes/next/</code>下的<code>_config.yml</code></strong>，查找<code>since</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">footer:<br>  # Specify the date when the site was setup.<br>  # If not defined, current year will be used.<br>  #since: 2015<br></code></pre></td></tr></table></figure>\n<p><strong>如果不设置，默认显示当前年份</strong>。</p>\n<hr>\n<h1 id=\"4-美化\"><a href=\"#4-美化\" class=\"headerlink\" title=\"4. 美化\"></a>4. 美化</h1><h2 id=\"4-1-设置头像\"><a href=\"#4-1-设置头像\" class=\"headerlink\" title=\"4.1 设置头像\"></a>4.1 设置头像</h2><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>avatar</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># Sidebar Avatar<br># in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif<br># in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif<br>avatar: http:&#x2F;&#x2F;XXXXXXXXX<br></code></pre></td></tr></table></figure>\n<p><code>avatar</code>的值是<strong>图片的链接地址</strong>(完整的URI 或者 站内的相对地址皆可)</p>\n<table>\n<thead>\n<tr>\n<th>地址</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>完整的URI</td>\n<td><a href=\"http://example.com/avatar.png\">http://example.com/avatar.png</a></td>\n</tr>\n<tr>\n<td>站点内地址</td>\n<td>图片放至<code>themes/next/source/images/</code>配置为：<code>avatar: /images/图片名</code></td>\n</tr>\n<tr>\n<td>站点内地址</td>\n<td>图片放至<strong>根目录下</strong><code>source/uploads/</code>(初始无uploads文件夹，自行创建)目录下配置为：<code>avatar: /uploads/图片名</code></td>\n</tr>\n</tbody></table>\n<p><strong>之后创建博文，对图片的引用 同样可以按照上述地址获取</strong>。</p>\n<hr>\n<h2 id=\"4-2-网站图标设置\"><a href=\"#4-2-网站图标设置\" class=\"headerlink\" title=\"4.2 网站图标设置\"></a>4.2 网站图标设置</h2><ul>\n<li><p>图标素材网站：<a href=\"https://www.iconfont.cn/\">iconfont</a>；<a href=\"https://www.easyicon.net/\">easyicon</a></p>\n</li>\n<li><p>下载16x16以及32x32大小的<strong>PNG格式图标</strong>，置于<code>/themes/next/source/images/</code>下</p>\n</li>\n<li><p>打开**</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure>\n<p>下的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">_config.yml<br></code></pre></td></tr></table></figure>\n<p>**，查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">favicon<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">favicon:<br>  small: &#x2F;images&#x2F;favicon-16x16-next.png<br>  medium: &#x2F;images&#x2F;favicon-32x32-next.png<br>  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png<br>  safari_pinned_tab: &#x2F;images&#x2F;logo.svg<br>  #android_manifest: &#x2F;images&#x2F;manifest.json<br>  #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml<br></code></pre></td></tr></table></figure>\n<p>修改small和medium的路径为下载的图标路径</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"4-3-背景动画\"><a href=\"#4-3-背景动画\" class=\"headerlink\" title=\"4.3 背景动画\"></a>4.3 背景动画</h2><h3 id=\"4-3-1-Canvas-nest风格\"><a href=\"#4-3-1-Canvas-nest风格\" class=\"headerlink\" title=\"4.3.1 Canvas-nest风格\"></a>4.3.1 <a href=\"https://blog.csdn.net/weixin_39345384/article/details/80544660\">Canvas-nest风格</a></h3><h3 id=\"4-3-2-JavaScript-3D-library风格\"><a href=\"#4-3-2-JavaScript-3D-library风格\" class=\"headerlink\" title=\"4.3.2 JavaScript 3D library风格\"></a>4.3.2 JavaScript 3D library风格</h3><ol>\n<li>进入theme/next目录</li>\n<li>执行命令：<code>git clone https://github.com/theme-next/theme-next-three source/lib/three</code></li>\n<li>将<code>themes/next/_config.yml</code>中查找<code>theme-next-three</code>，将想要的效果改为true即可：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># three_waves<br>three_waves: false<br># canvas_lines<br>canvas_lines: true<br># canvas_sphere<br>canvas_sphere: false<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-4-背景图片-顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色\"><a href=\"#4-4-背景图片-顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色\" class=\"headerlink\" title=\"4.4 背景图片/顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色\"></a>4.4 背景图片/顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;&#x2F;背景图片<br>body&#123;   <br>        background:url(图片链接);<br>        background-size:cover;<br>        background-repeat:no-repeat;<br>        background-attachment:fixed;<br>        background-position:center;<br>&#125;<br>&#x2F;&#x2F;顶栏图片<br>.header &#123;<br>          background:url(图片链接) none repeat scroll !important;<br>&#125;<br>&#x2F;&#x2F;底栏背景色<br>.footer &#123;<br>          background:rgba(颜色rgb,透明度) none repeat scroll !important;<br>&#125;<br>&#x2F;&#x2F;侧栏图片及内部文字颜色修改<br>#sidebar &#123;<br>            background:url(图片链接);<br>            background-size: cover;<br>            background-position:center;<br>            background-repeat:no-repeat;<br>            p,span,a &#123;color: 颜色代码;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其中的css样式属性都可以根据图片修改，以达到满意的效果。</p>\n<hr>\n<h2 id=\"4-5-侧栏置于左侧，修改控制按钮样式\"><a href=\"#4-5-侧栏置于左侧，修改控制按钮样式\" class=\"headerlink\" title=\"4.5 侧栏置于左侧，修改控制按钮样式\"></a>4.5 侧栏置于左侧，修改控制按钮样式</h2><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>sidebar</code></p>\n<h3 id=\"4-5-1-设置侧栏在左侧-右侧\"><a href=\"#4-5-1-设置侧栏在左侧-右侧\" class=\"headerlink\" title=\"4.5.1 设置侧栏在左侧/右侧\"></a>4.5.1 设置侧栏在左侧/右侧</h3><ul>\n<li><p>Pisces或Gemini方案</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">sidebar:<br>position: left<br>#position: right<br></code></pre></td></tr></table></figure></li>\n<li><p>Mist或Muse方案</p>\n</li>\n</ul>\n<ol>\n<li><p>打开<code>next/source/js/src/motion.js</code>，查找<code>paddingRight</code>，把所有（2个）<code>PaddingRight</code>更改为<code>paddingLeft</code>即可。</p>\n</li>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">next&#x2F;source&#x2F;css&#x2F;_custom&#x2F;custom.styl<br></code></pre></td></tr></table></figure>\n<p>，添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;&#x2F;侧边栏置于左侧<br>.sidebar &#123;<br>  left: 0;<br>&#125;<br>&#x2F;&#x2F;侧栏开关置于左侧<br>.sidebar-toggle &#123;<br>  left: $b2t-position-right;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>打开<code>next/source/css/_common/components/back-to-top.styl</code>，将<code>right: $b2t-position-right;</code>改为<code>left: $b2t-position-right;</code></p>\n</li>\n</ol>\n<h3 id=\"4-5-2-显示侧边栏的时机\"><a href=\"#4-5-2-显示侧边栏的时机\" class=\"headerlink\" title=\"4.5.2 显示侧边栏的时机\"></a>4.5.2 显示侧边栏的时机</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">#post - 默认行为，在文章页面（拥有目录列表）时显示<br>#always - 在所有页面中都显示<br>#hide - 在所有页面中都隐藏（可以手动展开）<br>#remove - 完全移除<br>display: post<br>#display: always<br>#display: hide<br>#display: remove<br></code></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-5-3-侧边栏控制按钮样式修改\"><a href=\"#4-5-3-侧边栏控制按钮样式修改\" class=\"headerlink\" title=\"4.5.3 侧边栏控制按钮样式修改\"></a>4.5.3 侧边栏控制按钮样式修改</h3><p>打开<code>themes/next/layout/source/js/src/motion.js</code>，找到如下代码处，更换close的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">var sidebarToggleLine1st &#x3D; new SidebarToggleLine(&#123;<br>    el: &#39;.sidebar-toggle-line-first&#39;,<br>    status: &#123;<br>      arrow: &#123;width: &#39;50%&#39;, rotateZ: &#39;45deg&#39;, top: &#39;2px&#39;, left: &#39;6px&#39;&#125;,<br>      &#x2F;&#x2F; close: &#123;width: &#39;100%&#39;, rotateZ: &#39;-45deg&#39;, top: &#39;5px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;X形<br>      close: &#123;width: &#39;50%&#39;, rotateZ: &#39;-45deg&#39;, top: &#39;2px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;箭头形<br>    &#125;<br>  &#125;);<br>  var sidebarToggleLine2nd &#x3D; new SidebarToggleLine(&#123;<br>    el: &#39;.sidebar-toggle-line-middle&#39;,<br>    status: &#123;<br>      arrow: &#123;width: &#39;90%&#39;&#125;,<br>      &#x2F;&#x2F; close: &#123;opacity: 0&#125; &#x2F;&#x2F;X形<br>      close: &#123;width: &#39;90%&#39;&#125; &#x2F;&#x2F;箭头形<br>    &#125;<br>  &#125;);<br>  var sidebarToggleLine3rd &#x3D; new SidebarToggleLine(&#123;<br>    el: &#39;.sidebar-toggle-line-last&#39;,<br>    status: &#123;<br>      arrow: &#123;width: &#39;50%&#39;, rotateZ: &#39;-45deg&#39;, top: &#39;-2px&#39;, left: &#39;6px&#39;&#125;,<br>      &#x2F;&#x2F; close: &#123;width: &#39;100%&#39;, rotateZ: &#39;45deg&#39;, top: &#39;-5px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;X形<br>      close: &#123;width: &#39;50%&#39;, rotateZ: &#39;45deg&#39;, top: &#39;-2px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;箭头形<br>    &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-6-文章底部标签显示的优化\"><a href=\"#4-6-文章底部标签显示的优化\" class=\"headerlink\" title=\"4.6 文章底部标签显示的优化\"></a>4.6 文章底部标签显示的优化</h2><p>修改<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>\n<h2 id=\"4-7-文章添加阴影、透明效果\"><a href=\"#4-7-文章添加阴影、透明效果\" class=\"headerlink\" title=\"4.7 文章添加阴影、透明效果\"></a>4.7 文章添加阴影、透明效果</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;&#x2F; 主页文章添加阴影效果<br>.post &#123;<br>   margin-top: 60px;<br>   margin-bottom: 60px;<br>   padding: 25px;<br>   background:rgba(255,255,255,0.9) none repeat scroll !important;<br>   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);<br>   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-8-Hexo添加文章时自动打开编辑器\"><a href=\"#4-8-Hexo添加文章时自动打开编辑器\" class=\"headerlink\" title=\"4.8 Hexo添加文章时自动打开编辑器\"></a>4.8 Hexo添加文章时自动打开编辑器</h2><ul>\n<li>首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。<br>如果没有这个scripts目录，则新建一个。</li>\n<li>scripts目录新建的JavaScript脚本文件可以任意取名。</li>\n</ul>\n<p>通过这个脚本，我们用其来监听<code>hexo new</code>这个动作，并在检测到<code>hexo new</code>之后，执行编辑器打开的命令。</p>\n<ul>\n<li>如果你是windows平台的Hexo用户，则将下列内容写入你的脚本：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">var spawn &#x3D; require(&#39;child_process&#39;).exec;<br>hexo.on(&#39;new&#39;, function(data)&#123;<br>  spawn(&#39;start  &quot;markdown编辑器绝对路径.exe&quot; &#39; + data.path);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果你是Mac平台Hexo用户，则将下列内容写入你的脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">var exec &#x3D; require(&#39;child_process&#39;).exec;<br>hexo.on(&#39;new&#39;, function(data)&#123;<br>    exec(&#39;open -a &quot;markdown编辑器绝对路径.app&quot; &#39; + data.path);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-9-点击侧栏头像回到首页\"><a href=\"#4-9-点击侧栏头像回到首页\" class=\"headerlink\" title=\"4.9 点击侧栏头像回到首页\"></a>4.9 点击侧栏头像回到首页</h2><p>修改<code>/themes/next/layout/_macro/sidebar.swig</code>，找到如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot;<br>    src&#x3D;&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &#39;&#x2F;avatar.gif&#39;) ) &#125;&#125;&quot;<br>    alt&#x3D;&quot;&#123;&#123; theme.author &#125;&#125;&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure>\n<p>在其前后加上<code>&lt;a href=&quot;/&quot;&gt;&lt;/a&gt;</code>即可，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;<br>   &lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot;<br>       src&#x3D;&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &#39;&#x2F;avatar.gif&#39;) ) &#125;&#125;&quot;<br>       alt&#x3D;&quot;&#123;&#123; theme.author &#125;&#125;&quot; &#x2F;&gt;<br>&lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-10-修改中文字体\"><a href=\"#4-10-修改中文字体\" class=\"headerlink\" title=\"4.10 修改中文字体\"></a>4.10 修改中文字体</h2><ol>\n<li><p>前往<a href=\"https://fonts.google.com/\">Google Fonts</a>查看合适的字体</p>\n</li>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure>\n<p>下的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">_config.yml<br></code></pre></td></tr></table></figure>\n<p>，查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">font<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">font:<br>\tenable: true<br>\t # Uri of fonts host. E.g. &#x2F;&#x2F;fonts.googleapis.com (Default). 修改为墙内镜像<br>\thost: https:&#x2F;&#x2F;fonts.loli.net<br>\tglobal:<br>\t\texternal: true<br>\t\tfamily: Noto Serif SC &#x2F;&#x2F; 挑选的字体<br>\t\tsize: 16<br></code></pre></td></tr></table></figure>\n<ol>\n<li>修改<code>/themes/next/source/css/_variables/base.styl</code><br>将</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$font-family-monospace    &#x3D; consolas, Menlo, $font-family-chinese, monospace<br>$font-family-monospace    &#x3D; get_font_family(&#39;codes&#39;), consolas, Menlo, $font-family-chinese, monospace if get_font_family(&#39;codes&#39;)<br></code></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$font-family-monospace    &#x3D; consolas, Menlo, $font-family-base, monospace<br>$font-family-monospace    &#x3D; get_font_family(&#39;codes&#39;), consolas, Menlo, $font-family-base, monospace if get_font_family(&#39;codes&#39;)<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-11-新建文章时，在相同目录下创建同名文件夹（便于图片管理）\"><a href=\"#4-11-新建文章时，在相同目录下创建同名文件夹（便于图片管理）\" class=\"headerlink\" title=\"4.11 新建文章时，在相同目录下创建同名文件夹（便于图片管理）\"></a>4.11 新建文章时，在相同目录下创建同名文件夹（便于图片管理）</h2><ul>\n<li>打开站点配置文件<code>_config.yml</code>，搜索<code>post_asset_folder</code>字段，设置其值为<code>true</code></li>\n<li>安装hexo-asset-image：<code>npm install hexo-asset-image --save</code></li>\n<li>此时<code>hexo new &quot;fileName&quot;</code>会在<code>/source/_posts</code>目录下创建同名的文件夹</li>\n<li>只需在 md 文件里使用 <code>![title](图片名.jpg)</code> ，无需路径名就可以插入图片。</li>\n</ul>\n<hr>\n<h2 id=\"4-12-首页显示文章摘要（阅读全文）及配图（文章内不重复显示）\"><a href=\"#4-12-首页显示文章摘要（阅读全文）及配图（文章内不重复显示）\" class=\"headerlink\" title=\"4.12 首页显示文章摘要（阅读全文）及配图（文章内不重复显示）\"></a>4.12 首页显示文章摘要（阅读全文）及配图（文章内不重复显示）</h2><ol>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure>\n<p>下的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">_config.yml<br></code></pre></td></tr></table></figure>\n<p>，查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">excerpt<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">auto_excerpt: &#x2F;&#x2F;自动摘录<br>  enable: true<br>  length: 150 &#x2F;&#x2F;摘录字数<br>read_more_btn: true &#x2F;&#x2F;显示全文按钮<br></code></pre></td></tr></table></figure></li>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes\\next\\layout\\_macro\\post.swig<br></code></pre></td></tr></table></figure>\n<p>，在</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if is_index %&#125;<br></code></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if post.description and theme.excerpt_description %&#125;<br></code></pre></td></tr></table></figure>\n<p>之间添加如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if post.images %&#125;<br>\t&lt;div class&#x3D;&quot;out-img-topic&quot;&gt;<br>\t\t&lt;img src&#x3D;&#123;&#123; post.images &#125;&#125; class&#x3D;&quot;img-topic&quot;&gt;<br>\t&lt;&#x2F;div&gt;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes\\next\\source\\css\\_custom\\custom.styl<br></code></pre></td></tr></table></figure>\n<p>中添加如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;&#x2F;文章摘要配图<br>&#x2F;&#x2F;图片外部的容器方框，限制图片大小<br>.out-img-topic &#123;<br>  display: block;<br>  max-height:500px;<br>  margin-bottom: 24px;<br>  overflow: hidden;<br>&#125;<br>&#x2F;&#x2F;图片<br>img.img-topic &#123;<br>  display: block ;<br>  margin-left: .7em;<br>  margin-right: .7em;<br>  padding: 0;<br>  float: right;<br>  clear: right;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>将摘要图片储存于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes\\next\\source\\images<br></code></pre></td></tr></table></figure>\n<p>中，建议</p>\n<p>在此路径下</p>\n<p>单独建一个文件夹存放摘要图片，</p>\n<p>这个图片和文章中插图的存放路径不同，不是一个概念</p>\n<p>。然后在文章YAML头信息中添加images字段，将值填为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;images&#x2F;imagename.jpg<br></code></pre></td></tr></table></figure>\n<p>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">images: &quot;images&#x2F;文章摘要配图&#x2F;Win10桌面.png&quot;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-13-给页面、侧边栏添加背景图片\"><a href=\"#4-13-给页面、侧边栏添加背景图片\" class=\"headerlink\" title=\"4.13 给页面、侧边栏添加背景图片\"></a>4.13 给页面、侧边栏添加背景图片</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">body &#123;<br>  background: url(&#x2F;images&#x2F;blogbk.jpg) no-repeat;<br>  &#x2F;* 背景图垂直、水平均居中 *&#x2F;<br>  background-position: center center;<br>  &#x2F;* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 *&#x2F;<br>  background-attachment: fixed;<br>  &#x2F;* 让背景图基于容器大小伸缩 *&#x2F;<br>  background-size: cover;<br>  &#x2F;* 设置背景颜色，背景图加载过程中会显示背景色 *&#x2F;<br>  background-color: rgba(0, 0, 0, 0.5);<br>&#125;<br>.sidebar &#123;<br>            background:url(&#x2F;images&#x2F;sidebar.jpg);<br>            background-size: cover;<br>            background-position:center;<br>            background-repeat:no-repeat;<br>            p,span,a &#123;color: rgba(255, 255, 255, 1);&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-14-文字背景以及半透明的设置\"><a href=\"#4-14-文字背景以及半透明的设置\" class=\"headerlink\" title=\"4.14 文字背景以及半透明的设置\"></a>4.14 文字背景以及半透明的设置</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">.content &#123;<br>\tborder-radius: 20px; &#x2F;&#x2F;文章背景设置圆角<br>\tpadding: 30px 60px 30px 60px;<br>\tbackground:rgba(255, 255, 255, 0.8) none repeat scroll !important;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-15-去除NexT主题Markdown分割线渲染效果\"><a href=\"#4-15-去除NexT主题Markdown分割线渲染效果\" class=\"headerlink\" title=\"4.15 去除NexT主题Markdown分割线渲染效果\"></a>4.15 去除NexT主题Markdown分割线渲染效果</h2><p>修改<code>/source/css/_common/scaffolding/base.styl</code>，注释或删除以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">background-image: repeating-linear-gradient(<br>    -45deg,<br>    white,<br>    white 4px,<br>    transparent 4px,<br>    transparent 8px<br>  );<br>1234567<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-16-图片可点击放大查看，放大后可关闭\"><a href=\"#4-16-图片可点击放大查看，放大后可关闭\" class=\"headerlink\" title=\"4.16 图片可点击放大查看，放大后可关闭\"></a>4.16 图片可点击放大查看，放大后可关闭</h2><ul>\n<li>打开站点配置文件<code>_config.yml</code>，搜索<code>fancybox</code>字段，设置其值为<code>true</code></li>\n<li>进入到<code>theme/text/</code>文件夹下，打开<code>git bash</code></li>\n<li><code>git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox</code></li>\n</ul>\n<hr>\n<h2 id=\"4-17-博客总访问量统计\"><a href=\"#4-17-博客总访问量统计\" class=\"headerlink\" title=\"4.17 博客总访问量统计\"></a>4.17 博客总访问量统计</h2><ul>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure>\n<p>下的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">_config.yml<br></code></pre></td></tr></table></figure>\n<p>，查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">busuanzi<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">busuanzi_count:<br>  enable: true<br>  total_visitors: false<br>  total_visitors_icon: user<br>  total_views: false<br>  total_views_icon: eye<br>  post_views: true<br>  post_views_icon: eye<br></code></pre></td></tr></table></figure>\n<p>当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动</p>\n</li>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig<br></code></pre></td></tr></table></figure>\n<p>，在最后添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;<br>  本站访问次数：&lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;<br>&lt;&#x2F;span&gt;<br></code></pre></td></tr></table></figure>\n<h2 id=\"4-18-文章末尾添加版权声明\"><a href=\"#4-18-文章末尾添加版权声明\" class=\"headerlink\" title=\"4.18 文章末尾添加版权声明\"></a>4.18 文章末尾添加版权声明</h2></li>\n</ul>\n<p><strong>效果：</strong><br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdn.net/2018062323493260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTM0NTM4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"><br><strong>配置：</strong><br>查找主题配置文件<code>themes/next/_config.yml</code>中的<code>creative_commons</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">creative_commons:<br>  license: by-nc-sa<br>  sidebar: false<br>  post: true  # 将false改为true即可显示版权信息<br>  language:<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-19-本地搜索（其余搜索方案的劣势只有收费）\"><a href=\"#4-19-本地搜索（其余搜索方案的劣势只有收费）\" class=\"headerlink\" title=\"4.19 本地搜索（其余搜索方案的劣势只有收费）\"></a>4.19 本地搜索（其余搜索方案的劣势只有收费）</h2><ul>\n<li><p><code>npm install hexo-generator-search</code></p>\n</li>\n<li><p>查找主题配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;_config.yml<br></code></pre></td></tr></table></figure>\n<p>中的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">local_search<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">local_search:<br>  enable: true<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h2 id=\"4-20-图床和上传工具\"><a href=\"#4-20-图床和上传工具\" class=\"headerlink\" title=\"4.20 图床和上传工具\"></a>4.20 图床和上传工具</h2><p><a href=\"https://zhuanlan.zhihu.com/p/35270383\">盘点一下免费好用的图床</a></p>\n<h2 id=\"4-21-文章置顶\"><a href=\"#4-21-文章置顶\" class=\"headerlink\" title=\"4.21 文章置顶\"></a>4.21 文章置顶</h2><p><a href=\"http://wangwlj.com/2018/01/09/blog_pin_post/\">Hexo博客彻底解决置顶问题</a><br>效果：<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20190329140445995.png\" alt=\"在这里插入图片描述\"><br>注：若有多篇文章需要置顶，排序方式为 在需要置顶的文章的<code>Front-matter</code>的<code>top:</code>填写阿拉伯数字即可，数越大，排序越靠前。</p>\n<h2 id=\"4-22-添加粒子时钟\"><a href=\"#4-22-添加粒子时钟\" class=\"headerlink\" title=\"4.22 添加粒子时钟\"></a>4.22 添加粒子时钟</h2><p>博客应用canvas粒子时钟的操作步骤：</p>\n<p>在<code>\\themes\\next\\layout\\_custom\\</code>目录下，新建<code>clock.swig</code>文件，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&lt;div style&#x3D;&quot;&quot;&gt;<br>  &lt;canvas id&#x3D;&quot;canvas&quot; style&#x3D;&quot;width:60%;&quot;&gt;当前浏览器不支持canvas，请更换浏览器后再试&lt;&#x2F;canvas&gt;<br>&lt;&#x2F;div&gt;<br>&lt;script&gt;<br>(function()&#123;<br><br>   var digit&#x3D;<br>    [<br>        [<br>            [0,0,1,1,1,0,0],<br>            [0,1,1,0,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,0,1,1,0],<br>            [0,0,1,1,1,0,0]<br>        ],&#x2F;&#x2F;0<br>        [<br>            [0,0,0,1,1,0,0],<br>            [0,1,1,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [1,1,1,1,1,1,1]<br>        ],&#x2F;&#x2F;1<br>        [<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,1,1,0,0,0,0],<br>            [1,1,0,0,0,0,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,1,1,1,1,1]<br>        ],&#x2F;&#x2F;2<br>        [<br>            [1,1,1,1,1,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;3<br>        [<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,1,0],<br>            [0,0,1,1,1,1,0],<br>            [0,1,1,0,1,1,0],<br>            [1,1,0,0,1,1,0],<br>            [1,1,1,1,1,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,1,1]<br>        ],&#x2F;&#x2F;4<br>        [<br>            [1,1,1,1,1,1,1],<br>            [1,1,0,0,0,0,0],<br>            [1,1,0,0,0,0,0],<br>            [1,1,1,1,1,1,0],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;5<br>        [<br>            [0,0,0,0,1,1,0],<br>            [0,0,1,1,0,0,0],<br>            [0,1,1,0,0,0,0],<br>            [1,1,0,0,0,0,0],<br>            [1,1,0,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;6<br>        [<br>            [1,1,1,1,1,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,0,1,1,0,0,0]<br>        ],&#x2F;&#x2F;7<br>        [<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;8<br>        [<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,1,1,0,0,0,0]<br>        ],&#x2F;&#x2F;9<br>        [<br>            [0,0,0,0,0,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,0,0,0,0,0],<br>            [0,0,0,0,0,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,0,0,0,0,0]<br>        ]&#x2F;&#x2F;:<br>    ];<br><br>var canvas &#x3D; document.getElementById(&#39;canvas&#39;);<br><br>if(canvas.getContext)&#123;<br>    var cxt &#x3D; canvas.getContext(&#39;2d&#39;);<br>    &#x2F;&#x2F;声明canvas的宽高<br>    var H &#x3D; 100,W &#x3D; 700;<br>    canvas.height &#x3D; H;<br>    canvas.width &#x3D; W;<br>    cxt.fillStyle &#x3D; &#39;#f00&#39;;<br>    cxt.fillRect(10,10,50,50);<br><br>    &#x2F;&#x2F;存储时间数据<br>    var data &#x3D; [];<br>    &#x2F;&#x2F;存储运动的小球<br>    var balls &#x3D; [];<br>    &#x2F;&#x2F;设置粒子半径<br>    var R &#x3D; canvas.height&#x2F;20-1;<br>    (function()&#123;<br>        var temp &#x3D; &#x2F;(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)&#x2F;.exec(new Date());<br>        &#x2F;&#x2F;存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成<br>        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);<br>    &#125;)();<br><br>    &#x2F;*生成点阵数字*&#x2F;<br>    function renderDigit(index,num)&#123;<br>        for(var i &#x3D; 0; i &lt; digit[num].length; i++)&#123;<br>            for(var j &#x3D; 0; j &lt; digit[num][i].length; j++)&#123;<br>                if(digit[num][i][j] &#x3D;&#x3D; 1)&#123;<br>                    cxt.beginPath();<br>                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);<br>                    cxt.closePath();<br>                    cxt.fill();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    &#x2F;*更新时钟*&#x2F;<br>    function updateDigitTime()&#123;<br>        var changeNumArray &#x3D; [];<br>        var temp &#x3D; &#x2F;(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)&#x2F;.exec(new Date());<br>        var NewData &#x3D; [];<br>        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);<br>        for(var i &#x3D; data.length-1; i &gt;&#x3D;0 ; i--)&#123;<br>            &#x2F;&#x2F;时间发生变化<br>            if(NewData[i] !&#x3D;&#x3D; data[i])&#123;<br>                &#x2F;&#x2F;将变化的数字值和在data数组中的索引存储在changeNumArray数组中<br>                changeNumArray.push(i+&#39;_&#39;+(Number(data[i])+1)%10);<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;增加小球<br>        for(var i &#x3D; 0; i&lt; changeNumArray.length; i++)&#123;<br>            addBalls.apply(this,changeNumArray[i].split(&#39;_&#39;));<br>        &#125;<br>        data &#x3D; NewData.concat();<br>    &#125;<br><br>    &#x2F;*更新小球状态*&#x2F;<br>    function updateBalls()&#123;<br>        for(var i &#x3D; 0; i &lt; balls.length; i++)&#123;<br>            balls[i].stepY +&#x3D; balls[i].disY;<br>            balls[i].x +&#x3D; balls[i].stepX;<br>            balls[i].y +&#x3D; balls[i].stepY;<br>            if(balls[i].x &gt; W + R || balls[i].y &gt; H + R)&#123;<br>                balls.splice(i,1);<br>                i--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    &#x2F;*增加要运动的小球*&#x2F;<br>    function addBalls(index,num)&#123;<br>        var numArray &#x3D; [1,2,3];<br>        var colorArray &#x3D;  [&quot;#3BE&quot;,&quot;#09C&quot;,&quot;#A6C&quot;,&quot;#93C&quot;,&quot;#9C0&quot;,&quot;#690&quot;,&quot;#FB3&quot;,&quot;#F80&quot;,&quot;#F44&quot;,&quot;#C00&quot;];<br>        for(var i &#x3D; 0; i &lt; digit[num].length; i++)&#123;<br>            for(var j &#x3D; 0; j &lt; digit[num][i].length; j++)&#123;<br>                if(digit[num][i][j] &#x3D;&#x3D; 1)&#123;<br>                    var ball &#x3D; &#123;<br>                        x:14*(R+2)*index + j*2*(R+1)+(R+1),<br>                        y:i*2*(R+1)+(R+1),<br>                        stepX:Math.floor(Math.random() * 4 -2),<br>                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],<br>                        color:colorArray[Math.floor(Math.random()*colorArray.length)],<br>                        disY:1<br>                    &#125;;<br>                    balls.push(ball);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    &#x2F;*渲染*&#x2F;<br>    function render()&#123;<br>        &#x2F;&#x2F;重置画布宽度，达到清空画布的效果<br>        canvas.height &#x3D; 100;<br>        &#x2F;&#x2F;渲染时钟<br>        for(var i &#x3D; 0; i &lt; data.length; i++)&#123;<br>            renderDigit(i,data[i]);<br>        &#125;<br>        &#x2F;&#x2F;渲染小球<br>        for(var i &#x3D; 0; i &lt; balls.length; i++)&#123;<br>            cxt.beginPath();<br>            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);<br>            cxt.fillStyle &#x3D; balls[i].color;<br>            cxt.closePath();<br>            cxt.fill();<br>        &#125;<br>    &#125;<br><br>    clearInterval(oTimer);<br>    var oTimer &#x3D; setInterval(function()&#123;<br>        &#x2F;&#x2F;更新时钟<br>        updateDigitTime();<br>        &#x2F;&#x2F;更新小球状态<br>        updateBalls();<br>        &#x2F;&#x2F;渲染<br>        render();<br>    &#125;,50);<br>&#125;<br><br>&#125;)();<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>引用代码</li>\n</ul>\n<p>直接引用或者通过配置文件配置，二选一</p>\n<ul>\n<li>直接引用</li>\n</ul>\n<p>在<code>博客目录\\themes\\next\\layout\\_macro\\sidebar.swig</code>尾部中引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% include &#39;..&#x2F;_custom&#x2F;clock.swig&#39; %&#125;<br></code></pre></td></tr></table></figure>\n<p>示意图如下：<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9jay5wbmc?x-oss-process=image/format,png\" alt=\"img\"></p>\n<blockquote>\n<p>注：代码块要放置在<code>sider-inner</code>的<code>div</code>块中，放在<code>div</code>块的位置决定时钟样式的展示位置。我选择放置在尾部，看着效果好点。</p>\n</blockquote>\n<ul>\n<li>通过配置文件配置</li>\n</ul>\n<p>1、在<code>博客目录\\themes\\next\\layout\\_macro\\sidebar.swig</code>尾部中引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if theme.diy_time.clock %&#125;<br>  &lt;!-- canvas粒子时钟 --&gt;<br>  &#123;% include &#39;..&#x2F;_custom&#x2F;clock.swig&#39; %&#125;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure>\n<p>示意图如下：<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9ja19pZi5wbmc?x-oss-process=image/format,png\" alt=\"img\"></p>\n<blockquote>\n<p>注：代码块要放置在<code>sider-inner</code>的<code>div</code>块中，放在<code>div</code>块的位置决定时钟样式的展示位置。</p>\n</blockquote>\n<p>2、在主题的配置文件中加入应用代码，配置文件位置是<code>博客目录\\themes\\next\\_config.yml</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># 侧栏粒子时钟<br>diy_time:<br>  runtime: true <br>  clock: true # 粒子时钟<br></code></pre></td></tr></table></figure>\n<h2 id=\"4-23-添加近期文章\"><a href=\"#4-23-添加近期文章\" class=\"headerlink\" title=\"4.23 添加近期文章\"></a>4.23 添加近期文章</h2><p>添加配置参数 <strong>~/theme/next/_config.yml</strong> ，添加如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">recent_posts:<br>  enable: true<br>  recent_posts_title: 最新发表文章<br></code></pre></td></tr></table></figure>\n<p>首先我们找到侧边栏模块 <strong>next/layout/_macro/sidebar.swig</strong> ,这个负责渲染侧边栏<br>在我们想要放置<strong>最新文章模块</strong>的地方添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if theme.recent_posts.enable %&#125;<br>  &lt;aside class&#x3D;&quot;sidebar sidebar-ads sidebar-posts&quot;&gt;<br>    &lt;div&gt;<br>      &lt;div class&#x3D;&quot;recent_posts_title&quot;&gt;<br>        &#123;&#123; theme.recent_posts.recent_posts_title &#125;&#125;<br>      &lt;&#x2F;div&gt;<br>      &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;<br>        &#123;% set posts &#x3D; site.posts.sort(&#39;-date&#39;) %&#125;<br>        &#123;% set bg_colors &#x3D; [&#39;rgb(31, 216, 210)&#39;, &#39;rgb(4, 166, 247)&#39;, &#39;rgb(70, 101, 226)&#39;, &#39;rgb(94, 137, 229)&#39;, &#39;rgb(0, 206, 123)&#39;] %&#125;<br>        &#123;% for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;<br>          &lt;li&gt;<br>            &lt;div class&#x3D;&quot;text-img&quot; style&#x3D;&quot;background:&#123;&#123;bg_colors[loop.index - 1]&#125;&#125;;&quot;&gt;&#123;&#123; post.title.substr(0, 3) &#125;&#125;&lt;&#x2F;div&gt;<br>            &lt;div class&#x3D;&quot;post-name&quot;&gt;<br>              &lt;div&gt;&#123;&#123; date(post.date, config.date_format) &#125;&#125;&lt;&#x2F;div&gt;<br>              &lt;div&gt;&lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; &gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;<br>            &lt;&#x2F;div&gt;<br>          &lt;&#x2F;li&gt;<br>        &#123;% endfor %&#125;<br>      &lt;&#x2F;ul&gt;<br>    &lt;&#x2F;div&gt;<br>  &lt;&#x2F;aside&gt;<br>  &#123;% endif %&#125;<br></code></pre></td></tr></table></figure>\n<p>最后重新执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">hexo clean<br>hexo g<br></code></pre></td></tr></table></figure>\n\n\n<p>最后我们得到的效果是</p>\n<h2 id=\"Google统计\"><a href=\"#Google统计\" class=\"headerlink\" title=\"Google统计\"></a>Google统计</h2><h2 id=\"Sitemap网站地图\"><a href=\"#Sitemap网站地图\" class=\"headerlink\" title=\"Sitemap网站地图\"></a>Sitemap网站地图</h2><h2 id=\"提交谷歌收录本站-Google-Search\"><a href=\"#提交谷歌收录本站-Google-Search\" class=\"headerlink\" title=\"提交谷歌收录本站 Google Search\"></a>提交谷歌收录本站 Google Search</h2><h2 id=\"文章阅读量统计\"><a href=\"#文章阅读量统计\" class=\"headerlink\" title=\"文章阅读量统计\"></a><a href=\"https://blog.csdn.net/weixin_39345384/article/details/80787998\">文章阅读量统计</a></h2><hr>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://mashirosorata.vicp.io/HEXO-NEXT主题个性化配置.html\">HEXO+NEXT主题个性化配置</a></li>\n<li><a href=\"https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html\">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li>\n<li><a href=\"https://juejin.im/post/5c45a503f265da616b10fe4e#heading-28\">[EasyHexo 专栏] #2 - 魔改 Next 不完全教程</a></li>\n<li><a href=\"https://blog.csdn.net/MasterAnt_D/article/details/56839222#t50\">基于Hexo+Node.js+github+coding搭建个人博客——进阶篇(从入门到入土)</a></li>\n<li><a href=\"http://www.shaoyance.com/2018/01/26/Hexo博客Next主题优化总结/\">Hexo博客Next主题优化总结</a></li>\n<li><a href=\"https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html\">为NexT主题添加文章阅读量统计功能</a></li>\n<li><a href=\"http://www.cduyzh.com/hexo-settings-3/\">2017年最新基于hexo搭建个人免费博客——自定义页面样式一</a></li>\n<li><a href=\"https://notes.doublemine.me/2015-06-29-Hexo添加文章时自动打开编辑器.html\">Hexo添加文章时自动打开编辑器</a></li>\n<li><a href=\"https://blog.yleao.com/2018/0901/hexo-next主题下的美化.html#next主题下点击侧边栏头像回到博客首页\">next主题下点击侧边栏头像回到博客首页</a></li>\n<li><a href=\"https://reuixiy.github.io/beautiful/share/2018/12/11/noto-serif-sc-added-on-google-fonts.html\">Google Fonts 已支持思源宋体！</a></li>\n<li><a href=\"https://www.bluelzy.com/articles/change_to_next_theme.html\">弃暗投明-Hexo更换next主题</a></li>\n<li><a href=\"https://www.feiwuuz.com.cn/archives/5483aa06.html\">hexo博客NEXT主题美化</a></li>\n<li><a href=\"http://chant00.com/2015/11/04/在hexo博客中插入图片，音乐，视屏，公式/\">在hexo博客中插入图片，音乐，视频</a></li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>前文：<a href=\"https://blog.csdn.net/weixin_39345384/article/details/80095883\">Windows下通过GitHub+Hexo搭建个人博客的步骤</a>；<br>博主的个人博客：<a href=\"https://hunter1023.github.io/\">https://hunter1023.github.io/</a> 按照本篇博客美化。</p>\n<p>在 Hexo 中有<strong>2份</strong>主要的配置文件，其名称都是<code>_config.yml</code>。 其中，一份位于<strong>博客根目录下</strong>，主要包含 <strong>Hexo 本身的配置</strong>；另一份位于<code>themes/next/</code>目录下，用于配置<strong>主题相关的选项</strong>。</p>\n<hr>\n<h1 id=\"2-基础设置\"><a href=\"#2-基础设置\" class=\"headerlink\" title=\"2. 基础设置\"></a>2. 基础设置</h1><h2 id=\"2-1-设置站点名、作者昵称和站点描述等内容\"><a href=\"#2-1-设置站点名、作者昵称和站点描述等内容\" class=\"headerlink\" title=\"2.1 设置站点名、作者昵称和站点描述等内容\"></a>2.1 设置站点名、作者昵称和站点描述等内容</h2><p>打开<strong>根目录下的<code>_config.yml</code></strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># Site<br>title: 特叔服务<br>subtitle: <br>keywords:<br>author: Hunter<br>description: Tough times never last, but tough people do.<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2-2-NexT主题的安装\"><a href=\"#2-2-NexT主题的安装\" class=\"headerlink\" title=\"2.2. NexT主题的安装\"></a>2.2. NexT主题的安装</h2><p>顾名思义，所谓主题就是界面的展示样式。Hexo安装主题，只需要将主题文件拷贝至博客所在目录的<code>themes</code>目录下，修改相关配置文件即可生效。</p>\n<p>博客所在目录下打开<code>git bash</code>，再通过<code>Git clone https://github.com/theme-next/hexo-theme-next themes/next</code>即可完成。</p>\n<hr>\n<h2 id=\"2-3-启用主题\"><a href=\"#2-3-启用主题\" class=\"headerlink\" title=\"2.3 启用主题\"></a>2.3 启用主题</h2><p>打开<strong>根目录下的<code>_config.yml</code></strong>,查找<code>theme</code>字段，将字段改为<code>theme: next</code>(<strong>冒号<code>:</code>之后要有空格分隔，否则无效</strong>) ，之后通过<code>hexo g</code>和<code>hexo s</code>，再在浏览器中访问<code>localhost:4000</code>即可本地预览主题效果。</p>\n<hr>\n<h1 id=\"3-主题设定\"><a href=\"#3-主题设定\" class=\"headerlink\" title=\"3. 主题设定\"></a>3. 主题设定</h1><h2 id=\"3-1-选择scheme\"><a href=\"#3-1-选择scheme\" class=\"headerlink\" title=\"3.1 选择scheme\"></a>3.1 选择scheme</h2><p>打开<code>themes/next/</code>下的<code>_config.yml</code>,查找<code>scheme</code>，可以看到如下四种不同的风格方案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">scheme: Muse<br>#scheme: Mist<br>#scheme: Pisces<br>#scheme: Gemini<br></code></pre></td></tr></table></figure>\n<p>去掉<code>#</code>注释，即启用对应的scheme，博主采用Muse主题，大家可以依次测试效果，选择自己喜欢的scheme。</p>\n<hr>\n<h2 id=\"3-2-设置语言\"><a href=\"#3-2-设置语言\" class=\"headerlink\" title=\"3.2 设置语言\"></a>3.2 设置语言</h2><p>博客框架默认的语言是英文，前往<code>/themes/next/languages</code>，查看当前NexT版本简体中文对照文件的名称是<code>zh-Hans</code>还是<code>zh-CN</code>。</p>\n<p>再前往根目录下的<code>_config.yml</code>，查找<code>language</code>，设置成<code>language: zh-Hans</code>或<code>language: zh-CN</code>，即显示简体中文。</p>\n<hr>\n<h2 id=\"3-3-设置菜单及对应页面\"><a href=\"#3-3-设置菜单及对应页面\" class=\"headerlink\" title=\"3.3 设置菜单及对应页面\"></a>3.3 设置菜单及对应页面</h2><ul>\n<li><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>menu</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">menu:<br>  home: &#x2F; || home<br>  #about: &#x2F;about&#x2F; || user<br>  tags: &#x2F;tags&#x2F; || tags<br>  categories: &#x2F;categories&#x2F; || th<br>  archives: &#x2F;archives&#x2F; || archive<br>  #schedule: &#x2F;schedule&#x2F; || calendar<br>  #sitemap: &#x2F;sitemap.xml || sitemap<br>  #commonweal: &#x2F;404&#x2F; || heartbeat<br></code></pre></td></tr></table></figure>\n<p>去掉<code>#</code>注释即可显示对应的菜单项，也可自定义新的菜单项。 <code>||</code>之前的值是目标链接，之后的是分类页面的图标，图标名称来自于FontAwesome icon。若没有配置图标，默认会使用问号图标。</p>\n</li>\n<li><p>新添加的菜单需要翻译对应的中文<br>打开<code>hexo/theme/next/languages/zh-CN.yml</code>，在menu下自定义，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">menu:<br>  resources: 资源<br></code></pre></td></tr></table></figure></li>\n<li><p><code>hexo new page &quot;categories&quot;</code><br>此时在根目录的<code>source</code>文件夹下会生成一个categories文件，文件中有一个<code>index.md</code>文件，修改内容如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">---<br>title: 分类<br>date: 2017-12-14 13:05:38<br>type: &quot;categories&quot;<br>comments: false<br>---<br></code></pre></td></tr></table></figure>\n<p>注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-4-设定站点建立时间\"><a href=\"#3-4-设定站点建立时间\" class=\"headerlink\" title=\"3.4 设定站点建立时间\"></a>3.4 设定站点建立时间</h2><p>打开<strong><code>themes/next/</code>下的<code>_config.yml</code></strong>，查找<code>since</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">footer:<br>  # Specify the date when the site was setup.<br>  # If not defined, current year will be used.<br>  #since: 2015<br></code></pre></td></tr></table></figure>\n<p><strong>如果不设置，默认显示当前年份</strong>。</p>\n<hr>\n<h1 id=\"4-美化\"><a href=\"#4-美化\" class=\"headerlink\" title=\"4. 美化\"></a>4. 美化</h1><h2 id=\"4-1-设置头像\"><a href=\"#4-1-设置头像\" class=\"headerlink\" title=\"4.1 设置头像\"></a>4.1 设置头像</h2><p>打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>avatar</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># Sidebar Avatar<br># in theme directory(source&#x2F;images): &#x2F;images&#x2F;avatar.gif<br># in site  directory(source&#x2F;uploads): &#x2F;uploads&#x2F;avatar.gif<br>avatar: http:&#x2F;&#x2F;XXXXXXXXX<br></code></pre></td></tr></table></figure>\n<p><code>avatar</code>的值是<strong>图片的链接地址</strong>(完整的URI 或者 站内的相对地址皆可)</p>\n<table>\n<thead>\n<tr>\n<th>地址</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>完整的URI</td>\n<td><a href=\"http://example.com/avatar.png\">http://example.com/avatar.png</a></td>\n</tr>\n<tr>\n<td>站点内地址</td>\n<td>图片放至<code>themes/next/source/images/</code>配置为：<code>avatar: /images/图片名</code></td>\n</tr>\n<tr>\n<td>站点内地址</td>\n<td>图片放至<strong>根目录下</strong><code>source/uploads/</code>(初始无uploads文件夹，自行创建)目录下配置为：<code>avatar: /uploads/图片名</code></td>\n</tr>\n</tbody></table>\n<p><strong>之后创建博文，对图片的引用 同样可以按照上述地址获取</strong>。</p>\n<hr>\n<h2 id=\"4-2-网站图标设置\"><a href=\"#4-2-网站图标设置\" class=\"headerlink\" title=\"4.2 网站图标设置\"></a>4.2 网站图标设置</h2><ul>\n<li><p>图标素材网站：<a href=\"https://www.iconfont.cn/\">iconfont</a>；<a href=\"https://www.easyicon.net/\">easyicon</a></p>\n</li>\n<li><p>下载16x16以及32x32大小的<strong>PNG格式图标</strong>，置于<code>/themes/next/source/images/</code>下</p>\n</li>\n<li><p>打开**</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure>\n<p>下的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">_config.yml<br></code></pre></td></tr></table></figure>\n<p>**，查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">favicon<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">favicon:<br>  small: &#x2F;images&#x2F;favicon-16x16-next.png<br>  medium: &#x2F;images&#x2F;favicon-32x32-next.png<br>  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png<br>  safari_pinned_tab: &#x2F;images&#x2F;logo.svg<br>  #android_manifest: &#x2F;images&#x2F;manifest.json<br>  #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml<br></code></pre></td></tr></table></figure>\n<p>修改small和medium的路径为下载的图标路径</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"4-3-背景动画\"><a href=\"#4-3-背景动画\" class=\"headerlink\" title=\"4.3 背景动画\"></a>4.3 背景动画</h2><h3 id=\"4-3-1-Canvas-nest风格\"><a href=\"#4-3-1-Canvas-nest风格\" class=\"headerlink\" title=\"4.3.1 Canvas-nest风格\"></a>4.3.1 <a href=\"https://blog.csdn.net/weixin_39345384/article/details/80544660\">Canvas-nest风格</a></h3><h3 id=\"4-3-2-JavaScript-3D-library风格\"><a href=\"#4-3-2-JavaScript-3D-library风格\" class=\"headerlink\" title=\"4.3.2 JavaScript 3D library风格\"></a>4.3.2 JavaScript 3D library风格</h3><ol>\n<li>进入theme/next目录</li>\n<li>执行命令：<code>git clone https://github.com/theme-next/theme-next-three source/lib/three</code></li>\n<li>将<code>themes/next/_config.yml</code>中查找<code>theme-next-three</code>，将想要的效果改为true即可：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># three_waves<br>three_waves: false<br># canvas_lines<br>canvas_lines: true<br># canvas_sphere<br>canvas_sphere: false<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-4-背景图片-顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色\"><a href=\"#4-4-背景图片-顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色\" class=\"headerlink\" title=\"4.4 背景图片/顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色\"></a>4.4 背景图片/顶栏、底栏图片（背景色）、侧栏背景及内部文字颜色</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;&#x2F;背景图片<br>body&#123;   <br>        background:url(图片链接);<br>        background-size:cover;<br>        background-repeat:no-repeat;<br>        background-attachment:fixed;<br>        background-position:center;<br>&#125;<br>&#x2F;&#x2F;顶栏图片<br>.header &#123;<br>          background:url(图片链接) none repeat scroll !important;<br>&#125;<br>&#x2F;&#x2F;底栏背景色<br>.footer &#123;<br>          background:rgba(颜色rgb,透明度) none repeat scroll !important;<br>&#125;<br>&#x2F;&#x2F;侧栏图片及内部文字颜色修改<br>#sidebar &#123;<br>            background:url(图片链接);<br>            background-size: cover;<br>            background-position:center;<br>            background-repeat:no-repeat;<br>            p,span,a &#123;color: 颜色代码;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其中的css样式属性都可以根据图片修改，以达到满意的效果。</p>\n<hr>\n<h2 id=\"4-5-侧栏置于左侧，修改控制按钮样式\"><a href=\"#4-5-侧栏置于左侧，修改控制按钮样式\" class=\"headerlink\" title=\"4.5 侧栏置于左侧，修改控制按钮样式\"></a>4.5 侧栏置于左侧，修改控制按钮样式</h2><p>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。打开<code>themes/next/</code>下的<code>_config.yml</code>，查找<code>sidebar</code></p>\n<h3 id=\"4-5-1-设置侧栏在左侧-右侧\"><a href=\"#4-5-1-设置侧栏在左侧-右侧\" class=\"headerlink\" title=\"4.5.1 设置侧栏在左侧/右侧\"></a>4.5.1 设置侧栏在左侧/右侧</h3><ul>\n<li><p>Pisces或Gemini方案</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">sidebar:<br>position: left<br>#position: right<br></code></pre></td></tr></table></figure></li>\n<li><p>Mist或Muse方案</p>\n</li>\n</ul>\n<ol>\n<li><p>打开<code>next/source/js/src/motion.js</code>，查找<code>paddingRight</code>，把所有（2个）<code>PaddingRight</code>更改为<code>paddingLeft</code>即可。</p>\n</li>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">next&#x2F;source&#x2F;css&#x2F;_custom&#x2F;custom.styl<br></code></pre></td></tr></table></figure>\n<p>，添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;&#x2F;侧边栏置于左侧<br>.sidebar &#123;<br>  left: 0;<br>&#125;<br>&#x2F;&#x2F;侧栏开关置于左侧<br>.sidebar-toggle &#123;<br>  left: $b2t-position-right;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>打开<code>next/source/css/_common/components/back-to-top.styl</code>，将<code>right: $b2t-position-right;</code>改为<code>left: $b2t-position-right;</code></p>\n</li>\n</ol>\n<h3 id=\"4-5-2-显示侧边栏的时机\"><a href=\"#4-5-2-显示侧边栏的时机\" class=\"headerlink\" title=\"4.5.2 显示侧边栏的时机\"></a>4.5.2 显示侧边栏的时机</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">#post - 默认行为，在文章页面（拥有目录列表）时显示<br>#always - 在所有页面中都显示<br>#hide - 在所有页面中都隐藏（可以手动展开）<br>#remove - 完全移除<br>display: post<br>#display: always<br>#display: hide<br>#display: remove<br></code></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"4-5-3-侧边栏控制按钮样式修改\"><a href=\"#4-5-3-侧边栏控制按钮样式修改\" class=\"headerlink\" title=\"4.5.3 侧边栏控制按钮样式修改\"></a>4.5.3 侧边栏控制按钮样式修改</h3><p>打开<code>themes/next/layout/source/js/src/motion.js</code>，找到如下代码处，更换close的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">var sidebarToggleLine1st &#x3D; new SidebarToggleLine(&#123;<br>    el: &#39;.sidebar-toggle-line-first&#39;,<br>    status: &#123;<br>      arrow: &#123;width: &#39;50%&#39;, rotateZ: &#39;45deg&#39;, top: &#39;2px&#39;, left: &#39;6px&#39;&#125;,<br>      &#x2F;&#x2F; close: &#123;width: &#39;100%&#39;, rotateZ: &#39;-45deg&#39;, top: &#39;5px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;X形<br>      close: &#123;width: &#39;50%&#39;, rotateZ: &#39;-45deg&#39;, top: &#39;2px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;箭头形<br>    &#125;<br>  &#125;);<br>  var sidebarToggleLine2nd &#x3D; new SidebarToggleLine(&#123;<br>    el: &#39;.sidebar-toggle-line-middle&#39;,<br>    status: &#123;<br>      arrow: &#123;width: &#39;90%&#39;&#125;,<br>      &#x2F;&#x2F; close: &#123;opacity: 0&#125; &#x2F;&#x2F;X形<br>      close: &#123;width: &#39;90%&#39;&#125; &#x2F;&#x2F;箭头形<br>    &#125;<br>  &#125;);<br>  var sidebarToggleLine3rd &#x3D; new SidebarToggleLine(&#123;<br>    el: &#39;.sidebar-toggle-line-last&#39;,<br>    status: &#123;<br>      arrow: &#123;width: &#39;50%&#39;, rotateZ: &#39;-45deg&#39;, top: &#39;-2px&#39;, left: &#39;6px&#39;&#125;,<br>      &#x2F;&#x2F; close: &#123;width: &#39;100%&#39;, rotateZ: &#39;45deg&#39;, top: &#39;-5px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;X形<br>      close: &#123;width: &#39;50%&#39;, rotateZ: &#39;45deg&#39;, top: &#39;-2px&#39;, left: &#39;0px&#39;&#125; &#x2F;&#x2F;箭头形<br>    &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-6-文章底部标签显示的优化\"><a href=\"#4-6-文章底部标签显示的优化\" class=\"headerlink\" title=\"4.6 文章底部标签显示的优化\"></a>4.6 文章底部标签显示的优化</h2><p>修改<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>\n<h2 id=\"4-7-文章添加阴影、透明效果\"><a href=\"#4-7-文章添加阴影、透明效果\" class=\"headerlink\" title=\"4.7 文章添加阴影、透明效果\"></a>4.7 文章添加阴影、透明效果</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;&#x2F; 主页文章添加阴影效果<br>.post &#123;<br>   margin-top: 60px;<br>   margin-bottom: 60px;<br>   padding: 25px;<br>   background:rgba(255,255,255,0.9) none repeat scroll !important;<br>   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);<br>   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-8-Hexo添加文章时自动打开编辑器\"><a href=\"#4-8-Hexo添加文章时自动打开编辑器\" class=\"headerlink\" title=\"4.8 Hexo添加文章时自动打开编辑器\"></a>4.8 Hexo添加文章时自动打开编辑器</h2><ul>\n<li>首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。<br>如果没有这个scripts目录，则新建一个。</li>\n<li>scripts目录新建的JavaScript脚本文件可以任意取名。</li>\n</ul>\n<p>通过这个脚本，我们用其来监听<code>hexo new</code>这个动作，并在检测到<code>hexo new</code>之后，执行编辑器打开的命令。</p>\n<ul>\n<li>如果你是windows平台的Hexo用户，则将下列内容写入你的脚本：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">var spawn &#x3D; require(&#39;child_process&#39;).exec;<br>hexo.on(&#39;new&#39;, function(data)&#123;<br>  spawn(&#39;start  &quot;markdown编辑器绝对路径.exe&quot; &#39; + data.path);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>如果你是Mac平台Hexo用户，则将下列内容写入你的脚本：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">var exec &#x3D; require(&#39;child_process&#39;).exec;<br>hexo.on(&#39;new&#39;, function(data)&#123;<br>    exec(&#39;open -a &quot;markdown编辑器绝对路径.app&quot; &#39; + data.path);<br>&#125;);<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-9-点击侧栏头像回到首页\"><a href=\"#4-9-点击侧栏头像回到首页\" class=\"headerlink\" title=\"4.9 点击侧栏头像回到首页\"></a>4.9 点击侧栏头像回到首页</h2><p>修改<code>/themes/next/layout/_macro/sidebar.swig</code>，找到如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot;<br>    src&#x3D;&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &#39;&#x2F;avatar.gif&#39;) ) &#125;&#125;&quot;<br>    alt&#x3D;&quot;&#123;&#123; theme.author &#125;&#125;&quot; &#x2F;&gt;<br></code></pre></td></tr></table></figure>\n<p>在其前后加上<code>&lt;a href=&quot;/&quot;&gt;&lt;/a&gt;</code>即可，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&lt;a href&#x3D;&quot;&#x2F;&quot;&gt;<br>   &lt;img class&#x3D;&quot;site-author-image&quot; itemprop&#x3D;&quot;image&quot;<br>       src&#x3D;&quot;&#123;&#123; url_for( theme.avatar | default(theme.images + &#39;&#x2F;avatar.gif&#39;) ) &#125;&#125;&quot;<br>       alt&#x3D;&quot;&#123;&#123; theme.author &#125;&#125;&quot; &#x2F;&gt;<br>&lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-10-修改中文字体\"><a href=\"#4-10-修改中文字体\" class=\"headerlink\" title=\"4.10 修改中文字体\"></a>4.10 修改中文字体</h2><ol>\n<li><p>前往<a href=\"https://fonts.google.com/\">Google Fonts</a>查看合适的字体</p>\n</li>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure>\n<p>下的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">_config.yml<br></code></pre></td></tr></table></figure>\n<p>，查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">font<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">font:<br>\tenable: true<br>\t # Uri of fonts host. E.g. &#x2F;&#x2F;fonts.googleapis.com (Default). 修改为墙内镜像<br>\thost: https:&#x2F;&#x2F;fonts.loli.net<br>\tglobal:<br>\t\texternal: true<br>\t\tfamily: Noto Serif SC &#x2F;&#x2F; 挑选的字体<br>\t\tsize: 16<br></code></pre></td></tr></table></figure>\n<ol>\n<li>修改<code>/themes/next/source/css/_variables/base.styl</code><br>将</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$font-family-monospace    &#x3D; consolas, Menlo, $font-family-chinese, monospace<br>$font-family-monospace    &#x3D; get_font_family(&#39;codes&#39;), consolas, Menlo, $font-family-chinese, monospace if get_font_family(&#39;codes&#39;)<br></code></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">$font-family-monospace    &#x3D; consolas, Menlo, $font-family-base, monospace<br>$font-family-monospace    &#x3D; get_font_family(&#39;codes&#39;), consolas, Menlo, $font-family-base, monospace if get_font_family(&#39;codes&#39;)<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-11-新建文章时，在相同目录下创建同名文件夹（便于图片管理）\"><a href=\"#4-11-新建文章时，在相同目录下创建同名文件夹（便于图片管理）\" class=\"headerlink\" title=\"4.11 新建文章时，在相同目录下创建同名文件夹（便于图片管理）\"></a>4.11 新建文章时，在相同目录下创建同名文件夹（便于图片管理）</h2><ul>\n<li>打开站点配置文件<code>_config.yml</code>，搜索<code>post_asset_folder</code>字段，设置其值为<code>true</code></li>\n<li>安装hexo-asset-image：<code>npm install hexo-asset-image --save</code></li>\n<li>此时<code>hexo new &quot;fileName&quot;</code>会在<code>/source/_posts</code>目录下创建同名的文件夹</li>\n<li>只需在 md 文件里使用 <code>![title](图片名.jpg)</code> ，无需路径名就可以插入图片。</li>\n</ul>\n<hr>\n<h2 id=\"4-12-首页显示文章摘要（阅读全文）及配图（文章内不重复显示）\"><a href=\"#4-12-首页显示文章摘要（阅读全文）及配图（文章内不重复显示）\" class=\"headerlink\" title=\"4.12 首页显示文章摘要（阅读全文）及配图（文章内不重复显示）\"></a>4.12 首页显示文章摘要（阅读全文）及配图（文章内不重复显示）</h2><ol>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure>\n<p>下的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">_config.yml<br></code></pre></td></tr></table></figure>\n<p>，查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">excerpt<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">auto_excerpt: &#x2F;&#x2F;自动摘录<br>  enable: true<br>  length: 150 &#x2F;&#x2F;摘录字数<br>read_more_btn: true &#x2F;&#x2F;显示全文按钮<br></code></pre></td></tr></table></figure></li>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes\\next\\layout\\_macro\\post.swig<br></code></pre></td></tr></table></figure>\n<p>，在</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if is_index %&#125;<br></code></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if post.description and theme.excerpt_description %&#125;<br></code></pre></td></tr></table></figure>\n<p>之间添加如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if post.images %&#125;<br>\t&lt;div class&#x3D;&quot;out-img-topic&quot;&gt;<br>\t\t&lt;img src&#x3D;&#123;&#123; post.images &#125;&#125; class&#x3D;&quot;img-topic&quot;&gt;<br>\t&lt;&#x2F;div&gt;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes\\next\\source\\css\\_custom\\custom.styl<br></code></pre></td></tr></table></figure>\n<p>中添加如下内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;&#x2F;文章摘要配图<br>&#x2F;&#x2F;图片外部的容器方框，限制图片大小<br>.out-img-topic &#123;<br>  display: block;<br>  max-height:500px;<br>  margin-bottom: 24px;<br>  overflow: hidden;<br>&#125;<br>&#x2F;&#x2F;图片<br>img.img-topic &#123;<br>  display: block ;<br>  margin-left: .7em;<br>  margin-right: .7em;<br>  padding: 0;<br>  float: right;<br>  clear: right;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>将摘要图片储存于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes\\next\\source\\images<br></code></pre></td></tr></table></figure>\n<p>中，建议</p>\n<p>在此路径下</p>\n<p>单独建一个文件夹存放摘要图片，</p>\n<p>这个图片和文章中插图的存放路径不同，不是一个概念</p>\n<p>。然后在文章YAML头信息中添加images字段，将值填为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;images&#x2F;imagename.jpg<br></code></pre></td></tr></table></figure>\n<p>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">images: &quot;images&#x2F;文章摘要配图&#x2F;Win10桌面.png&quot;<br></code></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"4-13-给页面、侧边栏添加背景图片\"><a href=\"#4-13-给页面、侧边栏添加背景图片\" class=\"headerlink\" title=\"4.13 给页面、侧边栏添加背景图片\"></a>4.13 给页面、侧边栏添加背景图片</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">body &#123;<br>  background: url(&#x2F;images&#x2F;blogbk.jpg) no-repeat;<br>  &#x2F;* 背景图垂直、水平均居中 *&#x2F;<br>  background-position: center center;<br>  &#x2F;* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 *&#x2F;<br>  background-attachment: fixed;<br>  &#x2F;* 让背景图基于容器大小伸缩 *&#x2F;<br>  background-size: cover;<br>  &#x2F;* 设置背景颜色，背景图加载过程中会显示背景色 *&#x2F;<br>  background-color: rgba(0, 0, 0, 0.5);<br>&#125;<br>.sidebar &#123;<br>            background:url(&#x2F;images&#x2F;sidebar.jpg);<br>            background-size: cover;<br>            background-position:center;<br>            background-repeat:no-repeat;<br>            p,span,a &#123;color: rgba(255, 255, 255, 1);&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-14-文字背景以及半透明的设置\"><a href=\"#4-14-文字背景以及半透明的设置\" class=\"headerlink\" title=\"4.14 文字背景以及半透明的设置\"></a>4.14 文字背景以及半透明的设置</h2><p>打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">.content &#123;<br>\tborder-radius: 20px; &#x2F;&#x2F;文章背景设置圆角<br>\tpadding: 30px 60px 30px 60px;<br>\tbackground:rgba(255, 255, 255, 0.8) none repeat scroll !important;<br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-15-去除NexT主题Markdown分割线渲染效果\"><a href=\"#4-15-去除NexT主题Markdown分割线渲染效果\" class=\"headerlink\" title=\"4.15 去除NexT主题Markdown分割线渲染效果\"></a>4.15 去除NexT主题Markdown分割线渲染效果</h2><p>修改<code>/source/css/_common/scaffolding/base.styl</code>，注释或删除以下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">background-image: repeating-linear-gradient(<br>    -45deg,<br>    white,<br>    white 4px,<br>    transparent 4px,<br>    transparent 8px<br>  );<br>1234567<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-16-图片可点击放大查看，放大后可关闭\"><a href=\"#4-16-图片可点击放大查看，放大后可关闭\" class=\"headerlink\" title=\"4.16 图片可点击放大查看，放大后可关闭\"></a>4.16 图片可点击放大查看，放大后可关闭</h2><ul>\n<li>打开站点配置文件<code>_config.yml</code>，搜索<code>fancybox</code>字段，设置其值为<code>true</code></li>\n<li>进入到<code>theme/text/</code>文件夹下，打开<code>git bash</code></li>\n<li><code>git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox</code></li>\n</ul>\n<hr>\n<h2 id=\"4-17-博客总访问量统计\"><a href=\"#4-17-博客总访问量统计\" class=\"headerlink\" title=\"4.17 博客总访问量统计\"></a>4.17 博客总访问量统计</h2><ul>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;<br></code></pre></td></tr></table></figure>\n<p>下的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">_config.yml<br></code></pre></td></tr></table></figure>\n<p>，查找</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">busuanzi<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">busuanzi_count:<br>  enable: true<br>  total_visitors: false<br>  total_visitors_icon: user<br>  total_views: false<br>  total_views_icon: eye<br>  post_views: true<br>  post_views_icon: eye<br></code></pre></td></tr></table></figure>\n<p>当前版本的NexT集成的不蒜子，总访问人数和人次只是分别用icon来表示，故取消显示，自行改动</p>\n</li>\n<li><p>打开</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig<br></code></pre></td></tr></table></figure>\n<p>，在最后添加如下内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot;&gt;<br>  本站访问次数：&lt;span class&#x3D;&quot;busuanzi-value&quot; id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;<br>&lt;&#x2F;span&gt;<br></code></pre></td></tr></table></figure>\n<h2 id=\"4-18-文章末尾添加版权声明\"><a href=\"#4-18-文章末尾添加版权声明\" class=\"headerlink\" title=\"4.18 文章末尾添加版权声明\"></a>4.18 文章末尾添加版权声明</h2></li>\n</ul>\n<p><strong>效果：</strong><br><img src=\"https://img-blog.csdn.net/2018062323493260?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTM0NTM4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"><br><strong>配置：</strong><br>查找主题配置文件<code>themes/next/_config.yml</code>中的<code>creative_commons</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">creative_commons:<br>  license: by-nc-sa<br>  sidebar: false<br>  post: true  # 将false改为true即可显示版权信息<br>  language:<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"4-19-本地搜索（其余搜索方案的劣势只有收费）\"><a href=\"#4-19-本地搜索（其余搜索方案的劣势只有收费）\" class=\"headerlink\" title=\"4.19 本地搜索（其余搜索方案的劣势只有收费）\"></a>4.19 本地搜索（其余搜索方案的劣势只有收费）</h2><ul>\n<li><p><code>npm install hexo-generator-search</code></p>\n</li>\n<li><p>查找主题配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">themes&#x2F;next&#x2F;_config.yml<br></code></pre></td></tr></table></figure>\n<p>中的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">local_search<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">local_search:<br>  enable: true<br></code></pre></td></tr></table></figure>\n</li>\n</ul>\n<hr>\n<h2 id=\"4-20-图床和上传工具\"><a href=\"#4-20-图床和上传工具\" class=\"headerlink\" title=\"4.20 图床和上传工具\"></a>4.20 图床和上传工具</h2><p><a href=\"https://zhuanlan.zhihu.com/p/35270383\">盘点一下免费好用的图床</a></p>\n<h2 id=\"4-21-文章置顶\"><a href=\"#4-21-文章置顶\" class=\"headerlink\" title=\"4.21 文章置顶\"></a>4.21 文章置顶</h2><p><a href=\"http://wangwlj.com/2018/01/09/blog_pin_post/\">Hexo博客彻底解决置顶问题</a><br>效果：<br><img src=\"https://img-blog.csdnimg.cn/20190329140445995.png\" alt=\"在这里插入图片描述\"><br>注：若有多篇文章需要置顶，排序方式为 在需要置顶的文章的<code>Front-matter</code>的<code>top:</code>填写阿拉伯数字即可，数越大，排序越靠前。</p>\n<h2 id=\"4-22-添加粒子时钟\"><a href=\"#4-22-添加粒子时钟\" class=\"headerlink\" title=\"4.22 添加粒子时钟\"></a>4.22 添加粒子时钟</h2><p>博客应用canvas粒子时钟的操作步骤：</p>\n<p>在<code>\\themes\\next\\layout\\_custom\\</code>目录下，新建<code>clock.swig</code>文件，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&lt;div style&#x3D;&quot;&quot;&gt;<br>  &lt;canvas id&#x3D;&quot;canvas&quot; style&#x3D;&quot;width:60%;&quot;&gt;当前浏览器不支持canvas，请更换浏览器后再试&lt;&#x2F;canvas&gt;<br>&lt;&#x2F;div&gt;<br>&lt;script&gt;<br>(function()&#123;<br><br>   var digit&#x3D;<br>    [<br>        [<br>            [0,0,1,1,1,0,0],<br>            [0,1,1,0,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,0,1,1,0],<br>            [0,0,1,1,1,0,0]<br>        ],&#x2F;&#x2F;0<br>        [<br>            [0,0,0,1,1,0,0],<br>            [0,1,1,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [1,1,1,1,1,1,1]<br>        ],&#x2F;&#x2F;1<br>        [<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,1,1,0,0,0,0],<br>            [1,1,0,0,0,0,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,1,1,1,1,1]<br>        ],&#x2F;&#x2F;2<br>        [<br>            [1,1,1,1,1,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;3<br>        [<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,1,0],<br>            [0,0,1,1,1,1,0],<br>            [0,1,1,0,1,1,0],<br>            [1,1,0,0,1,1,0],<br>            [1,1,1,1,1,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,1,1]<br>        ],&#x2F;&#x2F;4<br>        [<br>            [1,1,1,1,1,1,1],<br>            [1,1,0,0,0,0,0],<br>            [1,1,0,0,0,0,0],<br>            [1,1,1,1,1,1,0],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;5<br>        [<br>            [0,0,0,0,1,1,0],<br>            [0,0,1,1,0,0,0],<br>            [0,1,1,0,0,0,0],<br>            [1,1,0,0,0,0,0],<br>            [1,1,0,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;6<br>        [<br>            [1,1,1,1,1,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,0,1,1,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,0,1,1,0,0,0],<br>            [0,0,1,1,0,0,0]<br>        ],&#x2F;&#x2F;7<br>        [<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,1,1,0]<br>        ],&#x2F;&#x2F;8<br>        [<br>            [0,1,1,1,1,1,0],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [1,1,0,0,0,1,1],<br>            [0,1,1,1,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,0,1,1],<br>            [0,0,0,0,1,1,0],<br>            [0,0,0,1,1,0,0],<br>            [0,1,1,0,0,0,0]<br>        ],&#x2F;&#x2F;9<br>        [<br>            [0,0,0,0,0,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,0,0,0,0,0],<br>            [0,0,0,0,0,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,1,1,1,0,0],<br>            [0,0,0,0,0,0,0]<br>        ]&#x2F;&#x2F;:<br>    ];<br><br>var canvas &#x3D; document.getElementById(&#39;canvas&#39;);<br><br>if(canvas.getContext)&#123;<br>    var cxt &#x3D; canvas.getContext(&#39;2d&#39;);<br>    &#x2F;&#x2F;声明canvas的宽高<br>    var H &#x3D; 100,W &#x3D; 700;<br>    canvas.height &#x3D; H;<br>    canvas.width &#x3D; W;<br>    cxt.fillStyle &#x3D; &#39;#f00&#39;;<br>    cxt.fillRect(10,10,50,50);<br><br>    &#x2F;&#x2F;存储时间数据<br>    var data &#x3D; [];<br>    &#x2F;&#x2F;存储运动的小球<br>    var balls &#x3D; [];<br>    &#x2F;&#x2F;设置粒子半径<br>    var R &#x3D; canvas.height&#x2F;20-1;<br>    (function()&#123;<br>        var temp &#x3D; &#x2F;(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)&#x2F;.exec(new Date());<br>        &#x2F;&#x2F;存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成<br>        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);<br>    &#125;)();<br><br>    &#x2F;*生成点阵数字*&#x2F;<br>    function renderDigit(index,num)&#123;<br>        for(var i &#x3D; 0; i &lt; digit[num].length; i++)&#123;<br>            for(var j &#x3D; 0; j &lt; digit[num][i].length; j++)&#123;<br>                if(digit[num][i][j] &#x3D;&#x3D; 1)&#123;<br>                    cxt.beginPath();<br>                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);<br>                    cxt.closePath();<br>                    cxt.fill();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    &#x2F;*更新时钟*&#x2F;<br>    function updateDigitTime()&#123;<br>        var changeNumArray &#x3D; [];<br>        var temp &#x3D; &#x2F;(\\d)(\\d):(\\d)(\\d):(\\d)(\\d)&#x2F;.exec(new Date());<br>        var NewData &#x3D; [];<br>        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);<br>        for(var i &#x3D; data.length-1; i &gt;&#x3D;0 ; i--)&#123;<br>            &#x2F;&#x2F;时间发生变化<br>            if(NewData[i] !&#x3D;&#x3D; data[i])&#123;<br>                &#x2F;&#x2F;将变化的数字值和在data数组中的索引存储在changeNumArray数组中<br>                changeNumArray.push(i+&#39;_&#39;+(Number(data[i])+1)%10);<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F;增加小球<br>        for(var i &#x3D; 0; i&lt; changeNumArray.length; i++)&#123;<br>            addBalls.apply(this,changeNumArray[i].split(&#39;_&#39;));<br>        &#125;<br>        data &#x3D; NewData.concat();<br>    &#125;<br><br>    &#x2F;*更新小球状态*&#x2F;<br>    function updateBalls()&#123;<br>        for(var i &#x3D; 0; i &lt; balls.length; i++)&#123;<br>            balls[i].stepY +&#x3D; balls[i].disY;<br>            balls[i].x +&#x3D; balls[i].stepX;<br>            balls[i].y +&#x3D; balls[i].stepY;<br>            if(balls[i].x &gt; W + R || balls[i].y &gt; H + R)&#123;<br>                balls.splice(i,1);<br>                i--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    &#x2F;*增加要运动的小球*&#x2F;<br>    function addBalls(index,num)&#123;<br>        var numArray &#x3D; [1,2,3];<br>        var colorArray &#x3D;  [&quot;#3BE&quot;,&quot;#09C&quot;,&quot;#A6C&quot;,&quot;#93C&quot;,&quot;#9C0&quot;,&quot;#690&quot;,&quot;#FB3&quot;,&quot;#F80&quot;,&quot;#F44&quot;,&quot;#C00&quot;];<br>        for(var i &#x3D; 0; i &lt; digit[num].length; i++)&#123;<br>            for(var j &#x3D; 0; j &lt; digit[num][i].length; j++)&#123;<br>                if(digit[num][i][j] &#x3D;&#x3D; 1)&#123;<br>                    var ball &#x3D; &#123;<br>                        x:14*(R+2)*index + j*2*(R+1)+(R+1),<br>                        y:i*2*(R+1)+(R+1),<br>                        stepX:Math.floor(Math.random() * 4 -2),<br>                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],<br>                        color:colorArray[Math.floor(Math.random()*colorArray.length)],<br>                        disY:1<br>                    &#125;;<br>                    balls.push(ball);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    &#x2F;*渲染*&#x2F;<br>    function render()&#123;<br>        &#x2F;&#x2F;重置画布宽度，达到清空画布的效果<br>        canvas.height &#x3D; 100;<br>        &#x2F;&#x2F;渲染时钟<br>        for(var i &#x3D; 0; i &lt; data.length; i++)&#123;<br>            renderDigit(i,data[i]);<br>        &#125;<br>        &#x2F;&#x2F;渲染小球<br>        for(var i &#x3D; 0; i &lt; balls.length; i++)&#123;<br>            cxt.beginPath();<br>            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);<br>            cxt.fillStyle &#x3D; balls[i].color;<br>            cxt.closePath();<br>            cxt.fill();<br>        &#125;<br>    &#125;<br><br>    clearInterval(oTimer);<br>    var oTimer &#x3D; setInterval(function()&#123;<br>        &#x2F;&#x2F;更新时钟<br>        updateDigitTime();<br>        &#x2F;&#x2F;更新小球状态<br>        updateBalls();<br>        &#x2F;&#x2F;渲染<br>        render();<br>    &#125;,50);<br>&#125;<br><br>&#125;)();<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>引用代码</li>\n</ul>\n<p>直接引用或者通过配置文件配置，二选一</p>\n<ul>\n<li>直接引用</li>\n</ul>\n<p>在<code>博客目录\\themes\\next\\layout\\_macro\\sidebar.swig</code>尾部中引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% include &#39;..&#x2F;_custom&#x2F;clock.swig&#39; %&#125;<br></code></pre></td></tr></table></figure>\n<p>示意图如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9jay5wbmc?x-oss-process=image/format,png\" alt=\"img\"></p>\n<blockquote>\n<p>注：代码块要放置在<code>sider-inner</code>的<code>div</code>块中，放在<code>div</code>块的位置决定时钟样式的展示位置。我选择放置在尾部，看着效果好点。</p>\n</blockquote>\n<ul>\n<li>通过配置文件配置</li>\n</ul>\n<p>1、在<code>博客目录\\themes\\next\\layout\\_macro\\sidebar.swig</code>尾部中引入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if theme.diy_time.clock %&#125;<br>  &lt;!-- canvas粒子时钟 --&gt;<br>  &#123;% include &#39;..&#x2F;_custom&#x2F;clock.swig&#39; %&#125;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure>\n<p>示意图如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvYmxvZ19jbG9ja19pZi5wbmc?x-oss-process=image/format,png\" alt=\"img\"></p>\n<blockquote>\n<p>注：代码块要放置在<code>sider-inner</code>的<code>div</code>块中，放在<code>div</code>块的位置决定时钟样式的展示位置。</p>\n</blockquote>\n<p>2、在主题的配置文件中加入应用代码，配置文件位置是<code>博客目录\\themes\\next\\_config.yml</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\"># 侧栏粒子时钟<br>diy_time:<br>  runtime: true <br>  clock: true # 粒子时钟<br></code></pre></td></tr></table></figure>\n<h2 id=\"4-23-添加近期文章\"><a href=\"#4-23-添加近期文章\" class=\"headerlink\" title=\"4.23 添加近期文章\"></a>4.23 添加近期文章</h2><p>添加配置参数 <strong>~/theme/next/_config.yml</strong> ，添加如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">recent_posts:<br>  enable: true<br>  recent_posts_title: 最新发表文章<br></code></pre></td></tr></table></figure>\n<p>首先我们找到侧边栏模块 <strong>next/layout/_macro/sidebar.swig</strong> ,这个负责渲染侧边栏<br>在我们想要放置<strong>最新文章模块</strong>的地方添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">&#123;% if theme.recent_posts.enable %&#125;<br>  &lt;aside class&#x3D;&quot;sidebar sidebar-ads sidebar-posts&quot;&gt;<br>    &lt;div&gt;<br>      &lt;div class&#x3D;&quot;recent_posts_title&quot;&gt;<br>        &#123;&#123; theme.recent_posts.recent_posts_title &#125;&#125;<br>      &lt;&#x2F;div&gt;<br>      &lt;ul class&#x3D;&quot;links-of-blogroll-list&quot;&gt;<br>        &#123;% set posts &#x3D; site.posts.sort(&#39;-date&#39;) %&#125;<br>        &#123;% set bg_colors &#x3D; [&#39;rgb(31, 216, 210)&#39;, &#39;rgb(4, 166, 247)&#39;, &#39;rgb(70, 101, 226)&#39;, &#39;rgb(94, 137, 229)&#39;, &#39;rgb(0, 206, 123)&#39;] %&#125;<br>        &#123;% for post in posts.slice(&#39;0&#39;, &#39;5&#39;) %&#125;<br>          &lt;li&gt;<br>            &lt;div class&#x3D;&quot;text-img&quot; style&#x3D;&quot;background:&#123;&#123;bg_colors[loop.index - 1]&#125;&#125;;&quot;&gt;&#123;&#123; post.title.substr(0, 3) &#125;&#125;&lt;&#x2F;div&gt;<br>            &lt;div class&#x3D;&quot;post-name&quot;&gt;<br>              &lt;div&gt;&#123;&#123; date(post.date, config.date_format) &#125;&#125;&lt;&#x2F;div&gt;<br>              &lt;div&gt;&lt;a href&#x3D;&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title&#x3D;&quot;&#123;&#123; post.title &#125;&#125;&quot; &gt;&#123;&#123; post.title &#125;&#125;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;<br>            &lt;&#x2F;div&gt;<br>          &lt;&#x2F;li&gt;<br>        &#123;% endfor %&#125;<br>      &lt;&#x2F;ul&gt;<br>    &lt;&#x2F;div&gt;<br>  &lt;&#x2F;aside&gt;<br>  &#123;% endif %&#125;<br></code></pre></td></tr></table></figure>\n<p>最后重新执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plain\">hexo clean<br>hexo g<br></code></pre></td></tr></table></figure>\n\n\n<p>最后我们得到的效果是</p>\n<h2 id=\"Google统计\"><a href=\"#Google统计\" class=\"headerlink\" title=\"Google统计\"></a>Google统计</h2><h2 id=\"Sitemap网站地图\"><a href=\"#Sitemap网站地图\" class=\"headerlink\" title=\"Sitemap网站地图\"></a>Sitemap网站地图</h2><h2 id=\"提交谷歌收录本站-Google-Search\"><a href=\"#提交谷歌收录本站-Google-Search\" class=\"headerlink\" title=\"提交谷歌收录本站 Google Search\"></a>提交谷歌收录本站 Google Search</h2><h2 id=\"文章阅读量统计\"><a href=\"#文章阅读量统计\" class=\"headerlink\" title=\"文章阅读量统计\"></a><a href=\"https://blog.csdn.net/weixin_39345384/article/details/80787998\">文章阅读量统计</a></h2><hr>\n<hr>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://mashirosorata.vicp.io/HEXO-NEXT主题个性化配置.html\">HEXO+NEXT主题个性化配置</a></li>\n<li><a href=\"https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html\">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li>\n<li><a href=\"https://juejin.im/post/5c45a503f265da616b10fe4e#heading-28\">[EasyHexo 专栏] #2 - 魔改 Next 不完全教程</a></li>\n<li><a href=\"https://blog.csdn.net/MasterAnt_D/article/details/56839222#t50\">基于Hexo+Node.js+github+coding搭建个人博客——进阶篇(从入门到入土)</a></li>\n<li><a href=\"http://www.shaoyance.com/2018/01/26/Hexo博客Next主题优化总结/\">Hexo博客Next主题优化总结</a></li>\n<li><a href=\"https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html\">为NexT主题添加文章阅读量统计功能</a></li>\n<li><a href=\"http://www.cduyzh.com/hexo-settings-3/\">2017年最新基于hexo搭建个人免费博客——自定义页面样式一</a></li>\n<li><a href=\"https://notes.doublemine.me/2015-06-29-Hexo添加文章时自动打开编辑器.html\">Hexo添加文章时自动打开编辑器</a></li>\n<li><a href=\"https://blog.yleao.com/2018/0901/hexo-next主题下的美化.html#next主题下点击侧边栏头像回到博客首页\">next主题下点击侧边栏头像回到博客首页</a></li>\n<li><a href=\"https://reuixiy.github.io/beautiful/share/2018/12/11/noto-serif-sc-added-on-google-fonts.html\">Google Fonts 已支持思源宋体！</a></li>\n<li><a href=\"https://www.bluelzy.com/articles/change_to_next_theme.html\">弃暗投明-Hexo更换next主题</a></li>\n<li><a href=\"https://www.feiwuuz.com.cn/archives/5483aa06.html\">hexo博客NEXT主题美化</a></li>\n<li><a href=\"http://chant00.com/2015/11/04/在hexo博客中插入图片，音乐，视屏，公式/\">在hexo博客中插入图片，音乐，视频</a></li>\n</ul>\n"},{"title":"kafka入门教程[一]","abbrlink":1125805293,"cover":"https://cdn.tanxz.com/images/category/kafka.jpg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","date":"2018-04-10T13:38:18.000Z","_content":"\n\n## 一、概念理解\n\n**Kafka**是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。\n\n<!-- more -->\n\n### （1）产生背景\n\n当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：\n\n1. 如何收集这些巨大的信息\n2. 如何分析它\n3. 如何及时做到如上两点\n\n以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁-消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。\n\n**Kafka诞生**\nKafka由 linked-in 开源\nkafka-即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。\nkafka-高产出的分布式消息系统(A high-throughput distributed messaging system)\n\n### （2）Kafka的特性\n\n- **高吞吐量、低延迟**：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒\n- **可扩展性**：kafka集群支持热扩展\n- **持久性、可靠性**：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失\n- **容错性**：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）\n- **高并发**：支持数千个客户端同时读写\n\n### （3）Kafka场景应用\n\n- **日志收集**：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。\n- **消息系统**：解耦和生产者和消费者、缓存消息等。\n- **用户活动跟踪**：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。\n- **运营指标**：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。\n- **流式处理**：比如spark streaming和storm\n- **事件源**\n\n### （4）Kafka一些重要设计思想\n\n- **Consumergroup**：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。\n- **消息状态**：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。\n- **消息持久化**：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。\n- **消息有效期**：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。\n- **批量发送**：Kafka支持以消息集合为单位进行批量发送，以提高push效率。\n- **push-and-pull** :Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。\n- **Kafka集群中broker之间的关系**：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。\n- **负载均衡方面**： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。\n- **同步异步**：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。\n- **分区机制partition**：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。\n- **离线数据装载**：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。\n- **插件支持**：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。\n\n## 二、消息队列通信的模式\n\n### （1）点对点模式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624144932564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。\n\n### （2）发布订阅模式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020062414495136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！\n\n## 三、Kafka的架构原理\n\n上面简单的介绍了为什么需要消息队列以及消息队列通信的两种模式，下面主角介绍Kafka。Kafka是一种**高吞吐量的分布式发布订阅消息系统**，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。。\n\n### （1）基础架构与名词解释\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624145628396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n\n- Producer：Producer即生产者，消息的产生者，是消息的入口。\n- Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……\n- Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。\n- Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！\n- Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。\n- Message：每一条发送的消息主体。\n- Consumer：消费者，即消息的消费方，是消息的出口。\n- Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！\n- Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。\n\n### （2）工作流程分析\n\n#### （1）发送数据\n\n我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，**Producer在写入数据的时候永远的找leader**，不会直接将数据写入**follower**！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624150617430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624150636117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：\n\n1. **方便扩展**：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。\n2. **提高并发**：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。\n\n熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：\n\n1. partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。\n2. 如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。\n3. 如果既没指定partition，又没有设置key，则会轮询选出一个partition。\n\n保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为**0、1、all**。\n\n- 0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。\n- 1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。\n- all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。\n\n最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。\n\n#### （2）保存数据\n\nProducer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。\n\n##### （1）Partition 结构\n\n前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624170905606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。\n\n##### （2）Message结构\n\n上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：\n\n- **offset**：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！\n- **消息大小**：消息大小占用4byte，用于描述消息的大小。\n- **消息体**：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。\n\n##### （3）存储策略\n\n无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？\n\n- 基于时间，默认配置是168小时（7天）。\n- 基于大小，默认配置是1073741824。\n\n需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！\n\n#### （3）消费数据\n\n消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka采用的是点对点的模式，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找**leader**去拉取。\n\n多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！我们看下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624171149382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，**建议消费者组的consumer的数量与partition的数量一致**！\n\n在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624171235860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n\n1. 先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。\n2. 打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的相对offset为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。\n3. 根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。\n\n这套机制是建立在offset为有序的基础上，利用segment+有序offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！","source":"_posts/各类教程/中间件/kafka入门教程.md","raw":"---\ntitle: kafka入门教程[一]\ncategories: \n  \t- 技术实践\ntags:\n\t- Kafka\nabbrlink: 1125805293\ncover: https://cdn.tanxz.com/images/category/kafka.jpg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ndate: 2018-04-10 21:38:18\n---\n\n\n## 一、概念理解\n\n**Kafka**是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。\n\n<!-- more -->\n\n### （1）产生背景\n\n当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：\n\n1. 如何收集这些巨大的信息\n2. 如何分析它\n3. 如何及时做到如上两点\n\n以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁-消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。\n\n**Kafka诞生**\nKafka由 linked-in 开源\nkafka-即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。\nkafka-高产出的分布式消息系统(A high-throughput distributed messaging system)\n\n### （2）Kafka的特性\n\n- **高吞吐量、低延迟**：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒\n- **可扩展性**：kafka集群支持热扩展\n- **持久性、可靠性**：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失\n- **容错性**：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）\n- **高并发**：支持数千个客户端同时读写\n\n### （3）Kafka场景应用\n\n- **日志收集**：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。\n- **消息系统**：解耦和生产者和消费者、缓存消息等。\n- **用户活动跟踪**：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。\n- **运营指标**：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。\n- **流式处理**：比如spark streaming和storm\n- **事件源**\n\n### （4）Kafka一些重要设计思想\n\n- **Consumergroup**：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。\n- **消息状态**：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。\n- **消息持久化**：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。\n- **消息有效期**：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。\n- **批量发送**：Kafka支持以消息集合为单位进行批量发送，以提高push效率。\n- **push-and-pull** :Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。\n- **Kafka集群中broker之间的关系**：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。\n- **负载均衡方面**： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。\n- **同步异步**：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。\n- **分区机制partition**：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。\n- **离线数据装载**：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。\n- **插件支持**：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。\n\n## 二、消息队列通信的模式\n\n### （1）点对点模式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624144932564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。\n\n### （2）发布订阅模式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020062414495136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！\n\n## 三、Kafka的架构原理\n\n上面简单的介绍了为什么需要消息队列以及消息队列通信的两种模式，下面主角介绍Kafka。Kafka是一种**高吞吐量的分布式发布订阅消息系统**，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。。\n\n### （1）基础架构与名词解释\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624145628396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n\n- Producer：Producer即生产者，消息的产生者，是消息的入口。\n- Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……\n- Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。\n- Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！\n- Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。\n- Message：每一条发送的消息主体。\n- Consumer：消费者，即消息的消费方，是消息的出口。\n- Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！\n- Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。\n\n### （2）工作流程分析\n\n#### （1）发送数据\n\n我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，**Producer在写入数据的时候永远的找leader**，不会直接将数据写入**follower**！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624150617430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624150636117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：\n\n1. **方便扩展**：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。\n2. **提高并发**：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。\n\n熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：\n\n1. partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。\n2. 如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。\n3. 如果既没指定partition，又没有设置key，则会轮询选出一个partition。\n\n保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为**0、1、all**。\n\n- 0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。\n- 1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。\n- all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。\n\n最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。\n\n#### （2）保存数据\n\nProducer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。\n\n##### （1）Partition 结构\n\n前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624170905606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。\n\n##### （2）Message结构\n\n上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：\n\n- **offset**：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！\n- **消息大小**：消息大小占用4byte，用于描述消息的大小。\n- **消息体**：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。\n\n##### （3）存储策略\n\n无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？\n\n- 基于时间，默认配置是168小时（7天）。\n- 基于大小，默认配置是1073741824。\n\n需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！\n\n#### （3）消费数据\n\n消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka采用的是点对点的模式，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找**leader**去拉取。\n\n多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！我们看下图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624171149382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，**建议消费者组的consumer的数量与partition的数量一致**！\n\n在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624171235860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70)\n\n1. 先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。\n2. 打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的相对offset为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。\n3. 根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。\n\n这套机制是建立在offset为有序的基础上，利用segment+有序offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！","slug":"各类教程/中间件/kafka入门教程","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6i5003htvcdbxfvg5xx","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、概念理解\"><a href=\"#一、概念理解\" class=\"headerlink\" title=\"一、概念理解\"></a>一、概念理解</h2><p><strong>Kafka</strong>是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"（1）产生背景\"><a href=\"#（1）产生背景\" class=\"headerlink\" title=\"（1）产生背景\"></a>（1）产生背景</h3><p>当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：</p>\n<ol>\n<li>如何收集这些巨大的信息</li>\n<li>如何分析它</li>\n<li>如何及时做到如上两点</li>\n</ol>\n<p>以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁-消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。</p>\n<p><strong>Kafka诞生</strong><br>Kafka由 linked-in 开源<br>kafka-即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。<br>kafka-高产出的分布式消息系统(A high-throughput distributed messaging system)</p>\n<h3 id=\"（2）Kafka的特性\"><a href=\"#（2）Kafka的特性\" class=\"headerlink\" title=\"（2）Kafka的特性\"></a>（2）Kafka的特性</h3><ul>\n<li><strong>高吞吐量、低延迟</strong>：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li>\n<li><strong>可扩展性</strong>：kafka集群支持热扩展</li>\n<li><strong>持久性、可靠性</strong>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>\n<li><strong>容错性</strong>：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>\n<li><strong>高并发</strong>：支持数千个客户端同时读写</li>\n</ul>\n<h3 id=\"（3）Kafka场景应用\"><a href=\"#（3）Kafka场景应用\" class=\"headerlink\" title=\"（3）Kafka场景应用\"></a>（3）Kafka场景应用</h3><ul>\n<li><strong>日志收集</strong>：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>\n<li><strong>消息系统</strong>：解耦和生产者和消费者、缓存消息等。</li>\n<li><strong>用户活动跟踪</strong>：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li>\n<li><strong>运营指标</strong>：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>\n<li><strong>流式处理</strong>：比如spark streaming和storm</li>\n<li><strong>事件源</strong></li>\n</ul>\n<h3 id=\"（4）Kafka一些重要设计思想\"><a href=\"#（4）Kafka一些重要设计思想\" class=\"headerlink\" title=\"（4）Kafka一些重要设计思想\"></a>（4）Kafka一些重要设计思想</h3><ul>\n<li><strong>Consumergroup</strong>：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。</li>\n<li><strong>消息状态</strong>：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。</li>\n<li><strong>消息持久化</strong>：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。</li>\n<li><strong>消息有效期</strong>：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。</li>\n<li><strong>批量发送</strong>：Kafka支持以消息集合为单位进行批量发送，以提高push效率。</li>\n<li><strong>push-and-pull</strong> :Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。</li>\n<li><strong>Kafka集群中broker之间的关系</strong>：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。</li>\n<li><strong>负载均衡方面</strong>： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。</li>\n<li><strong>同步异步</strong>：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</li>\n<li><strong>分区机制partition</strong>：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。</li>\n<li><strong>离线数据装载</strong>：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。</li>\n<li><strong>插件支持</strong>：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。</li>\n</ul>\n<h2 id=\"二、消息队列通信的模式\"><a href=\"#二、消息队列通信的模式\" class=\"headerlink\" title=\"二、消息队列通信的模式\"></a>二、消息队列通信的模式</h2><h3 id=\"（1）点对点模式\"><a href=\"#（1）点对点模式\" class=\"headerlink\" title=\"（1）点对点模式\"></a>（1）点对点模式</h3><p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200624144932564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p>\n<h3 id=\"（2）发布订阅模式\"><a href=\"#（2）发布订阅模式\" class=\"headerlink\" title=\"（2）发布订阅模式\"></a>（2）发布订阅模式</h3><p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/2020062414495136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！</p>\n<h2 id=\"三、Kafka的架构原理\"><a href=\"#三、Kafka的架构原理\" class=\"headerlink\" title=\"三、Kafka的架构原理\"></a>三、Kafka的架构原理</h2><p>上面简单的介绍了为什么需要消息队列以及消息队列通信的两种模式，下面主角介绍Kafka。Kafka是一种<strong>高吞吐量的分布式发布订阅消息系统</strong>，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。。</p>\n<h3 id=\"（1）基础架构与名词解释\"><a href=\"#（1）基础架构与名词解释\" class=\"headerlink\" title=\"（1）基础架构与名词解释\"></a>（1）基础架构与名词解释</h3><p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200624145628396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>Producer：Producer即生产者，消息的产生者，是消息的入口。</li>\n<li>Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……</li>\n<li>Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。</li>\n<li>Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！</li>\n<li>Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</li>\n<li>Message：每一条发送的消息主体。</li>\n<li>Consumer：消费者，即消息的消费方，是消息的出口。</li>\n<li>Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！</li>\n<li>Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。</li>\n</ul>\n<h3 id=\"（2）工作流程分析\"><a href=\"#（2）工作流程分析\" class=\"headerlink\" title=\"（2）工作流程分析\"></a>（2）工作流程分析</h3><h4 id=\"（1）发送数据\"><a href=\"#（1）发送数据\" class=\"headerlink\" title=\"（1）发送数据\"></a>（1）发送数据</h4><p>我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，<strong>Producer在写入数据的时候永远的找leader</strong>，不会直接将数据写入<strong>follower</strong>！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200624150617430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200624150636117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：</p>\n<ol>\n<li><strong>方便扩展</strong>：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。</li>\n<li><strong>提高并发</strong>：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li>\n</ol>\n<p>熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：</p>\n<ol>\n<li>partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。</li>\n<li>如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。</li>\n<li>如果既没指定partition，又没有设置key，则会轮询选出一个partition。</li>\n</ol>\n<p>保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为<strong>0、1、all</strong>。</p>\n<ul>\n<li>0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。</li>\n<li>1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。</li>\n<li>all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</li>\n</ul>\n<p>最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。</p>\n<h4 id=\"（2）保存数据\"><a href=\"#（2）保存数据\" class=\"headerlink\" title=\"（2）保存数据\"></a>（2）保存数据</h4><p>Producer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。</p>\n<h5 id=\"（1）Partition-结构\"><a href=\"#（1）Partition-结构\" class=\"headerlink\" title=\"（1）Partition 结构\"></a>（1）Partition 结构</h5><p>前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200624170905606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。</p>\n<h5 id=\"（2）Message结构\"><a href=\"#（2）Message结构\" class=\"headerlink\" title=\"（2）Message结构\"></a>（2）Message结构</h5><p>上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：</p>\n<ul>\n<li><strong>offset</strong>：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！</li>\n<li><strong>消息大小</strong>：消息大小占用4byte，用于描述消息的大小。</li>\n<li><strong>消息体</strong>：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。</li>\n</ul>\n<h5 id=\"（3）存储策略\"><a href=\"#（3）存储策略\" class=\"headerlink\" title=\"（3）存储策略\"></a>（3）存储策略</h5><p>无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？</p>\n<ul>\n<li>基于时间，默认配置是168小时（7天）。</li>\n<li>基于大小，默认配置是1073741824。</li>\n</ul>\n<p>需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！</p>\n<h4 id=\"（3）消费数据\"><a href=\"#（3）消费数据\" class=\"headerlink\" title=\"（3）消费数据\"></a>（3）消费数据</h4><p>消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka采用的是点对点的模式，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找<strong>leader</strong>去拉取。</p>\n<p>多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！我们看下图：<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200624171149382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，<strong>建议消费者组的consumer的数量与partition的数量一致</strong>！</p>\n<p>在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：<br><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://img-blog.csdnimg.cn/20200624171235860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li>先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。</li>\n<li>打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的相对offset为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。</li>\n<li>根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。</li>\n</ol>\n<p>这套机制是建立在offset为有序的基础上，利用segment+有序offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"<h2 id=\"一、概念理解\"><a href=\"#一、概念理解\" class=\"headerlink\" title=\"一、概念理解\"></a>一、概念理解</h2><p><strong>Kafka</strong>是最初由Linkedin公司开发，是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p>","more":"<h3 id=\"（1）产生背景\"><a href=\"#（1）产生背景\" class=\"headerlink\" title=\"（1）产生背景\"></a>（1）产生背景</h3><p>当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：</p>\n<ol>\n<li>如何收集这些巨大的信息</li>\n<li>如何分析它</li>\n<li>如何及时做到如上两点</li>\n</ol>\n<p>以上几个挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁-消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。</p>\n<p><strong>Kafka诞生</strong><br>Kafka由 linked-in 开源<br>kafka-即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。<br>kafka-高产出的分布式消息系统(A high-throughput distributed messaging system)</p>\n<h3 id=\"（2）Kafka的特性\"><a href=\"#（2）Kafka的特性\" class=\"headerlink\" title=\"（2）Kafka的特性\"></a>（2）Kafka的特性</h3><ul>\n<li><strong>高吞吐量、低延迟</strong>：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li>\n<li><strong>可扩展性</strong>：kafka集群支持热扩展</li>\n<li><strong>持久性、可靠性</strong>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>\n<li><strong>容错性</strong>：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>\n<li><strong>高并发</strong>：支持数千个客户端同时读写</li>\n</ul>\n<h3 id=\"（3）Kafka场景应用\"><a href=\"#（3）Kafka场景应用\" class=\"headerlink\" title=\"（3）Kafka场景应用\"></a>（3）Kafka场景应用</h3><ul>\n<li><strong>日志收集</strong>：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</li>\n<li><strong>消息系统</strong>：解耦和生产者和消费者、缓存消息等。</li>\n<li><strong>用户活动跟踪</strong>：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li>\n<li><strong>运营指标</strong>：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>\n<li><strong>流式处理</strong>：比如spark streaming和storm</li>\n<li><strong>事件源</strong></li>\n</ul>\n<h3 id=\"（4）Kafka一些重要设计思想\"><a href=\"#（4）Kafka一些重要设计思想\" class=\"headerlink\" title=\"（4）Kafka一些重要设计思想\"></a>（4）Kafka一些重要设计思想</h3><ul>\n<li><strong>Consumergroup</strong>：各个consumer可以组成一个组，每个消息只能被组中的一个consumer消费，如果一个消息可以被多个consumer消费的话，那么这些consumer必须在不同的组。</li>\n<li><strong>消息状态</strong>：在Kafka中，消息的状态被保存在consumer中，broker不会关心哪个消息被消费了被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果consumer处理不好的话，broker上的一个消息可能会被消费多次。</li>\n<li><strong>消息持久化</strong>：Kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。</li>\n<li><strong>消息有效期</strong>：Kafka会长久保留其中的消息，以便consumer可以多次消费，当然其中很多细节是可配置的。</li>\n<li><strong>批量发送</strong>：Kafka支持以消息集合为单位进行批量发送，以提高push效率。</li>\n<li><strong>push-and-pull</strong> :Kafka中的Producer和consumer采用的是push-and-pull模式，即Producer只管向broker push消息，consumer只管从broker pull消息，两者对消息的生产和消费是异步的。</li>\n<li><strong>Kafka集群中broker之间的关系</strong>：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。</li>\n<li><strong>负载均衡方面</strong>： Kafka提供了一个 metadata API来管理broker之间的负载（对Kafka0.8.x而言，对于0.7.x主要靠zookeeper来实现负载均衡）。</li>\n<li><strong>同步异步</strong>：Producer采用异步push方式，极大提高Kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</li>\n<li><strong>分区机制partition</strong>：Kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可配置的。分区的意义很重大，后面的内容会逐渐体现。</li>\n<li><strong>离线数据装载</strong>：Kafka由于对可拓展的数据持久化的支持，它也非常适合向Hadoop或者数据仓库中进行数据装载。</li>\n<li><strong>插件支持</strong>：现在不少活跃的社区已经开发出不少插件来拓展Kafka的功能，如用来配合Storm、Hadoop、flume相关的插件。</li>\n</ul>\n<h2 id=\"二、消息队列通信的模式\"><a href=\"#二、消息队列通信的模式\" class=\"headerlink\" title=\"二、消息队列通信的模式\"></a>二、消息队列通信的模式</h2><h3 id=\"（1）点对点模式\"><a href=\"#（1）点对点模式\" class=\"headerlink\" title=\"（1）点对点模式\"></a>（1）点对点模式</h3><p><img src=\"https://img-blog.csdnimg.cn/20200624144932564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图所示，点对点模式通常是基于拉取或者轮询的消息传送模型，这个模型的特点是发送到队列的消息被一个且只有一个消费者进行处理。生产者将消息放入消息队列后，由消费者主动的去拉取消息进行消费。点对点模型的的优点是消费者拉取消息的频率可以由自己控制。但是消息队列是否有消息需要消费，在消费者端无法感知，所以在消费者端需要额外的线程去监控。</p>\n<h3 id=\"（2）发布订阅模式\"><a href=\"#（2）发布订阅模式\" class=\"headerlink\" title=\"（2）发布订阅模式\"></a>（2）发布订阅模式</h3><p><img src=\"https://img-blog.csdnimg.cn/2020062414495136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图所示，发布订阅模式是一个基于消息送的消息传送模型，改模型可以有多种不同的订阅者。生产者将消息放入消息队列后，队列会将消息推送给订阅过该类消息的消费者（类似微信公众号）。由于是消费者被动接收推送，所以无需感知消息队列是否有待消费的消息！但是consumer1、consumer2、consumer3由于机器性能不一样，所以处理消息的能力也会不一样，但消息队列却无法感知消费者消费的速度！所以推送的速度成了发布订阅模模式的一个问题！假设三个消费者处理速度分别是8M/s、5M/s、2M/s，如果队列推送的速度为5M/s，则consumer3无法承受！如果队列推送的速度为2M/s，则consumer1、consumer2会出现资源的极大浪费！</p>\n<h2 id=\"三、Kafka的架构原理\"><a href=\"#三、Kafka的架构原理\" class=\"headerlink\" title=\"三、Kafka的架构原理\"></a>三、Kafka的架构原理</h2><p>上面简单的介绍了为什么需要消息队列以及消息队列通信的两种模式，下面主角介绍Kafka。Kafka是一种<strong>高吞吐量的分布式发布订阅消息系统</strong>，它可以处理消费者规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。。</p>\n<h3 id=\"（1）基础架构与名词解释\"><a href=\"#（1）基础架构与名词解释\" class=\"headerlink\" title=\"（1）基础架构与名词解释\"></a>（1）基础架构与名词解释</h3><p><img src=\"https://img-blog.csdnimg.cn/20200624145628396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>Producer：Producer即生产者，消息的产生者，是消息的入口。</li>\n<li>Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……</li>\n<li>Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。</li>\n<li>Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹！</li>\n<li>Replication:每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</li>\n<li>Message：每一条发送的消息主体。</li>\n<li>Consumer：消费者，即消息的消费方，是消息的出口。</li>\n<li>Consumer Group：我们可以将多个消费组组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！</li>\n<li>Zookeeper：kafka集群依赖zookeeper来保存集群的的元信息，来保证系统的可用性。</li>\n</ul>\n<h3 id=\"（2）工作流程分析\"><a href=\"#（2）工作流程分析\" class=\"headerlink\" title=\"（2）工作流程分析\"></a>（2）工作流程分析</h3><h4 id=\"（1）发送数据\"><a href=\"#（1）发送数据\" class=\"headerlink\" title=\"（1）发送数据\"></a>（1）发送数据</h4><p>我们看上面的架构图中，producer就是生产者，是数据的入口。注意看图中的红色箭头，<strong>Producer在写入数据的时候永远的找leader</strong>，不会直接将数据写入<strong>follower</strong>！那leader怎么找呢？写入的流程又是什么样的呢？我们看下图：<br><img src=\"https://img-blog.csdnimg.cn/20200624150617430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>发送的流程就在图中已经说明了，就不单独在文字列出来了！需要注意的一点是，消息写入leader后，follower是主动的去leader进行同步的！producer采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的！写入示意图如下：<br><img src=\"https://img-blog.csdnimg.cn/20200624150636117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？相信大家应该也能猜到，分区的主要目的是：</p>\n<ol>\n<li><strong>方便扩展</strong>：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。</li>\n<li><strong>提高并发</strong>：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li>\n</ol>\n<p>熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，producer又怎么知道该将数据发往哪个partition呢？kafka中有几个原则：</p>\n<ol>\n<li>partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。</li>\n<li>如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。</li>\n<li>如果既没指定partition，又没有设置key，则会轮询选出一个partition。</li>\n</ol>\n<p>保证消息不丢失是一个消息队列中间件的基本保证，那producer在向kafka写入消息的时候，怎么保证消息不丢失呢？其实上面的写入流程图中有描述出来，那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为<strong>0、1、all</strong>。</p>\n<ul>\n<li>0代表producer往集群发送数据不需要等到集群的返回，不确保消息发送成功。安全性最低但是效率最高。</li>\n<li>1代表producer往集群发送数据只要leader应答就可以发送下一条，只确保leader发送成功。</li>\n<li>all代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保leader发送成功和所有的副本都完成备份。安全性最高，但是效率最低。</li>\n</ul>\n<p>最后要注意的是，如果往不存在的topic写数据，能不能写入成功呢？kafka会自动创建topic，分区和副本的数量根据默认配置都是1。</p>\n<h4 id=\"（2）保存数据\"><a href=\"#（2）保存数据\" class=\"headerlink\" title=\"（2）保存数据\"></a>（2）保存数据</h4><p>Producer将数据写入kafka后，集群就需要对数据进行保存了！kafka将数据保存在磁盘，可能在我们的一般的认知里，写入磁盘是比较耗时的操作，不适合这种高并发的组件。Kafka初始会单独开辟一块磁盘空间，顺序写入数据（效率比随机写入高）。</p>\n<h5 id=\"（1）Partition-结构\"><a href=\"#（1）Partition-结构\" class=\"headerlink\" title=\"（1）Partition 结构\"></a>（1）Partition 结构</h5><p>前面说过了每个topic都可以分为一个或多个partition，如果你觉得topic比较抽象，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件（早期版本中没有）三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。<br><img src=\"https://img-blog.csdnimg.cn/20200624170905606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>如上图，这个partition有三组segment文件，每个log文件的大小是一样的，但是存储的message数量是不一定相等的（每条的message大小不一致）。文件的命名是以该segment最小offset来命名的，如000.index存储offset为0~368795的消息，kafka就是利用分段+索引的方式来解决查找效率的问题。</p>\n<h5 id=\"（2）Message结构\"><a href=\"#（2）Message结构\" class=\"headerlink\" title=\"（2）Message结构\"></a>（2）Message结构</h5><p>上面说到log文件就实际是存储message的地方，我们在producer往kafka写入的也是一条一条的message，那存储在log中的message是什么样子的呢？消息主要包含消息体、消息大小、offset、压缩类型……等等！我们重点需要知道的是下面三个：</p>\n<ul>\n<li><strong>offset</strong>：offset是一个占8byte的有序id号，它可以唯一确定每条消息在parition内的位置！</li>\n<li><strong>消息大小</strong>：消息大小占用4byte，用于描述消息的大小。</li>\n<li><strong>消息体</strong>：消息体存放的是实际的消息数据（被压缩过），占用的空间根据具体的消息而不一样。</li>\n</ul>\n<h5 id=\"（3）存储策略\"><a href=\"#（3）存储策略\" class=\"headerlink\" title=\"（3）存储策略\"></a>（3）存储策略</h5><p>无论消息是否被消费，kafka都会保存所有的消息。那对于旧数据有什么删除策略呢？</p>\n<ul>\n<li>基于时间，默认配置是168小时（7天）。</li>\n<li>基于大小，默认配置是1073741824。</li>\n</ul>\n<p>需要注意的是，kafka读取特定消息的时间复杂度是O(1)，所以这里删除过期的文件并不会提高kafka的性能！</p>\n<h4 id=\"（3）消费数据\"><a href=\"#（3）消费数据\" class=\"headerlink\" title=\"（3）消费数据\"></a>（3）消费数据</h4><p>消息存储在log文件后，消费者就可以进行消费了。在讲消息队列通信的两种模式的时候讲到过点对点模式和发布订阅模式。Kafka采用的是点对点的模式，消费者主动的去kafka集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找<strong>leader</strong>去拉取。</p>\n<p>多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id！同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会组内多个消费者消费同一分区的数据！！！我们看下图：<br><img src=\"https://img-blog.csdnimg.cn/20200624171149382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>图示是消费者组内的消费者小于partition数量的情况，所以会出现某个消费者消费多个partition数据的情况，消费的速度也就不及只处理一个partition的消费者的处理速度！如果是消费者组的消费者多于partition的数量，那会不会出现多个消费者消费同一个partition的数据呢？上面已经提到过不会出现这种情况！多出来的消费者不消费任何partition的数据。所以在实际的应用中，<strong>建议消费者组的consumer的数量与partition的数量一致</strong>！</p>\n<p>在保存数据的小节里面，我们聊到了partition划分为多组segment，每个segment又包含.log、.index、.timeindex文件，存放的每条message包含offset、消息大小、消息体……我们多次提到segment和offset，查找消息的时候是怎么利用segment+offset配合查找的呢？假如现在需要查找一个offset为368801的message是什么样的过程呢？我们先看看下面的图：<br><img src=\"https://img-blog.csdnimg.cn/20200624171235860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTM2NjQ5OQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ol>\n<li>先找到offset的368801message所在的segment文件（利用二分法查找），这里找到的就是在第二个segment文件。</li>\n<li>打开找到的segment中的.index文件（也就是368796.index文件，该文件起始偏移量为368796+1，我们要查找的offset为368801的message在该index内的偏移量为368796+5=368801，所以这里要查找的相对offset为5）。由于该文件采用的是稀疏索引的方式存储着相对offset及对应message物理偏移量的关系，所以直接找相对offset为5的索引找不到，这里同样利用二分法查找相对offset小于或者等于指定的相对offset的索引条目中最大的那个相对offset，所以找到的是相对offset为4的这个索引。</li>\n<li>根据找到的相对offset为4的索引确定message存储的物理偏移位置为256。打开数据文件，从位置为256的那个地方开始顺序扫描直到找到offset为368801的那条Message。</li>\n</ol>\n<p>这套机制是建立在offset为有序的基础上，利用segment+有序offset+稀疏索引+二分查找+顺序查找等多种手段来高效的查找数据！至此，消费者就能拿到需要处理的数据进行处理了。那每个消费者又是怎么记录自己消费的位置呢？在早期的版本中，消费者将消费到的offset维护zookeeper中，consumer每间隔一段时间上报一次，这里容易导致重复消费，且性能不好！在新的版本中消费者消费到的offset已经直接维护在kafk集群的__consumer_offsets这个topic中！</p>"},{"title":"Linux命令systemd","abbrlink":1026478354,"cover":"https://cdn.tanxz.com/images/category/linux.jpeg","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","date":"2017-12-19T16:00:00.000Z","_content":"\n\n\n## **Systemd 概述**\n\n### **Systemd 简介**\n\nSystemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。\n\nSystemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。\n\n1. 更少的进程\n\nSystemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。\n\n1. 允许更多的进程并行启动\n\n在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。\n\n1. 使用 CGroup 跟踪和管理进程的生命周期\n\n在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。\n\n而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。\n\n1. 统一管理服务日志\n\nSystemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。\n\n### **Systemd 架构**\n\n![img](https://ask.qcloudimg.com/http-save/yehe-5449090/97kx52pwuj.png?imageView2/2/w/1620)\n\n## **Systemd 的 Unit 文件**\n\nSystemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）。\n\n在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。\n\n1. Systemd 支持的 12 种 Unit 文件类型\n\n- .automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务\n- .device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系\n- .mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件\n- .path：用于监控指定目录或文件的变化，并触发其它 Unit 运行\n- .scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息\n- .service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件\n- .slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件\n- .snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照\n- .socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动\n- .swap：定义一个用户做虚拟内存的交换分区\n- .target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式\n- .timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能\n\n1. Systemd 目录\n\nUnit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。\n\n- /etc/systemd/system：系统或用户自定义的配置文件\n- /run/systemd/system：软件运行时生成的配置文件\n- /usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。\n  - CentOS 7：Unit 文件指向该目录\n  - ubuntu 16：被移到了 /lib/systemd/system\n\nSystemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。\n\n1. Unit 和 Target\n\nUnit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。\n\nTarget 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。\n\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。\n\n## **Systemd Service Unit**\n\n### **Unit 文件结构**\n\n```javascript\n[Unit]\nDescription=Hello World\nAfter=docker.service\nRequires=docker.service\n[Service]\nTimeoutStartSec=0\nExecStartPre=-/usr/bin/docker kill busybox1\nExecStartPre=-/usr/bin/docker rm busybox1\nExecStartPre=/usr/bin/docker pull busybox\nExecStart=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c \"while true; do echo Hello World; sleep 1; done\"\nExecStop=\"/usr/bin/docker stop busybox1\"\nExecStopPost=\"/usr/bin/docker rm busybox1\"\n[Install]\nWantedBy=multi-user.target\n```\n\n如下所示，Systemd 服务的 Unit 文件可以分为三个配置区段：\n\n- Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式\n- Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法\n\n#### **Unit 段**\n\n- Description：描述这个 Unit 文件的信息\n- Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径\n- Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止\n- Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功\n- After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务\n- Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行\n- Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启\n- Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动\n- OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块\n- Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然\n\n#### **Install 段**\n\n这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束：\n\n- WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 <Target 名> + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“\n\n```javascript\n# find /etc/systemd/system/* -type d\n/etc/systemd/system/default.target.wants\n/etc/systemd/system/getty.target.wants\n/etc/systemd/system/graphical.target.wants\n/etc/systemd/system/multi-user.target.wants\n/etc/systemd/system/network-online.target.wants\n/etc/systemd/system/paths.target.wants\n/etc/systemd/system/shutdown.target.wants\n/etc/systemd/system/sockets.target.wants\n/etc/systemd/system/sysinit.target.wants\n/etc/systemd/system/timers.target.wants\n```\n\n- RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 <Target 名> + .required 后缀构成的子目录中\n- Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit\n- Alias：当前 Unit 可用于启动的别名\n\n1. SysV-init 运行级别与 Systemd Target 对应的 Unit 文件\n\n![img](https://ask.qcloudimg.com/http-save/yehe-5449090/mvna7qlr41.png?imageView2/2/w/1620)\n\n通过 systemctl list-units --type=target 命令可以获取当前正在使用的运行目标\n\n```javascript\n# systemctl list-units --type=target\nUNIT                   LOAD   ACTIVE SUB    DESCRIPTION\nbasic.target           loaded active active Basic System\ncryptsetup.target      loaded active active Encrypted Volumes\ngetty.target           loaded active active Login Prompts\ngraphical.target       loaded active active Graphical Interface\nlocal-fs-pre.target    loaded active active Local File Systems (Pre)\nlocal-fs.target        loaded active active Local File Systems\nmulti-user.target      loaded active active Multi-User System\nnetwork-online.target  loaded active active Network is Online\nnetwork.target         loaded active active Network\nnss-user-lookup.target loaded active active User and Group Name Lookups\npaths.target           loaded active active Paths\nremote-fs-pre.target   loaded active active Remote File Systems (Pre)\nremote-fs.target       loaded active active Remote File Systems\nslices.target          loaded active active Slices\nsockets.target         loaded active active Sockets\nsound.target           loaded active active Sound Card\nswap.target            loaded active active Swap\nsysinit.target         loaded active active System Initialization\ntime-sync.target       loaded active active System Time Synchronized\ntimers.target          loaded active active Timers\nLOAD   = Reflects whether the unit definition was properly loaded.\nACTIVE = The high-level unit activation state, i.e. generalization of SUB.\nSUB    = The low-level unit activation state, values depend on unit type.\n20 loaded units listed. Pass --all to see loaded but inactive units, too.\nTo show all installed unit files use 'systemctl list-unit-files'.\n```\n\n#### **Service 段**\n\n用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段分为服务生命周期和服务上下文配置两个方面。\n\n1. 服务生命周期控制相关\n\n- Type：定义启动时的进程行为，它有以下几种值：\n  - Type=simple：默认值，执行ExecStart指定的命令，启动主进程\n  - Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出\n  - Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行\n  - Type=dbus：当前服务通过D-Bus启动\n  - Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行\n  - Type=idle：若有其他任务执行完毕，当前服务才会运行\n- RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。\n- ExecStart：启动当前服务的命令\n- ExecStartPre：启动当前服务之前执行的命令\n- ExecStartPos：启动当前服务之后执行的命令\n- ExecReload：重启当前服务时执行的命令\n- ExecStop：停止当前服务时执行的命令\n- ExecStopPost：停止当其服务之后执行的命令\n- RestartSec：自动重启当前服务间隔的秒数\n- Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog\n- TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测\n- TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程\n\n1. 服务上下文配置相关\n\n- Environment：为服务指定环境变量\n- EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义\n- Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级\n- WorkingDirectory：指定服务的工作目录\n- RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件\n- User：指定运行服务的用户\n- Group：指定运行服务的用户组\n- MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private\n  - shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上\n  - slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上\n  - private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上\n- LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等\n\n> 注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。\n\n### **Unit 文件占位符和模板**\n\n#### **Unit 文件占位符**\n\n在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行被动态地替换实际的值。\n\n- %n：完整的 Unit 文件名字，包括 .service 后缀名\n- %p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号\n- %i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名\n- %t：存放系统运行文件的目录，通常是 “run”\n- %u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root\n- %U：运行服务的用户 ID\n- %h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值\n- %s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值\n- %m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用\n- %b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变\n- %H：实际运行节点的主机名\n- %v：内核版本，即 “uname -r” 命令输出的内容\n- %%：在 Unit 模板文件中表示一个普通的百分号\n\n#### **Unit 模板**\n\n在现实中，往往有一些应用需要被复制多份运行。例如，用于同一个[负载均衡](https://cloud.tencent.com/product/clb?from=10680)器分流的多个服务实例，或者为每个 SSH 连接建立一个独立的 sshd 服务进程。\n\nUnit 模板文件的写法与普通的服务 Unit 文件基本相同，不过 Unit 模板的文件名是以 @ 符号结尾的。通过模板启动服务实例时，需要在其文件名的 @ 字符后面附加一个参数字符串。\n\n1. 示例：apache@.service\n\n- apache@.service 模板\n\n```javascript\n[Unit]\nDescription=My Advanced Service Template\nAfter=etcd.service docker.service\n[Service]\nTimeoutStartSec=0\nExecStartPre=-/usr/bin/docker kill apache%i\nExecStartPre=-/usr/bin/docker rm apache%i\nExecStartPre=/usr/bin/docker pull coreos/apache\nExecStart=/usr/bin/docker run --name apache%i -p %i:80 coreos/apache /usr/sbin/apache2ctl -D FOREGROUND\nExecStartPost=/usr/bin/etcdctl set /domains/example.com/%H:%i running\nExecStop=/usr/bin/docker stop apache1\nExecStopPost=/usr/bin/docker rm apache1\nExecStopPost=/usr/bin/etcdctl rm /domains/example.com/%H:%i\n[Install]\nWantedBy=multi-user.target\n```\n\n- 启动 Unit 模板的服务实例\n\n在服务启动时需要在 @ 后面放置一个用于区分服务实例的附加字符参数，通常这个参数用于监控的端口号或控制台 TTY 编译号。\n\n```javascript\n# systemctl start apache@8080.service\n```\n\nSystemd 在运行服务时，总是会先尝试找到一个完整匹配的 Unit 文件，如果没有找到，才会尝试选择匹配模板。例如上面的命令，System 首先会在约定的目录下寻找名为 apache@8080.service 的文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 apache@8080.service，systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。\n\n## **Systemd 的资源管理**\n\n### **Systemctl 命令**\n\n```javascript\n# systemctl --help\nsystemctl [OPTIONS...] {COMMAND} ...\nQuery or send control commands to the systemd manager.\n  -h --help           Show this help\n     --version        Show package version\n     --system         Connect to system manager\n  -H --host=[USER@]HOST\n                      Operate on remote host\n  -M --machine=CONTAINER\n                      Operate on local container\n  -t --type=TYPE      List units of a particular type\n     --state=STATE    List units with particular LOAD or SUB or ACTIVE state\n  -p --property=NAME  Show only properties by this name\n  -a --all            Show all loaded units/properties, including dead/empty\n                      ones. To list all units installed on the system, use\n                      the 'list-unit-files' command instead.\n  -l --full           Don't ellipsize unit names on output\n  -r --recursive      Show unit list of host and local containers\n     --reverse        Show reverse dependencies with 'list-dependencies'\n     --job-mode=MODE  Specify how to deal with already queued jobs, when\n                      queueing a new job\n     --show-types     When showing sockets, explicitly show their type\n  -i --ignore-inhibitors\n                      When shutting down or sleeping, ignore inhibitors\n     --kill-who=WHO   Who to send signal to\n  -s --signal=SIGNAL  Which signal to send\n     --now            Start or stop unit in addition to enabling or disabling it\n  -q --quiet          Suppress output\n     --no-block       Do not wait until operation finished\n     --no-wall        Don't send wall message before halt/power-off/reboot\n     --no-reload      Don't reload daemon after en-/dis-abling unit files\n     --no-legend      Do not print a legend (column headers and hints)\n     --no-pager       Do not pipe output into a pager\n     --no-ask-password\n                      Do not ask for system passwords\n     --global         Enable/disable unit files globally\n     --runtime        Enable unit files only temporarily until next reboot\n  -f --force          When enabling unit files, override existing symlinks\n                      When shutting down, execute action immediately\n     --preset-mode=   Apply only enable, only disable, or all presets\n     --root=PATH      Enable unit files in the specified root directory\n  -n --lines=INTEGER  Number of journal entries to show\n  -o --output=STRING  Change journal output mode (short, short-iso,\n                              short-precise, short-monotonic, verbose,\n                              export, json, json-pretty, json-sse, cat)\n     --plain          Print unit dependencies as a list instead of a tree\nUnit Commands:\n  list-units [PATTERN...]         List loaded units\n  list-sockets [PATTERN...]       List loaded sockets ordered by address\n  list-timers [PATTERN...]        List loaded timers ordered by next elapse\n  start NAME...                   Start (activate) one or more units\n  stop NAME...                    Stop (deactivate) one or more units\n  reload NAME...                  Reload one or more units\n  restart NAME...                 Start or restart one or more units\n  try-restart NAME...             Restart one or more units if active\n  reload-or-restart NAME...       Reload one or more units if possible,\n                                  otherwise start or restart\n  reload-or-try-restart NAME...   Reload one or more units if possible,\n                                  otherwise restart if active\n  isolate NAME                    Start one unit and stop all others\n  kill NAME...                    Send signal to processes of a unit\n  is-active PATTERN...            Check whether units are active\n  is-failed PATTERN...            Check whether units are failed\n  status [PATTERN...|PID...]      Show runtime status of one or more units\n  show [PATTERN...|JOB...]        Show properties of one or more\n                                  units/jobs or the manager\n  cat PATTERN...                  Show files and drop-ins of one or more units\n  set-property NAME ASSIGNMENT... Sets one or more properties of a unit\n  help PATTERN...|PID...          Show manual for one or more units\n  reset-failed [PATTERN...]       Reset failed state for all, one, or more\n                                  units\n  list-dependencies [NAME]        Recursively show units which are required\n                                  or wanted by this unit or by which this\n                                  unit is required or wanted\nUnit File Commands:\n  list-unit-files [PATTERN...]    List installed unit files\n  enable NAME...                  Enable one or more unit files\n  disable NAME...                 Disable one or more unit files\n  reenable NAME...                Reenable one or more unit files\n  preset NAME...                  Enable/disable one or more unit files\n                                  based on preset configuration\n  preset-all                      Enable/disable all unit files based on\n                                  preset configuration\n  is-enabled NAME...              Check whether unit files are enabled\n  mask NAME...                    Mask one or more units\n  unmask NAME...                  Unmask one or more units\n  link PATH...                    Link one or more units files into\n                                  the search path\n  add-wants TARGET NAME...        Add 'Wants' dependency for the target\n                                  on specified one or more units\n  add-requires TARGET NAME...     Add 'Requires' dependency for the target\n                                  on specified one or more units\n  edit NAME...                    Edit one or more unit files\n  get-default                     Get the name of the default target\n  set-default NAME                Set the default target\nMachine Commands:\n  list-machines [PATTERN...]      List local containers and host\nJob Commands:\n  list-jobs [PATTERN...]          List jobs\n  cancel [JOB...]                 Cancel all, one, or more jobs\nSnapshot Commands:\n  snapshot [NAME]                 Create a snapshot\n  delete NAME...                  Remove one or more snapshots\nEnvironment Commands:\n  show-environment                Dump environment\n  set-environment NAME=VALUE...   Set one or more environment variables\n  unset-environment NAME...       Unset one or more environment variables\n  import-environment [NAME...]    Import all or some environment variables\nManager Lifecycle Commands:\n  daemon-reload                   Reload systemd manager configuration\n  daemon-reexec                   Reexecute systemd manager\nSystem Commands:\n  is-system-running               Check whether system is fully running\n  default                         Enter system default mode\n  rescue                          Enter system rescue mode\n  emergency                       Enter system emergency mode\n  halt                            Shut down and halt the system\n  poweroff                        Shut down and power-off the system\n  reboot [ARG]                    Shut down and reboot the system\n  kexec                           Shut down and reboot the system with kexec\n  exit                            Request user instance exit\n  switch-root ROOT [INIT]         Change to a different root file system\n  suspend                         Suspend the system\n  hibernate                       Hibernate the system\n  hybrid-sleep                    Hibernate and suspend the system\n```\n\n### **Unit 管理**\n\n1. 查看当前系统的所有 Unit\n\n```javascript\n# 列出正在运行的 Unit\n$ systemctl list-units\n\n# 列出所有Unit，包括没有找到配置文件的或者启动失败的\n$ systemctl list-units --all\n\n# 列出所有没有运行的 Unit\n$ systemctl list-units --all --state=inactive\n\n# 列出所有加载失败的 Unit\n$ systemctl list-units --failed\n\n# 列出所有正在运行的、类型为 service 的 Unit\n$ systemctl list-units --type=service\n\n# 查看 Unit 配置文件的内容\n$ systemctl cat docker.service\n```\n\n1. 查看 Unit 的状态\n\n- enabled：已建立启动链接\n- disabled：没建立启动链接\n- static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖\n- masked：该配置文件被禁止建立启动链接\n\n```javascript\n# 显示系统状态\n$ systemctl status\n\n# 显示单个 Unit 的状态\n$ ystemctl status bluetooth.service\n\n# 显示远程主机的某个 Unit 的状态\n$ systemctl -H root@rhel7.example.com status httpd.service\n```\n\n1. Unit 的管理\n\n```javascript\n# 立即启动一个服务\n$ sudo systemctl start apache.service\n\n# 立即停止一个服务\n$ sudo systemctl stop apache.service\n\n# 重启一个服务\n$ sudo systemctl restart apache.service\n\n# 杀死一个服务的所有子进程\n$ sudo systemctl kill apache.service\n\n# 重新加载一个服务的配置文件\n$ sudo systemctl reload apache.service\n\n# 重载所有修改过的配置文件\n$ sudo systemctl daemon-reload\n\n# 显示某个 Unit 的所有底层参数\n$ systemctl show httpd.service\n\n# 显示某个 Unit 的指定属性的值\n$ systemctl show -p CPUShares httpd.service\n\n# 设置某个 Unit 的指定属性\n$ sudo systemctl set-property httpd.service CPUShares=500\n```\n\n1. 查看 Unit 的依赖关系\n\n```javascript\n# 列出一个 Unit 的所有依赖，默认不会列出 target 类型\n$ systemctl list-dependencies nginx.service\n\n# 列出一个 Unit 的所有依赖，包括 target 类型\n$ systemctl list-dependencies --all nginx.service\n```\n\n### **服务的生命周期**\n\n当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。\n\n1. 服务的激活\n\n- systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中\n- systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令\n\n1. 服务的启动和停止\n\n- systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令\n- systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令\n- systemctl restart：重启服务\n- systemctl kill：立即杀死服务\n\n1. 服务的开机启动和取消\n\n- systemctl enable：除了激活服务以外，也可以置服务为开机启动\n- systemctl disable：取消服务的开机启动\n\n1. 服务的修改和移除\n\n- systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件\n- systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。\n\n### **Target 管理**\n\nTarget 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。\n\n在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n\n```javascript\n# 查看当前系统的所有 Target\n$ systemctl list-unit-files --type=target\n\n# 查看一个 Target 包含的所有 Unit\n$ systemctl list-dependencies multi-user.target\n\n# 查看启动时的默认 Target\n$ systemctl get-default\n\n# 设置启动时的默认 Target\n$ sudo systemctl set-default multi-user.target\n\n# 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程\n$ sudo systemctl isolate multi-user.target\n```\n\n1. Target 与 SysV-init 进程的主要区别：\n\n- 默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n- 启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。\n- 配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。\n\n### **日志管理**\n\nSystemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。\n\nSystemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。\n\n默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。\n\n```javascript\n# 查看所有日志（默认情况下 ，只保存本次启动的日志）\n$ sudo journalctl\n\n# 查看内核日志（不显示应用日志）：--dmesg 或 -k\n$ sudo journalctl -k\n\n# 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b\n$ sudo journalctl -b\n$ sudo journalctl -b -0\n\n# 查看上一次启动的日志（需更改设置）\n$ sudo journalctl -b -1\n\n# 查看指定服务的日志：--unit 或 -u\n$ sudo journalctl -u docker.servcie\n\n# 查看指定服务的日志\n$ sudo journalctl /usr/lib/systemd/systemd\n\n# 实时滚动显示最新日志\n$ sudo journalctl -f\n\n# 查看指定时间的日志\n$ sudo journalctl --since=\"2012-10-30 18:17:16\"\n$ sudo journalctl --since \"20 min ago\"\n$ sudo journalctl --since yesterday\n$ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"\n$ sudo journalctl --since 09:00 --until \"1 hour ago\"\n\n# 显示尾部的最新 10 行日志：--lines 或 -n\n$ sudo journalctl -n\n\n# 显示尾部指定行数的日志\n$ sudo journalctl -n 20\n\n# 将最新的日志显示在前面\n$ sudo journalctl -r -u docker.service\n\n# 改变输出的格式：--output 或 -o\n$ sudo journalctl -r -u docker.service -o json-pretty\n\n# 查看指定进程的日志\n$ sudo journalctl _PID=1\n\n# 查看某个路径的脚本的日志\n$ sudo journalctl /usr/bin/bash\n\n# 查看指定用户的日志\n$ sudo journalctl _UID=33 --since today\n\n# 查看某个 Unit 的日志\n$ sudo journalctl -u nginx.service\n$ sudo journalctl -u nginx.service --since today\n\n# 实时滚动显示某个 Unit 的最新日志\n$ sudo journalctl -u nginx.service -f\n\n# 合并显示多个 Unit 的日志\n$ journalctl -u nginx.service -u php-fpm.service --since today\n\n# 查看指定优先级（及其以上级别）的日志，共有 8 级\n# 0: emerg\n# 1: alert\n# 2: crit\n# 3: err\n# 4: warning\n# 5: notice\n# 6: info\n# 7: debug\n$ sudo journalctl -p err -b\n\n# 日志默认分页输出，--no-pager 改为正常的标准输出\n$ sudo journalctl --no-pager\n\n# 以 JSON 格式（单行）输出\n$ sudo journalctl -b -u nginx.service -o json\n\n# 以 JSON 格式（多行）输出，可读性更好\n$ sudo journalctl -b -u nginx.serviceqq\n -o json-pretty\n\n# 显示日志占据的硬盘空间\n$ sudo journalctl --disk-usage\n\n# 指定日志文件占据的最大空间\n$ sudo journalctl --vacuum-size=1G\n\n# 指定日志文件保存多久\n$ sudo journalctl --vacuum-time=1years\n```\n\n## **Systemd 工具集**\n\n- systemctl：用于检查和控制各种系统服务和资源的状态\n- bootctl：用于查看和管理系统启动分区\n- hostnamectl：用于查看和修改系统的主机名和主机信息\n- journalctl：用于查看系统日志和各类应用服务日志\n- localectl：用于查看和管理系统的地区信息\n- loginctl：用于管理系统已登录用户和 Session 的信息\n- machinectl：用于操作 Systemd 容器\n- timedatectl：用于查看和管理系统的时间和时区信息\n- systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈\n- systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容\n- systemd-cat：用于将其他命令的输出重定向到系统日志\n- systemd-cgls：递归地显示指定 CGroup 的继承链\n- systemd-cgtop：显示系统当前最耗资源的 CGroup 单元\n- systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符\n- systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库\n- systemd-delta：对比当前系统配置与默认系统配置的差异\n- systemd-detect-virt：显示主机的虚拟化类型\n- systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件\n- systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID\n- systemd-notify：Systemd 的内部工具，用于通知服务的状态变化\n- systemd-nspawn：用于创建 Systemd 容器\n- systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置\n- systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行\n- systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线\n- systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录\n- systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求\n\n1. systemctl\n\n```javascript\n# 重启系统\n$ sudo systemctl reboot\n\n# 关闭系统，切断电源\n$ sudo systemctl poweroff\n\n# CPU停止工作\n$ sudo systemctl halt\n\n# 暂停系统\n$ sudo systemctl suspend\n\n# 让系统进入冬眠状态\n$ sudo systemctl hibernate\n\n# 让系统进入交互式休眠状态\n$ sudo systemctl hybrid-sleep\n\n# 启动进入救援状态（单用户状态）\n$ sudo systemctl rescue\n```\n\n1. systemd-analyze\n\n```javascript\n# 查看启动耗时\n$ systemd-analyze\n\n# 查看每个服务的启动耗时\n$ systemd-analyze blame\n\n# 显示瀑布状的启动过程流\n$ systemd-analyze critical-chain\n\n# 显示指定服务的启动流\n$ systemd-analyze critical-chain atd.service\n```\n\n1. hostnamectl\n\n```javascript\n# 显示当前主机的信息\n$ hostnamectl\n\n# 设置主机名。\n$ sudo hostnamectl set-hostname rhel7\n```\n\n1. timedatectl\n\n```javascript\n# 查看当前时区设置\n$ timedatectl\n\n# 显示所有可用的时区\n$ timedatectl list-timezones\n\n# 设置当前时区\n$ sudo timedatectl set-timezone America/New_York\n$ sudo timedatectl set-time YYYY-MM-DD\n$ sudo timedatectl set-time HH:MM:SS\n```\n\n1. loginctl\n\n```javascript\n# 列出当前 session\n$ loginctl list-sessions\n\n# 列出当前登录用户\n$ loginctl list-users\n\n# 列出显示指定用户的信息\n$ loginctl show-user ruanyf\n```\n\n1. systemd-ask-password\n\n```javascript\n$ PASSWORD=$(systemd-ask-password \"Input Your Passowrd:\")\n```\n\n1. systemd-run\n\nsystemd-run 可以将一个指定的操作变成后台运行的服务。它的效果似乎与直接在命令后加上表示后台运行的 & 符号很相似。然而，它让命令成为服务还意味着，它的生命周期将由 Systemd 控制。具体来说，包括以下好处：\n\n- 服务的生命击期由 Systemd 接管，不会随着启动它的控制台关闭而结束\n- 可以通过 systemctl 工具管理服务的状态\n- 可以通过 journalctl 工具查看和管理服务的日志信息\n- 可以通过 Systemd 提供的方法限制服务的 CPU、内存、磁盘 IO 等系统资源的使用情况。","source":"_posts/技术分享/linux/linux命令/Linux命令systemd.md","raw":"---\ntitle: Linux命令systemd\nabbrlink: 1026478354\ncover: https://cdn.tanxz.com/images/category/linux.jpeg\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ntags:\n\t- Linux\n\t- Centos\ndate: 2017-12-20\n---\n\n\n\n## **Systemd 概述**\n\n### **Systemd 简介**\n\nSystemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。\n\nSystemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。\n\n1. 更少的进程\n\nSystemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。\n\n1. 允许更多的进程并行启动\n\n在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。\n\n1. 使用 CGroup 跟踪和管理进程的生命周期\n\n在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。\n\n而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。\n\n1. 统一管理服务日志\n\nSystemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。\n\n### **Systemd 架构**\n\n![img](https://ask.qcloudimg.com/http-save/yehe-5449090/97kx52pwuj.png?imageView2/2/w/1620)\n\n## **Systemd 的 Unit 文件**\n\nSystemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）。\n\n在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。\n\n1. Systemd 支持的 12 种 Unit 文件类型\n\n- .automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务\n- .device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系\n- .mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件\n- .path：用于监控指定目录或文件的变化，并触发其它 Unit 运行\n- .scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息\n- .service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件\n- .slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件\n- .snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照\n- .socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动\n- .swap：定义一个用户做虚拟内存的交换分区\n- .target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式\n- .timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能\n\n1. Systemd 目录\n\nUnit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。\n\n- /etc/systemd/system：系统或用户自定义的配置文件\n- /run/systemd/system：软件运行时生成的配置文件\n- /usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。\n  - CentOS 7：Unit 文件指向该目录\n  - ubuntu 16：被移到了 /lib/systemd/system\n\nSystemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。\n\n1. Unit 和 Target\n\nUnit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。\n\nTarget 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。\n\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。\n\n## **Systemd Service Unit**\n\n### **Unit 文件结构**\n\n```javascript\n[Unit]\nDescription=Hello World\nAfter=docker.service\nRequires=docker.service\n[Service]\nTimeoutStartSec=0\nExecStartPre=-/usr/bin/docker kill busybox1\nExecStartPre=-/usr/bin/docker rm busybox1\nExecStartPre=/usr/bin/docker pull busybox\nExecStart=/usr/bin/docker run --name busybox1 busybox /bin/ sh -c \"while true; do echo Hello World; sleep 1; done\"\nExecStop=\"/usr/bin/docker stop busybox1\"\nExecStopPost=\"/usr/bin/docker rm busybox1\"\n[Install]\nWantedBy=multi-user.target\n```\n\n如下所示，Systemd 服务的 Unit 文件可以分为三个配置区段：\n\n- Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式\n- Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法\n\n#### **Unit 段**\n\n- Description：描述这个 Unit 文件的信息\n- Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径\n- Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止\n- Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功\n- After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务\n- Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行\n- Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启\n- Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动\n- OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块\n- Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然\n\n#### **Install 段**\n\n这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束：\n\n- WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 <Target 名> + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“\n\n```javascript\n# find /etc/systemd/system/* -type d\n/etc/systemd/system/default.target.wants\n/etc/systemd/system/getty.target.wants\n/etc/systemd/system/graphical.target.wants\n/etc/systemd/system/multi-user.target.wants\n/etc/systemd/system/network-online.target.wants\n/etc/systemd/system/paths.target.wants\n/etc/systemd/system/shutdown.target.wants\n/etc/systemd/system/sockets.target.wants\n/etc/systemd/system/sysinit.target.wants\n/etc/systemd/system/timers.target.wants\n```\n\n- RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 <Target 名> + .required 后缀构成的子目录中\n- Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit\n- Alias：当前 Unit 可用于启动的别名\n\n1. SysV-init 运行级别与 Systemd Target 对应的 Unit 文件\n\n![img](https://ask.qcloudimg.com/http-save/yehe-5449090/mvna7qlr41.png?imageView2/2/w/1620)\n\n通过 systemctl list-units --type=target 命令可以获取当前正在使用的运行目标\n\n```javascript\n# systemctl list-units --type=target\nUNIT                   LOAD   ACTIVE SUB    DESCRIPTION\nbasic.target           loaded active active Basic System\ncryptsetup.target      loaded active active Encrypted Volumes\ngetty.target           loaded active active Login Prompts\ngraphical.target       loaded active active Graphical Interface\nlocal-fs-pre.target    loaded active active Local File Systems (Pre)\nlocal-fs.target        loaded active active Local File Systems\nmulti-user.target      loaded active active Multi-User System\nnetwork-online.target  loaded active active Network is Online\nnetwork.target         loaded active active Network\nnss-user-lookup.target loaded active active User and Group Name Lookups\npaths.target           loaded active active Paths\nremote-fs-pre.target   loaded active active Remote File Systems (Pre)\nremote-fs.target       loaded active active Remote File Systems\nslices.target          loaded active active Slices\nsockets.target         loaded active active Sockets\nsound.target           loaded active active Sound Card\nswap.target            loaded active active Swap\nsysinit.target         loaded active active System Initialization\ntime-sync.target       loaded active active System Time Synchronized\ntimers.target          loaded active active Timers\nLOAD   = Reflects whether the unit definition was properly loaded.\nACTIVE = The high-level unit activation state, i.e. generalization of SUB.\nSUB    = The low-level unit activation state, values depend on unit type.\n20 loaded units listed. Pass --all to see loaded but inactive units, too.\nTo show all installed unit files use 'systemctl list-unit-files'.\n```\n\n#### **Service 段**\n\n用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段分为服务生命周期和服务上下文配置两个方面。\n\n1. 服务生命周期控制相关\n\n- Type：定义启动时的进程行为，它有以下几种值：\n  - Type=simple：默认值，执行ExecStart指定的命令，启动主进程\n  - Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出\n  - Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行\n  - Type=dbus：当前服务通过D-Bus启动\n  - Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行\n  - Type=idle：若有其他任务执行完毕，当前服务才会运行\n- RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。\n- ExecStart：启动当前服务的命令\n- ExecStartPre：启动当前服务之前执行的命令\n- ExecStartPos：启动当前服务之后执行的命令\n- ExecReload：重启当前服务时执行的命令\n- ExecStop：停止当前服务时执行的命令\n- ExecStopPost：停止当其服务之后执行的命令\n- RestartSec：自动重启当前服务间隔的秒数\n- Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog\n- TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测\n- TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程\n\n1. 服务上下文配置相关\n\n- Environment：为服务指定环境变量\n- EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义\n- Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级\n- WorkingDirectory：指定服务的工作目录\n- RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件\n- User：指定运行服务的用户\n- Group：指定运行服务的用户组\n- MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private\n  - shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上\n  - slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上\n  - private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上\n- LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等\n\n> 注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。\n\n### **Unit 文件占位符和模板**\n\n#### **Unit 文件占位符**\n\n在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行被动态地替换实际的值。\n\n- %n：完整的 Unit 文件名字，包括 .service 后缀名\n- %p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号\n- %i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名\n- %t：存放系统运行文件的目录，通常是 “run”\n- %u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root\n- %U：运行服务的用户 ID\n- %h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值\n- %s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值\n- %m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用\n- %b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变\n- %H：实际运行节点的主机名\n- %v：内核版本，即 “uname -r” 命令输出的内容\n- %%：在 Unit 模板文件中表示一个普通的百分号\n\n#### **Unit 模板**\n\n在现实中，往往有一些应用需要被复制多份运行。例如，用于同一个[负载均衡](https://cloud.tencent.com/product/clb?from=10680)器分流的多个服务实例，或者为每个 SSH 连接建立一个独立的 sshd 服务进程。\n\nUnit 模板文件的写法与普通的服务 Unit 文件基本相同，不过 Unit 模板的文件名是以 @ 符号结尾的。通过模板启动服务实例时，需要在其文件名的 @ 字符后面附加一个参数字符串。\n\n1. 示例：apache@.service\n\n- apache@.service 模板\n\n```javascript\n[Unit]\nDescription=My Advanced Service Template\nAfter=etcd.service docker.service\n[Service]\nTimeoutStartSec=0\nExecStartPre=-/usr/bin/docker kill apache%i\nExecStartPre=-/usr/bin/docker rm apache%i\nExecStartPre=/usr/bin/docker pull coreos/apache\nExecStart=/usr/bin/docker run --name apache%i -p %i:80 coreos/apache /usr/sbin/apache2ctl -D FOREGROUND\nExecStartPost=/usr/bin/etcdctl set /domains/example.com/%H:%i running\nExecStop=/usr/bin/docker stop apache1\nExecStopPost=/usr/bin/docker rm apache1\nExecStopPost=/usr/bin/etcdctl rm /domains/example.com/%H:%i\n[Install]\nWantedBy=multi-user.target\n```\n\n- 启动 Unit 模板的服务实例\n\n在服务启动时需要在 @ 后面放置一个用于区分服务实例的附加字符参数，通常这个参数用于监控的端口号或控制台 TTY 编译号。\n\n```javascript\n# systemctl start apache@8080.service\n```\n\nSystemd 在运行服务时，总是会先尝试找到一个完整匹配的 Unit 文件，如果没有找到，才会尝试选择匹配模板。例如上面的命令，System 首先会在约定的目录下寻找名为 apache@8080.service 的文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 apache@8080.service，systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。\n\n## **Systemd 的资源管理**\n\n### **Systemctl 命令**\n\n```javascript\n# systemctl --help\nsystemctl [OPTIONS...] {COMMAND} ...\nQuery or send control commands to the systemd manager.\n  -h --help           Show this help\n     --version        Show package version\n     --system         Connect to system manager\n  -H --host=[USER@]HOST\n                      Operate on remote host\n  -M --machine=CONTAINER\n                      Operate on local container\n  -t --type=TYPE      List units of a particular type\n     --state=STATE    List units with particular LOAD or SUB or ACTIVE state\n  -p --property=NAME  Show only properties by this name\n  -a --all            Show all loaded units/properties, including dead/empty\n                      ones. To list all units installed on the system, use\n                      the 'list-unit-files' command instead.\n  -l --full           Don't ellipsize unit names on output\n  -r --recursive      Show unit list of host and local containers\n     --reverse        Show reverse dependencies with 'list-dependencies'\n     --job-mode=MODE  Specify how to deal with already queued jobs, when\n                      queueing a new job\n     --show-types     When showing sockets, explicitly show their type\n  -i --ignore-inhibitors\n                      When shutting down or sleeping, ignore inhibitors\n     --kill-who=WHO   Who to send signal to\n  -s --signal=SIGNAL  Which signal to send\n     --now            Start or stop unit in addition to enabling or disabling it\n  -q --quiet          Suppress output\n     --no-block       Do not wait until operation finished\n     --no-wall        Don't send wall message before halt/power-off/reboot\n     --no-reload      Don't reload daemon after en-/dis-abling unit files\n     --no-legend      Do not print a legend (column headers and hints)\n     --no-pager       Do not pipe output into a pager\n     --no-ask-password\n                      Do not ask for system passwords\n     --global         Enable/disable unit files globally\n     --runtime        Enable unit files only temporarily until next reboot\n  -f --force          When enabling unit files, override existing symlinks\n                      When shutting down, execute action immediately\n     --preset-mode=   Apply only enable, only disable, or all presets\n     --root=PATH      Enable unit files in the specified root directory\n  -n --lines=INTEGER  Number of journal entries to show\n  -o --output=STRING  Change journal output mode (short, short-iso,\n                              short-precise, short-monotonic, verbose,\n                              export, json, json-pretty, json-sse, cat)\n     --plain          Print unit dependencies as a list instead of a tree\nUnit Commands:\n  list-units [PATTERN...]         List loaded units\n  list-sockets [PATTERN...]       List loaded sockets ordered by address\n  list-timers [PATTERN...]        List loaded timers ordered by next elapse\n  start NAME...                   Start (activate) one or more units\n  stop NAME...                    Stop (deactivate) one or more units\n  reload NAME...                  Reload one or more units\n  restart NAME...                 Start or restart one or more units\n  try-restart NAME...             Restart one or more units if active\n  reload-or-restart NAME...       Reload one or more units if possible,\n                                  otherwise start or restart\n  reload-or-try-restart NAME...   Reload one or more units if possible,\n                                  otherwise restart if active\n  isolate NAME                    Start one unit and stop all others\n  kill NAME...                    Send signal to processes of a unit\n  is-active PATTERN...            Check whether units are active\n  is-failed PATTERN...            Check whether units are failed\n  status [PATTERN...|PID...]      Show runtime status of one or more units\n  show [PATTERN...|JOB...]        Show properties of one or more\n                                  units/jobs or the manager\n  cat PATTERN...                  Show files and drop-ins of one or more units\n  set-property NAME ASSIGNMENT... Sets one or more properties of a unit\n  help PATTERN...|PID...          Show manual for one or more units\n  reset-failed [PATTERN...]       Reset failed state for all, one, or more\n                                  units\n  list-dependencies [NAME]        Recursively show units which are required\n                                  or wanted by this unit or by which this\n                                  unit is required or wanted\nUnit File Commands:\n  list-unit-files [PATTERN...]    List installed unit files\n  enable NAME...                  Enable one or more unit files\n  disable NAME...                 Disable one or more unit files\n  reenable NAME...                Reenable one or more unit files\n  preset NAME...                  Enable/disable one or more unit files\n                                  based on preset configuration\n  preset-all                      Enable/disable all unit files based on\n                                  preset configuration\n  is-enabled NAME...              Check whether unit files are enabled\n  mask NAME...                    Mask one or more units\n  unmask NAME...                  Unmask one or more units\n  link PATH...                    Link one or more units files into\n                                  the search path\n  add-wants TARGET NAME...        Add 'Wants' dependency for the target\n                                  on specified one or more units\n  add-requires TARGET NAME...     Add 'Requires' dependency for the target\n                                  on specified one or more units\n  edit NAME...                    Edit one or more unit files\n  get-default                     Get the name of the default target\n  set-default NAME                Set the default target\nMachine Commands:\n  list-machines [PATTERN...]      List local containers and host\nJob Commands:\n  list-jobs [PATTERN...]          List jobs\n  cancel [JOB...]                 Cancel all, one, or more jobs\nSnapshot Commands:\n  snapshot [NAME]                 Create a snapshot\n  delete NAME...                  Remove one or more snapshots\nEnvironment Commands:\n  show-environment                Dump environment\n  set-environment NAME=VALUE...   Set one or more environment variables\n  unset-environment NAME...       Unset one or more environment variables\n  import-environment [NAME...]    Import all or some environment variables\nManager Lifecycle Commands:\n  daemon-reload                   Reload systemd manager configuration\n  daemon-reexec                   Reexecute systemd manager\nSystem Commands:\n  is-system-running               Check whether system is fully running\n  default                         Enter system default mode\n  rescue                          Enter system rescue mode\n  emergency                       Enter system emergency mode\n  halt                            Shut down and halt the system\n  poweroff                        Shut down and power-off the system\n  reboot [ARG]                    Shut down and reboot the system\n  kexec                           Shut down and reboot the system with kexec\n  exit                            Request user instance exit\n  switch-root ROOT [INIT]         Change to a different root file system\n  suspend                         Suspend the system\n  hibernate                       Hibernate the system\n  hybrid-sleep                    Hibernate and suspend the system\n```\n\n### **Unit 管理**\n\n1. 查看当前系统的所有 Unit\n\n```javascript\n# 列出正在运行的 Unit\n$ systemctl list-units\n\n# 列出所有Unit，包括没有找到配置文件的或者启动失败的\n$ systemctl list-units --all\n\n# 列出所有没有运行的 Unit\n$ systemctl list-units --all --state=inactive\n\n# 列出所有加载失败的 Unit\n$ systemctl list-units --failed\n\n# 列出所有正在运行的、类型为 service 的 Unit\n$ systemctl list-units --type=service\n\n# 查看 Unit 配置文件的内容\n$ systemctl cat docker.service\n```\n\n1. 查看 Unit 的状态\n\n- enabled：已建立启动链接\n- disabled：没建立启动链接\n- static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖\n- masked：该配置文件被禁止建立启动链接\n\n```javascript\n# 显示系统状态\n$ systemctl status\n\n# 显示单个 Unit 的状态\n$ ystemctl status bluetooth.service\n\n# 显示远程主机的某个 Unit 的状态\n$ systemctl -H root@rhel7.example.com status httpd.service\n```\n\n1. Unit 的管理\n\n```javascript\n# 立即启动一个服务\n$ sudo systemctl start apache.service\n\n# 立即停止一个服务\n$ sudo systemctl stop apache.service\n\n# 重启一个服务\n$ sudo systemctl restart apache.service\n\n# 杀死一个服务的所有子进程\n$ sudo systemctl kill apache.service\n\n# 重新加载一个服务的配置文件\n$ sudo systemctl reload apache.service\n\n# 重载所有修改过的配置文件\n$ sudo systemctl daemon-reload\n\n# 显示某个 Unit 的所有底层参数\n$ systemctl show httpd.service\n\n# 显示某个 Unit 的指定属性的值\n$ systemctl show -p CPUShares httpd.service\n\n# 设置某个 Unit 的指定属性\n$ sudo systemctl set-property httpd.service CPUShares=500\n```\n\n1. 查看 Unit 的依赖关系\n\n```javascript\n# 列出一个 Unit 的所有依赖，默认不会列出 target 类型\n$ systemctl list-dependencies nginx.service\n\n# 列出一个 Unit 的所有依赖，包括 target 类型\n$ systemctl list-dependencies --all nginx.service\n```\n\n### **服务的生命周期**\n\n当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。\n\n1. 服务的激活\n\n- systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中\n- systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令\n\n1. 服务的启动和停止\n\n- systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令\n- systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令\n- systemctl restart：重启服务\n- systemctl kill：立即杀死服务\n\n1. 服务的开机启动和取消\n\n- systemctl enable：除了激活服务以外，也可以置服务为开机启动\n- systemctl disable：取消服务的开机启动\n\n1. 服务的修改和移除\n\n- systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件\n- systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。\n\n### **Target 管理**\n\nTarget 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。\n\n在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n\n```javascript\n# 查看当前系统的所有 Target\n$ systemctl list-unit-files --type=target\n\n# 查看一个 Target 包含的所有 Unit\n$ systemctl list-dependencies multi-user.target\n\n# 查看启动时的默认 Target\n$ systemctl get-default\n\n# 设置启动时的默认 Target\n$ sudo systemctl set-default multi-user.target\n\n# 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程\n$ sudo systemctl isolate multi-user.target\n```\n\n1. Target 与 SysV-init 进程的主要区别：\n\n- 默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n- 启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。\n- 配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。\n\n### **日志管理**\n\nSystemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。\n\nSystemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。\n\n默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。\n\n```javascript\n# 查看所有日志（默认情况下 ，只保存本次启动的日志）\n$ sudo journalctl\n\n# 查看内核日志（不显示应用日志）：--dmesg 或 -k\n$ sudo journalctl -k\n\n# 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b\n$ sudo journalctl -b\n$ sudo journalctl -b -0\n\n# 查看上一次启动的日志（需更改设置）\n$ sudo journalctl -b -1\n\n# 查看指定服务的日志：--unit 或 -u\n$ sudo journalctl -u docker.servcie\n\n# 查看指定服务的日志\n$ sudo journalctl /usr/lib/systemd/systemd\n\n# 实时滚动显示最新日志\n$ sudo journalctl -f\n\n# 查看指定时间的日志\n$ sudo journalctl --since=\"2012-10-30 18:17:16\"\n$ sudo journalctl --since \"20 min ago\"\n$ sudo journalctl --since yesterday\n$ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"\n$ sudo journalctl --since 09:00 --until \"1 hour ago\"\n\n# 显示尾部的最新 10 行日志：--lines 或 -n\n$ sudo journalctl -n\n\n# 显示尾部指定行数的日志\n$ sudo journalctl -n 20\n\n# 将最新的日志显示在前面\n$ sudo journalctl -r -u docker.service\n\n# 改变输出的格式：--output 或 -o\n$ sudo journalctl -r -u docker.service -o json-pretty\n\n# 查看指定进程的日志\n$ sudo journalctl _PID=1\n\n# 查看某个路径的脚本的日志\n$ sudo journalctl /usr/bin/bash\n\n# 查看指定用户的日志\n$ sudo journalctl _UID=33 --since today\n\n# 查看某个 Unit 的日志\n$ sudo journalctl -u nginx.service\n$ sudo journalctl -u nginx.service --since today\n\n# 实时滚动显示某个 Unit 的最新日志\n$ sudo journalctl -u nginx.service -f\n\n# 合并显示多个 Unit 的日志\n$ journalctl -u nginx.service -u php-fpm.service --since today\n\n# 查看指定优先级（及其以上级别）的日志，共有 8 级\n# 0: emerg\n# 1: alert\n# 2: crit\n# 3: err\n# 4: warning\n# 5: notice\n# 6: info\n# 7: debug\n$ sudo journalctl -p err -b\n\n# 日志默认分页输出，--no-pager 改为正常的标准输出\n$ sudo journalctl --no-pager\n\n# 以 JSON 格式（单行）输出\n$ sudo journalctl -b -u nginx.service -o json\n\n# 以 JSON 格式（多行）输出，可读性更好\n$ sudo journalctl -b -u nginx.serviceqq\n -o json-pretty\n\n# 显示日志占据的硬盘空间\n$ sudo journalctl --disk-usage\n\n# 指定日志文件占据的最大空间\n$ sudo journalctl --vacuum-size=1G\n\n# 指定日志文件保存多久\n$ sudo journalctl --vacuum-time=1years\n```\n\n## **Systemd 工具集**\n\n- systemctl：用于检查和控制各种系统服务和资源的状态\n- bootctl：用于查看和管理系统启动分区\n- hostnamectl：用于查看和修改系统的主机名和主机信息\n- journalctl：用于查看系统日志和各类应用服务日志\n- localectl：用于查看和管理系统的地区信息\n- loginctl：用于管理系统已登录用户和 Session 的信息\n- machinectl：用于操作 Systemd 容器\n- timedatectl：用于查看和管理系统的时间和时区信息\n- systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈\n- systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容\n- systemd-cat：用于将其他命令的输出重定向到系统日志\n- systemd-cgls：递归地显示指定 CGroup 的继承链\n- systemd-cgtop：显示系统当前最耗资源的 CGroup 单元\n- systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符\n- systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库\n- systemd-delta：对比当前系统配置与默认系统配置的差异\n- systemd-detect-virt：显示主机的虚拟化类型\n- systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件\n- systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID\n- systemd-notify：Systemd 的内部工具，用于通知服务的状态变化\n- systemd-nspawn：用于创建 Systemd 容器\n- systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置\n- systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行\n- systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线\n- systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录\n- systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求\n\n1. systemctl\n\n```javascript\n# 重启系统\n$ sudo systemctl reboot\n\n# 关闭系统，切断电源\n$ sudo systemctl poweroff\n\n# CPU停止工作\n$ sudo systemctl halt\n\n# 暂停系统\n$ sudo systemctl suspend\n\n# 让系统进入冬眠状态\n$ sudo systemctl hibernate\n\n# 让系统进入交互式休眠状态\n$ sudo systemctl hybrid-sleep\n\n# 启动进入救援状态（单用户状态）\n$ sudo systemctl rescue\n```\n\n1. systemd-analyze\n\n```javascript\n# 查看启动耗时\n$ systemd-analyze\n\n# 查看每个服务的启动耗时\n$ systemd-analyze blame\n\n# 显示瀑布状的启动过程流\n$ systemd-analyze critical-chain\n\n# 显示指定服务的启动流\n$ systemd-analyze critical-chain atd.service\n```\n\n1. hostnamectl\n\n```javascript\n# 显示当前主机的信息\n$ hostnamectl\n\n# 设置主机名。\n$ sudo hostnamectl set-hostname rhel7\n```\n\n1. timedatectl\n\n```javascript\n# 查看当前时区设置\n$ timedatectl\n\n# 显示所有可用的时区\n$ timedatectl list-timezones\n\n# 设置当前时区\n$ sudo timedatectl set-timezone America/New_York\n$ sudo timedatectl set-time YYYY-MM-DD\n$ sudo timedatectl set-time HH:MM:SS\n```\n\n1. loginctl\n\n```javascript\n# 列出当前 session\n$ loginctl list-sessions\n\n# 列出当前登录用户\n$ loginctl list-users\n\n# 列出显示指定用户的信息\n$ loginctl show-user ruanyf\n```\n\n1. systemd-ask-password\n\n```javascript\n$ PASSWORD=$(systemd-ask-password \"Input Your Passowrd:\")\n```\n\n1. systemd-run\n\nsystemd-run 可以将一个指定的操作变成后台运行的服务。它的效果似乎与直接在命令后加上表示后台运行的 & 符号很相似。然而，它让命令成为服务还意味着，它的生命周期将由 Systemd 控制。具体来说，包括以下好处：\n\n- 服务的生命击期由 Systemd 接管，不会随着启动它的控制台关闭而结束\n- 可以通过 systemctl 工具管理服务的状态\n- 可以通过 journalctl 工具查看和管理服务的日志信息\n- 可以通过 Systemd 提供的方法限制服务的 CPU、内存、磁盘 IO 等系统资源的使用情况。","slug":"技术分享/linux/linux命令/Linux命令systemd","published":1,"updated":"2020-12-24T14:39:35.813Z","_id":"ckiyez6i9003vtvcdhv6s8615","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Systemd-概述\"><a href=\"#Systemd-概述\" class=\"headerlink\" title=\"Systemd 概述\"></a><strong>Systemd 概述</strong></h2><h3 id=\"Systemd-简介\"><a href=\"#Systemd-简介\" class=\"headerlink\" title=\"Systemd 简介\"></a><strong>Systemd 简介</strong></h3><p>Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。</p>\n<p>Systemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。</p>\n<ol>\n<li>更少的进程</li>\n</ol>\n<p>Systemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。</p>\n<ol>\n<li>允许更多的进程并行启动</li>\n</ol>\n<p>在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。</p>\n<ol>\n<li>使用 CGroup 跟踪和管理进程的生命周期</li>\n</ol>\n<p>在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。</p>\n<p>而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。</p>\n<ol>\n<li>统一管理服务日志</li>\n</ol>\n<p>Systemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。</p>\n<h3 id=\"Systemd-架构\"><a href=\"#Systemd-架构\" class=\"headerlink\" title=\"Systemd 架构\"></a><strong>Systemd 架构</strong></h3><p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://ask.qcloudimg.com/http-save/yehe-5449090/97kx52pwuj.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2 id=\"Systemd-的-Unit-文件\"><a href=\"#Systemd-的-Unit-文件\" class=\"headerlink\" title=\"Systemd 的 Unit 文件\"></a><strong>Systemd 的 Unit 文件</strong></h2><p>Systemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）。</p>\n<p>在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。</p>\n<ol>\n<li>Systemd 支持的 12 种 Unit 文件类型</li>\n</ol>\n<ul>\n<li>.automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</li>\n<li>.device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系</li>\n<li>.mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件</li>\n<li>.path：用于监控指定目录或文件的变化，并触发其它 Unit 运行</li>\n<li>.scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</li>\n<li>.service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</li>\n<li>.slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件</li>\n<li>.snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照</li>\n<li>.socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动</li>\n<li>.swap：定义一个用户做虚拟内存的交换分区</li>\n<li>.target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式</li>\n<li>.timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能</li>\n</ul>\n<ol>\n<li>Systemd 目录</li>\n</ol>\n<p>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p>\n<ul>\n<li>/etc/systemd/system：系统或用户自定义的配置文件</li>\n<li>/run/systemd/system：软件运行时生成的配置文件</li>\n<li>/usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。<ul>\n<li>CentOS 7：Unit 文件指向该目录</li>\n<li>ubuntu 16：被移到了 /lib/systemd/system</li>\n</ul>\n</li>\n</ul>\n<p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p>\n<ol>\n<li>Unit 和 Target</li>\n</ol>\n<p>Unit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。</p>\n<p>Target 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。</p>\n<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p>\n<h2 id=\"Systemd-Service-Unit\"><a href=\"#Systemd-Service-Unit\" class=\"headerlink\" title=\"Systemd Service Unit\"></a><strong>Systemd Service Unit</strong></h2><h3 id=\"Unit-文件结构\"><a href=\"#Unit-文件结构\" class=\"headerlink\" title=\"Unit 文件结构\"></a><strong>Unit 文件结构</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[Unit]<br>Description=Hello World<br>After=docker.service<br>Requires=docker.service<br>[Service]<br>TimeoutStartSec=<span class=\"hljs-number\">0</span><br>ExecStartPre=-<span class=\"hljs-regexp\">/usr/</span>bin/docker kill busybox1<br>ExecStartPre=-<span class=\"hljs-regexp\">/usr/</span>bin/docker rm busybox1<br>ExecStartPre=<span class=\"hljs-regexp\">/usr/</span>bin/docker pull busybox<br>ExecStart=<span class=\"hljs-regexp\">/usr/</span>bin/docker run --name busybox1 busybox /bin/ sh -c <span class=\"hljs-string\">&quot;while true; do echo Hello World; sleep 1; done&quot;</span><br>ExecStop=<span class=\"hljs-string\">&quot;/usr/bin/docker stop busybox1&quot;</span><br>ExecStopPost=<span class=\"hljs-string\">&quot;/usr/bin/docker rm busybox1&quot;</span><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure>\n<p>如下所示，Systemd 服务的 Unit 文件可以分为三个配置区段：</p>\n<ul>\n<li>Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式</li>\n<li>Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法</li>\n</ul>\n<h4 id=\"Unit-段\"><a href=\"#Unit-段\" class=\"headerlink\" title=\"Unit 段\"></a><strong>Unit 段</strong></h4><ul>\n<li>Description：描述这个 Unit 文件的信息</li>\n<li>Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径</li>\n<li>Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止</li>\n<li>Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功</li>\n<li>After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务</li>\n<li>Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行</li>\n<li>Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启</li>\n<li>Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动</li>\n<li>OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块</li>\n<li>Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然</li>\n</ul>\n<h4 id=\"Install-段\"><a href=\"#Install-段\" class=\"headerlink\" title=\"Install 段\"></a><strong>Install 段</strong></h4><p>这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束：</p>\n<ul>\n<li>WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># find /etc/systemd/system/* -type d<br>/etc/systemd/system/<span class=\"hljs-keyword\">default</span>.target.wants<br>/etc/systemd/system/getty.target.wants<br>/etc/systemd/system/graphical.target.wants<br>/etc/systemd/system/multi-user.target.wants<br>/etc/systemd/system/network-online.target.wants<br>/etc/systemd/system/paths.target.wants<br>/etc/systemd/system/shutdown.target.wants<br>/etc/systemd/system/sockets.target.wants<br>/etc/systemd/system/sysinit.target.wants<br>/etc/systemd/system/timers.target.wants<br></code></pre></td></tr></table></figure>\n<ul>\n<li>RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .required 后缀构成的子目录中</li>\n<li>Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit</li>\n<li>Alias：当前 Unit 可用于启动的别名</li>\n</ul>\n<ol>\n<li>SysV-init 运行级别与 Systemd Target 对应的 Unit 文件</li>\n</ol>\n<p><img src= \"https://cdn.tanxz.com/images/loading.gif\" data-lazy-src=\"https://ask.qcloudimg.com/http-save/yehe-5449090/mvna7qlr41.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>通过 systemctl list-units –type=target 命令可以获取当前正在使用的运行目标</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># systemctl list-units --type=target<br>UNIT                   LOAD   ACTIVE SUB    DESCRIPTION<br>basic.target           loaded active active Basic System<br>cryptsetup.target      loaded active active Encrypted Volumes<br>getty.target           loaded active active Login Prompts<br>graphical.target       loaded active active Graphical Interface<br>local-fs-pre.target    loaded active active Local File Systems (Pre)<br>local-fs.target        loaded active active Local File Systems<br>multi-user.target      loaded active active Multi-User System<br>network-online.target  loaded active active Network is Online<br>network.target         loaded active active Network<br>nss-user-lookup.target loaded active active User and Group Name Lookups<br>paths.target           loaded active active Paths<br>remote-fs-pre.target   loaded active active Remote File Systems (Pre)<br>remote-fs.target       loaded active active Remote File Systems<br>slices.target          loaded active active Slices<br>sockets.target         loaded active active Sockets<br>sound.target           loaded active active Sound Card<br>swap.target            loaded active active Swap<br>sysinit.target         loaded active active System Initialization<br>time-sync.target       loaded active active System Time Synchronized<br>timers.target          loaded active active Timers<br>LOAD   = Reflects whether the unit definition was properly loaded.<br>ACTIVE = The high-level unit activation state, i.e. generalization <span class=\"hljs-keyword\">of</span> SUB.<br>SUB    = The low-level unit activation state, values depend on unit type.<br><span class=\"hljs-number\">20</span> loaded units listed. Pass --all to see loaded but inactive units, too.<br>To show all installed unit files use <span class=\"hljs-string\">&#x27;systemctl list-unit-files&#x27;</span>.<br></code></pre></td></tr></table></figure>\n<h4 id=\"Service-段\"><a href=\"#Service-段\" class=\"headerlink\" title=\"Service 段\"></a><strong>Service 段</strong></h4><p>用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段分为服务生命周期和服务上下文配置两个方面。</p>\n<ol>\n<li>服务生命周期控制相关</li>\n</ol>\n<ul>\n<li>Type：定义启动时的进程行为，它有以下几种值：<ul>\n<li>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</li>\n<li>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>\n<li>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>\n<li>Type=dbus：当前服务通过D-Bus启动</li>\n<li>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</li>\n<li>Type=idle：若有其他任务执行完毕，当前服务才会运行</li>\n</ul>\n</li>\n<li>RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。</li>\n<li>ExecStart：启动当前服务的命令</li>\n<li>ExecStartPre：启动当前服务之前执行的命令</li>\n<li>ExecStartPos：启动当前服务之后执行的命令</li>\n<li>ExecReload：重启当前服务时执行的命令</li>\n<li>ExecStop：停止当前服务时执行的命令</li>\n<li>ExecStopPost：停止当其服务之后执行的命令</li>\n<li>RestartSec：自动重启当前服务间隔的秒数</li>\n<li>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li>\n<li>TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测</li>\n<li>TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程</li>\n</ul>\n<ol>\n<li>服务上下文配置相关</li>\n</ol>\n<ul>\n<li>Environment：为服务指定环境变量</li>\n<li>EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义</li>\n<li>Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级</li>\n<li>WorkingDirectory：指定服务的工作目录</li>\n<li>RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件</li>\n<li>User：指定运行服务的用户</li>\n<li>Group：指定运行服务的用户组</li>\n<li>MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private<ul>\n<li>shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上</li>\n<li>slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上</li>\n<li>private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上</li>\n</ul>\n</li>\n<li>LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等</li>\n</ul>\n<blockquote>\n<p>注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。</p>\n</blockquote>\n<h3 id=\"Unit-文件占位符和模板\"><a href=\"#Unit-文件占位符和模板\" class=\"headerlink\" title=\"Unit 文件占位符和模板\"></a><strong>Unit 文件占位符和模板</strong></h3><h4 id=\"Unit-文件占位符\"><a href=\"#Unit-文件占位符\" class=\"headerlink\" title=\"Unit 文件占位符\"></a><strong>Unit 文件占位符</strong></h4><p>在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行被动态地替换实际的值。</p>\n<ul>\n<li>%n：完整的 Unit 文件名字，包括 .service 后缀名</li>\n<li>%p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号</li>\n<li>%i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名</li>\n<li>%t：存放系统运行文件的目录，通常是 “run”</li>\n<li>%u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root</li>\n<li>%U：运行服务的用户 ID</li>\n<li>%h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值</li>\n<li>%s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值</li>\n<li>%m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用</li>\n<li>%b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变</li>\n<li>%H：实际运行节点的主机名</li>\n<li>%v：内核版本，即 “uname -r” 命令输出的内容</li>\n<li>%%：在 Unit 模板文件中表示一个普通的百分号</li>\n</ul>\n<h4 id=\"Unit-模板\"><a href=\"#Unit-模板\" class=\"headerlink\" title=\"Unit 模板\"></a><strong>Unit 模板</strong></h4><p>在现实中，往往有一些应用需要被复制多份运行。例如，用于同一个<a href=\"https://cloud.tencent.com/product/clb?from=10680\">负载均衡</a>器分流的多个服务实例，或者为每个 SSH 连接建立一个独立的 sshd 服务进程。</p>\n<p>Unit 模板文件的写法与普通的服务 Unit 文件基本相同，不过 Unit 模板的文件名是以 @ 符号结尾的。通过模板启动服务实例时，需要在其文件名的 @ 字符后面附加一个参数字符串。</p>\n<ol>\n<li>示例：apache@.service</li>\n</ol>\n<ul>\n<li>apache@.service 模板</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[Unit]<br>Description=My Advanced Service Template<br>After=etcd.service docker.service<br>[Service]<br>TimeoutStartSec=<span class=\"hljs-number\">0</span><br>ExecStartPre=-<span class=\"hljs-regexp\">/usr/</span>bin/docker kill apache%i<br>ExecStartPre=-<span class=\"hljs-regexp\">/usr/</span>bin/docker rm apache%i<br>ExecStartPre=<span class=\"hljs-regexp\">/usr/</span>bin/docker pull coreos/apache<br>ExecStart=<span class=\"hljs-regexp\">/usr/</span>bin/docker run --name apache%i -p %i:<span class=\"hljs-number\">80</span> coreos/apache /usr/sbin/apache2ctl -D FOREGROUND<br>ExecStartPost=<span class=\"hljs-regexp\">/usr/</span>bin/etcdctl set /domains/example.com/%H:%i running<br>ExecStop=<span class=\"hljs-regexp\">/usr/</span>bin/docker stop apache1<br>ExecStopPost=<span class=\"hljs-regexp\">/usr/</span>bin/docker rm apache1<br>ExecStopPost=<span class=\"hljs-regexp\">/usr/</span>bin/etcdctl rm /domains/example.com/%H:%i<br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure>\n<ul>\n<li>启动 Unit 模板的服务实例</li>\n</ul>\n<p>在服务启动时需要在 @ 后面放置一个用于区分服务实例的附加字符参数，通常这个参数用于监控的端口号或控制台 TTY 编译号。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># systemctl start apache@8080.service<br></code></pre></td></tr></table></figure>\n<p>Systemd 在运行服务时，总是会先尝试找到一个完整匹配的 Unit 文件，如果没有找到，才会尝试选择匹配模板。例如上面的命令，System 首先会在约定的目录下寻找名为 <a href=\"mailto:apache@8080.service\">apache@8080.service</a> 的文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 <a href=\"mailto:apache@8080.service\">apache@8080.service</a>，systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。</p>\n<h2 id=\"Systemd-的资源管理\"><a href=\"#Systemd-的资源管理\" class=\"headerlink\" title=\"Systemd 的资源管理\"></a><strong>Systemd 的资源管理</strong></h2><h3 id=\"Systemctl-命令\"><a href=\"#Systemctl-命令\" class=\"headerlink\" title=\"Systemctl 命令\"></a><strong>Systemctl 命令</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># systemctl --help<br>systemctl [OPTIONS...] &#123;COMMAND&#125; ...<br>Query or send control commands to the systemd manager.<br>  -h --help           Show <span class=\"hljs-built_in\">this</span> help<br>     --version        Show package version<br>     --system         Connect to system manager<br>  -H --host=[USER@]HOST<br>                      Operate on remote host<br>  -M --machine=CONTAINER<br>                      Operate on local container<br>  -t --type=TYPE      List units <span class=\"hljs-keyword\">of</span> a particular type<br>     --state=STATE    List units <span class=\"hljs-keyword\">with</span> particular LOAD or SUB or ACTIVE state<br>  -p --property=NAME  Show only properties by <span class=\"hljs-built_in\">this</span> name<br>  -a --all            Show all loaded units/properties, including dead/empty<br>                      ones. To list all units installed on the system, use<br>                      the <span class=\"hljs-string\">&#x27;list-unit-files&#x27;</span> command instead.<br>  -l --full           Don<span class=\"hljs-string\">&#x27;t ellipsize unit names on output</span><br><span class=\"hljs-string\">  -r --recursive      Show unit list of host and local containers</span><br><span class=\"hljs-string\">     --reverse        Show reverse dependencies with &#x27;</span>list-dependencies<span class=\"hljs-string\">&#x27;</span><br><span class=\"hljs-string\">     --job-mode=MODE  Specify how to deal with already queued jobs, when</span><br><span class=\"hljs-string\">                      queueing a new job</span><br><span class=\"hljs-string\">     --show-types     When showing sockets, explicitly show their type</span><br><span class=\"hljs-string\">  -i --ignore-inhibitors</span><br><span class=\"hljs-string\">                      When shutting down or sleeping, ignore inhibitors</span><br><span class=\"hljs-string\">     --kill-who=WHO   Who to send signal to</span><br><span class=\"hljs-string\">  -s --signal=SIGNAL  Which signal to send</span><br><span class=\"hljs-string\">     --now            Start or stop unit in addition to enabling or disabling it</span><br><span class=\"hljs-string\">  -q --quiet          Suppress output</span><br><span class=\"hljs-string\">     --no-block       Do not wait until operation finished</span><br><span class=\"hljs-string\">     --no-wall        Don&#x27;</span>t send wall message before halt/power-off/reboot<br>     --no-reload      Don<span class=\"hljs-string\">&#x27;t reload daemon after en-/dis-abling unit files</span><br><span class=\"hljs-string\">     --no-legend      Do not print a legend (column headers and hints)</span><br><span class=\"hljs-string\">     --no-pager       Do not pipe output into a pager</span><br><span class=\"hljs-string\">     --no-ask-password</span><br><span class=\"hljs-string\">                      Do not ask for system passwords</span><br><span class=\"hljs-string\">     --global         Enable/disable unit files globally</span><br><span class=\"hljs-string\">     --runtime        Enable unit files only temporarily until next reboot</span><br><span class=\"hljs-string\">  -f --force          When enabling unit files, override existing symlinks</span><br><span class=\"hljs-string\">                      When shutting down, execute action immediately</span><br><span class=\"hljs-string\">     --preset-mode=   Apply only enable, only disable, or all presets</span><br><span class=\"hljs-string\">     --root=PATH      Enable unit files in the specified root directory</span><br><span class=\"hljs-string\">  -n --lines=INTEGER  Number of journal entries to show</span><br><span class=\"hljs-string\">  -o --output=STRING  Change journal output mode (short, short-iso,</span><br><span class=\"hljs-string\">                              short-precise, short-monotonic, verbose,</span><br><span class=\"hljs-string\">                              export, json, json-pretty, json-sse, cat)</span><br><span class=\"hljs-string\">     --plain          Print unit dependencies as a list instead of a tree</span><br><span class=\"hljs-string\">Unit Commands:</span><br><span class=\"hljs-string\">  list-units [PATTERN...]         List loaded units</span><br><span class=\"hljs-string\">  list-sockets [PATTERN...]       List loaded sockets ordered by address</span><br><span class=\"hljs-string\">  list-timers [PATTERN...]        List loaded timers ordered by next elapse</span><br><span class=\"hljs-string\">  start NAME...                   Start (activate) one or more units</span><br><span class=\"hljs-string\">  stop NAME...                    Stop (deactivate) one or more units</span><br><span class=\"hljs-string\">  reload NAME...                  Reload one or more units</span><br><span class=\"hljs-string\">  restart NAME...                 Start or restart one or more units</span><br><span class=\"hljs-string\">  try-restart NAME...             Restart one or more units if active</span><br><span class=\"hljs-string\">  reload-or-restart NAME...       Reload one or more units if possible,</span><br><span class=\"hljs-string\">                                  otherwise start or restart</span><br><span class=\"hljs-string\">  reload-or-try-restart NAME...   Reload one or more units if possible,</span><br><span class=\"hljs-string\">                                  otherwise restart if active</span><br><span class=\"hljs-string\">  isolate NAME                    Start one unit and stop all others</span><br><span class=\"hljs-string\">  kill NAME...                    Send signal to processes of a unit</span><br><span class=\"hljs-string\">  is-active PATTERN...            Check whether units are active</span><br><span class=\"hljs-string\">  is-failed PATTERN...            Check whether units are failed</span><br><span class=\"hljs-string\">  status [PATTERN...|PID...]      Show runtime status of one or more units</span><br><span class=\"hljs-string\">  show [PATTERN...|JOB...]        Show properties of one or more</span><br><span class=\"hljs-string\">                                  units/jobs or the manager</span><br><span class=\"hljs-string\">  cat PATTERN...                  Show files and drop-ins of one or more units</span><br><span class=\"hljs-string\">  set-property NAME ASSIGNMENT... Sets one or more properties of a unit</span><br><span class=\"hljs-string\">  help PATTERN...|PID...          Show manual for one or more units</span><br><span class=\"hljs-string\">  reset-failed [PATTERN...]       Reset failed state for all, one, or more</span><br><span class=\"hljs-string\">                                  units</span><br><span class=\"hljs-string\">  list-dependencies [NAME]        Recursively show units which are required</span><br><span class=\"hljs-string\">                                  or wanted by this unit or by which this</span><br><span class=\"hljs-string\">                                  unit is required or wanted</span><br><span class=\"hljs-string\">Unit File Commands:</span><br><span class=\"hljs-string\">  list-unit-files [PATTERN...]    List installed unit files</span><br><span class=\"hljs-string\">  enable NAME...                  Enable one or more unit files</span><br><span class=\"hljs-string\">  disable NAME...                 Disable one or more unit files</span><br><span class=\"hljs-string\">  reenable NAME...                Reenable one or more unit files</span><br><span class=\"hljs-string\">  preset NAME...                  Enable/disable one or more unit files</span><br><span class=\"hljs-string\">                                  based on preset configuration</span><br><span class=\"hljs-string\">  preset-all                      Enable/disable all unit files based on</span><br><span class=\"hljs-string\">                                  preset configuration</span><br><span class=\"hljs-string\">  is-enabled NAME...              Check whether unit files are enabled</span><br><span class=\"hljs-string\">  mask NAME...                    Mask one or more units</span><br><span class=\"hljs-string\">  unmask NAME...                  Unmask one or more units</span><br><span class=\"hljs-string\">  link PATH...                    Link one or more units files into</span><br><span class=\"hljs-string\">                                  the search path</span><br><span class=\"hljs-string\">  add-wants TARGET NAME...        Add &#x27;</span>Wants<span class=\"hljs-string\">&#x27; dependency for the target</span><br><span class=\"hljs-string\">                                  on specified one or more units</span><br><span class=\"hljs-string\">  add-requires TARGET NAME...     Add &#x27;</span>Requires<span class=\"hljs-string\">&#x27; dependency for the target</span><br><span class=\"hljs-string\">                                  on specified one or more units</span><br><span class=\"hljs-string\">  edit NAME...                    Edit one or more unit files</span><br><span class=\"hljs-string\">  get-default                     Get the name of the default target</span><br><span class=\"hljs-string\">  set-default NAME                Set the default target</span><br><span class=\"hljs-string\">Machine Commands:</span><br><span class=\"hljs-string\">  list-machines [PATTERN...]      List local containers and host</span><br><span class=\"hljs-string\">Job Commands:</span><br><span class=\"hljs-string\">  list-jobs [PATTERN...]          List jobs</span><br><span class=\"hljs-string\">  cancel [JOB...]                 Cancel all, one, or more jobs</span><br><span class=\"hljs-string\">Snapshot Commands:</span><br><span class=\"hljs-string\">  snapshot [NAME]                 Create a snapshot</span><br><span class=\"hljs-string\">  delete NAME...                  Remove one or more snapshots</span><br><span class=\"hljs-string\">Environment Commands:</span><br><span class=\"hljs-string\">  show-environment                Dump environment</span><br><span class=\"hljs-string\">  set-environment NAME=VALUE...   Set one or more environment variables</span><br><span class=\"hljs-string\">  unset-environment NAME...       Unset one or more environment variables</span><br><span class=\"hljs-string\">  import-environment [NAME...]    Import all or some environment variables</span><br><span class=\"hljs-string\">Manager Lifecycle Commands:</span><br><span class=\"hljs-string\">  daemon-reload                   Reload systemd manager configuration</span><br><span class=\"hljs-string\">  daemon-reexec                   Reexecute systemd manager</span><br><span class=\"hljs-string\">System Commands:</span><br><span class=\"hljs-string\">  is-system-running               Check whether system is fully running</span><br><span class=\"hljs-string\">  default                         Enter system default mode</span><br><span class=\"hljs-string\">  rescue                          Enter system rescue mode</span><br><span class=\"hljs-string\">  emergency                       Enter system emergency mode</span><br><span class=\"hljs-string\">  halt                            Shut down and halt the system</span><br><span class=\"hljs-string\">  poweroff                        Shut down and power-off the system</span><br><span class=\"hljs-string\">  reboot [ARG]                    Shut down and reboot the system</span><br><span class=\"hljs-string\">  kexec                           Shut down and reboot the system with kexec</span><br><span class=\"hljs-string\">  exit                            Request user instance exit</span><br><span class=\"hljs-string\">  switch-root ROOT [INIT]         Change to a different root file system</span><br><span class=\"hljs-string\">  suspend                         Suspend the system</span><br><span class=\"hljs-string\">  hibernate                       Hibernate the system</span><br><span class=\"hljs-string\">  hybrid-sleep                    Hibernate and suspend the system</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Unit-管理\"><a href=\"#Unit-管理\" class=\"headerlink\" title=\"Unit 管理\"></a><strong>Unit 管理</strong></h3><ol>\n<li>查看当前系统的所有 Unit</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 列出正在运行的 Unit<br>$ systemctl list-units<br><br># 列出所有Unit，包括没有找到配置文件的或者启动失败的<br>$ systemctl list-units --all<br><br># 列出所有没有运行的 Unit<br>$ systemctl list-units --all --state=inactive<br><br># 列出所有加载失败的 Unit<br>$ systemctl list-units --failed<br><br># 列出所有正在运行的、类型为 service 的 Unit<br>$ systemctl list-units --type=service<br><br># 查看 Unit 配置文件的内容<br>$ systemctl cat docker.service<br></code></pre></td></tr></table></figure>\n<ol>\n<li>查看 Unit 的状态</li>\n</ol>\n<ul>\n<li>enabled：已建立启动链接</li>\n<li>disabled：没建立启动链接</li>\n<li>static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖</li>\n<li>masked：该配置文件被禁止建立启动链接</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 显示系统状态<br>$ systemctl status<br><br># 显示单个 Unit 的状态<br>$ ystemctl status bluetooth.service<br><br># 显示远程主机的某个 Unit 的状态<br>$ systemctl -H root@rhel7.example.com status httpd.service<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Unit 的管理</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 立即启动一个服务<br>$ sudo systemctl start apache.service<br><br># 立即停止一个服务<br>$ sudo systemctl stop apache.service<br><br># 重启一个服务<br>$ sudo systemctl restart apache.service<br><br># 杀死一个服务的所有子进程<br>$ sudo systemctl kill apache.service<br><br># 重新加载一个服务的配置文件<br>$ sudo systemctl reload apache.service<br><br># 重载所有修改过的配置文件<br>$ sudo systemctl daemon-reload<br><br># 显示某个 Unit 的所有底层参数<br>$ systemctl show httpd.service<br><br># 显示某个 Unit 的指定属性的值<br>$ systemctl show -p CPUShares httpd.service<br><br># 设置某个 Unit 的指定属性<br>$ sudo systemctl set-property httpd.service CPUShares=<span class=\"hljs-number\">500</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>查看 Unit 的依赖关系</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 列出一个 Unit 的所有依赖，默认不会列出 target 类型<br>$ systemctl list-dependencies nginx.service<br><br># 列出一个 Unit 的所有依赖，包括 target 类型<br>$ systemctl list-dependencies --all nginx.service<br></code></pre></td></tr></table></figure>\n<h3 id=\"服务的生命周期\"><a href=\"#服务的生命周期\" class=\"headerlink\" title=\"服务的生命周期\"></a><strong>服务的生命周期</strong></h3><p>当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。</p>\n<ol>\n<li>服务的激活</li>\n</ol>\n<ul>\n<li>systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中</li>\n<li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li>\n</ul>\n<ol>\n<li>服务的启动和停止</li>\n</ol>\n<ul>\n<li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li>\n<li>systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令</li>\n<li>systemctl restart：重启服务</li>\n<li>systemctl kill：立即杀死服务</li>\n</ul>\n<ol>\n<li>服务的开机启动和取消</li>\n</ol>\n<ul>\n<li>systemctl enable：除了激活服务以外，也可以置服务为开机启动</li>\n<li>systemctl disable：取消服务的开机启动</li>\n</ul>\n<ol>\n<li>服务的修改和移除</li>\n</ol>\n<ul>\n<li>systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件</li>\n<li>systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。</li>\n</ul>\n<h3 id=\"Target-管理\"><a href=\"#Target-管理\" class=\"headerlink\" title=\"Target 管理\"></a><strong>Target 管理</strong></h3><p>Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p>\n<p>在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 查看当前系统的所有 Target<br>$ systemctl list-unit-files --type=target<br><br># 查看一个 Target 包含的所有 Unit<br>$ systemctl list-dependencies multi-user.target<br><br># 查看启动时的默认 Target<br>$ systemctl get-<span class=\"hljs-keyword\">default</span><br><br># 设置启动时的默认 Target<br>$ sudo systemctl set-<span class=\"hljs-keyword\">default</span> multi-user.target<br><br># 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程<br>$ sudo systemctl isolate multi-user.target<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Target 与 SysV-init 进程的主要区别：</li>\n</ol>\n<ul>\n<li>默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</li>\n<li>启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。</li>\n<li>配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。</li>\n</ul>\n<h3 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a><strong>日志管理</strong></h3><p>Systemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。</p>\n<p>Systemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。</p>\n<p>默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 查看所有日志（默认情况下 ，只保存本次启动的日志）<br>$ sudo journalctl<br><br># 查看内核日志（不显示应用日志）：--dmesg 或 -k<br>$ sudo journalctl -k<br><br># 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b<br>$ sudo journalctl -b<br>$ sudo journalctl -b -<span class=\"hljs-number\">0</span><br><br># 查看上一次启动的日志（需更改设置）<br>$ sudo journalctl -b -<span class=\"hljs-number\">1</span><br><br># 查看指定服务的日志：--unit 或 -u<br>$ sudo journalctl -u docker.servcie<br><br># 查看指定服务的日志<br>$ sudo journalctl /usr/lib/systemd/systemd<br><br># 实时滚动显示最新日志<br>$ sudo journalctl -f<br><br># 查看指定时间的日志<br>$ sudo journalctl --since=<span class=\"hljs-string\">&quot;2012-10-30 18:17:16&quot;</span><br>$ sudo journalctl --since <span class=\"hljs-string\">&quot;20 min ago&quot;</span><br>$ sudo journalctl --since yesterday<br>$ sudo journalctl --since <span class=\"hljs-string\">&quot;2015-01-10&quot;</span> --until <span class=\"hljs-string\">&quot;2015-01-11 03:00&quot;</span><br>$ sudo journalctl --since <span class=\"hljs-number\">09</span>:<span class=\"hljs-number\">00</span> --until <span class=\"hljs-string\">&quot;1 hour ago&quot;</span><br><br># 显示尾部的最新 10 行日志：--lines 或 -n<br>$ sudo journalctl -n<br><br># 显示尾部指定行数的日志<br>$ sudo journalctl -n <span class=\"hljs-number\">20</span><br><br># 将最新的日志显示在前面<br>$ sudo journalctl -r -u docker.service<br><br># 改变输出的格式：--output 或 -o<br>$ sudo journalctl -r -u docker.service -o json-pretty<br><br># 查看指定进程的日志<br>$ sudo journalctl _PID=<span class=\"hljs-number\">1</span><br><br># 查看某个路径的脚本的日志<br>$ sudo journalctl /usr/bin/bash<br><br># 查看指定用户的日志<br>$ sudo journalctl _UID=<span class=\"hljs-number\">33</span> --since today<br><br># 查看某个 Unit 的日志<br>$ sudo journalctl -u nginx.service<br>$ sudo journalctl -u nginx.service --since today<br><br># 实时滚动显示某个 Unit 的最新日志<br>$ sudo journalctl -u nginx.service -f<br><br># 合并显示多个 Unit 的日志<br>$ journalctl -u nginx.service -u php-fpm.service --since today<br><br># 查看指定优先级（及其以上级别）的日志，共有 8 级<br># 0: emerg<br># 1: alert<br># 2: crit<br># 3: err<br># 4: warning<br># 5: notice<br># 6: info<br># 7: debug<br>$ sudo journalctl -p err -b<br><br># 日志默认分页输出，--no-pager 改为正常的标准输出<br>$ sudo journalctl --no-pager<br><br># 以 JSON 格式（单行）输出<br>$ sudo journalctl -b -u nginx.service -o json<br><br># 以 JSON 格式（多行）输出，可读性更好<br>$ sudo journalctl -b -u nginx.serviceqq<br> -o json-pretty<br><br># 显示日志占据的硬盘空间<br>$ sudo journalctl --disk-usage<br><br># 指定日志文件占据的最大空间<br>$ sudo journalctl --vacuum-size=1G<br><br># 指定日志文件保存多久<br>$ sudo journalctl --vacuum-time=1years<br></code></pre></td></tr></table></figure>\n<h2 id=\"Systemd-工具集\"><a href=\"#Systemd-工具集\" class=\"headerlink\" title=\"Systemd 工具集\"></a><strong>Systemd 工具集</strong></h2><ul>\n<li>systemctl：用于检查和控制各种系统服务和资源的状态</li>\n<li>bootctl：用于查看和管理系统启动分区</li>\n<li>hostnamectl：用于查看和修改系统的主机名和主机信息</li>\n<li>journalctl：用于查看系统日志和各类应用服务日志</li>\n<li>localectl：用于查看和管理系统的地区信息</li>\n<li>loginctl：用于管理系统已登录用户和 Session 的信息</li>\n<li>machinectl：用于操作 Systemd 容器</li>\n<li>timedatectl：用于查看和管理系统的时间和时区信息</li>\n<li>systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈</li>\n<li>systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容</li>\n<li>systemd-cat：用于将其他命令的输出重定向到系统日志</li>\n<li>systemd-cgls：递归地显示指定 CGroup 的继承链</li>\n<li>systemd-cgtop：显示系统当前最耗资源的 CGroup 单元</li>\n<li>systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符</li>\n<li>systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库</li>\n<li>systemd-delta：对比当前系统配置与默认系统配置的差异</li>\n<li>systemd-detect-virt：显示主机的虚拟化类型</li>\n<li>systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件</li>\n<li>systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID</li>\n<li>systemd-notify：Systemd 的内部工具，用于通知服务的状态变化</li>\n<li>systemd-nspawn：用于创建 Systemd 容器</li>\n<li>systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置</li>\n<li>systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行</li>\n<li>systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线</li>\n<li>systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录</li>\n<li>systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求</li>\n</ul>\n<ol>\n<li>systemctl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 重启系统<br>$ sudo systemctl reboot<br><br># 关闭系统，切断电源<br>$ sudo systemctl poweroff<br><br># CPU停止工作<br>$ sudo systemctl halt<br><br># 暂停系统<br>$ sudo systemctl suspend<br><br># 让系统进入冬眠状态<br>$ sudo systemctl hibernate<br><br># 让系统进入交互式休眠状态<br>$ sudo systemctl hybrid-sleep<br><br># 启动进入救援状态（单用户状态）<br>$ sudo systemctl rescue<br></code></pre></td></tr></table></figure>\n<ol>\n<li>systemd-analyze</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 查看启动耗时<br>$ systemd-analyze<br><br># 查看每个服务的启动耗时<br>$ systemd-analyze blame<br><br># 显示瀑布状的启动过程流<br>$ systemd-analyze critical-chain<br><br># 显示指定服务的启动流<br>$ systemd-analyze critical-chain atd.service<br></code></pre></td></tr></table></figure>\n<ol>\n<li>hostnamectl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 显示当前主机的信息<br>$ hostnamectl<br><br># 设置主机名。<br>$ sudo hostnamectl set-hostname rhel7<br></code></pre></td></tr></table></figure>\n<ol>\n<li>timedatectl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 查看当前时区设置<br>$ timedatectl<br><br># 显示所有可用的时区<br>$ timedatectl list-timezones<br><br># 设置当前时区<br>$ sudo timedatectl set-timezone America/New_York<br>$ sudo timedatectl set-time YYYY-MM-DD<br>$ sudo timedatectl set-time HH:MM:SS<br></code></pre></td></tr></table></figure>\n<ol>\n<li>loginctl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 列出当前 session<br>$ loginctl list-sessions<br><br># 列出当前登录用户<br>$ loginctl list-users<br><br># 列出显示指定用户的信息<br>$ loginctl show-user ruanyf<br></code></pre></td></tr></table></figure>\n<ol>\n<li>systemd-ask-password</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$ PASSWORD=$(systemd-ask-password <span class=\"hljs-string\">&quot;Input Your Passowrd:&quot;</span>)<br></code></pre></td></tr></table></figure>\n<ol>\n<li>systemd-run</li>\n</ol>\n<p>systemd-run 可以将一个指定的操作变成后台运行的服务。它的效果似乎与直接在命令后加上表示后台运行的 &amp; 符号很相似。然而，它让命令成为服务还意味着，它的生命周期将由 Systemd 控制。具体来说，包括以下好处：</p>\n<ul>\n<li>服务的生命击期由 Systemd 接管，不会随着启动它的控制台关闭而结束</li>\n<li>可以通过 systemctl 工具管理服务的状态</li>\n<li>可以通过 journalctl 工具查看和管理服务的日志信息</li>\n<li>可以通过 Systemd 提供的方法限制服务的 CPU、内存、磁盘 IO 等系统资源的使用情况。</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"Systemd-概述\"><a href=\"#Systemd-概述\" class=\"headerlink\" title=\"Systemd 概述\"></a><strong>Systemd 概述</strong></h2><h3 id=\"Systemd-简介\"><a href=\"#Systemd-简介\" class=\"headerlink\" title=\"Systemd 简介\"></a><strong>Systemd 简介</strong></h3><p>Systemd 是一系列工具的集合，其作用也远远不仅是启动操作系统，它还接管了后台服务、结束、状态查询，以及日志归档、设备管理、电源管理、定时任务等许多职责，并支持通过特定事件（如插入特定 USB 设备）和特定端口数据触发的 On-demand（按需）任务。</p>\n<p>Systemd 的后台服务还有一个特殊的身份——它是系统中 PID 值为 1 的进程。</p>\n<ol>\n<li>更少的进程</li>\n</ol>\n<p>Systemd 提供了 服务按需启动 的能力，使得特定的服务只有在真定被请求时才启动。</p>\n<ol>\n<li>允许更多的进程并行启动</li>\n</ol>\n<p>在 SysV-init 时代，将每个服务项目编号依次执行启动脚本。Ubuntu 的 Upstart 解决了没有直接依赖的启动之间的并行启动。而 Systemd 通过 Socket 缓存、DBus 缓存和建立临时挂载点等方法进一步解决了启动进程之间的依赖，做到了所有系统服务并发启动。对于用户自定义的服务，Systemd 允许配置其启动依赖项目，从而确保服务按必要的顺序运行。</p>\n<ol>\n<li>使用 CGroup 跟踪和管理进程的生命周期</li>\n</ol>\n<p>在 Systemd 之间的主流应用管理服务都是使用 进程树 来跟踪应用的继承关系的，而进程的父子关系很容易通过 两次 fork 的方法脱离。</p>\n<p>而 Systemd 则提供通过 CGroup 跟踪进程关系，引补了这个缺漏。通过 CGroup 不仅能够实现服务之间访问隔离，限制特定应用程序对系统资源的访问配额，还能更精确地管理服务的生命周期。</p>\n<ol>\n<li>统一管理服务日志</li>\n</ol>\n<p>Systemd 是一系列工具的集合， 包括了一个专用的系统日志管理服务：Journald。这个服务的设计初衷是克服现有 Syslog 服务的日志内容易伪造和日志格式不统一等缺点，Journald 用 二进制格式 保存所有的日志信息，因而日志内容很难被手工伪造。Journald 还提供了一个 journalctl 命令来查看日志信息，这样就使得不同服务输出的日志具有相同的排版格式， 便于数据的二次处理。</p>\n<h3 id=\"Systemd-架构\"><a href=\"#Systemd-架构\" class=\"headerlink\" title=\"Systemd 架构\"></a><strong>Systemd 架构</strong></h3><p><img src=\"https://ask.qcloudimg.com/http-save/yehe-5449090/97kx52pwuj.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<h2 id=\"Systemd-的-Unit-文件\"><a href=\"#Systemd-的-Unit-文件\" class=\"headerlink\" title=\"Systemd 的 Unit 文件\"></a><strong>Systemd 的 Unit 文件</strong></h2><p>Systemd 可以管理所有系统资源，不同的资源统称为 Unit（单位）。</p>\n<p>在 Systemd 的生态圈中，Unit 文件统一了过去各种不同系统资源配置格式，例如服务的启/停、定时任务、设备自动挂载、网络配置、虚拟内存配置等。而 Systemd 通过不同的文件后缀来区分这些配置文件。</p>\n<ol>\n<li>Systemd 支持的 12 种 Unit 文件类型</li>\n</ol>\n<ul>\n<li>.automount：用于控制自动挂载文件系统，相当于 SysV-init 的 autofs 服务</li>\n<li>.device：对于 /dev 目录下的设备，主要用于定义设备之间的依赖关系</li>\n<li>.mount：定义系统结构层次中的一个挂载点，可以替代过去的 /etc/fstab 配置文件</li>\n<li>.path：用于监控指定目录或文件的变化，并触发其它 Unit 运行</li>\n<li>.scope：这种 Unit 文件不是用户创建的，而是 Systemd 运行时产生的，描述一些系统服务的分组信息</li>\n<li>.service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件</li>\n<li>.slice：用于表示一个 CGroup 的树，通常用户不会自己创建这样的 Unit 文件</li>\n<li>.snapshot：用于表示一个由 systemctl snapshot 命令创建的 Systemd Units 运行状态快照</li>\n<li>.socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动</li>\n<li>.swap：定义一个用户做虚拟内存的交换分区</li>\n<li>.target：用于对 Unit 文件进行逻辑分组，引导其它 Unit 的执行。它替代了 SysV-init 运行级别的作用，并提供更灵活的基于特定设备事件的启动方式</li>\n<li>.timer：用于配置在特定时间触发的任务，替代了 Crontab 的功能</li>\n</ul>\n<ol>\n<li>Systemd 目录</li>\n</ol>\n<p>Unit 文件按照 Systemd 约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。</p>\n<ul>\n<li>/etc/systemd/system：系统或用户自定义的配置文件</li>\n<li>/run/systemd/system：软件运行时生成的配置文件</li>\n<li>/usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。<ul>\n<li>CentOS 7：Unit 文件指向该目录</li>\n<li>ubuntu 16：被移到了 /lib/systemd/system</li>\n</ul>\n</li>\n</ul>\n<p>Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p>\n<ol>\n<li>Unit 和 Target</li>\n</ol>\n<p>Unit 是 Systemd 管理系统资源的基本单元，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令。</p>\n<p>Target 是 Systemd 中用于指定系统资源启动组的方式，相当于 SysV-init 中的运行级别。</p>\n<p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</p>\n<h2 id=\"Systemd-Service-Unit\"><a href=\"#Systemd-Service-Unit\" class=\"headerlink\" title=\"Systemd Service Unit\"></a><strong>Systemd Service Unit</strong></h2><h3 id=\"Unit-文件结构\"><a href=\"#Unit-文件结构\" class=\"headerlink\" title=\"Unit 文件结构\"></a><strong>Unit 文件结构</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[Unit]<br>Description=Hello World<br>After=docker.service<br>Requires=docker.service<br>[Service]<br>TimeoutStartSec=<span class=\"hljs-number\">0</span><br>ExecStartPre=-<span class=\"hljs-regexp\">/usr/</span>bin/docker kill busybox1<br>ExecStartPre=-<span class=\"hljs-regexp\">/usr/</span>bin/docker rm busybox1<br>ExecStartPre=<span class=\"hljs-regexp\">/usr/</span>bin/docker pull busybox<br>ExecStart=<span class=\"hljs-regexp\">/usr/</span>bin/docker run --name busybox1 busybox /bin/ sh -c <span class=\"hljs-string\">&quot;while true; do echo Hello World; sleep 1; done&quot;</span><br>ExecStop=<span class=\"hljs-string\">&quot;/usr/bin/docker stop busybox1&quot;</span><br>ExecStopPost=<span class=\"hljs-string\">&quot;/usr/bin/docker rm busybox1&quot;</span><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure>\n<p>如下所示，Systemd 服务的 Unit 文件可以分为三个配置区段：</p>\n<ul>\n<li>Unit 和 Install 段：所有 Unit 文件通用，用于配置服务（或其它系统资源）的描述、依赖和随系统启动的方式</li>\n<li>Service 段：服务（Service）类型的 Unit 文件（后缀为 .service）特有的，用于定义服务的具体管理和操作方法</li>\n</ul>\n<h4 id=\"Unit-段\"><a href=\"#Unit-段\" class=\"headerlink\" title=\"Unit 段\"></a><strong>Unit 段</strong></h4><ul>\n<li>Description：描述这个 Unit 文件的信息</li>\n<li>Documentation：指定服务的文档，可以是一个或多个文档的 URL 路径</li>\n<li>Requires：依赖的其它 Unit 列表，列在其中的 Unit 模板会在这个服务启动时的同时被启动。并且，如果其中任意一个服务启动失败，这个服务也会被终止</li>\n<li>Wants：与 Requires 相似，但只是在被配置的这个 Unit 启动时，触发启动列出的每个 Unit 模块，而不去考虑这些模板启动是否成功</li>\n<li>After：与 Requires 相似，但是在后面列出的所有模块全部启动完成以后，才会启动当前的服务</li>\n<li>Before：与 After 相反，在启动指定的任务一个模块之间，都会首先确证当前服务已经运行</li>\n<li>Binds To：与 Requires 相似，失败时失败，成功时成功，但是在这些模板中有任意一个出现意外结束或重启时，这个服务也会跟着终止或重启</li>\n<li>Part Of：一个 Bind To 作用的子集，仅在列出的任务模块失败或重启时，终止或重启当前服务，而不会随列出模板的启动而启动</li>\n<li>OnFailure：当这个模板启动失败时，就会自动启动列出的每个模块</li>\n<li>Conflicts：与这个模块有冲突的模块，如果列出的模块中有已经在运行的，这个服务就不能启动，反之亦然</li>\n</ul>\n<h4 id=\"Install-段\"><a href=\"#Install-段\" class=\"headerlink\" title=\"Install 段\"></a><strong>Install 段</strong></h4><p>这部分配置的目标模块通常是特定运行目标的 .target 文件，用来使得服务在系统启动时自动运行。这个区段可以包含三种启动约束：</p>\n<ul>\n<li>WantedBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .wants 后缀构成的子目录中，如 “/etc/systemd/system/multi-user.target.wants/“</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># find /etc/systemd/system/* -type d<br>/etc/systemd/system/<span class=\"hljs-keyword\">default</span>.target.wants<br>/etc/systemd/system/getty.target.wants<br>/etc/systemd/system/graphical.target.wants<br>/etc/systemd/system/multi-user.target.wants<br>/etc/systemd/system/network-online.target.wants<br>/etc/systemd/system/paths.target.wants<br>/etc/systemd/system/shutdown.target.wants<br>/etc/systemd/system/sockets.target.wants<br>/etc/systemd/system/sysinit.target.wants<br>/etc/systemd/system/timers.target.wants<br></code></pre></td></tr></table></figure>\n<ul>\n<li>RequiredBy：和 Unit 段的 Wants 作用相似，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块。它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入 /etc/systemd/system 目录下面以 &lt;Target 名&gt; + .required 后缀构成的子目录中</li>\n<li>Also：当前 Unit enable/disable 时，同时 enable/disable 的其他 Unit</li>\n<li>Alias：当前 Unit 可用于启动的别名</li>\n</ul>\n<ol>\n<li>SysV-init 运行级别与 Systemd Target 对应的 Unit 文件</li>\n</ol>\n<p><img src=\"https://ask.qcloudimg.com/http-save/yehe-5449090/mvna7qlr41.png?imageView2/2/w/1620\" alt=\"img\"></p>\n<p>通过 systemctl list-units –type=target 命令可以获取当前正在使用的运行目标</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># systemctl list-units --type=target<br>UNIT                   LOAD   ACTIVE SUB    DESCRIPTION<br>basic.target           loaded active active Basic System<br>cryptsetup.target      loaded active active Encrypted Volumes<br>getty.target           loaded active active Login Prompts<br>graphical.target       loaded active active Graphical Interface<br>local-fs-pre.target    loaded active active Local File Systems (Pre)<br>local-fs.target        loaded active active Local File Systems<br>multi-user.target      loaded active active Multi-User System<br>network-online.target  loaded active active Network is Online<br>network.target         loaded active active Network<br>nss-user-lookup.target loaded active active User and Group Name Lookups<br>paths.target           loaded active active Paths<br>remote-fs-pre.target   loaded active active Remote File Systems (Pre)<br>remote-fs.target       loaded active active Remote File Systems<br>slices.target          loaded active active Slices<br>sockets.target         loaded active active Sockets<br>sound.target           loaded active active Sound Card<br>swap.target            loaded active active Swap<br>sysinit.target         loaded active active System Initialization<br>time-sync.target       loaded active active System Time Synchronized<br>timers.target          loaded active active Timers<br>LOAD   = Reflects whether the unit definition was properly loaded.<br>ACTIVE = The high-level unit activation state, i.e. generalization <span class=\"hljs-keyword\">of</span> SUB.<br>SUB    = The low-level unit activation state, values depend on unit type.<br><span class=\"hljs-number\">20</span> loaded units listed. Pass --all to see loaded but inactive units, too.<br>To show all installed unit files use <span class=\"hljs-string\">&#x27;systemctl list-unit-files&#x27;</span>.<br></code></pre></td></tr></table></figure>\n<h4 id=\"Service-段\"><a href=\"#Service-段\" class=\"headerlink\" title=\"Service 段\"></a><strong>Service 段</strong></h4><p>用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段分为服务生命周期和服务上下文配置两个方面。</p>\n<ol>\n<li>服务生命周期控制相关</li>\n</ol>\n<ul>\n<li>Type：定义启动时的进程行为，它有以下几种值：<ul>\n<li>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</li>\n<li>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li>\n<li>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li>\n<li>Type=dbus：当前服务通过D-Bus启动</li>\n<li>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</li>\n<li>Type=idle：若有其他任务执行完毕，当前服务才会运行</li>\n</ul>\n</li>\n<li>RemainAfterExit：值为 true 或 false（默认）。当配置为 true 时，Systemd 只会负责启动服务进程，之后即便服务进程退出了，Systemd 也仍然会认为这个服务还在运行中。这个配置主要是提供给一些并非常驻内存，而是启动注册后立即退出，然后等待消息按需启动的特殊类型服务使用的。</li>\n<li>ExecStart：启动当前服务的命令</li>\n<li>ExecStartPre：启动当前服务之前执行的命令</li>\n<li>ExecStartPos：启动当前服务之后执行的命令</li>\n<li>ExecReload：重启当前服务时执行的命令</li>\n<li>ExecStop：停止当前服务时执行的命令</li>\n<li>ExecStopPost：停止当其服务之后执行的命令</li>\n<li>RestartSec：自动重启当前服务间隔的秒数</li>\n<li>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li>\n<li>TimeoutStartSec：启动服务时等待的秒数，这一配置对于使用 Docker 容器而言显得尤为重要，因其第一次运行时可能需要下载镜像，严重延时会容易被 Systemd 误判为启动失败杀死。通常，对于这种服务，将此值指定为 0，从而关闭超时检测</li>\n<li>TimeoutStopSec：停止服务时的等待秒数，如果超过这个时间仍然没有停止，Systemd 会使用 SIGKILL 信号强行杀死服务的进程</li>\n</ul>\n<ol>\n<li>服务上下文配置相关</li>\n</ol>\n<ul>\n<li>Environment：为服务指定环境变量</li>\n<li>EnvironmentFile：指定加载一个包含服务所需的环境变量的列表的文件，文件中的每一行都是一个环境变量的定义</li>\n<li>Nice：服务的进程优先级，值越小优先级越高，默认为 0。其中 -20 为最高优先级，19 为最低优先级</li>\n<li>WorkingDirectory：指定服务的工作目录</li>\n<li>RootDirectory：指定服务进程的根目录（/ 目录）。如果配置了这个参数，服务将无法访问指定目录以外的任何文件</li>\n<li>User：指定运行服务的用户</li>\n<li>Group：指定运行服务的用户组</li>\n<li>MountFlags：服务的 Mount Namespace 配置，会影响进程上下文中挂载点的信息，即服务是否会继承主机上已有挂载点，以及如果服务运行执行了挂载或卸载设备的操作，是否会真实地在主机上产生效果。可选值为 shared、slaved 或 private<ul>\n<li>shared：服务与主机共用一个 Mount Namespace，继承主机挂载点，且服务挂载或卸载设备会真实地反映到主机上</li>\n<li>slave：服务使用独立的 Mount Namespace，它会继承主机挂载点，但服务对挂载点的操作只有在自己的 Namespace 内生效，不会反映到主机上</li>\n<li>private：服务使用独立的 Mount Namespace，它在启动时没有任何任何挂载点，服务对挂载点的操作也不会反映到主机上</li>\n</ul>\n</li>\n<li>LimitCPU / LimitSTACK / LimitNOFILE / LimitNPROC 等：限制特定服务的系统资源量，例如 CPU、程序堆栈、文件句柄数量、子进程数量等</li>\n</ul>\n<blockquote>\n<p>注意：如果在 ExecStart、ExecStop 等属性中使用了 Linux 命令，则必须要写出完整的绝对路径。对于 ExecStartPre 和 ExecStartPost 辅助命令，若前面有个 “-” 符号，表示忽略这些命令的出错。因为有些 “辅助” 命令本来就不一定成功，比如尝试清空一个文件，但文件可能不存在。</p>\n</blockquote>\n<h3 id=\"Unit-文件占位符和模板\"><a href=\"#Unit-文件占位符和模板\" class=\"headerlink\" title=\"Unit 文件占位符和模板\"></a><strong>Unit 文件占位符和模板</strong></h3><h4 id=\"Unit-文件占位符\"><a href=\"#Unit-文件占位符\" class=\"headerlink\" title=\"Unit 文件占位符\"></a><strong>Unit 文件占位符</strong></h4><p>在 Unit 文件中，有时会需要使用到一些与运行环境有关的信息，例如节点 ID、运行服务的用户等。这些信息可以使用占位符来表示，然后在实际运行被动态地替换实际的值。</p>\n<ul>\n<li>%n：完整的 Unit 文件名字，包括 .service 后缀名</li>\n<li>%p：Unit 模板文件名中 @ 符号之前的部分，不包括 @ 符号</li>\n<li>%i：Unit 模板文件名中 @ 符号之后的部分，不包括 @ 符号和 .service 后缀名</li>\n<li>%t：存放系统运行文件的目录，通常是 “run”</li>\n<li>%u：运行服务的用户，如果 Unit 文件中没有指定，则默认为 root</li>\n<li>%U：运行服务的用户 ID</li>\n<li>%h：运行服务的用户 Home 目录，即 %{HOME} 环境变量的值</li>\n<li>%s：运行服务的用户默认 Shell 类型，即 %{SHELL} 环境变量的值</li>\n<li>%m：实际运行节点的 Machine ID，对于运行位置每个的服务比较有用</li>\n<li>%b：Boot ID，这是一个随机数，每个节点各不相同，并且每次节点重启时都会改变</li>\n<li>%H：实际运行节点的主机名</li>\n<li>%v：内核版本，即 “uname -r” 命令输出的内容</li>\n<li>%%：在 Unit 模板文件中表示一个普通的百分号</li>\n</ul>\n<h4 id=\"Unit-模板\"><a href=\"#Unit-模板\" class=\"headerlink\" title=\"Unit 模板\"></a><strong>Unit 模板</strong></h4><p>在现实中，往往有一些应用需要被复制多份运行。例如，用于同一个<a href=\"https://cloud.tencent.com/product/clb?from=10680\">负载均衡</a>器分流的多个服务实例，或者为每个 SSH 连接建立一个独立的 sshd 服务进程。</p>\n<p>Unit 模板文件的写法与普通的服务 Unit 文件基本相同，不过 Unit 模板的文件名是以 @ 符号结尾的。通过模板启动服务实例时，需要在其文件名的 @ 字符后面附加一个参数字符串。</p>\n<ol>\n<li>示例：apache@.service</li>\n</ol>\n<ul>\n<li>apache@.service 模板</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">[Unit]<br>Description=My Advanced Service Template<br>After=etcd.service docker.service<br>[Service]<br>TimeoutStartSec=<span class=\"hljs-number\">0</span><br>ExecStartPre=-<span class=\"hljs-regexp\">/usr/</span>bin/docker kill apache%i<br>ExecStartPre=-<span class=\"hljs-regexp\">/usr/</span>bin/docker rm apache%i<br>ExecStartPre=<span class=\"hljs-regexp\">/usr/</span>bin/docker pull coreos/apache<br>ExecStart=<span class=\"hljs-regexp\">/usr/</span>bin/docker run --name apache%i -p %i:<span class=\"hljs-number\">80</span> coreos/apache /usr/sbin/apache2ctl -D FOREGROUND<br>ExecStartPost=<span class=\"hljs-regexp\">/usr/</span>bin/etcdctl set /domains/example.com/%H:%i running<br>ExecStop=<span class=\"hljs-regexp\">/usr/</span>bin/docker stop apache1<br>ExecStopPost=<span class=\"hljs-regexp\">/usr/</span>bin/docker rm apache1<br>ExecStopPost=<span class=\"hljs-regexp\">/usr/</span>bin/etcdctl rm /domains/example.com/%H:%i<br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure>\n<ul>\n<li>启动 Unit 模板的服务实例</li>\n</ul>\n<p>在服务启动时需要在 @ 后面放置一个用于区分服务实例的附加字符参数，通常这个参数用于监控的端口号或控制台 TTY 编译号。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># systemctl start apache@8080.service<br></code></pre></td></tr></table></figure>\n<p>Systemd 在运行服务时，总是会先尝试找到一个完整匹配的 Unit 文件，如果没有找到，才会尝试选择匹配模板。例如上面的命令，System 首先会在约定的目录下寻找名为 <a href=\"mailto:apache@8080.service\">apache@8080.service</a> 的文件，如果没有找到，而文件名中包含 @ 字符，它就会尝试去掉后缀参数匹配模板文件。对于 <a href=\"mailto:apache@8080.service\">apache@8080.service</a>，systemd 会找到 apache@.service 模板文件，并通过这个模板文件将服务实例化。</p>\n<h2 id=\"Systemd-的资源管理\"><a href=\"#Systemd-的资源管理\" class=\"headerlink\" title=\"Systemd 的资源管理\"></a><strong>Systemd 的资源管理</strong></h2><h3 id=\"Systemctl-命令\"><a href=\"#Systemctl-命令\" class=\"headerlink\" title=\"Systemctl 命令\"></a><strong>Systemctl 命令</strong></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># systemctl --help<br>systemctl [OPTIONS...] &#123;COMMAND&#125; ...<br>Query or send control commands to the systemd manager.<br>  -h --help           Show <span class=\"hljs-built_in\">this</span> help<br>     --version        Show package version<br>     --system         Connect to system manager<br>  -H --host=[USER@]HOST<br>                      Operate on remote host<br>  -M --machine=CONTAINER<br>                      Operate on local container<br>  -t --type=TYPE      List units <span class=\"hljs-keyword\">of</span> a particular type<br>     --state=STATE    List units <span class=\"hljs-keyword\">with</span> particular LOAD or SUB or ACTIVE state<br>  -p --property=NAME  Show only properties by <span class=\"hljs-built_in\">this</span> name<br>  -a --all            Show all loaded units/properties, including dead/empty<br>                      ones. To list all units installed on the system, use<br>                      the <span class=\"hljs-string\">&#x27;list-unit-files&#x27;</span> command instead.<br>  -l --full           Don<span class=\"hljs-string\">&#x27;t ellipsize unit names on output</span><br><span class=\"hljs-string\">  -r --recursive      Show unit list of host and local containers</span><br><span class=\"hljs-string\">     --reverse        Show reverse dependencies with &#x27;</span>list-dependencies<span class=\"hljs-string\">&#x27;</span><br><span class=\"hljs-string\">     --job-mode=MODE  Specify how to deal with already queued jobs, when</span><br><span class=\"hljs-string\">                      queueing a new job</span><br><span class=\"hljs-string\">     --show-types     When showing sockets, explicitly show their type</span><br><span class=\"hljs-string\">  -i --ignore-inhibitors</span><br><span class=\"hljs-string\">                      When shutting down or sleeping, ignore inhibitors</span><br><span class=\"hljs-string\">     --kill-who=WHO   Who to send signal to</span><br><span class=\"hljs-string\">  -s --signal=SIGNAL  Which signal to send</span><br><span class=\"hljs-string\">     --now            Start or stop unit in addition to enabling or disabling it</span><br><span class=\"hljs-string\">  -q --quiet          Suppress output</span><br><span class=\"hljs-string\">     --no-block       Do not wait until operation finished</span><br><span class=\"hljs-string\">     --no-wall        Don&#x27;</span>t send wall message before halt/power-off/reboot<br>     --no-reload      Don<span class=\"hljs-string\">&#x27;t reload daemon after en-/dis-abling unit files</span><br><span class=\"hljs-string\">     --no-legend      Do not print a legend (column headers and hints)</span><br><span class=\"hljs-string\">     --no-pager       Do not pipe output into a pager</span><br><span class=\"hljs-string\">     --no-ask-password</span><br><span class=\"hljs-string\">                      Do not ask for system passwords</span><br><span class=\"hljs-string\">     --global         Enable/disable unit files globally</span><br><span class=\"hljs-string\">     --runtime        Enable unit files only temporarily until next reboot</span><br><span class=\"hljs-string\">  -f --force          When enabling unit files, override existing symlinks</span><br><span class=\"hljs-string\">                      When shutting down, execute action immediately</span><br><span class=\"hljs-string\">     --preset-mode=   Apply only enable, only disable, or all presets</span><br><span class=\"hljs-string\">     --root=PATH      Enable unit files in the specified root directory</span><br><span class=\"hljs-string\">  -n --lines=INTEGER  Number of journal entries to show</span><br><span class=\"hljs-string\">  -o --output=STRING  Change journal output mode (short, short-iso,</span><br><span class=\"hljs-string\">                              short-precise, short-monotonic, verbose,</span><br><span class=\"hljs-string\">                              export, json, json-pretty, json-sse, cat)</span><br><span class=\"hljs-string\">     --plain          Print unit dependencies as a list instead of a tree</span><br><span class=\"hljs-string\">Unit Commands:</span><br><span class=\"hljs-string\">  list-units [PATTERN...]         List loaded units</span><br><span class=\"hljs-string\">  list-sockets [PATTERN...]       List loaded sockets ordered by address</span><br><span class=\"hljs-string\">  list-timers [PATTERN...]        List loaded timers ordered by next elapse</span><br><span class=\"hljs-string\">  start NAME...                   Start (activate) one or more units</span><br><span class=\"hljs-string\">  stop NAME...                    Stop (deactivate) one or more units</span><br><span class=\"hljs-string\">  reload NAME...                  Reload one or more units</span><br><span class=\"hljs-string\">  restart NAME...                 Start or restart one or more units</span><br><span class=\"hljs-string\">  try-restart NAME...             Restart one or more units if active</span><br><span class=\"hljs-string\">  reload-or-restart NAME...       Reload one or more units if possible,</span><br><span class=\"hljs-string\">                                  otherwise start or restart</span><br><span class=\"hljs-string\">  reload-or-try-restart NAME...   Reload one or more units if possible,</span><br><span class=\"hljs-string\">                                  otherwise restart if active</span><br><span class=\"hljs-string\">  isolate NAME                    Start one unit and stop all others</span><br><span class=\"hljs-string\">  kill NAME...                    Send signal to processes of a unit</span><br><span class=\"hljs-string\">  is-active PATTERN...            Check whether units are active</span><br><span class=\"hljs-string\">  is-failed PATTERN...            Check whether units are failed</span><br><span class=\"hljs-string\">  status [PATTERN...|PID...]      Show runtime status of one or more units</span><br><span class=\"hljs-string\">  show [PATTERN...|JOB...]        Show properties of one or more</span><br><span class=\"hljs-string\">                                  units/jobs or the manager</span><br><span class=\"hljs-string\">  cat PATTERN...                  Show files and drop-ins of one or more units</span><br><span class=\"hljs-string\">  set-property NAME ASSIGNMENT... Sets one or more properties of a unit</span><br><span class=\"hljs-string\">  help PATTERN...|PID...          Show manual for one or more units</span><br><span class=\"hljs-string\">  reset-failed [PATTERN...]       Reset failed state for all, one, or more</span><br><span class=\"hljs-string\">                                  units</span><br><span class=\"hljs-string\">  list-dependencies [NAME]        Recursively show units which are required</span><br><span class=\"hljs-string\">                                  or wanted by this unit or by which this</span><br><span class=\"hljs-string\">                                  unit is required or wanted</span><br><span class=\"hljs-string\">Unit File Commands:</span><br><span class=\"hljs-string\">  list-unit-files [PATTERN...]    List installed unit files</span><br><span class=\"hljs-string\">  enable NAME...                  Enable one or more unit files</span><br><span class=\"hljs-string\">  disable NAME...                 Disable one or more unit files</span><br><span class=\"hljs-string\">  reenable NAME...                Reenable one or more unit files</span><br><span class=\"hljs-string\">  preset NAME...                  Enable/disable one or more unit files</span><br><span class=\"hljs-string\">                                  based on preset configuration</span><br><span class=\"hljs-string\">  preset-all                      Enable/disable all unit files based on</span><br><span class=\"hljs-string\">                                  preset configuration</span><br><span class=\"hljs-string\">  is-enabled NAME...              Check whether unit files are enabled</span><br><span class=\"hljs-string\">  mask NAME...                    Mask one or more units</span><br><span class=\"hljs-string\">  unmask NAME...                  Unmask one or more units</span><br><span class=\"hljs-string\">  link PATH...                    Link one or more units files into</span><br><span class=\"hljs-string\">                                  the search path</span><br><span class=\"hljs-string\">  add-wants TARGET NAME...        Add &#x27;</span>Wants<span class=\"hljs-string\">&#x27; dependency for the target</span><br><span class=\"hljs-string\">                                  on specified one or more units</span><br><span class=\"hljs-string\">  add-requires TARGET NAME...     Add &#x27;</span>Requires<span class=\"hljs-string\">&#x27; dependency for the target</span><br><span class=\"hljs-string\">                                  on specified one or more units</span><br><span class=\"hljs-string\">  edit NAME...                    Edit one or more unit files</span><br><span class=\"hljs-string\">  get-default                     Get the name of the default target</span><br><span class=\"hljs-string\">  set-default NAME                Set the default target</span><br><span class=\"hljs-string\">Machine Commands:</span><br><span class=\"hljs-string\">  list-machines [PATTERN...]      List local containers and host</span><br><span class=\"hljs-string\">Job Commands:</span><br><span class=\"hljs-string\">  list-jobs [PATTERN...]          List jobs</span><br><span class=\"hljs-string\">  cancel [JOB...]                 Cancel all, one, or more jobs</span><br><span class=\"hljs-string\">Snapshot Commands:</span><br><span class=\"hljs-string\">  snapshot [NAME]                 Create a snapshot</span><br><span class=\"hljs-string\">  delete NAME...                  Remove one or more snapshots</span><br><span class=\"hljs-string\">Environment Commands:</span><br><span class=\"hljs-string\">  show-environment                Dump environment</span><br><span class=\"hljs-string\">  set-environment NAME=VALUE...   Set one or more environment variables</span><br><span class=\"hljs-string\">  unset-environment NAME...       Unset one or more environment variables</span><br><span class=\"hljs-string\">  import-environment [NAME...]    Import all or some environment variables</span><br><span class=\"hljs-string\">Manager Lifecycle Commands:</span><br><span class=\"hljs-string\">  daemon-reload                   Reload systemd manager configuration</span><br><span class=\"hljs-string\">  daemon-reexec                   Reexecute systemd manager</span><br><span class=\"hljs-string\">System Commands:</span><br><span class=\"hljs-string\">  is-system-running               Check whether system is fully running</span><br><span class=\"hljs-string\">  default                         Enter system default mode</span><br><span class=\"hljs-string\">  rescue                          Enter system rescue mode</span><br><span class=\"hljs-string\">  emergency                       Enter system emergency mode</span><br><span class=\"hljs-string\">  halt                            Shut down and halt the system</span><br><span class=\"hljs-string\">  poweroff                        Shut down and power-off the system</span><br><span class=\"hljs-string\">  reboot [ARG]                    Shut down and reboot the system</span><br><span class=\"hljs-string\">  kexec                           Shut down and reboot the system with kexec</span><br><span class=\"hljs-string\">  exit                            Request user instance exit</span><br><span class=\"hljs-string\">  switch-root ROOT [INIT]         Change to a different root file system</span><br><span class=\"hljs-string\">  suspend                         Suspend the system</span><br><span class=\"hljs-string\">  hibernate                       Hibernate the system</span><br><span class=\"hljs-string\">  hybrid-sleep                    Hibernate and suspend the system</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Unit-管理\"><a href=\"#Unit-管理\" class=\"headerlink\" title=\"Unit 管理\"></a><strong>Unit 管理</strong></h3><ol>\n<li>查看当前系统的所有 Unit</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 列出正在运行的 Unit<br>$ systemctl list-units<br><br># 列出所有Unit，包括没有找到配置文件的或者启动失败的<br>$ systemctl list-units --all<br><br># 列出所有没有运行的 Unit<br>$ systemctl list-units --all --state=inactive<br><br># 列出所有加载失败的 Unit<br>$ systemctl list-units --failed<br><br># 列出所有正在运行的、类型为 service 的 Unit<br>$ systemctl list-units --type=service<br><br># 查看 Unit 配置文件的内容<br>$ systemctl cat docker.service<br></code></pre></td></tr></table></figure>\n<ol>\n<li>查看 Unit 的状态</li>\n</ol>\n<ul>\n<li>enabled：已建立启动链接</li>\n<li>disabled：没建立启动链接</li>\n<li>static：该配置文件没有 [Install] 部分（无法执行），只能作为其他配置文件的依赖</li>\n<li>masked：该配置文件被禁止建立启动链接</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 显示系统状态<br>$ systemctl status<br><br># 显示单个 Unit 的状态<br>$ ystemctl status bluetooth.service<br><br># 显示远程主机的某个 Unit 的状态<br>$ systemctl -H root@rhel7.example.com status httpd.service<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Unit 的管理</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 立即启动一个服务<br>$ sudo systemctl start apache.service<br><br># 立即停止一个服务<br>$ sudo systemctl stop apache.service<br><br># 重启一个服务<br>$ sudo systemctl restart apache.service<br><br># 杀死一个服务的所有子进程<br>$ sudo systemctl kill apache.service<br><br># 重新加载一个服务的配置文件<br>$ sudo systemctl reload apache.service<br><br># 重载所有修改过的配置文件<br>$ sudo systemctl daemon-reload<br><br># 显示某个 Unit 的所有底层参数<br>$ systemctl show httpd.service<br><br># 显示某个 Unit 的指定属性的值<br>$ systemctl show -p CPUShares httpd.service<br><br># 设置某个 Unit 的指定属性<br>$ sudo systemctl set-property httpd.service CPUShares=<span class=\"hljs-number\">500</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>查看 Unit 的依赖关系</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 列出一个 Unit 的所有依赖，默认不会列出 target 类型<br>$ systemctl list-dependencies nginx.service<br><br># 列出一个 Unit 的所有依赖，包括 target 类型<br>$ systemctl list-dependencies --all nginx.service<br></code></pre></td></tr></table></figure>\n<h3 id=\"服务的生命周期\"><a href=\"#服务的生命周期\" class=\"headerlink\" title=\"服务的生命周期\"></a><strong>服务的生命周期</strong></h3><p>当一个新的 Unit 文件被放入 /etc/systemd/system/ 或 /usr/lib/systemd/system/ 目录中时，它是不会被自识识别的。</p>\n<ol>\n<li>服务的激活</li>\n</ol>\n<ul>\n<li>systemctl enable：在 /etc/systemd/system/ 建立服务的符号链接，指向 /usr/lib/systemd/system/ 中</li>\n<li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li>\n</ul>\n<ol>\n<li>服务的启动和停止</li>\n</ol>\n<ul>\n<li>systemctl start：依次启动定义在 Unit 文件中的 ExecStartPre、ExecStart 和 ExecStartPost 命令</li>\n<li>systemctl stop：依次停止定义在 Unit 文件中的 ExecStopPre、ExecStop 和 ExecStopPost 命令</li>\n<li>systemctl restart：重启服务</li>\n<li>systemctl kill：立即杀死服务</li>\n</ul>\n<ol>\n<li>服务的开机启动和取消</li>\n</ol>\n<ul>\n<li>systemctl enable：除了激活服务以外，也可以置服务为开机启动</li>\n<li>systemctl disable：取消服务的开机启动</li>\n</ul>\n<ol>\n<li>服务的修改和移除</li>\n</ol>\n<ul>\n<li>systemctl daemon-reload：Systemd 会将 Unit 文件的内容写到缓存中，因此当 Unit 文件被更新时，需要告诉 Systemd 重新读取所有的 Unit 文件</li>\n<li>systemctl reset-failed：移除标记为丢失的 Unit 文件。在删除 Unit 文件后，由于缓存的关系，即使通过 daemon-reload 更新了缓存，在 list-units 中依然会显示标记为 not-found 的 Unit。</li>\n</ul>\n<h3 id=\"Target-管理\"><a href=\"#Target-管理\" class=\"headerlink\" title=\"Target 管理\"></a><strong>Target 管理</strong></h3><p>Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。</p>\n<p>在传统的 SysV-init 启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 查看当前系统的所有 Target<br>$ systemctl list-unit-files --type=target<br><br># 查看一个 Target 包含的所有 Unit<br>$ systemctl list-dependencies multi-user.target<br><br># 查看启动时的默认 Target<br>$ systemctl get-<span class=\"hljs-keyword\">default</span><br><br># 设置启动时的默认 Target<br>$ sudo systemctl set-<span class=\"hljs-keyword\">default</span> multi-user.target<br><br># 切换 Target 时，默认不关闭前一个 Target 启动的进程，systemctl isolate 命令改变这种行为，关闭前一个 Target 里面所有不属于后一个 Target 的进程<br>$ sudo systemctl isolate multi-user.target<br></code></pre></td></tr></table></figure>\n<ol>\n<li>Target 与 SysV-init 进程的主要区别：</li>\n</ol>\n<ul>\n<li>默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</li>\n<li>启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在 /lib/systemd/system 和 /etc/systemd/system 目录。</li>\n<li>配置文件的位置，以前 init 进程的配置文件是 /etc/inittab，各种服务的配置文件存放在 /etc/sysconfig 目录。现在的配置文件主要存放在 /lib/systemd 目录，在 /etc/systemd 目录里面的修改可以覆盖原始设置。</li>\n</ul>\n<h3 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a><strong>日志管理</strong></h3><p>Systemd 通过其标准日志服务 Journald 提供的配套程序 journalctl 将其管理的所有后台进程打印到 std:out（即控制台）的输出重定向到了日志文件。</p>\n<p>Systemd 的日志文件是二进制格式的，必须使用 Journald 提供的 journalctl 来查看，默认不带任何参数时会输出系统和所有后台进程的混合日志。</p>\n<p>默认日志最大限制为所在文件系统容量的 10%，可以修改 /etc/systemd/journald.conf 中的 SystemMaxUse 来指定该最大限制。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 查看所有日志（默认情况下 ，只保存本次启动的日志）<br>$ sudo journalctl<br><br># 查看内核日志（不显示应用日志）：--dmesg 或 -k<br>$ sudo journalctl -k<br><br># 查看系统本次启动的日志（其中包括了内核日志和各类系统服务的控制台输出）：--system 或 -b<br>$ sudo journalctl -b<br>$ sudo journalctl -b -<span class=\"hljs-number\">0</span><br><br># 查看上一次启动的日志（需更改设置）<br>$ sudo journalctl -b -<span class=\"hljs-number\">1</span><br><br># 查看指定服务的日志：--unit 或 -u<br>$ sudo journalctl -u docker.servcie<br><br># 查看指定服务的日志<br>$ sudo journalctl /usr/lib/systemd/systemd<br><br># 实时滚动显示最新日志<br>$ sudo journalctl -f<br><br># 查看指定时间的日志<br>$ sudo journalctl --since=<span class=\"hljs-string\">&quot;2012-10-30 18:17:16&quot;</span><br>$ sudo journalctl --since <span class=\"hljs-string\">&quot;20 min ago&quot;</span><br>$ sudo journalctl --since yesterday<br>$ sudo journalctl --since <span class=\"hljs-string\">&quot;2015-01-10&quot;</span> --until <span class=\"hljs-string\">&quot;2015-01-11 03:00&quot;</span><br>$ sudo journalctl --since <span class=\"hljs-number\">09</span>:<span class=\"hljs-number\">00</span> --until <span class=\"hljs-string\">&quot;1 hour ago&quot;</span><br><br># 显示尾部的最新 10 行日志：--lines 或 -n<br>$ sudo journalctl -n<br><br># 显示尾部指定行数的日志<br>$ sudo journalctl -n <span class=\"hljs-number\">20</span><br><br># 将最新的日志显示在前面<br>$ sudo journalctl -r -u docker.service<br><br># 改变输出的格式：--output 或 -o<br>$ sudo journalctl -r -u docker.service -o json-pretty<br><br># 查看指定进程的日志<br>$ sudo journalctl _PID=<span class=\"hljs-number\">1</span><br><br># 查看某个路径的脚本的日志<br>$ sudo journalctl /usr/bin/bash<br><br># 查看指定用户的日志<br>$ sudo journalctl _UID=<span class=\"hljs-number\">33</span> --since today<br><br># 查看某个 Unit 的日志<br>$ sudo journalctl -u nginx.service<br>$ sudo journalctl -u nginx.service --since today<br><br># 实时滚动显示某个 Unit 的最新日志<br>$ sudo journalctl -u nginx.service -f<br><br># 合并显示多个 Unit 的日志<br>$ journalctl -u nginx.service -u php-fpm.service --since today<br><br># 查看指定优先级（及其以上级别）的日志，共有 8 级<br># 0: emerg<br># 1: alert<br># 2: crit<br># 3: err<br># 4: warning<br># 5: notice<br># 6: info<br># 7: debug<br>$ sudo journalctl -p err -b<br><br># 日志默认分页输出，--no-pager 改为正常的标准输出<br>$ sudo journalctl --no-pager<br><br># 以 JSON 格式（单行）输出<br>$ sudo journalctl -b -u nginx.service -o json<br><br># 以 JSON 格式（多行）输出，可读性更好<br>$ sudo journalctl -b -u nginx.serviceqq<br> -o json-pretty<br><br># 显示日志占据的硬盘空间<br>$ sudo journalctl --disk-usage<br><br># 指定日志文件占据的最大空间<br>$ sudo journalctl --vacuum-size=1G<br><br># 指定日志文件保存多久<br>$ sudo journalctl --vacuum-time=1years<br></code></pre></td></tr></table></figure>\n<h2 id=\"Systemd-工具集\"><a href=\"#Systemd-工具集\" class=\"headerlink\" title=\"Systemd 工具集\"></a><strong>Systemd 工具集</strong></h2><ul>\n<li>systemctl：用于检查和控制各种系统服务和资源的状态</li>\n<li>bootctl：用于查看和管理系统启动分区</li>\n<li>hostnamectl：用于查看和修改系统的主机名和主机信息</li>\n<li>journalctl：用于查看系统日志和各类应用服务日志</li>\n<li>localectl：用于查看和管理系统的地区信息</li>\n<li>loginctl：用于管理系统已登录用户和 Session 的信息</li>\n<li>machinectl：用于操作 Systemd 容器</li>\n<li>timedatectl：用于查看和管理系统的时间和时区信息</li>\n<li>systemd-analyze 显示此次系统启动时运行每个服务所消耗的时间，可以用于分析系统启动过程中的性能瓶颈</li>\n<li>systemd-ask-password：辅助性工具，用星号屏蔽用户的任意输入，然后返回实际输入的内容</li>\n<li>systemd-cat：用于将其他命令的输出重定向到系统日志</li>\n<li>systemd-cgls：递归地显示指定 CGroup 的继承链</li>\n<li>systemd-cgtop：显示系统当前最耗资源的 CGroup 单元</li>\n<li>systemd-escape：辅助性工具，用于去除指定字符串中不能作为 Unit 文件名的字符</li>\n<li>systemd-hwdb：Systemd 的内部工具，用于更新硬件数据库</li>\n<li>systemd-delta：对比当前系统配置与默认系统配置的差异</li>\n<li>systemd-detect-virt：显示主机的虚拟化类型</li>\n<li>systemd-inhibit：用于强制延迟或禁止系统的关闭、睡眠和待机事件</li>\n<li>systemd-machine-id-setup：Systemd 的内部工具，用于给 Systemd 容器生成 ID</li>\n<li>systemd-notify：Systemd 的内部工具，用于通知服务的状态变化</li>\n<li>systemd-nspawn：用于创建 Systemd 容器</li>\n<li>systemd-path：Systemd 的内部工具，用于显示系统上下文中的各种路径配置</li>\n<li>systemd-run：用于将任意指定的命令包装成一个临时的后台服务运行</li>\n<li>systemd-stdio- bridge：Systemd 的内部 工具，用于将程序的标准输入输出重定向到系统总线</li>\n<li>systemd-tmpfiles：Systemd 的内部工具，用于创建和管理临时文件目录</li>\n<li>systemd-tty-ask-password-agent：用于响应后台服务进程发出的输入密码请求</li>\n</ul>\n<ol>\n<li>systemctl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 重启系统<br>$ sudo systemctl reboot<br><br># 关闭系统，切断电源<br>$ sudo systemctl poweroff<br><br># CPU停止工作<br>$ sudo systemctl halt<br><br># 暂停系统<br>$ sudo systemctl suspend<br><br># 让系统进入冬眠状态<br>$ sudo systemctl hibernate<br><br># 让系统进入交互式休眠状态<br>$ sudo systemctl hybrid-sleep<br><br># 启动进入救援状态（单用户状态）<br>$ sudo systemctl rescue<br></code></pre></td></tr></table></figure>\n<ol>\n<li>systemd-analyze</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 查看启动耗时<br>$ systemd-analyze<br><br># 查看每个服务的启动耗时<br>$ systemd-analyze blame<br><br># 显示瀑布状的启动过程流<br>$ systemd-analyze critical-chain<br><br># 显示指定服务的启动流<br>$ systemd-analyze critical-chain atd.service<br></code></pre></td></tr></table></figure>\n<ol>\n<li>hostnamectl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 显示当前主机的信息<br>$ hostnamectl<br><br># 设置主机名。<br>$ sudo hostnamectl set-hostname rhel7<br></code></pre></td></tr></table></figure>\n<ol>\n<li>timedatectl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 查看当前时区设置<br>$ timedatectl<br><br># 显示所有可用的时区<br>$ timedatectl list-timezones<br><br># 设置当前时区<br>$ sudo timedatectl set-timezone America/New_York<br>$ sudo timedatectl set-time YYYY-MM-DD<br>$ sudo timedatectl set-time HH:MM:SS<br></code></pre></td></tr></table></figure>\n<ol>\n<li>loginctl</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"># 列出当前 session<br>$ loginctl list-sessions<br><br># 列出当前登录用户<br>$ loginctl list-users<br><br># 列出显示指定用户的信息<br>$ loginctl show-user ruanyf<br></code></pre></td></tr></table></figure>\n<ol>\n<li>systemd-ask-password</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">$ PASSWORD=$(systemd-ask-password <span class=\"hljs-string\">&quot;Input Your Passowrd:&quot;</span>)<br></code></pre></td></tr></table></figure>\n<ol>\n<li>systemd-run</li>\n</ol>\n<p>systemd-run 可以将一个指定的操作变成后台运行的服务。它的效果似乎与直接在命令后加上表示后台运行的 &amp; 符号很相似。然而，它让命令成为服务还意味着，它的生命周期将由 Systemd 控制。具体来说，包括以下好处：</p>\n<ul>\n<li>服务的生命击期由 Systemd 接管，不会随着启动它的控制台关闭而结束</li>\n<li>可以通过 systemctl 工具管理服务的状态</li>\n<li>可以通过 journalctl 工具查看和管理服务的日志信息</li>\n<li>可以通过 Systemd 提供的方法限制服务的 CPU、内存、磁盘 IO 等系统资源的使用情况。</li>\n</ul>\n"},{"title":"后端架构师技术图谱","toc_number":true,"abbrlink":189445432,"date":"2020-12-21T03:24:10.000Z","updated":"2020-12-24T14:39:35.813Z","keywords":["tanxz博客","tanxz blog","java","架构师","互联网架构师","后端架构师","java架构师","后端架构师技术图谱"],"description":"后端架构师技术图谱","top_img":"https://cdn.tanxz.com/images/post/default_top_img.jpg","comments":1,"cover":"https://cdn.tanxz.com/images/category/java-structure.jpg","toc":null,"copyright":null,"copyright_author":null,"copyright_author_href":null,"copyright_url":null,"copyright_info":null,"mathjax":null,"katex":null,"aplayer":null,"highlight_shrink":null,"aside":null,"_content":"\n<b style=\"color:red\">推荐:</b> [《Java技术书籍大全》 - awesome-java-books](https://github.com/sorenduan/awesome-java-books)\n<p>从初级开发者到资深架构师，看这些书就够了</p>\n<hr/>\n<!-- \n[![知识共享协议（CC协议）](https://img.shields.io/badge/License-Creative%20Commons-DC3D24.svg)](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)[![GitHub stars](https://img.shields.io/github/stars/xingshaocheng/architect-awesome.svg?style=flat&label=Star)](https://github.com/xingshaocheng/architect-awesome/stargazers)[![GitHub forks](https://img.shields.io/github/forks/xingshaocheng/architect-awesome.svg?style=flat&label=Fork)](https://github.com/xingshaocheng/architect-awesome/fork)[![GitHub watchers](https://img.shields.io/github/watchers/xingshaocheng/architect-awesome.svg?style=flat&label=Watch)](https://github.com/xingshaocheng/architect-awesome/watchers)[![GitHub followers](https://img.shields.io/github/followers/xingshaocheng.svg?label=%E5%85%B3%E6%B3%A8)](https://github.com/xingshaocheng) -->\n\n<!-- **（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）** -->\n\n# 数据结构\n\n## 队列\n* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)\n\t* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。\n\t* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。\n\n* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)\n\n## 集合\n* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)\n\n## 链表、数组\n* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)\n\n## 字典、关联数组\n* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)\n\n## 栈\n* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)\n* [《Java Stack 类》](http://www.runoob.com/java/java-stack-class.html)\n* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)\n\t* Stack 是线程安全的。\n\t* 内部使用数组保存数据，不够时翻倍。\n\n## 树\n\n### 二叉树\n\n每个节点最多有两个叶子节点。\n*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)\n\n### 完全二叉树\n* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)\n\t* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。\n\n### 平衡二叉树\n左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n* [《浅谈数据结构-平衡二叉树》](http://www.cnblogs.com/polly333/p/4798944.html)\n* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)\n\n### 二叉查找树（BST）\n二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。\n\n* [《浅谈算法和数据结构: 七 二叉查找树》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)\n\n\n### 红黑树\n* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)\n\t* 添加阶段后，左旋或者右旋从而再次达到平衡。 \n* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)\n\n### B，B+，B*树\nMySQL是基于B+树聚集索引组织表\n\n* [《B-树，B+树，B\\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)\n* [《B-树，B+树与B\\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)\n\t* B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。\n### LSM 树\n\nLSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。\n\n* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)\n\t* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。\n\t* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n\t\n* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)\n\t* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。\n\t* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。\n\t* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。\n\n## BitSet\n\n经常用于大规模数据的排重检查。\n\n* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)\n* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)\n\n# 常用算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n## 排序、查找算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n### 选择排序\n* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)\n\t* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\n\n### 冒泡排序\n* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)\n\t* 相邻元素前后交换、把最大的排到最后。\n\t* 时间复杂度 O(n²) \n\n### 插入排序\n* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)\n\n### 快速排序\n* [《坐在马桶上看算法：快速排序》](https://blog.csdn.net/afjaklsdflka/article/details/52829030)\n\t* 一侧比另外一侧都大或小。 \n### 归并排序\n* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)\n\t* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 \n\n### 希尔排序\nTODO\n\n### 堆排序\n* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)\n\t* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\n\n### 计数排序\n* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)\n\t* 和桶排序过程比较像，差别在于桶的数量。\n\n### 桶排序\n* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)\n* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)\n\t* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。\n\t* 每个桶单独进行排序，然后再遍历每个桶。\n\n### 基数排序\n\n按照个位、十位、百位、...依次来排。\n\n* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)\n* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)\n\n\n### 二分查找\n* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)\n\t* 要求待查找的序列有序。\n\t* 时间复杂度 O(logN)。\n\n* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)\n\t* while + 递归。\n### Java 中的排序工具\n* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)\n\t* Collections.sort算法调用的是合并排序。\n\t* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。\n\n## 布隆过滤器\n\n常用于大数据的排重，比如email，url 等。\n核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。\n优点：空间和时间效率都很高。\n缺点：随着存入的元素数量增加，误算率随之增加。\n\n* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)\n* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)\n* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)\n\t* 基于 Redis 的 Bitmap 数据结构。\n* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)\n\t* 使用Java中的 BitSet 类 和 加权和hash算法。\n\n## 字符串比较\n\n### KMP 算法\nKMP：Knuth-Morris-Pratt算法（简称KMP）\n核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。\n* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n## 深度优先、广度优先\n* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)\n\n## 贪心算法\n* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)\n* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)\n\n## 回溯算法\n* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)\n\n## 剪枝算法\n* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)\n\n## 动态规划\n* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)\n* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)\n\n## 朴素贝叶斯\n\n* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)\n\t* P(B|A)=P(A|B)P(B)/P(A)\n\n* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)\n* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)\n\n\n## 推荐算法\n* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)\n* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)\n\n## 最小生成树算法\n* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)\n\n## 最短路径算法\n\n* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)\n\n# 并发\n\n## Java 并发\n\n* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)\n* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)\n\n## 多线程\n\n* [《40个Java多线程问题总结》](https://www.cnblogs.com/xrq730/p/5060921.html)\n\n## 线程安全\n\n* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)\n\n## 一致性、事务\n\n### 事务 ACID 特性\n* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)\n\n### 事务的隔离级别\n\n* 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。\n* 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。\n* 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。\n* 序列化：所有事物串行处理（牺牲了效率）\n\n* [《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)\n* [数据库事务的四大特性及事务隔离级别](https://www.cnblogs.com/z-sm/p/7245981.html)\n\n* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)\n\t* 幻读的例子非常清楚。\n\t* 通过 SELECT ... FOR UPDATE 解决。\n\t\n* [《一篇文章带你读懂MySQL和InnoDB》](https://draveness.me/mysql-innodb)\n\t* 图解脏读、不可重复读、幻读问题。\n\n\n### MVCC\n\n\n* [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)\n\t* innodb 中 MVCC 用在 Repeatable-Read 隔离级别。\n\t* MVCC 会产生幻读问题（更新时异常。）\n\n* [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)\n\n\t* 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间\n\t* 每次只操作比当前版本小（或等于）的 行。\n\t\n\n\n## 锁\n\n### Java中的锁和同步类\n\n* [《Java中的锁分类》](https://www.cnblogs.com/qifengshi/p/6831055.html)\n\t* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 \n\n* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)\n\n* [《Java中信号量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)\n\t* 有数量控制\n\t* 申请用 acquire，申请不要则阻塞；释放用 release。\n\n* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)\n\t* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。\t \n\n### 公平锁 & 非公平锁\n\n公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。\n\n* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)\n\t* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。\n\n### 悲观锁 \n\n悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。\n\n* [《【MySQL】悲观锁&乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)\n\t* 乐观锁的方式：版本号+重试方式\n\t* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。\n\n* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)\n\t* mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。\n\t* 锁相同数据的不同索引条件可能会引起死锁。\n\t\n* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)\n\n### 乐观锁 & CAS\n\n* [《乐观锁的一种实现方式——CAS》](https://blog.csdn.net/u011514810/article/details/76895723/)\n\t* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。\t \n\n### ABA 问题\n\n由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。\n\n* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)\n* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)\n\t* AtomicStampedReference 和 AtomicStampedReference。 \n\n### CopyOnWrite容器\n\n可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。\n\n* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)\n\t* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  \n\t* 不用加锁，通过最终一致实现一致性。\n\t\n* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)\n\n### RingBuffer \n* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)\n\n### 可重入锁 & 不可重入锁\n\n* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)\n\t* 通过简单代码举例说明可重入锁和不可重入锁。\n\t* 可重入锁指同一个线程可以再次获得之前已经获得的锁。\n\t* 可重入锁可以用户避免死锁。\n\t* Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock\n\n* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)\n\t* synchronized 使用方便，编译器来加锁，是非公平锁。\n\t* ReenTrantLock 使用灵活，锁的公平性可以定制。\n\t* 相同加锁场景下，推荐使用 synchronized。\n\n### 互斥锁 & 共享锁\n\n互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。\n共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。\n\n* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)\n\n### 死锁\n* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)\n\t* 互斥、持有、不可剥夺、环形等待。\n* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)\n\t* JConsole 可以识别死锁。\n\t\n* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)\n\t* jstack 可以显示死锁。\n\t\n# 操作系统\n\n## 计算机原理\n\n* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)\n\n## CPU\n\n### 多级缓存\n典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。\n\n* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)\n\n## 进程\n\nTODO\n\n## 线程\n\n* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)\n\n## 协程\n\n* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)\n\t* 线程的调度是由操作系统负责，协程调度是程序自行负责\n\t* 与线程相比，协程减少了无谓的操作系统切换.\n\t* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.\n\t\n## Linux\n\n* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)\n\n# 设计模式\n\n## 设计模式的六大原则\n* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)\n\t* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。\n\t* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。\n\t* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。\n\t* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。\n\t* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。\n\t* 合成复用原则：尽量使用合成/聚合,而不是使用继承。\n\n## 23种常见设计模式\n* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)\n* [《设计模式类图与示例》](https://github.com/ToryZhou/design-pattern)\n\n## 应用场景\n* [《细数JDK里的设计模式》](https://www.cnblogs.com/winkey4986/p/5148953.html)\n\t* 结构型模式：\n\t\t* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。\n\t\t* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；\n\t\t* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。\n\t\t* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。\n\t\t* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。\n\t\t* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy\n\t\t\n\t* 创建模式:\n\t\t* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。\n\t\t* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。\n\t\t* 工厂方法：就是 **一个返回**具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。\n\t\t* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。\n\t\t* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。\n\t* 行为模式：\n\t\t* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。\n\t\t* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。\n\t\t* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。\n\t\t* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。\n\t\t* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。\n\t\t* 空对象模式：如 java.util.Collections#emptyList()。\n\t\t* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。\n\t\t* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。\n\n* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)\n* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)\n\n## 单例模式\n* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)\n* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)\n\t* 使用枚举类型。\n\n## 责任链模式\nTODO\n\n## MVC\n* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)\n\t* 模型(model)－视图(view)－控制器(controller) \n\n## IOC\n* [《理解 IOC》](https://www.zhihu.com/question/23277575)\n* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)\n\t* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。\n\t* 作用：用于模块解耦。\n\t* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。\n\n## AOP\n\n* [《轻松理解AOP(面向切面编程)》](https://blog.csdn.net/yanquan345/article/details/19760027)\n* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)\n* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)\n\t* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。\n* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)\n\t* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 \n\n\n## UML\n\n* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)\n\n## 微服务思想\n* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)\n* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)\n\n### 康威定律\n* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)\n\t* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。\n\t* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。\n\t* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。\n\t* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。\n\n* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)\n\n# 运维 & 统计 & 技术支持 \n\n## 常规监控\n\n* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)\n\t* 监控的方式：主动、被动、旁路(比如舆情监控)\n\t* 监控类型： 基础监控、服务端监控、客户端监控、\n\t监控、用户端监控\n\t* 监控的目标：全、块、准\n\t* 核心指标：请求量、成功率、耗时\n\n* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)\n\t* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。\n\n* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)\n\n**命令行监控工具**\n\n* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)\n\t* top、sar、tsar、nload\n\n* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)\n\n* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)\n\n## APM\n\nAPM —  Application Performance Management\n\n* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)\n\n* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)\n\n* 主要开源软件，按字母排序\n  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)\n  * [CAT](https://github.com/dianping/cat)\n  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)\n  * [Pinpoint](https://github.com/naver/pinpoint)\n  * [Zipkin](https://github.com/openzipkin/zipkin)\n\n* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)\n\t* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。\n\t\n\n\n## 统计分析\n\n* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)\n\t* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度\n\n* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)\n\t* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。\n\n* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt_mobile_analytics_practice.html)\n\t* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 \n\n\n## 持续集成(CI/CD)\n\n* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n* [《8个流行的持续集成工具》](http://www.51testing.com/html/74/n-3723774.html)\n\n### Jenkins\n\n* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)\n\n### 环境分离\n\n开发、测试、生成环境分离。\n\n* [《开发环境、生产环境、测试环境的基本理解和区》](https://my.oschina.net/sancuo/blog/214904)\n\n## 自动化运维\n\n### Ansible\n* [《Ansible中文权威指南》](http://www.ansible.com.cn/)\n* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)\n\n### puppet\n* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)\n\n### chef\n* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)\n\n## 测试\n\n### TDD 理论\n\n* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)\n\t* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.\n\t* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； \n\n### 单元测试\n\n* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)\n* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)\n\t* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 \n* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)\n\t* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 \n\n### 压力测试\n\n* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)\n* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)\n* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)\n* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)\n* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)\n\n\n### 全链路压测\n* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)\n* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)\n* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)\n* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)\n\n\n### A/B 、灰度、蓝绿测试\n\n* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)\n* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)\n\n* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)\n\n## 虚拟化\n\n* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)\n\n### KVM\n* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)\n* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)\n\n### Xen\n* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)\n\n### OpenVZ\n* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)\n\n## 容器技术\n\n### Docker\n* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)\n* [《Docker 核心技术与实现原理》](https://draveness.me/docker)\n* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)\n\n## 云技术\n\n### OpenStack\n* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)\n\n## DevOps\n* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)\n* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)\n\n## 文档管理\n\n* [Confluence-收费文档管理系统](http://www.confluence.cn/)\n* GitLab?\n* Wiki\n\n# 中间件\n\n## Web Server\n\n### Nginx\n* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)\n\t* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。\n\t* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  \n\n* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)\n\t* nginx只适合静态和反向代理，不适合处理动态请求。\n\n### OpenResty\n* [官方网站](http://openresty.org/cn/)\n* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)\n\t* 通过 Lua 模块可以在Nginx上进行开发。   \n* [agentzh 的 Nginx 教程](https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html)  \n\t\n### Tengine\n* [官方网站](http://tengine.taobao.org/)  \n\n### Apache Httpd\n* [官方网站](http://httpd.apache.org/)\n\n### Tomcat\n\n#### 架构原理\n* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)\n* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)\n* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)\n\n* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)\n\n* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)\n\t* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。\n\t* Jboss 实现全部了JEE特性，软件开源免费、文档收费。\n\n#### 调优方案\n\n* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)\n\t* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； \n\n* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)\n* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)\n\t* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。\n\t* 并发高时，AJP协议优于HTTP协议。\n\n### Jetty\n* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)\n* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)\n\t* 架构比较:Jetty的架构比Tomcat的更为简单。\n\t* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。\n\t* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 \n\n\n\n## 缓存\n\n* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)\n\n### 本地缓存\n\n* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)\n\n* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)\n\t* 堆内、堆外、磁盘三级缓存。\n\t* 可按照缓存空间容量进行设置。\n\t* 按照时间、次数等过期策略。\n\n* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)\n\t* 简单轻量、无堆外、磁盘缓存。\n\n\n* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)\n\n* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)\n\n## 客户端缓存\n\n* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)\n\t* 主要是利用 Cache-Control 参数。\n\n* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)\n\n## 服务端缓存\n\n### Web缓存\n\n* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache\n* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache\n* [squid](https://github.com/squid-cache/squid) - squid cache\n\n### Memcached\n* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)\n* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)\n\t* 采用多路复用技术提高并发性。\n\t* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。\n* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)\n* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)\n\n* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)\n\t* 区别在于当key存在还是不存在时，返回值是true和false的。\n\n* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)\n\n### Redis\n\n* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)\n* [《redis底层原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)\n\t* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。\n\t* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。\n* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)\n\t* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。\n\t* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。\n\t* 也可以两者结合使用。\n\n* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)\n\n#### 架构\n* [《Redis单线程架构》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)\n\n#### 回收策略\n* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)\n\n### Tair\n\n* [官方网站](https://github.com/alibaba/tair)\n* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)\n* 特点：可以配置备份节点数目，通过异步同步到备份节点\n* 一致性Hash算法。\n* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。\n\n\n几种存储引擎:\n* MDB，完全内存性，可以用来存储Session等数据。\n* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作\n* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。\n* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。\n\n## 消息队列\n\n* [《消息队列-推/拉模式学习 & ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)\n\t* RabbitMQ 消费者默认是推模式（也支持拉模式）。\n\t* Kafka 默认是拉模式。\n\t* Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。\n\t* Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。\n\n* [《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》](https://blog.csdn.net/yunfeng482/article/details/72856762)\n\n### 消息总线\n\n消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。\n\n* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)\n\n### 消息的顺序\n* [《如何保证消费者接收消息的顺序》](https://www.cnblogs.com/cjsblog/p/8267892.html)\n\n### RabbitMQ\n\n支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。\n\n* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)\n* [《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57) \n* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)\n\n### RocketMQ\nJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。\n* [《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)\n* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome)\n\n### ActiveMQ\n纯Java实现，兼容JMS，可以内嵌于Java应用中。\n* [《ActiveMQ消息队列介绍》](https://www.cnblogs.com/wintersun/p/3962302.html)\n\n### Kafka\n高吞吐量、采用拉模式。适合高IO场景，比如日志同步。\n\n* [官方网站](http://kafka.apache.org/)\n* [《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)\n* [《Kafka分区机制介绍与示例》](http://lxw1234.com/archives/2015/10/538.htm)\n\n### Redis 消息推送\n\n生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。\n\n* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)\n\n### ZeroMQ\n TODO\n\n\n## 定时调度\n\n### 单机定时调度\n\n* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)\n\n* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)\n\t* fork 进程 + sleep 轮询\n\n* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)\n* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)\n* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)\n\t* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。\n\n\n### 分布式定时调度\n\n* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)\n\t* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares\n\n* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)\n\t* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 \n* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome)\n* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome)\n\n\n## RPC\n\n* [《从零开始实现RPC框架 - RPC原理及实现》](https://blog.csdn.net/top_code/article/details/54615853)\n\t* 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。\n\n* [《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》](https://blog.csdn.net/testcs_dn/article/details/78050590)\n\n### Dubbo\n* [官方网站](http://dubbo.apache.org/)\n* [dubbo实现原理简单介绍](https://www.cnblogs.com/steven520213/p/7606598.html)\n\n** SPI **\nTODO\n\n### Thrift\n* [官方网站](http://thrift.apache.org/)\n* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)\n\t* 支持多语言，通过中间语言定义接口。\n\n### gRPC\n\n服务端可以认证加密，在外网环境下，可以保证数据安全。\n\n* [官方网站](https://grpc.io/)\n* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)\n\n\n## 数据库中间件\n\n### Sharding Jdbc\n\n* [官网](http://shardingjdbc.io/)\n* [源码解析](http://www.iocoder.cn/categories/Sharding-JDBC/?vip&architect-awesome)\n\n## 日志系统\n\n### 日志搜集\n\n* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)\n* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)\n* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)\n\n## 配置中心\n\n* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)\n\t* Spring Boot 和 Spring Cloud\n\t* 支持推、拉模式更新配置\n\t* 支持多种语言 \n\n* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)\n\n* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)\n\nservlet 3.0 异步特性可用于配置中心的客户端\n* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)\n\n## API 网关\n\n主要职责：请求转发、安全认证、协议转换、容灾。\n\n* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)\n* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)\n\n* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)\n* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome)\n* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)\n\n# 网络\n\n\n## 协议\n\n### OSI 七层协议\n\n* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)\n\n### TCP/IP\n* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)\n* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)\n\n### HTTP\n* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)\n\n### HTTP2.0\n* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)\n* [《HTTP2.0的基本单位为二进制帧》](https://blog.csdn.net/u012657197/article/details/77877840)\n\t* 利用二进制帧负责传输。\n\t* 多路复用。\n\n### HTTPS\n* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)\n\t* 使用非对称加密协商加密算法\n\t* 使用对称加密方式传输数据\n\t* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。\n\n* [《八大免费SSL证书-给你的网站免费添加Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)\n\n## 网络模型\n\n* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)\n\t* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。\n\t* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。\n\n* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)\n\t* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\t* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。\n\t* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。\n\t* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。\n\t\n* [《select，poll，epoll比较  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)\n\t* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。\n\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n\t* NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务\n\n* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)\n\n* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)\n\n### Epoll\n\n* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)\n\n### Java NIO\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)\n\n### kqueue\n* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)\n\n## 连接和短连接\n\n* [《TCP/IP系列——长连接与短连接的区别》](https://www.cnblogs.com/pangguoping/p/5571422.html)\n\n## 框架\n\n* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)\n\t* Reactor 模式介绍。\n\t* Netty 是 Reactor 模式的一种实现。\n\n## 零拷贝（Zero-copy）\n* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)\n\t* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。\n\n## 序列化(二进制协议)\n\n### Hessian\n* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)\nBinary-RPC;不仅仅是序列化\n\n### Protobuf\n* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)\nGoolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。\n* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)\n  \t* 关于协议的解释；缺点：可读性差;\n\n* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)\n\t* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。\n\n# 数据库\n## 基础理论\n### 关系数据库设计的三大范式\n* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)\n\t* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；\n\t* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；\n\t* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；\n\n## MySQL\n\n### 原理\n* [《MySQL的InnoDB索引原理详解》](https://blog.csdn.net/voidccc/article/details/40077329)\n\n* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)\n\t* 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁\n\n* [《myisam和innodb索引实现的不同》](https://www.2cto.com/database/201211/172380.html)\n\n### InnoDB\n\n* [《一篇文章带你读懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)\n\n### 优化\n\n* [《MySQL36条军规》](http://vdisk.weibo.com/s/muWOT)\n\n* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)\n* [《SQL优化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)\n* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)\n* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)\n* [《 MYSQL分页limit速度太慢优化方法》](https://www.jianshu.com/p/0a7e3055a01f)\n\t* 原则上就是缩小扫描范围。\n\n\n### 索引\n\n#### 聚集索引, 非聚集索引\n\n* [《MySQL 聚集索引/非聚集索引简述》](https://blog.csdn.net/no_endless/article/details/77073549)\n* [《MyISAM和InnoDB的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)\n\nMyISAM 是非聚集，InnoDB 是聚集\n\n#### 复合索引\n\n* [《复合索引的优点和注意事项》](https://www.cnblogs.com/summer0space/p/7247778.html)\n\t* 文中有一处错误：\n\t> 对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引\n\t* 原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。\n\t\n* [《MySQL查询where条件的顺序对查询效率的影响》](https://www.cnblogs.com/acode/p/7489258.html)\n\t\n#### 自适应哈希索引(AHI)\n\n* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)\n\n\n### explain\n* [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)\n\n## NoSQL\n\n### MongoDB\n\n* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n* [《Mongodb相对于关系型数据库的优缺点》](http://mxdxm.iteye.com/blog/2093603)\n\t* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；\n\t* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；\n\n### Hbase\n\n* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)\n* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)\n* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)\n\n\n* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)\n\t* 空数据不存储，节省空间，且适用于并发。\n\n* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)\n\t* rowkey 按照字典顺序排列，便于批量扫描。\n\t* 通过散列可以避免热点。\n\n# 搜索引擎\n\n## 搜索引擎原理\n\n* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)\n\n## Lucene\n* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)\n\n## Elasticsearch\n\n* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)\n* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)\n\n## Solr\n* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)\n* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)\n\n## sphinx \n* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)\n\n# 性能\n\n## 性能优化方法论\n\n* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)\n\t* 代码层面、业务层面、数据库层面、服务器层面、前端优化。\n\n* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)\n\n## 容量评估\n* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)\n* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect)\n\t* 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS\n\n## CDN 网络\n\n* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)\n* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)\n\n## 连接池\n\n* [《主流Java数据库连接池比较与开发配置实战》](https://blog.csdn.net/fysuccess/article/details/66972554)\n\n## 性能调优\n\n* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)\n\n\n# 大数据\n\n## 流式计算\n\n### Storm\n* [官方网站](http://storm.apache.org/)\n* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)\n\n### Flink\n* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)\n\n### Kafka Stream\n* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)\n\n### 应用场景\n\n例如：\n\n* 广告相关实时统计；\n* 推荐系统用户画像标签实时更新；\n* 线上服务健康状况实时监测；\n* 实时榜单；\n* 实时数据统计。\n\n## Hadoop\n\n* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)\n* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)\n\n### HDFS\n* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)\n\n### MapReduce\n* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)\n* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)\n\n### Yarn\n* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)\n\n## Spark\n* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)\n* [《子雨大数据之Spark入门教程(Python版)》](http://dblab.xmu.edu.cn/blog/1709-2/)\n\n\n# 安全\n\n## web 安全\n\n### XSS\n* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)\n### CSRF\n* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)\n\n### SQL 注入\n\n* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)\n\n### Hash Dos\n\n\n* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)\n\t* 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。\n* [《一种高级的DoS攻击-Hash碰撞攻击》](http://blog.it2048.cn/article_hash-collision.html )\n* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)\n\n### 脚本注入\n\n* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)\n\n### 漏洞扫描工具\n* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)\n* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)\n* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)\n\n### 验证码\n\n* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)\n\n* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)\n\t* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。\n\n* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)\n\n## DDoS 防范\n* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)\n* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)\n\n## 用户隐私信息保护\n\n1. 用户密码非明文保存，加动态salt。\n2. 身份证号，手机号如果要显示，用 “\\*” 替代部分字符。\n3. 联系方式在的显示与否由用户自己控制。\n4. TODO\n\n* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)\n* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)\n\n* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)\n\n## 序列化漏洞\n* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)\n\n## 加密解密\n\n### 对称加密\n\n* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)\n\t* DES、3DES、Blowfish、AES\n\t* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。\n\t* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。\n\t\n### 哈希算法\n* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)\n\t* MD5 和 SHA-1 已经不再安全，已被弃用。\n\t* 目前 SHA-256 是比较安全的。\n\t\n* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)\n\n### 非对称加密\n* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)\n\t* RSA、DSA、ECDSA(螺旋曲线加密算法)\n\t* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。\n\t* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。\n\n\t\t[《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)\t\n\n\n## 服务器安全\n* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)\n\n## 数据安全\n\n### 数据备份\n\nTODO\n\n## 网络隔离\n\n### 内外网分离\n\nTODO\n\n### 登录跳板机\n在内外环境中通过跳板机登录到线上主机。\n* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)\n\n## 授权、认证\n\n* [授权认证知识库](https://docs.authing.cn/authing/)\n\n### RBAC \n* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)\n* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)\n\n### OAuth2.0\n* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)\n\n### OIDC\n* [理解 OIDC](https://docs.authing.cn/authing/advanced/oidc/li-jie-oidc-liu-cheng)\n\n### SAML\n* [理解 SAML](https://docs.authing.cn/authing/advanced/use-saml/li-jie-saml-liu-cheng)\n\n### 双因素认证（2FA）\n\n2FA - Two-factor authentication，用于加强登录验证\n\n常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）\n\n* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)\n\n### 单点登录(SSO)\n\n* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)\n* [CAS单点登录框架](https://github.com/apereo/cas)\n* [使用 Authing 实现单点登录](https://docs.authing.cn/authing/quickstart/implement-sso-with-authing)\n\n# 常用开源框架\n\n## 开源协议\n\n* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)\n\n* [如何选择一个开源软件协议](http://choosealicense.online/)\n\n## 日志框架\n\n### Log4j、Log4j2\n* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)\n* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)\n* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)\n\t* Log4J 异步日志性能优异。 \n\n### Logback\n* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)\n\n## ORM\n\n* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)\n\t* 主要目的是为了提高开发效率。 \n\n**MyBatis：**\n\n* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)\n\t* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效\n\t* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  \n\n* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)\n\n## 网络框架\n\nTODO\n\n## Web 框架\n\n### Spring 家族\n**Spring**\n* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)\n\n**Spring Boot**\n* [官方网站](http://projects.spring.io/spring-boot/)\n* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n**Spring Cloud**\n\n* [Spring Boot 中文索引站](http://springboot.fun/)\n* [Spring Cloud 中文文档](https://springcloud.cc/)\n* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n## 工具框架\n\n* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)\n* [《Google guava 中文教程》](http://ifeve.com/google-guava/)\n\n\n# 分布式设计\n\n## 扩展性设计\n\n* [《架构师不可不知的十大可扩展架构》](https://blog.csdn.net/hemin1003/article/details/53633926)\n\t* 总结下来，通用的套路就是分布、缓存及异步处理。 \n\n* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)\n\t* 水平切分+垂直切分\n\t* 利用中间件进行分片如，MySQL Proxy。\n\t* 利用分片策略进行切分，如按照ID取模。 \n* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)\n\t* 分布式服务+消息队列。\n\n* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)\n\n## 稳定性 & 高可用\n\n* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)\n\t* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。\n\t* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。\n\t* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。\n\t* 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。\n\t* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。\n\t* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。\n\t* 自动化测试：通过完善的测试，减少发布引起的故障。\n\t* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。\n\n\n* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)\n\t* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。\t \n\n### 硬件负载均衡\n\n* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)\n\t* 主要是和F5对比。\n\n* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)\n\n### 软件负载均衡\n\n* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)\n\t轮寻、权重、负载、最少连接、QoS\n* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)\n\t* 配置简单，更新速度慢。 \n* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)\n\t* 简单轻量、学习成本低；主要适用于web应用。\n\n*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)\n\t* 配置比较负载、只支持到4层，性能较高。\n\n* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)\n\t* 支持到七层（比如HTTP）、功能比较全面，性能也不错。\n\n* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)\n\t* 主要是用户读请求的负载均衡。\n\n* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)\n\n### 限流\n\n* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)\n\t* 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。\n\t* 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。\n\t* 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。\n\t* Nginx 限流：通过 `limit_req` 等模块限制并发连接数。\n\n### 应用层容灾\n\n* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)\n\t* 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 \n\t* 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。\n\t* Hystrix设计原则：\n\t\t* 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。\n\t\t* 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。\n\t\t* 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 \n\n* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)\n* [《缓存击穿、失效以及热点key问题》](https://blog.csdn.net/zeb_perfect/article/details/54135506) \n\t* 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；\n\t* 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；\n\n### 跨机房容灾\n\n* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)\n\t* 通过自研中间件进行数据同步。 \n\n* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)\n\t* 注意延迟问题，多次跨机房调用会将延时放大数倍。\n\t* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。\n\t* 不能依赖于程序端数据双写，要有自动同步方案。 \n\t* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。\n\t* 核心业务和次要业务分而治之，甚至只考虑核心业务。\n\t* 异地多活监控部署、测试也要跟上。\n\t* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。\n\t* 控制跨机房消息体大小，越小越好。\n\t* 考虑使用docker容器虚拟化技术，提高动态调度能力。\n\n* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)\n\n\n### 容灾演练流程\n\n* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)\n\t* 常见故障画像\n\t* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。\n\n### 平滑启动\n\n* 平滑重启应用思路\n1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用\n\n* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)\n推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。\n* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)\nJava、Spring、Dubbo 优雅关闭方式。\n\n## 数据库扩展\n\n### 读写分离模式\n\n* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)\n* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)\n* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)\n\n* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)\n\t* DRDB 进行磁盘复制，避免单点问题。\n\n* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)\n\n### 分片模式\n* [《分库分表需要考虑的问题及方案》](https://www.jianshu.com/p/32b3e91aa22c)\n\t* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。\n\t* 问题：事务、Join、迁移、扩容、ID、分页等。\n\t* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。\n\t* 分库策略：数值范围；取模；日期等。\n\t* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 \n\n* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)\n\t* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。\n\t* 分表：物理上创建不同的表、客户端需要管理分表路由。\n\n## 服务治理\n###  服务注册与发现\n\n* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)\n  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。\n  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。\n* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)\n  * CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）\n  * 作者认为目前 Consul 对 Spring cloud 的支持比较好。\n\n* [《基于Zookeeper的服务注册与发现》](http://mobile.51cto.com/news-502394.htm)\n\t* 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 \n\n### 服务路由控制\n* [《分布式服务框架学习笔记4 服务路由》](https://blog.csdn.net/xundh/article/details/59492750)\n\t* 原则：透明化路由\n\t* 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接\n\t* 本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。\n\t* 配置方式：统一注册表；本地配置；动态下发。\n\n## 分布式一致\n\n### CAP 与 BASE 理论\n\n* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)\n\t* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)\n\t* CAP：一致性、可用性、分区容错性(网络故障引起)\n\t* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）\n\t* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n### 分布式锁\n\n* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)\n\t* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；\n\t* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。\n\t* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。\n* [《基于Zookeeper的分布式锁》](https://www.tuicool.com/articles/VZJr6fY)\n\t* 清楚的原理描述 + Java 代码示例。 \n\n* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)\n\t* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。\n\n* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)\n\t* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。\n\n### 分布式一致性算法\n\n#### PAXOS\n* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)\n* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)\n* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)\n\n#### Zab\n* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)\n\n#### Raft\n* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)\n\t* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）\n\t* 通过随机等待的方式发出投票，得票多的获胜。\n\n#### Gossip\n* [《Gossip算法》](http://blog.51cto.com/tianya23/530743)\n\n#### 两阶段提交、多阶段提交\n\n* [《关于分布式事务、两阶段提交协议、三阶提交协议》](http://blog.jobbole.com/95632/)\n\n### 幂等\n\n* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)\n\t* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。\n\t* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 \n\n### 分布式一致方案\n* [《分布式系统事务一致性解决方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)\n* [《保证分布式系统数据一致性的6种方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)\n\n### 分布式 Leader 节点选举\n* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)\n\n### TCC(Try/Confirm/Cancel) 柔性事务\n* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)\n\t* 基于BASE理论：基本可用、柔性状态、最终一致。\n\t* 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。\n\n## 分布式文件系统\n\n* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？\n* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？\n  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。\n  * FastDFS：轻量级、适合小文件。\n\n## 唯一ID 生成\n\n### 全局唯一ID\n* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)\n\t* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)\n\t* Flicker 方案：MySQL自增ID + \"REPLACE INTO XXX:SELECT LAST_INSERT_ID();\" \n\t* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。\n\t* MongoDB 方案：利用 ObjectId。缺点：不能自增。\n\n* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)\n\t* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。\n\t* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。\n\t* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。\n\n## 一致性Hash算法\n\n* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)\n\n# 设计思想 & 开发模式\n\n## DDD(Domain-driven Design - 领域驱动设计)\n\n* [《浅谈我对DDD领域驱动设计的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)\n  * 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。\n  * 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。\n  * 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。\n  \n* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)\n  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。\n  * 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。\n  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；\n  * 领域通用语言：领域专家、开发设计人员都能理解的语言或工具。\n  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。\n  * 使用的模式：\n    * 关联尽量少，尽量单项，尽量降低整体复杂度。\n    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。\n    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小而简单的对象，比如Date。\n    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。\n    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；\n    * 工厂（Factory）：类似于设计模式中的工厂模式。\n    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。\n\n* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)\n\t* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。\n\n* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](http://www.hollischuang.com/archives/553)\n\n\n### 命令查询职责分离(CQRS)\n\nCQRS — Command Query Responsibility Seperation\n\n* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)\n\t* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。\n\n* [《DDD CQRS架构和传统架构的优缺点比较》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)\n\t* 最终一致的设计理念；依赖于高可用消息中间件。\n\t\n* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)\n\t* 一个实现 CQRS 的抽象案例。\n\n* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)\n\t* CQRS 模式分析 + 12306 抢票案例\n\n### 贫血，充血模型\n\n* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)\n\t* 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。\n\t* 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；\n\t* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。\n\t* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。\n\t* 作者主张使用贫血模式。\n\t\n## Actor 模式\n\nTODO\n\n## 响应式编程\n\n### Reactor\nTODO\n### RxJava\nTODO\n### Vert.x\nTODO\n\n## DODAF2.0\n\n* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)\n* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)\n\n## Serverless\n\n无需过多关系服务器的服务架构理念。\n\n* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)\n\t* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。\n\t* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。\n\t* Serverless 不代表某个具体的框架。\n\n* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)\n\t* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）\n\n\n\n## Service Mesh\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)\n\n\n# 项目管理\n\n## 架构评审\n* [《架构设计之如何评审架构设计说明书》](http://developer.51cto.com/art/201506/478486.htm)\n* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)\n\n## 重构\n\n* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)\n\n## 代码规范\n\n* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)\n\n## 代码 Review\n\n\n制度还是制度!\n另外，每个公司需要根据自己的需求和目标制定自己的 check list\n\n* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)\n\t* 代码 review 做的好，在于制度建设。\n\n* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)\n\n* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)\n* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)\n\n* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)\n\n## RUP\n* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)\n\n## 看板管理\n* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)\n\n## SCRUM\n\nSCRUM - 争球\n\n* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。\n* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；\n* 五个价值观：专注、勇气、公开、承诺、尊重。\n\n\n* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)\n\n* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)\n\n## 敏捷开发\n\nTODO\n\n## 极限编程（XP）\n\nXP - eXtreme Programming\n\n* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)\n\t* 是一种指导开发人员的方法论。\n\t* 4大价值：\n\t\t* 沟通：鼓励口头沟通，提高效率。\n\t\t* 简单：够用就好。\n\t\t* 反馈：及时反馈、通知相关人。\n\t\t* 勇气：提倡拥抱变化，敢于重构。\n\t\t\n\t* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。\n\t* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。\n\n## 结对编程\n\n边写码，边review。能够增强代码质量、减少bug。\n\n* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)\n\n## PDCA 循环质量管理\n\nP——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进\n\n* [《PDCA》](http://www.baike.com/wiki/PDCA)\n\n## FMEA管理模式\n\nTODO\n\n# 通用业务术语\n\nTODO\n\n# 技术趋势\n\nTODO\n\n# 政策、法规\n\n## 法律\n\n* [《中华人民共和国网络安全法》](https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/16843044)\n  * 2016年11月7日发布，自2017年6月1日起施行\n\n* [《个人信息保护法》](https://baike.baidu.com/item/个人信息保护法/8343360)\n  * 个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。\n\n* [《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》](https://baike.baidu.com/item/最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释/20497481)\n  * 《解释》共十三条，自2017年6月1日起施行\n  > * 1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”；\n  > * 2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上；\n  > * 3、对于其他公民个人信息，标准为 5000条以上。\n\n* [《中华人民共和国电子商务法》](https://baike.baidu.com/item/中华人民共和国电子商务法/16467544)\n  * 2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行\n  * [解读电子商务法（一）什么是电商](https://v.youku.com/v_show/id_XNDAzNjAyNDM0MA==.html)\n  * [解读电子商务法（二）电商经营者](https://v.youku.com/v_show/id_XNDA1OTc0OTQ5Mg==.html)\n  * [解读电子商务法（三）电商行为规范](https://v.youku.com/v_show/id_XNDA4NzIyNjI4MA==.html)\n  * [解读电子商务法（四）电商的法律关系](https://v.qq.com/x/page/e08443fc1cr.html)\n  * [解读电子商务法（外传）电商挣钱的秘密](https://v.youku.com/v_show/id_XNDA4MTQ2Nzk4NA==.html)\n  * [解读电子商务法（外传）电商模式](https://v.qq.com/x/page/j0844twjwr5.html)\n\n* [程序员需要知道的法律常识](https://blog.csdn.net/a331685690/article/details/79917772)\n* [白话法律42讲-为程序员打造的专属法律武器](https://time.geekbang.org/column/132)\n\n### 严格遵守刑法253法条\n\n我国刑法第253条之一规定：\n\n> * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。\n> * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 \n> * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。\n\n最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”\n\n* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)\n\n### 避风港原则\n“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。\n* [《避风港原则》](https://baike.baidu.com/item/%E9%81%BF%E9%A3%8E%E6%B8%AF%E5%8E%9F%E5%88%99/588459?fr=aladdin)\n\n# 架构师素质\n\n* [《架构师画像》](http://hellojava.info/?p=430)\n\t* 业务理解和抽象能力\n\t* NB的代码能力\n\t* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； \n\t* 全局：是否考虑到了对上下游的系统的影响。\n\t* 权衡：权衡投入产出比；优先级和节奏控制；\n\n* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)\n\t* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。\n\t* 基础设施、配置、测试、开发、运维综合考虑。\n\t* 考虑人、团队、和组织的影响。 \n\n* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) \n\n* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)\n\t* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。\n\t* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 \n\n* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)\n\t* 第一层的架构师看到的只是产品本身\n\t* 第二层的架构师不仅看到自己的产品，还看到了整体的方案\n\t* 第三层的架构师看到的是商业价值 \n\n# 团队管理\n\nTODO\n\n## 招聘\n\n# 资讯\n\n## 行业资讯\n\n* [36kr](http://36kr.com/)\n* [Techweb](http://www.techweb.com.cn/)\n\n## 公众号列表\n\nTODO\n\n## 博客\n\n### 团队博客\n* [阿里中间件博客](http://jm.taobao.org/)\n* [美团点评技术团队博客](https://tech.meituan.com)\n\n### 个人博客\n\n* [阮一峰的网络日志](http://www.ruanyifeng.com/)\n* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)\n* [hellojava-阿里毕玄](http://hellojava.info/)\n* [Cm's Blog](http://cmsblogs.com/)\n* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)\n\n## 综合门户、社区\n\n**国内：**\n\n* [CSDN](http://csdn.net)\n\t 老牌技术社区、不必解释。\n* [51cto.com](http://www.51cto.com/)\n* [ITeye](http://www.iteye.com/)\n\t* 偏 Java 方向 \n* [博客园](https://www.cnblogs.com)\n* [ChinaUnix](http://www.chinaunix.net/)\n\t* 偏 Linux 方向 \n* [开源中国社区](https://www.oschina.net/)\n* [InfoQ](https://www.infoq.cn/)\n* [深度开源](http://www.open-open.com/)\n* [伯乐在线](http://www.jobbole.com/)\n\t* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。\n\n* [ITPUB](http://www.itpub.net/)\n* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)\n* [阿里云— 云栖社区](https://yq.aliyun.com/)\n* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)\n* [开发者头条](https://toutiao.io/)\n* [LinkedKeeper](http://www.linkedkeeper.com)\n\n**国外：**\n\n* [DZone](https://dzone.com)\n* [Reddit](https://www.reddit.com)\n\n## 问答、讨论类社区\n\n* [segmentfault](https://segmentfault.com)\n\t* 问答+专栏 \n* [知乎](https://www.zhihu.com/)\n* [stackoverflow](https://stackoverflow.com/)\n\n## 行业数据分析\n\n* [艾瑞网](http://report.iresearch.cn/)\n* [QUEST MOBILE](https://www.questmobile.com.cn)\n\n* [国家数据](http://data.stats.gov.cn/)\n\n* [TalkingData](http://www.talkingdata.com/)\n\n## 专项网站\n\n* 测试:\n\t* [领测国际](http://www.ltesting.net/) \n\t* [测试窝](https://www.testwo.com/)\n\t* [TesterHome](https://testerhome.com)\n\n* 运维:\n  \t* [运维派](http://www.yunweipai.com/) \n  \t* [Abcdocker](https://www.abcdocker.com/)\n  \n* Java:\n\t* [ImportNew](http://www.importnew.com/)\n\t\t* 专注于 Java 技术分享\n\t* [HowToDoInJava](https://howtodoinjava.com/)\n\t\t* 英文博客\n\t\n* 安全\n\t* [红黑联盟](https://www.2cto.com/) \n\t* [FreeBuf](http://www.freebuf.com/)\n\n* 大数据\n\t* [中国大数据](http://www.thebigdata.cn/) \n\n* 其他专题网站：\n\t* [InfoQ](http://www.infoq.com/cn/)\n\t\t* 偏重于基础架构、运维方向\n\t* [DockerInfo](http://www.dockerinfo.net/)\n\t\t* 专注于 Docker 应用及咨询、教程的网站\n\t* [Linux公社](https://www.linuxidc.com/)\n\t\t* Linux 主题社区\n\n## 其他类\n\n* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)\n\n## 推荐参考书\n\n\n### 在线电子书\n\n* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)\n\n\n* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)\n* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)\n\n* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)\n\n* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)\n\n* [《架构师之路》](https://www.w3cschool.cn/architectroad/)\n\n### 纸质书\n\n<b style=\"color:red\">更多架构方面书籍参考:</b> [awesome-java-books](https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%9E%B6%E6%9E%84)\n\n#### 开发方面\n\n* 《阿里巴巴Java开发手册》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BfL5CR)\n\n#### 架构方面\n* 《软件架构师的12项修炼：技术技能篇》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=rTlo0m)\n* 《架构之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=1KECBZ) \n* 《分布式服务架构》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=hkzqtK) \n* 《聊聊架构》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=A8Nd6Z) \n* 《云原生应用架构实践》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=D4WCpd) \n* 《亿级流量网站架构核心技术》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Rdmd21)\n* 《淘宝技术这十年》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=CoUdGG)\n* 《企业IT架构转型之道-中台战略思想与架构实战》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BxS6eI) \n\n* 《高可用架构（第1卷）》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BcjUwS) \n\n#### 技术管理方面\n* 《CTO说》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Gl3QAo) \n* 《技术管理之巅》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=MeloLt)\n* 《网易一千零一夜：互联网产品项目管理实战》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=qPuqMg) \n\n#### 基础理论\n* 《数学之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=0seUpO) \n* 《编程珠玑》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=I7jj9r) \n\n#### 工具方面\nTODO\n\n#### 大数据方面\n\n# 技术资源\n\n## 开源资源\n* [github](https://github.com)\n\n* [Apache 软件基金会](https://www.apache.org/index.html)\n\n## 手册、文档、教程\n\n**国内：**\n* [W3Cschool](http://w3cschool.cn) \n* [Runoob.com](http://www.runoob.com/)\n\t* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。\n\n* [Love2.io](https://love2.io/)\n\t* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。\n* [gitbook.cn](http://gitbook.cn/)\n\t* 付费电子书。 \n* [ApacheCN](http://www.apachecn.org/)\n\t* AI、大数据方面系列中文文档。\n\n**国外：**\n\n* [Quick Code](http://www.quickcode.co/)\n\t* 免费在线技术教程。\n* [gitbook.com](http://gitbook.com)\n\t* 有部分中文电子书。\n* [Cheatography](https://www.cheatography.com/)\n\t* Cheat Sheets 大全，单页文档网站。\n* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)\n\t* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。\n* [LeetCode](https://leetcode.com/problemset/all/)\n\t* 知名题库网站，提供Java、Python、C#、C++、算法、SQL、等高质量各程度题库和解决办法。\n\n## 在线课堂\n\n* [学徒无忧](http://www.xuetuwuyou.com/)\n* [极客时间](https://time.geekbang.org/)\n* [segmentfault](https://segmentfault.com/lives)\n* [斯达克学院](https://new.stuq.org/course/explore)\n* [牛客网](http://nowcoder.com)\n* [极客学院](https://www.jikexueyuan.com/)\n* [51CTO学院](http://edu.51cto.com/)\n\n## 会议、活动\n\n* [QCon](http://www.infoq.com/cn/qcon/)\n* [ArchSummit](https://archsummit.com)\n* [GITC全球互联网技术大会](http://www.thegitc.com/)\n\n**活动发布平台:** \n* [活动行](http://www.huodongxing.com/)\n\n## 常用APP\n\n* [极客时间](https://time.geekbang.org)\n* [得到](https://www.igetget.com)\n\n## 找工作\n* [Boss直聘](https://www.zhipin.com)\n* [拉勾网](https://www.lagou.com)\n* [猎聘](https://www.liepin.com)\n* [100Offer](https://cn.100offer.com/)\n\n## 工具\n\n* [极客搜索](https://s.geekbang.org/)\n\t* 技术文章搜索引擎。\n\n## 代码托管\n\n* [Coding](https://coding.net)\n* [码云](https://gitee.com/)\n\n## 文件服务\n* 七牛\n* 又拍云\n\n## 综合云服务商\n* 阿里云\n* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c)\n* 百度云\n* 新浪云\n* 金山云\n* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)\n* [谷歌云](https://cloud.google.com/?hl=zh-cn)\n* [微软云](https://azure.microsoft.com/zh-cn/)\n\n### VPS\n* [Linode](http://linode.com)\n* [DigitalOcean](https://www.digitalocean.com)\n* [Vultr](https://www.vultr.com/)","source":"_posts/技术分享/后端架构师技术图谱.md","raw":"---\ntitle: 后端架构师技术图谱\ncategories:\n  - 手段方法\ntoc_number: true\nabbrlink: 189445432\ndate: 2020-12-21 11:24:10\nupdated:\ntags:\n  - java\n  - 架构师\nkeywords:\n  - tanxz博客\n  - tanxz blog\n  - java\n  - 架构师\n  - 互联网架构师\n  - 后端架构师\n  - java架构师\n  - 后端架构师技术图谱\ndescription: 后端架构师技术图谱\ntop_img: https://cdn.tanxz.com/images/post/default_top_img.jpg\ncomments:\ncover: https://cdn.tanxz.com/images/category/java-structure.jpg\ntoc:\ncopyright:\ncopyright_author:\ncopyright_author_href:\ncopyright_url:\ncopyright_info:\nmathjax:\nkatex:\naplayer:\nhighlight_shrink:\naside:\n---\n\n<b style=\"color:red\">推荐:</b> [《Java技术书籍大全》 - awesome-java-books](https://github.com/sorenduan/awesome-java-books)\n<p>从初级开发者到资深架构师，看这些书就够了</p>\n<hr/>\n<!-- \n[![知识共享协议（CC协议）](https://img.shields.io/badge/License-Creative%20Commons-DC3D24.svg)](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)[![GitHub stars](https://img.shields.io/github/stars/xingshaocheng/architect-awesome.svg?style=flat&label=Star)](https://github.com/xingshaocheng/architect-awesome/stargazers)[![GitHub forks](https://img.shields.io/github/forks/xingshaocheng/architect-awesome.svg?style=flat&label=Fork)](https://github.com/xingshaocheng/architect-awesome/fork)[![GitHub watchers](https://img.shields.io/github/watchers/xingshaocheng/architect-awesome.svg?style=flat&label=Watch)](https://github.com/xingshaocheng/architect-awesome/watchers)[![GitHub followers](https://img.shields.io/github/followers/xingshaocheng.svg?label=%E5%85%B3%E6%B3%A8)](https://github.com/xingshaocheng) -->\n\n<!-- **（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）** -->\n\n# 数据结构\n\n## 队列\n* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)\n\t* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。\n\t* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。\n\n* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)\n\n## 集合\n* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)\n\n## 链表、数组\n* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)\n\n## 字典、关联数组\n* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)\n\n## 栈\n* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)\n* [《Java Stack 类》](http://www.runoob.com/java/java-stack-class.html)\n* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)\n\t* Stack 是线程安全的。\n\t* 内部使用数组保存数据，不够时翻倍。\n\n## 树\n\n### 二叉树\n\n每个节点最多有两个叶子节点。\n*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)\n\n### 完全二叉树\n* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)\n\t* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。\n\n### 平衡二叉树\n左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n* [《浅谈数据结构-平衡二叉树》](http://www.cnblogs.com/polly333/p/4798944.html)\n* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)\n\n### 二叉查找树（BST）\n二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。\n\n* [《浅谈算法和数据结构: 七 二叉查找树》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)\n\n\n### 红黑树\n* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)\n\t* 添加阶段后，左旋或者右旋从而再次达到平衡。 \n* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)\n\n### B，B+，B*树\nMySQL是基于B+树聚集索引组织表\n\n* [《B-树，B+树，B\\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)\n* [《B-树，B+树与B\\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)\n\t* B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。\n### LSM 树\n\nLSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。\n\n* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)\n\t* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。\n\t* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n\t\n* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)\n\t* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。\n\t* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。\n\t* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。\n\n## BitSet\n\n经常用于大规模数据的排重检查。\n\n* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)\n* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)\n\n# 常用算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n## 排序、查找算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n### 选择排序\n* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)\n\t* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\n\n### 冒泡排序\n* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)\n\t* 相邻元素前后交换、把最大的排到最后。\n\t* 时间复杂度 O(n²) \n\n### 插入排序\n* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)\n\n### 快速排序\n* [《坐在马桶上看算法：快速排序》](https://blog.csdn.net/afjaklsdflka/article/details/52829030)\n\t* 一侧比另外一侧都大或小。 \n### 归并排序\n* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)\n\t* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 \n\n### 希尔排序\nTODO\n\n### 堆排序\n* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)\n\t* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\n\n### 计数排序\n* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)\n\t* 和桶排序过程比较像，差别在于桶的数量。\n\n### 桶排序\n* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)\n* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)\n\t* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。\n\t* 每个桶单独进行排序，然后再遍历每个桶。\n\n### 基数排序\n\n按照个位、十位、百位、...依次来排。\n\n* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)\n* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)\n\n\n### 二分查找\n* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)\n\t* 要求待查找的序列有序。\n\t* 时间复杂度 O(logN)。\n\n* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)\n\t* while + 递归。\n### Java 中的排序工具\n* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)\n\t* Collections.sort算法调用的是合并排序。\n\t* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。\n\n## 布隆过滤器\n\n常用于大数据的排重，比如email，url 等。\n核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。\n优点：空间和时间效率都很高。\n缺点：随着存入的元素数量增加，误算率随之增加。\n\n* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)\n* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)\n* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)\n\t* 基于 Redis 的 Bitmap 数据结构。\n* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)\n\t* 使用Java中的 BitSet 类 和 加权和hash算法。\n\n## 字符串比较\n\n### KMP 算法\nKMP：Knuth-Morris-Pratt算法（简称KMP）\n核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。\n* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n## 深度优先、广度优先\n* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)\n\n## 贪心算法\n* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)\n* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)\n\n## 回溯算法\n* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)\n\n## 剪枝算法\n* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)\n\n## 动态规划\n* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)\n* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)\n\n## 朴素贝叶斯\n\n* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)\n\t* P(B|A)=P(A|B)P(B)/P(A)\n\n* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)\n* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)\n\n\n## 推荐算法\n* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)\n* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)\n\n## 最小生成树算法\n* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)\n\n## 最短路径算法\n\n* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)\n\n# 并发\n\n## Java 并发\n\n* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)\n* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)\n\n## 多线程\n\n* [《40个Java多线程问题总结》](https://www.cnblogs.com/xrq730/p/5060921.html)\n\n## 线程安全\n\n* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)\n\n## 一致性、事务\n\n### 事务 ACID 特性\n* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)\n\n### 事务的隔离级别\n\n* 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。\n* 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。\n* 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。\n* 序列化：所有事物串行处理（牺牲了效率）\n\n* [《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)\n* [数据库事务的四大特性及事务隔离级别](https://www.cnblogs.com/z-sm/p/7245981.html)\n\n* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)\n\t* 幻读的例子非常清楚。\n\t* 通过 SELECT ... FOR UPDATE 解决。\n\t\n* [《一篇文章带你读懂MySQL和InnoDB》](https://draveness.me/mysql-innodb)\n\t* 图解脏读、不可重复读、幻读问题。\n\n\n### MVCC\n\n\n* [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)\n\t* innodb 中 MVCC 用在 Repeatable-Read 隔离级别。\n\t* MVCC 会产生幻读问题（更新时异常。）\n\n* [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)\n\n\t* 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间\n\t* 每次只操作比当前版本小（或等于）的 行。\n\t\n\n\n## 锁\n\n### Java中的锁和同步类\n\n* [《Java中的锁分类》](https://www.cnblogs.com/qifengshi/p/6831055.html)\n\t* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 \n\n* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)\n\n* [《Java中信号量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)\n\t* 有数量控制\n\t* 申请用 acquire，申请不要则阻塞；释放用 release。\n\n* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)\n\t* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。\t \n\n### 公平锁 & 非公平锁\n\n公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。\n\n* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)\n\t* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。\n\n### 悲观锁 \n\n悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。\n\n* [《【MySQL】悲观锁&乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)\n\t* 乐观锁的方式：版本号+重试方式\n\t* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。\n\n* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)\n\t* mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。\n\t* 锁相同数据的不同索引条件可能会引起死锁。\n\t\n* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)\n\n### 乐观锁 & CAS\n\n* [《乐观锁的一种实现方式——CAS》](https://blog.csdn.net/u011514810/article/details/76895723/)\n\t* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。\t \n\n### ABA 问题\n\n由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。\n\n* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)\n* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)\n\t* AtomicStampedReference 和 AtomicStampedReference。 \n\n### CopyOnWrite容器\n\n可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。\n\n* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)\n\t* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  \n\t* 不用加锁，通过最终一致实现一致性。\n\t\n* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)\n\n### RingBuffer \n* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)\n\n### 可重入锁 & 不可重入锁\n\n* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)\n\t* 通过简单代码举例说明可重入锁和不可重入锁。\n\t* 可重入锁指同一个线程可以再次获得之前已经获得的锁。\n\t* 可重入锁可以用户避免死锁。\n\t* Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock\n\n* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)\n\t* synchronized 使用方便，编译器来加锁，是非公平锁。\n\t* ReenTrantLock 使用灵活，锁的公平性可以定制。\n\t* 相同加锁场景下，推荐使用 synchronized。\n\n### 互斥锁 & 共享锁\n\n互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。\n共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。\n\n* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)\n\n### 死锁\n* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)\n\t* 互斥、持有、不可剥夺、环形等待。\n* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)\n\t* JConsole 可以识别死锁。\n\t\n* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)\n\t* jstack 可以显示死锁。\n\t\n# 操作系统\n\n## 计算机原理\n\n* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)\n\n## CPU\n\n### 多级缓存\n典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。\n\n* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)\n\n## 进程\n\nTODO\n\n## 线程\n\n* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)\n\n## 协程\n\n* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)\n\t* 线程的调度是由操作系统负责，协程调度是程序自行负责\n\t* 与线程相比，协程减少了无谓的操作系统切换.\n\t* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.\n\t\n## Linux\n\n* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)\n\n# 设计模式\n\n## 设计模式的六大原则\n* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)\n\t* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。\n\t* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。\n\t* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。\n\t* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。\n\t* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。\n\t* 合成复用原则：尽量使用合成/聚合,而不是使用继承。\n\n## 23种常见设计模式\n* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)\n* [《设计模式类图与示例》](https://github.com/ToryZhou/design-pattern)\n\n## 应用场景\n* [《细数JDK里的设计模式》](https://www.cnblogs.com/winkey4986/p/5148953.html)\n\t* 结构型模式：\n\t\t* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。\n\t\t* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；\n\t\t* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。\n\t\t* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。\n\t\t* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。\n\t\t* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy\n\t\t\n\t* 创建模式:\n\t\t* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。\n\t\t* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。\n\t\t* 工厂方法：就是 **一个返回**具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。\n\t\t* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。\n\t\t* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。\n\t* 行为模式：\n\t\t* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。\n\t\t* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。\n\t\t* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。\n\t\t* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。\n\t\t* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。\n\t\t* 空对象模式：如 java.util.Collections#emptyList()。\n\t\t* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。\n\t\t* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。\n\n* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)\n* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)\n\n## 单例模式\n* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)\n* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)\n\t* 使用枚举类型。\n\n## 责任链模式\nTODO\n\n## MVC\n* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)\n\t* 模型(model)－视图(view)－控制器(controller) \n\n## IOC\n* [《理解 IOC》](https://www.zhihu.com/question/23277575)\n* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)\n\t* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。\n\t* 作用：用于模块解耦。\n\t* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。\n\n## AOP\n\n* [《轻松理解AOP(面向切面编程)》](https://blog.csdn.net/yanquan345/article/details/19760027)\n* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)\n* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)\n\t* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。\n* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)\n\t* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 \n\n\n## UML\n\n* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)\n\n## 微服务思想\n* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)\n* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)\n\n### 康威定律\n* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)\n\t* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。\n\t* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。\n\t* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。\n\t* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。\n\n* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)\n\n# 运维 & 统计 & 技术支持 \n\n## 常规监控\n\n* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)\n\t* 监控的方式：主动、被动、旁路(比如舆情监控)\n\t* 监控类型： 基础监控、服务端监控、客户端监控、\n\t监控、用户端监控\n\t* 监控的目标：全、块、准\n\t* 核心指标：请求量、成功率、耗时\n\n* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)\n\t* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。\n\n* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)\n\n**命令行监控工具**\n\n* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)\n\t* top、sar、tsar、nload\n\n* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)\n\n* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)\n\n## APM\n\nAPM —  Application Performance Management\n\n* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)\n\n* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)\n\n* 主要开源软件，按字母排序\n  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)\n  * [CAT](https://github.com/dianping/cat)\n  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)\n  * [Pinpoint](https://github.com/naver/pinpoint)\n  * [Zipkin](https://github.com/openzipkin/zipkin)\n\n* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)\n\t* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。\n\t\n\n\n## 统计分析\n\n* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)\n\t* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度\n\n* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)\n\t* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。\n\n* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt_mobile_analytics_practice.html)\n\t* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 \n\n\n## 持续集成(CI/CD)\n\n* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n* [《8个流行的持续集成工具》](http://www.51testing.com/html/74/n-3723774.html)\n\n### Jenkins\n\n* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)\n\n### 环境分离\n\n开发、测试、生成环境分离。\n\n* [《开发环境、生产环境、测试环境的基本理解和区》](https://my.oschina.net/sancuo/blog/214904)\n\n## 自动化运维\n\n### Ansible\n* [《Ansible中文权威指南》](http://www.ansible.com.cn/)\n* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)\n\n### puppet\n* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)\n\n### chef\n* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)\n\n## 测试\n\n### TDD 理论\n\n* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)\n\t* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.\n\t* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； \n\n### 单元测试\n\n* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)\n* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)\n\t* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 \n* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)\n\t* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 \n\n### 压力测试\n\n* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)\n* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)\n* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)\n* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)\n* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)\n\n\n### 全链路压测\n* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)\n* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)\n* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)\n* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)\n\n\n### A/B 、灰度、蓝绿测试\n\n* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)\n* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)\n\n* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)\n\n## 虚拟化\n\n* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)\n\n### KVM\n* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)\n* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)\n\n### Xen\n* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)\n\n### OpenVZ\n* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)\n\n## 容器技术\n\n### Docker\n* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)\n* [《Docker 核心技术与实现原理》](https://draveness.me/docker)\n* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)\n\n## 云技术\n\n### OpenStack\n* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)\n\n## DevOps\n* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)\n* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)\n\n## 文档管理\n\n* [Confluence-收费文档管理系统](http://www.confluence.cn/)\n* GitLab?\n* Wiki\n\n# 中间件\n\n## Web Server\n\n### Nginx\n* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)\n\t* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。\n\t* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  \n\n* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)\n\t* nginx只适合静态和反向代理，不适合处理动态请求。\n\n### OpenResty\n* [官方网站](http://openresty.org/cn/)\n* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)\n\t* 通过 Lua 模块可以在Nginx上进行开发。   \n* [agentzh 的 Nginx 教程](https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html)  \n\t\n### Tengine\n* [官方网站](http://tengine.taobao.org/)  \n\n### Apache Httpd\n* [官方网站](http://httpd.apache.org/)\n\n### Tomcat\n\n#### 架构原理\n* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)\n* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)\n* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)\n\n* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)\n\n* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)\n\t* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。\n\t* Jboss 实现全部了JEE特性，软件开源免费、文档收费。\n\n#### 调优方案\n\n* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)\n\t* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； \n\n* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)\n* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)\n\t* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。\n\t* 并发高时，AJP协议优于HTTP协议。\n\n### Jetty\n* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)\n* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)\n\t* 架构比较:Jetty的架构比Tomcat的更为简单。\n\t* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。\n\t* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 \n\n\n\n## 缓存\n\n* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)\n\n### 本地缓存\n\n* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)\n\n* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)\n\t* 堆内、堆外、磁盘三级缓存。\n\t* 可按照缓存空间容量进行设置。\n\t* 按照时间、次数等过期策略。\n\n* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)\n\t* 简单轻量、无堆外、磁盘缓存。\n\n\n* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)\n\n* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)\n\n## 客户端缓存\n\n* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)\n\t* 主要是利用 Cache-Control 参数。\n\n* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)\n\n## 服务端缓存\n\n### Web缓存\n\n* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache\n* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache\n* [squid](https://github.com/squid-cache/squid) - squid cache\n\n### Memcached\n* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)\n* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)\n\t* 采用多路复用技术提高并发性。\n\t* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。\n* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)\n* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)\n\n* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)\n\t* 区别在于当key存在还是不存在时，返回值是true和false的。\n\n* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)\n\n### Redis\n\n* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)\n* [《redis底层原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)\n\t* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。\n\t* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。\n* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)\n\t* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。\n\t* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。\n\t* 也可以两者结合使用。\n\n* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)\n\n#### 架构\n* [《Redis单线程架构》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)\n\n#### 回收策略\n* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)\n\n### Tair\n\n* [官方网站](https://github.com/alibaba/tair)\n* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)\n* 特点：可以配置备份节点数目，通过异步同步到备份节点\n* 一致性Hash算法。\n* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。\n\n\n几种存储引擎:\n* MDB，完全内存性，可以用来存储Session等数据。\n* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作\n* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。\n* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。\n\n## 消息队列\n\n* [《消息队列-推/拉模式学习 & ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)\n\t* RabbitMQ 消费者默认是推模式（也支持拉模式）。\n\t* Kafka 默认是拉模式。\n\t* Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。\n\t* Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。\n\n* [《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》](https://blog.csdn.net/yunfeng482/article/details/72856762)\n\n### 消息总线\n\n消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。\n\n* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)\n\n### 消息的顺序\n* [《如何保证消费者接收消息的顺序》](https://www.cnblogs.com/cjsblog/p/8267892.html)\n\n### RabbitMQ\n\n支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。\n\n* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)\n* [《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57) \n* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)\n\n### RocketMQ\nJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。\n* [《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)\n* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome)\n\n### ActiveMQ\n纯Java实现，兼容JMS，可以内嵌于Java应用中。\n* [《ActiveMQ消息队列介绍》](https://www.cnblogs.com/wintersun/p/3962302.html)\n\n### Kafka\n高吞吐量、采用拉模式。适合高IO场景，比如日志同步。\n\n* [官方网站](http://kafka.apache.org/)\n* [《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)\n* [《Kafka分区机制介绍与示例》](http://lxw1234.com/archives/2015/10/538.htm)\n\n### Redis 消息推送\n\n生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。\n\n* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)\n\n### ZeroMQ\n TODO\n\n\n## 定时调度\n\n### 单机定时调度\n\n* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)\n\n* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)\n\t* fork 进程 + sleep 轮询\n\n* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)\n* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)\n* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)\n\t* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。\n\n\n### 分布式定时调度\n\n* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)\n\t* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares\n\n* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)\n\t* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 \n* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome)\n* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome)\n\n\n## RPC\n\n* [《从零开始实现RPC框架 - RPC原理及实现》](https://blog.csdn.net/top_code/article/details/54615853)\n\t* 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。\n\n* [《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》](https://blog.csdn.net/testcs_dn/article/details/78050590)\n\n### Dubbo\n* [官方网站](http://dubbo.apache.org/)\n* [dubbo实现原理简单介绍](https://www.cnblogs.com/steven520213/p/7606598.html)\n\n** SPI **\nTODO\n\n### Thrift\n* [官方网站](http://thrift.apache.org/)\n* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)\n\t* 支持多语言，通过中间语言定义接口。\n\n### gRPC\n\n服务端可以认证加密，在外网环境下，可以保证数据安全。\n\n* [官方网站](https://grpc.io/)\n* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)\n\n\n## 数据库中间件\n\n### Sharding Jdbc\n\n* [官网](http://shardingjdbc.io/)\n* [源码解析](http://www.iocoder.cn/categories/Sharding-JDBC/?vip&architect-awesome)\n\n## 日志系统\n\n### 日志搜集\n\n* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)\n* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)\n* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)\n\n## 配置中心\n\n* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)\n\t* Spring Boot 和 Spring Cloud\n\t* 支持推、拉模式更新配置\n\t* 支持多种语言 \n\n* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)\n\n* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)\n\nservlet 3.0 异步特性可用于配置中心的客户端\n* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)\n\n## API 网关\n\n主要职责：请求转发、安全认证、协议转换、容灾。\n\n* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)\n* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)\n\n* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)\n* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome)\n* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)\n\n# 网络\n\n\n## 协议\n\n### OSI 七层协议\n\n* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)\n\n### TCP/IP\n* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)\n* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)\n\n### HTTP\n* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)\n\n### HTTP2.0\n* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)\n* [《HTTP2.0的基本单位为二进制帧》](https://blog.csdn.net/u012657197/article/details/77877840)\n\t* 利用二进制帧负责传输。\n\t* 多路复用。\n\n### HTTPS\n* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)\n\t* 使用非对称加密协商加密算法\n\t* 使用对称加密方式传输数据\n\t* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。\n\n* [《八大免费SSL证书-给你的网站免费添加Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)\n\n## 网络模型\n\n* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)\n\t* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。\n\t* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。\n\n* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)\n\t* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\t* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。\n\t* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。\n\t* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。\n\t\n* [《select，poll，epoll比较  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)\n\t* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。\n\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n\t* NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务\n\n* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)\n\n* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)\n\n### Epoll\n\n* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)\n\n### Java NIO\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)\n\n### kqueue\n* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)\n\n## 连接和短连接\n\n* [《TCP/IP系列——长连接与短连接的区别》](https://www.cnblogs.com/pangguoping/p/5571422.html)\n\n## 框架\n\n* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)\n\t* Reactor 模式介绍。\n\t* Netty 是 Reactor 模式的一种实现。\n\n## 零拷贝（Zero-copy）\n* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)\n\t* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。\n\n## 序列化(二进制协议)\n\n### Hessian\n* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)\nBinary-RPC;不仅仅是序列化\n\n### Protobuf\n* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)\nGoolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。\n* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)\n  \t* 关于协议的解释；缺点：可读性差;\n\n* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)\n\t* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。\n\n# 数据库\n## 基础理论\n### 关系数据库设计的三大范式\n* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)\n\t* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；\n\t* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；\n\t* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；\n\n## MySQL\n\n### 原理\n* [《MySQL的InnoDB索引原理详解》](https://blog.csdn.net/voidccc/article/details/40077329)\n\n* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)\n\t* 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁\n\n* [《myisam和innodb索引实现的不同》](https://www.2cto.com/database/201211/172380.html)\n\n### InnoDB\n\n* [《一篇文章带你读懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)\n\n### 优化\n\n* [《MySQL36条军规》](http://vdisk.weibo.com/s/muWOT)\n\n* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)\n* [《SQL优化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)\n* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)\n* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)\n* [《 MYSQL分页limit速度太慢优化方法》](https://www.jianshu.com/p/0a7e3055a01f)\n\t* 原则上就是缩小扫描范围。\n\n\n### 索引\n\n#### 聚集索引, 非聚集索引\n\n* [《MySQL 聚集索引/非聚集索引简述》](https://blog.csdn.net/no_endless/article/details/77073549)\n* [《MyISAM和InnoDB的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)\n\nMyISAM 是非聚集，InnoDB 是聚集\n\n#### 复合索引\n\n* [《复合索引的优点和注意事项》](https://www.cnblogs.com/summer0space/p/7247778.html)\n\t* 文中有一处错误：\n\t> 对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引\n\t* 原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。\n\t\n* [《MySQL查询where条件的顺序对查询效率的影响》](https://www.cnblogs.com/acode/p/7489258.html)\n\t\n#### 自适应哈希索引(AHI)\n\n* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)\n\n\n### explain\n* [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)\n\n## NoSQL\n\n### MongoDB\n\n* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n* [《Mongodb相对于关系型数据库的优缺点》](http://mxdxm.iteye.com/blog/2093603)\n\t* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；\n\t* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；\n\n### Hbase\n\n* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)\n* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)\n* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)\n\n\n* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)\n\t* 空数据不存储，节省空间，且适用于并发。\n\n* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)\n\t* rowkey 按照字典顺序排列，便于批量扫描。\n\t* 通过散列可以避免热点。\n\n# 搜索引擎\n\n## 搜索引擎原理\n\n* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)\n\n## Lucene\n* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)\n\n## Elasticsearch\n\n* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)\n* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)\n\n## Solr\n* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)\n* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)\n\n## sphinx \n* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)\n\n# 性能\n\n## 性能优化方法论\n\n* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)\n\t* 代码层面、业务层面、数据库层面、服务器层面、前端优化。\n\n* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)\n\n## 容量评估\n* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)\n* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect)\n\t* 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS\n\n## CDN 网络\n\n* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)\n* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)\n\n## 连接池\n\n* [《主流Java数据库连接池比较与开发配置实战》](https://blog.csdn.net/fysuccess/article/details/66972554)\n\n## 性能调优\n\n* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)\n\n\n# 大数据\n\n## 流式计算\n\n### Storm\n* [官方网站](http://storm.apache.org/)\n* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)\n\n### Flink\n* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)\n\n### Kafka Stream\n* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)\n\n### 应用场景\n\n例如：\n\n* 广告相关实时统计；\n* 推荐系统用户画像标签实时更新；\n* 线上服务健康状况实时监测；\n* 实时榜单；\n* 实时数据统计。\n\n## Hadoop\n\n* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)\n* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)\n\n### HDFS\n* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)\n\n### MapReduce\n* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)\n* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)\n\n### Yarn\n* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)\n\n## Spark\n* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)\n* [《子雨大数据之Spark入门教程(Python版)》](http://dblab.xmu.edu.cn/blog/1709-2/)\n\n\n# 安全\n\n## web 安全\n\n### XSS\n* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)\n### CSRF\n* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)\n\n### SQL 注入\n\n* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)\n\n### Hash Dos\n\n\n* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)\n\t* 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。\n* [《一种高级的DoS攻击-Hash碰撞攻击》](http://blog.it2048.cn/article_hash-collision.html )\n* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)\n\n### 脚本注入\n\n* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)\n\n### 漏洞扫描工具\n* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)\n* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)\n* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)\n\n### 验证码\n\n* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)\n\n* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)\n\t* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。\n\n* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)\n\n## DDoS 防范\n* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)\n* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)\n\n## 用户隐私信息保护\n\n1. 用户密码非明文保存，加动态salt。\n2. 身份证号，手机号如果要显示，用 “\\*” 替代部分字符。\n3. 联系方式在的显示与否由用户自己控制。\n4. TODO\n\n* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)\n* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)\n\n* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)\n\n## 序列化漏洞\n* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)\n\n## 加密解密\n\n### 对称加密\n\n* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)\n\t* DES、3DES、Blowfish、AES\n\t* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。\n\t* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。\n\t\n### 哈希算法\n* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)\n\t* MD5 和 SHA-1 已经不再安全，已被弃用。\n\t* 目前 SHA-256 是比较安全的。\n\t\n* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)\n\n### 非对称加密\n* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)\n\t* RSA、DSA、ECDSA(螺旋曲线加密算法)\n\t* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。\n\t* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。\n\n\t\t[《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)\t\n\n\n## 服务器安全\n* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)\n\n## 数据安全\n\n### 数据备份\n\nTODO\n\n## 网络隔离\n\n### 内外网分离\n\nTODO\n\n### 登录跳板机\n在内外环境中通过跳板机登录到线上主机。\n* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)\n\n## 授权、认证\n\n* [授权认证知识库](https://docs.authing.cn/authing/)\n\n### RBAC \n* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)\n* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)\n\n### OAuth2.0\n* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)\n\n### OIDC\n* [理解 OIDC](https://docs.authing.cn/authing/advanced/oidc/li-jie-oidc-liu-cheng)\n\n### SAML\n* [理解 SAML](https://docs.authing.cn/authing/advanced/use-saml/li-jie-saml-liu-cheng)\n\n### 双因素认证（2FA）\n\n2FA - Two-factor authentication，用于加强登录验证\n\n常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）\n\n* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)\n\n### 单点登录(SSO)\n\n* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)\n* [CAS单点登录框架](https://github.com/apereo/cas)\n* [使用 Authing 实现单点登录](https://docs.authing.cn/authing/quickstart/implement-sso-with-authing)\n\n# 常用开源框架\n\n## 开源协议\n\n* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)\n\n* [如何选择一个开源软件协议](http://choosealicense.online/)\n\n## 日志框架\n\n### Log4j、Log4j2\n* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)\n* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)\n* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)\n\t* Log4J 异步日志性能优异。 \n\n### Logback\n* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)\n\n## ORM\n\n* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)\n\t* 主要目的是为了提高开发效率。 \n\n**MyBatis：**\n\n* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)\n\t* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效\n\t* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  \n\n* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)\n\n## 网络框架\n\nTODO\n\n## Web 框架\n\n### Spring 家族\n**Spring**\n* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)\n\n**Spring Boot**\n* [官方网站](http://projects.spring.io/spring-boot/)\n* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n**Spring Cloud**\n\n* [Spring Boot 中文索引站](http://springboot.fun/)\n* [Spring Cloud 中文文档](https://springcloud.cc/)\n* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n## 工具框架\n\n* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)\n* [《Google guava 中文教程》](http://ifeve.com/google-guava/)\n\n\n# 分布式设计\n\n## 扩展性设计\n\n* [《架构师不可不知的十大可扩展架构》](https://blog.csdn.net/hemin1003/article/details/53633926)\n\t* 总结下来，通用的套路就是分布、缓存及异步处理。 \n\n* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)\n\t* 水平切分+垂直切分\n\t* 利用中间件进行分片如，MySQL Proxy。\n\t* 利用分片策略进行切分，如按照ID取模。 \n* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)\n\t* 分布式服务+消息队列。\n\n* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)\n\n## 稳定性 & 高可用\n\n* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)\n\t* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。\n\t* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。\n\t* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。\n\t* 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。\n\t* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。\n\t* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。\n\t* 自动化测试：通过完善的测试，减少发布引起的故障。\n\t* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。\n\n\n* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)\n\t* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。\t \n\n### 硬件负载均衡\n\n* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)\n\t* 主要是和F5对比。\n\n* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)\n\n### 软件负载均衡\n\n* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)\n\t轮寻、权重、负载、最少连接、QoS\n* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)\n\t* 配置简单，更新速度慢。 \n* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)\n\t* 简单轻量、学习成本低；主要适用于web应用。\n\n*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)\n\t* 配置比较负载、只支持到4层，性能较高。\n\n* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)\n\t* 支持到七层（比如HTTP）、功能比较全面，性能也不错。\n\n* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)\n\t* 主要是用户读请求的负载均衡。\n\n* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)\n\n### 限流\n\n* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)\n\t* 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。\n\t* 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。\n\t* 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。\n\t* Nginx 限流：通过 `limit_req` 等模块限制并发连接数。\n\n### 应用层容灾\n\n* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)\n\t* 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 \n\t* 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。\n\t* Hystrix设计原则：\n\t\t* 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。\n\t\t* 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。\n\t\t* 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 \n\n* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)\n* [《缓存击穿、失效以及热点key问题》](https://blog.csdn.net/zeb_perfect/article/details/54135506) \n\t* 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；\n\t* 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；\n\n### 跨机房容灾\n\n* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)\n\t* 通过自研中间件进行数据同步。 \n\n* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)\n\t* 注意延迟问题，多次跨机房调用会将延时放大数倍。\n\t* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。\n\t* 不能依赖于程序端数据双写，要有自动同步方案。 \n\t* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。\n\t* 核心业务和次要业务分而治之，甚至只考虑核心业务。\n\t* 异地多活监控部署、测试也要跟上。\n\t* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。\n\t* 控制跨机房消息体大小，越小越好。\n\t* 考虑使用docker容器虚拟化技术，提高动态调度能力。\n\n* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)\n\n\n### 容灾演练流程\n\n* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)\n\t* 常见故障画像\n\t* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。\n\n### 平滑启动\n\n* 平滑重启应用思路\n1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用\n\n* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)\n推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。\n* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)\nJava、Spring、Dubbo 优雅关闭方式。\n\n## 数据库扩展\n\n### 读写分离模式\n\n* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)\n* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)\n* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)\n\n* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)\n\t* DRDB 进行磁盘复制，避免单点问题。\n\n* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)\n\n### 分片模式\n* [《分库分表需要考虑的问题及方案》](https://www.jianshu.com/p/32b3e91aa22c)\n\t* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。\n\t* 问题：事务、Join、迁移、扩容、ID、分页等。\n\t* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。\n\t* 分库策略：数值范围；取模；日期等。\n\t* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 \n\n* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)\n\t* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。\n\t* 分表：物理上创建不同的表、客户端需要管理分表路由。\n\n## 服务治理\n###  服务注册与发现\n\n* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)\n  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。\n  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。\n* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)\n  * CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）\n  * 作者认为目前 Consul 对 Spring cloud 的支持比较好。\n\n* [《基于Zookeeper的服务注册与发现》](http://mobile.51cto.com/news-502394.htm)\n\t* 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 \n\n### 服务路由控制\n* [《分布式服务框架学习笔记4 服务路由》](https://blog.csdn.net/xundh/article/details/59492750)\n\t* 原则：透明化路由\n\t* 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接\n\t* 本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。\n\t* 配置方式：统一注册表；本地配置；动态下发。\n\n## 分布式一致\n\n### CAP 与 BASE 理论\n\n* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)\n\t* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)\n\t* CAP：一致性、可用性、分区容错性(网络故障引起)\n\t* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）\n\t* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n### 分布式锁\n\n* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)\n\t* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；\n\t* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。\n\t* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。\n* [《基于Zookeeper的分布式锁》](https://www.tuicool.com/articles/VZJr6fY)\n\t* 清楚的原理描述 + Java 代码示例。 \n\n* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)\n\t* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。\n\n* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)\n\t* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。\n\n### 分布式一致性算法\n\n#### PAXOS\n* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)\n* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)\n* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)\n\n#### Zab\n* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)\n\n#### Raft\n* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)\n\t* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）\n\t* 通过随机等待的方式发出投票，得票多的获胜。\n\n#### Gossip\n* [《Gossip算法》](http://blog.51cto.com/tianya23/530743)\n\n#### 两阶段提交、多阶段提交\n\n* [《关于分布式事务、两阶段提交协议、三阶提交协议》](http://blog.jobbole.com/95632/)\n\n### 幂等\n\n* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)\n\t* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。\n\t* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 \n\n### 分布式一致方案\n* [《分布式系统事务一致性解决方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)\n* [《保证分布式系统数据一致性的6种方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)\n\n### 分布式 Leader 节点选举\n* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)\n\n### TCC(Try/Confirm/Cancel) 柔性事务\n* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)\n\t* 基于BASE理论：基本可用、柔性状态、最终一致。\n\t* 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。\n\n## 分布式文件系统\n\n* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？\n* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？\n  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。\n  * FastDFS：轻量级、适合小文件。\n\n## 唯一ID 生成\n\n### 全局唯一ID\n* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)\n\t* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)\n\t* Flicker 方案：MySQL自增ID + \"REPLACE INTO XXX:SELECT LAST_INSERT_ID();\" \n\t* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。\n\t* MongoDB 方案：利用 ObjectId。缺点：不能自增。\n\n* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)\n\t* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。\n\t* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。\n\t* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。\n\n## 一致性Hash算法\n\n* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)\n\n# 设计思想 & 开发模式\n\n## DDD(Domain-driven Design - 领域驱动设计)\n\n* [《浅谈我对DDD领域驱动设计的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)\n  * 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。\n  * 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。\n  * 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。\n  \n* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)\n  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。\n  * 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。\n  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；\n  * 领域通用语言：领域专家、开发设计人员都能理解的语言或工具。\n  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。\n  * 使用的模式：\n    * 关联尽量少，尽量单项，尽量降低整体复杂度。\n    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。\n    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小而简单的对象，比如Date。\n    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。\n    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；\n    * 工厂（Factory）：类似于设计模式中的工厂模式。\n    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。\n\n* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)\n\t* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。\n\n* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](http://www.hollischuang.com/archives/553)\n\n\n### 命令查询职责分离(CQRS)\n\nCQRS — Command Query Responsibility Seperation\n\n* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)\n\t* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。\n\n* [《DDD CQRS架构和传统架构的优缺点比较》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)\n\t* 最终一致的设计理念；依赖于高可用消息中间件。\n\t\n* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)\n\t* 一个实现 CQRS 的抽象案例。\n\n* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)\n\t* CQRS 模式分析 + 12306 抢票案例\n\n### 贫血，充血模型\n\n* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)\n\t* 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。\n\t* 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；\n\t* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。\n\t* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。\n\t* 作者主张使用贫血模式。\n\t\n## Actor 模式\n\nTODO\n\n## 响应式编程\n\n### Reactor\nTODO\n### RxJava\nTODO\n### Vert.x\nTODO\n\n## DODAF2.0\n\n* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)\n* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)\n\n## Serverless\n\n无需过多关系服务器的服务架构理念。\n\n* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)\n\t* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。\n\t* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。\n\t* Serverless 不代表某个具体的框架。\n\n* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)\n\t* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）\n\n\n\n## Service Mesh\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)\n\n\n# 项目管理\n\n## 架构评审\n* [《架构设计之如何评审架构设计说明书》](http://developer.51cto.com/art/201506/478486.htm)\n* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)\n\n## 重构\n\n* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)\n\n## 代码规范\n\n* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)\n\n## 代码 Review\n\n\n制度还是制度!\n另外，每个公司需要根据自己的需求和目标制定自己的 check list\n\n* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)\n\t* 代码 review 做的好，在于制度建设。\n\n* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)\n\n* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)\n* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)\n\n* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)\n\n## RUP\n* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)\n\n## 看板管理\n* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)\n\n## SCRUM\n\nSCRUM - 争球\n\n* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。\n* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；\n* 五个价值观：专注、勇气、公开、承诺、尊重。\n\n\n* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)\n\n* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)\n\n## 敏捷开发\n\nTODO\n\n## 极限编程（XP）\n\nXP - eXtreme Programming\n\n* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)\n\t* 是一种指导开发人员的方法论。\n\t* 4大价值：\n\t\t* 沟通：鼓励口头沟通，提高效率。\n\t\t* 简单：够用就好。\n\t\t* 反馈：及时反馈、通知相关人。\n\t\t* 勇气：提倡拥抱变化，敢于重构。\n\t\t\n\t* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。\n\t* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。\n\n## 结对编程\n\n边写码，边review。能够增强代码质量、减少bug。\n\n* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)\n\n## PDCA 循环质量管理\n\nP——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进\n\n* [《PDCA》](http://www.baike.com/wiki/PDCA)\n\n## FMEA管理模式\n\nTODO\n\n# 通用业务术语\n\nTODO\n\n# 技术趋势\n\nTODO\n\n# 政策、法规\n\n## 法律\n\n* [《中华人民共和国网络安全法》](https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/16843044)\n  * 2016年11月7日发布，自2017年6月1日起施行\n\n* [《个人信息保护法》](https://baike.baidu.com/item/个人信息保护法/8343360)\n  * 个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。\n\n* [《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》](https://baike.baidu.com/item/最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释/20497481)\n  * 《解释》共十三条，自2017年6月1日起施行\n  > * 1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”；\n  > * 2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上；\n  > * 3、对于其他公民个人信息，标准为 5000条以上。\n\n* [《中华人民共和国电子商务法》](https://baike.baidu.com/item/中华人民共和国电子商务法/16467544)\n  * 2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行\n  * [解读电子商务法（一）什么是电商](https://v.youku.com/v_show/id_XNDAzNjAyNDM0MA==.html)\n  * [解读电子商务法（二）电商经营者](https://v.youku.com/v_show/id_XNDA1OTc0OTQ5Mg==.html)\n  * [解读电子商务法（三）电商行为规范](https://v.youku.com/v_show/id_XNDA4NzIyNjI4MA==.html)\n  * [解读电子商务法（四）电商的法律关系](https://v.qq.com/x/page/e08443fc1cr.html)\n  * [解读电子商务法（外传）电商挣钱的秘密](https://v.youku.com/v_show/id_XNDA4MTQ2Nzk4NA==.html)\n  * [解读电子商务法（外传）电商模式](https://v.qq.com/x/page/j0844twjwr5.html)\n\n* [程序员需要知道的法律常识](https://blog.csdn.net/a331685690/article/details/79917772)\n* [白话法律42讲-为程序员打造的专属法律武器](https://time.geekbang.org/column/132)\n\n### 严格遵守刑法253法条\n\n我国刑法第253条之一规定：\n\n> * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。\n> * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 \n> * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。\n\n最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”\n\n* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)\n\n### 避风港原则\n“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。\n* [《避风港原则》](https://baike.baidu.com/item/%E9%81%BF%E9%A3%8E%E6%B8%AF%E5%8E%9F%E5%88%99/588459?fr=aladdin)\n\n# 架构师素质\n\n* [《架构师画像》](http://hellojava.info/?p=430)\n\t* 业务理解和抽象能力\n\t* NB的代码能力\n\t* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； \n\t* 全局：是否考虑到了对上下游的系统的影响。\n\t* 权衡：权衡投入产出比；优先级和节奏控制；\n\n* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)\n\t* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。\n\t* 基础设施、配置、测试、开发、运维综合考虑。\n\t* 考虑人、团队、和组织的影响。 \n\n* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) \n\n* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)\n\t* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。\n\t* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 \n\n* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)\n\t* 第一层的架构师看到的只是产品本身\n\t* 第二层的架构师不仅看到自己的产品，还看到了整体的方案\n\t* 第三层的架构师看到的是商业价值 \n\n# 团队管理\n\nTODO\n\n## 招聘\n\n# 资讯\n\n## 行业资讯\n\n* [36kr](http://36kr.com/)\n* [Techweb](http://www.techweb.com.cn/)\n\n## 公众号列表\n\nTODO\n\n## 博客\n\n### 团队博客\n* [阿里中间件博客](http://jm.taobao.org/)\n* [美团点评技术团队博客](https://tech.meituan.com)\n\n### 个人博客\n\n* [阮一峰的网络日志](http://www.ruanyifeng.com/)\n* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)\n* [hellojava-阿里毕玄](http://hellojava.info/)\n* [Cm's Blog](http://cmsblogs.com/)\n* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)\n\n## 综合门户、社区\n\n**国内：**\n\n* [CSDN](http://csdn.net)\n\t 老牌技术社区、不必解释。\n* [51cto.com](http://www.51cto.com/)\n* [ITeye](http://www.iteye.com/)\n\t* 偏 Java 方向 \n* [博客园](https://www.cnblogs.com)\n* [ChinaUnix](http://www.chinaunix.net/)\n\t* 偏 Linux 方向 \n* [开源中国社区](https://www.oschina.net/)\n* [InfoQ](https://www.infoq.cn/)\n* [深度开源](http://www.open-open.com/)\n* [伯乐在线](http://www.jobbole.com/)\n\t* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。\n\n* [ITPUB](http://www.itpub.net/)\n* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)\n* [阿里云— 云栖社区](https://yq.aliyun.com/)\n* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)\n* [开发者头条](https://toutiao.io/)\n* [LinkedKeeper](http://www.linkedkeeper.com)\n\n**国外：**\n\n* [DZone](https://dzone.com)\n* [Reddit](https://www.reddit.com)\n\n## 问答、讨论类社区\n\n* [segmentfault](https://segmentfault.com)\n\t* 问答+专栏 \n* [知乎](https://www.zhihu.com/)\n* [stackoverflow](https://stackoverflow.com/)\n\n## 行业数据分析\n\n* [艾瑞网](http://report.iresearch.cn/)\n* [QUEST MOBILE](https://www.questmobile.com.cn)\n\n* [国家数据](http://data.stats.gov.cn/)\n\n* [TalkingData](http://www.talkingdata.com/)\n\n## 专项网站\n\n* 测试:\n\t* [领测国际](http://www.ltesting.net/) \n\t* [测试窝](https://www.testwo.com/)\n\t* [TesterHome](https://testerhome.com)\n\n* 运维:\n  \t* [运维派](http://www.yunweipai.com/) \n  \t* [Abcdocker](https://www.abcdocker.com/)\n  \n* Java:\n\t* [ImportNew](http://www.importnew.com/)\n\t\t* 专注于 Java 技术分享\n\t* [HowToDoInJava](https://howtodoinjava.com/)\n\t\t* 英文博客\n\t\n* 安全\n\t* [红黑联盟](https://www.2cto.com/) \n\t* [FreeBuf](http://www.freebuf.com/)\n\n* 大数据\n\t* [中国大数据](http://www.thebigdata.cn/) \n\n* 其他专题网站：\n\t* [InfoQ](http://www.infoq.com/cn/)\n\t\t* 偏重于基础架构、运维方向\n\t* [DockerInfo](http://www.dockerinfo.net/)\n\t\t* 专注于 Docker 应用及咨询、教程的网站\n\t* [Linux公社](https://www.linuxidc.com/)\n\t\t* Linux 主题社区\n\n## 其他类\n\n* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)\n\n## 推荐参考书\n\n\n### 在线电子书\n\n* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)\n\n\n* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)\n* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)\n\n* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)\n\n* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)\n\n* [《架构师之路》](https://www.w3cschool.cn/architectroad/)\n\n### 纸质书\n\n<b style=\"color:red\">更多架构方面书籍参考:</b> [awesome-java-books](https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%9E%B6%E6%9E%84)\n\n#### 开发方面\n\n* 《阿里巴巴Java开发手册》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BfL5CR)\n\n#### 架构方面\n* 《软件架构师的12项修炼：技术技能篇》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=rTlo0m)\n* 《架构之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=1KECBZ) \n* 《分布式服务架构》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=hkzqtK) \n* 《聊聊架构》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=A8Nd6Z) \n* 《云原生应用架构实践》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=D4WCpd) \n* 《亿级流量网站架构核心技术》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Rdmd21)\n* 《淘宝技术这十年》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=CoUdGG)\n* 《企业IT架构转型之道-中台战略思想与架构实战》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BxS6eI) \n\n* 《高可用架构（第1卷）》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BcjUwS) \n\n#### 技术管理方面\n* 《CTO说》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Gl3QAo) \n* 《技术管理之巅》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=MeloLt)\n* 《网易一千零一夜：互联网产品项目管理实战》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=qPuqMg) \n\n#### 基础理论\n* 《数学之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=0seUpO) \n* 《编程珠玑》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=I7jj9r) \n\n#### 工具方面\nTODO\n\n#### 大数据方面\n\n# 技术资源\n\n## 开源资源\n* [github](https://github.com)\n\n* [Apache 软件基金会](https://www.apache.org/index.html)\n\n## 手册、文档、教程\n\n**国内：**\n* [W3Cschool](http://w3cschool.cn) \n* [Runoob.com](http://www.runoob.com/)\n\t* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。\n\n* [Love2.io](https://love2.io/)\n\t* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。\n* [gitbook.cn](http://gitbook.cn/)\n\t* 付费电子书。 \n* [ApacheCN](http://www.apachecn.org/)\n\t* AI、大数据方面系列中文文档。\n\n**国外：**\n\n* [Quick Code](http://www.quickcode.co/)\n\t* 免费在线技术教程。\n* [gitbook.com](http://gitbook.com)\n\t* 有部分中文电子书。\n* [Cheatography](https://www.cheatography.com/)\n\t* Cheat Sheets 大全，单页文档网站。\n* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)\n\t* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。\n* [LeetCode](https://leetcode.com/problemset/all/)\n\t* 知名题库网站，提供Java、Python、C#、C++、算法、SQL、等高质量各程度题库和解决办法。\n\n## 在线课堂\n\n* [学徒无忧](http://www.xuetuwuyou.com/)\n* [极客时间](https://time.geekbang.org/)\n* [segmentfault](https://segmentfault.com/lives)\n* [斯达克学院](https://new.stuq.org/course/explore)\n* [牛客网](http://nowcoder.com)\n* [极客学院](https://www.jikexueyuan.com/)\n* [51CTO学院](http://edu.51cto.com/)\n\n## 会议、活动\n\n* [QCon](http://www.infoq.com/cn/qcon/)\n* [ArchSummit](https://archsummit.com)\n* [GITC全球互联网技术大会](http://www.thegitc.com/)\n\n**活动发布平台:** \n* [活动行](http://www.huodongxing.com/)\n\n## 常用APP\n\n* [极客时间](https://time.geekbang.org)\n* [得到](https://www.igetget.com)\n\n## 找工作\n* [Boss直聘](https://www.zhipin.com)\n* [拉勾网](https://www.lagou.com)\n* [猎聘](https://www.liepin.com)\n* [100Offer](https://cn.100offer.com/)\n\n## 工具\n\n* [极客搜索](https://s.geekbang.org/)\n\t* 技术文章搜索引擎。\n\n## 代码托管\n\n* [Coding](https://coding.net)\n* [码云](https://gitee.com/)\n\n## 文件服务\n* 七牛\n* 又拍云\n\n## 综合云服务商\n* 阿里云\n* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c)\n* 百度云\n* 新浪云\n* 金山云\n* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)\n* [谷歌云](https://cloud.google.com/?hl=zh-cn)\n* [微软云](https://azure.microsoft.com/zh-cn/)\n\n### VPS\n* [Linode](http://linode.com)\n* [DigitalOcean](https://www.digitalocean.com)\n* [Vultr](https://www.vultr.com/)","slug":"技术分享/后端架构师技术图谱","published":1,"_id":"ckiyez6ig003ztvcdcwzo74fu","layout":"post","photos":[],"link":"","content":"<p><b style=\"color:red\">推荐:</b> <a href=\"https://github.com/sorenduan/awesome-java-books\">《Java技术书籍大全》 - awesome-java-books</a></p>\n<p>从初级开发者到资深架构师，看这些书就够了</p>\n<hr/>\n<!-- \n[![知识共享协议（CC协议）](https://img.shields.io/badge/License-Creative%20Commons-DC3D24.svg)](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)[![GitHub stars](https://img.shields.io/github/stars/xingshaocheng/architect-awesome.svg?style=flat&label=Star)](https://github.com/xingshaocheng/architect-awesome/stargazers)[![GitHub forks](https://img.shields.io/github/forks/xingshaocheng/architect-awesome.svg?style=flat&label=Fork)](https://github.com/xingshaocheng/architect-awesome/fork)[![GitHub watchers](https://img.shields.io/github/watchers/xingshaocheng/architect-awesome.svg?style=flat&label=Watch)](https://github.com/xingshaocheng/architect-awesome/watchers)[![GitHub followers](https://img.shields.io/github/followers/xingshaocheng.svg?label=%E5%85%B3%E6%B3%A8)](https://github.com/xingshaocheng) -->\n\n<!-- **（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）** -->\n\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/lemon-flm/p/7877898.html\">《java队列——queue详细分析》</a></p>\n<ul>\n<li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li>\n<li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/mantu/p/5802393.html\">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></p>\n</li>\n</ul>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_33642117/article/details/52040345\">《Java Set集合的详解》</a></li>\n</ul>\n<h2 id=\"链表、数组\"><a href=\"#链表、数组\" class=\"headerlink\" title=\"链表、数组\"></a>链表、数组</h2><ul>\n<li><a href=\"https://blog.csdn.net/wz249863091/article/details/52853360\">《Java集合详解–什么是List》</a></li>\n</ul>\n<h2 id=\"字典、关联数组\"><a href=\"#字典、关联数组\" class=\"headerlink\" title=\"字典、关联数组\"></a>字典、关联数组</h2><ul>\n<li><a href=\"https://baike.xsoftlab.net/view/250.html\">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><a href=\"https://blog.csdn.net/javazejian/article/details/53362993\">《java数据结构与算法之栈（Stack）设计与实现》</a></li>\n<li><a href=\"http://www.runoob.com/java/java-stack-class.html\">《Java Stack 类》</a></li>\n<li><a href=\"https://blog.csdn.net/f2006116/article/details/51375225\">《java stack的详细实现分析》</a><ul>\n<li>Stack 是线程安全的。</li>\n<li>内部使用数组保存数据，不够时翻倍。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/cai2016/article/details/52589952\">《二叉树》</a></li>\n</ul>\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin\">《完全二叉树》</a><ul>\n<li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/polly333/p/4798944.html\">《浅谈数据结构-平衡二叉树》</a></li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html\">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li>\n</ul>\n<h3 id=\"二叉查找树（BST）\"><a href=\"#二叉查找树（BST）\" class=\"headerlink\" title=\"二叉查找树（BST）\"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html\">《浅谈算法和数据结构: 七 二叉查找树》</a></li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><ul>\n<li><a href=\"https://blog.csdn.net/sun_tttt/article/details/65445754\">《最容易懂得红黑树》</a><ul>\n<li>添加阶段后，左旋或者右旋从而再次达到平衡。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html\">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li>\n</ul>\n<h3 id=\"B，B-，B-树\"><a href=\"#B，B-，B-树\" class=\"headerlink\" title=\"B，B+，B*树\"></a>B，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/aqzwss/article/details/53074186\">《B-树，B+树，B*树详解》</a></li>\n<li><a href=\"https://blog.csdn.net/bigtree_3721/article/details/73632405\">《B-树，B+树与B*树的优缺点比较》</a><ul>\n<li>B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。<h3 id=\"LSM-树\"><a href=\"#LSM-树\" class=\"headerlink\" title=\"LSM 树\"></a>LSM 树</h3></li>\n</ul>\n</li>\n</ul>\n<p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。<br>Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/dbanote/article/details/8897599\">《LSM树 VS B+树》</a></p>\n<ul>\n<li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。</li>\n<li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014774781/article/details/52105708\">《LSM树（Log-Structured Merge Tree）存储引擎》</a></p>\n<ul>\n<li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li>\n<li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li>\n<li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"BitSet\"><a href=\"#BitSet\" class=\"headerlink\" title=\"BitSet\"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p>\n<ul>\n<li><a href=\"http://www.runoob.com/java/java-bitset-class.html\">《Java Bitset类》</a></li>\n<li><a href=\"https://blog.csdn.net/caiandyong/article/details/51581160\">《Java BitSet（位集）》</a></li>\n</ul>\n<h1 id=\"常用算法\"><a href=\"#常用算法\" class=\"headerlink\" title=\"常用算法\"></a>常用算法</h1><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h2 id=\"排序、查找算法\"><a href=\"#排序、查找算法\" class=\"headerlink\" title=\"排序、查找算法\"></a>排序、查找算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/shen-hua/p/5424059.html\">《Java中的经典算法之选择排序（SelectionSort）》</a><ul>\n<li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li><a href=\"https://blog.csdn.net/shuaizai88/article/details/73250615\">《冒泡排序的2种写法》</a><ul>\n<li>相邻元素前后交换、把最大的排到最后。</li>\n<li>时间复杂度 O(n²) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/hapjin/p/5517667.html\">《排序算法总结之插入排序》</a></li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li><a href=\"https://blog.csdn.net/afjaklsdflka/article/details/52829030\">《坐在马桶上看算法：快速排序》</a><ul>\n<li>一侧比另外一侧都大或小。 <h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3></li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/chengxiao/p/6194356.html\">《图解排序算法(四)之归并排序》</a><ul>\n<li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>TODO</p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/chengxiao/p/6129630.html\">《图解排序算法(三)之堆排序》</a><ul>\n<li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/suvllian/p/5495780.html\">《计数排序和桶排序》</a><ul>\n<li>和桶排序过程比较像，差别在于桶的数量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li><a href=\"http://blog.51cto.com/ahalei/1362789\">《【啊哈！算法】最快最简单的排序——桶排序》</a></li>\n<li><a href=\"https://blog.csdn.net/sunjinshengli/article/details/70738527\">《排序算法（三）：计数排序与桶排序》</a><ul>\n<li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li>\n<li>每个桶单独进行排序，然后再遍历每个桶。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/51695211\">《排序算法系列：基数排序》</a></li>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/3603669.html\">《基数排序》</a></li>\n</ul>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/coderising/p/5708632.html\">《二分查找(java实现)》</a></p>\n<ul>\n<li>要求待查找的序列有序。</li>\n<li>时间复杂度 O(logN)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/maoyuanming0806/article/details/78176957\">《java实现二分查找-两种方式》</a></p>\n<ul>\n<li>while + 递归。<h3 id=\"Java-中的排序工具\"><a href=\"#Java-中的排序工具\" class=\"headerlink\" title=\"Java 中的排序工具\"></a>Java 中的排序工具</h3></li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1\">《Arrays.sort和Collections.sort实现原理解析》</a></p>\n<ul>\n<li>Collections.sort算法调用的是合并排序。</li>\n<li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。<br>核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。<br>优点：空间和时间效率都很高。<br>缺点：随着存入的元素数量增加，误算率随之增加。</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000002729689\">《布隆过滤器 – 空间效率很高的数据结构》</a></li>\n<li><a href=\"https://blog.csdn.net/zdxiq000/article/details/57626464\">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li>\n<li><a href=\"https://blog.csdn.net/qq_30242609/article/details/71024458\">《基于Redis的布隆过滤器的实现》</a><ul>\n<li>基于 Redis 的 Bitmap 数据结构。</li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/47973715\">《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》</a><ul>\n<li>使用Java中的 BitSet 类 和 加权和hash算法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h2><h3 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP）<br>核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\">《字符串匹配的KMP算法》</a></li>\n</ul>\n<h2 id=\"深度优先、广度优先\"><a href=\"#深度优先、广度优先\" class=\"headerlink\" title=\"深度优先、广度优先\"></a>深度优先、广度优先</h2><ul>\n<li><a href=\"https://www.cnblogs.com/0kk470/p/7555033.html\">《广度优先搜索BFS和深度优先搜索DFS》</a></li>\n</ul>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><ul>\n<li><a href=\"https://www.cnblogs.com/MrSaver/p/8641971.html\">《算法：贪婪算法基础》</a></li>\n<li><a href=\"https://blog.csdn.net/a345017062/article/details/52443781\">《常见算法及问题场景——贪心算法》</a></li>\n</ul>\n<h2 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qfikh/article/details/51960331\">《 五大常用算法之四：回溯法》</a></li>\n</ul>\n<h2 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luningcsdn/article/details/50930276\">《α-β剪枝算法》</a></li>\n</ul>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><ul>\n<li><a href=\"https://www.cnblogs.com/little-YTMM/p/5372680.html\">《详解动态规划——邹博讲动态规划》</a></li>\n<li><a href=\"https://blog.csdn.net/yao_zi_jie/article/details/54580283\">《动态规划算法的个人理解》</a></li>\n</ul>\n<h2 id=\"朴素贝叶斯\"><a href=\"#朴素贝叶斯\" class=\"headerlink\" title=\"朴素贝叶斯\"></a>朴素贝叶斯</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/amds123/article/details/70173402\">《带你搞懂朴素贝叶斯分类算法》</a></p>\n<ul>\n<li>P(B|A)=P(A|B)P(B)/P(A)</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html\">《贝叶斯推断及其互联网应用1》</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html\">《贝叶斯推断及其互联网应用2》</a></p>\n</li>\n</ul>\n<h2 id=\"推荐算法\"><a href=\"#推荐算法\" class=\"headerlink\" title=\"推荐算法\"></a>推荐算法</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01\">《推荐算法综述》</a></li>\n<li><a href=\"https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems\">《TOP 10 开源的推荐系统简介》</a></li>\n</ul>\n<h2 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luoshixian099/article/details/51908175\">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li>\n</ul>\n<h2 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_35644234/article/details/60870719\">《Dijkstra算法详解》</a></li>\n</ul>\n<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h1><h2 id=\"Java-并发\"><a href=\"#Java-并发\" class=\"headerlink\" title=\"Java 并发\"></a>Java 并发</h2><ul>\n<li><a href=\"https://github.com/CL0610/Java-concurrency\">Java 并发知识合集</a></li>\n<li><a href=\"https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png\">JAVA并发知识图谱</a></li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xrq730/p/5060921.html\">《40个Java多线程问题总结》</a></li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><ul>\n<li><a href=\"https://www.cnblogs.com/zhanht/p/5450325.html\">《Java并发编程——线程安全及解决机制简介》</a></li>\n</ul>\n<h2 id=\"一致性、事务\"><a href=\"#一致性、事务\" class=\"headerlink\" title=\"一致性、事务\"></a>一致性、事务</h2><h3 id=\"事务-ACID-特性\"><a href=\"#事务-ACID-特性\" class=\"headerlink\" title=\"事务 ACID 特性\"></a>事务 ACID 特性</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012440687/article/details/52116108\">《数据库事务ACID特性》</a></li>\n</ul>\n<h3 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h3><ul>\n<li><p>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</p>\n</li>\n<li><p>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</p>\n</li>\n<li><p>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</p>\n</li>\n<li><p>序列化：所有事物串行处理（牺牲了效率）</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_33290787/article/details/51924963\">《理解事务的4种隔离级别》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/z-sm/p/7245981.html\">数据库事务的四大特性及事务隔离级别</a></p>\n</li>\n<li><p><a href=\"http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html\">《MySQL的InnoDB的幻读问题 》</a></p>\n<ul>\n<li>幻读的例子非常清楚。</li>\n<li>通过 SELECT … FOR UPDATE 解决。</li>\n</ul>\n</li>\n<li><p><a href=\"https://draveness.me/mysql-innodb\">《一篇文章带你读懂MySQL和InnoDB》</a></p>\n<ul>\n<li>图解脏读、不可重复读、幻读问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/chenpingzhao/p/5065316.html\">《【mysql】关于innodb中MVCC的一些理解》</a></p>\n<ul>\n<li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li>\n<li>MVCC 会产生幻读问题（更新时异常。）</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/whoamiyang/article/details/51901888\">《轻松理解MYSQL MVCC 实现机制》</a></p>\n<ul>\n<li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li>\n<li>每次只操作比当前版本小（或等于）的 行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"Java中的锁和同步类\"><a href=\"#Java中的锁和同步类\" class=\"headerlink\" title=\"Java中的锁和同步类\"></a>Java中的锁和同步类</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/qifengshi/p/6831055.html\">《Java中的锁分类》</a></p>\n<ul>\n<li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\">《Java并发之AQS详解》</a></p>\n</li>\n<li><p><a href=\"http://cuisuqiang.iteye.com/blog/2020146\">《Java中信号量 Semaphore》</a></p>\n<ul>\n<li>有数量控制</li>\n<li>申请用 acquire，申请不要则阻塞；释放用 release。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/davidwang456/p/6094947.html\">《java开发中的Mutex vs Semaphore》</a></p>\n<ul>\n<li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"公平锁-amp-非公平锁\"><a href=\"#公平锁-amp-非公平锁\" class=\"headerlink\" title=\"公平锁 &amp; 非公平锁\"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/EthanWhite/article/details/55508357\">《公平锁与非公平锁》</a><ul>\n<li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/zhiqian-ali/p/6200874.html\">《【MySQL】悲观锁&amp;乐观锁》</a></p>\n<ul>\n<li>乐观锁的方式：版本号+重试方式</li>\n<li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/Lawson/p/5008741.html\">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a></p>\n<ul>\n<li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li>\n<li>锁相同数据的不同索引条件可能会引起死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zejin2008/p/5262751.html\">《Mysql并发时经典常见的死锁原因及解决方法》</a></p>\n</li>\n</ul>\n<h3 id=\"乐观锁-amp-CAS\"><a href=\"#乐观锁-amp-CAS\" class=\"headerlink\" title=\"乐观锁 &amp; CAS\"></a>乐观锁 &amp; CAS</h3><ul>\n<li><a href=\"https://blog.csdn.net/u011514810/article/details/76895723/\">《乐观锁的一种实现方式——CAS》</a><ul>\n<li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ABA-问题\"><a href=\"#ABA-问题\" class=\"headerlink\" title=\"ABA 问题\"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/549294286/p/3766717.html\">《Java CAS 和ABA问题》</a></li>\n<li><a href=\"https://blog.csdn.net/li954644351/article/details/50511879\">《Java 中 ABA问题及避免》</a><ul>\n<li>AtomicStampedReference 和 AtomicStampedReference。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CopyOnWrite容器\"><a href=\"#CopyOnWrite容器\" class=\"headerlink\" title=\"CopyOnWrite容器\"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/hapjin/p/4840107.html\">《JAVA中写时复制(Copy-On-Write)Map实现》</a></p>\n<ul>\n<li>实现读写分离，读取发生在原始数据上，写入发生在副本上。  </li>\n<li>不用加锁，通过最终一致实现一致性。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/a494303877/article/details/53404623\">《聊聊并发-Java中的Copy-On-Write容器》</a></p>\n</li>\n</ul>\n<h3 id=\"RingBuffer\"><a href=\"#RingBuffer\" class=\"headerlink\" title=\"RingBuffer\"></a>RingBuffer</h3><ul>\n<li><a href=\"http://www.cnblogs.com/l00l/p/4115001.html\">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li>\n</ul>\n<h3 id=\"可重入锁-amp-不可重入锁\"><a href=\"#可重入锁-amp-不可重入锁\" class=\"headerlink\" title=\"可重入锁 &amp; 不可重入锁\"></a>可重入锁 &amp; 不可重入锁</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/dj3839/p/6580765.html\">《可重入锁和不可重入锁》</a></p>\n<ul>\n<li>通过简单代码举例说明可重入锁和不可重入锁。</li>\n<li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li>\n<li>可重入锁可以用户避免死锁。</li>\n<li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/baizhanshi/p/7211802.html\">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a></p>\n<ul>\n<li>synchronized 使用方便，编译器来加锁，是非公平锁。</li>\n<li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li>\n<li>相同加锁场景下，推荐使用 synchronized。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"互斥锁-amp-共享锁\"><a href=\"#互斥锁-amp-共享锁\" class=\"headerlink\" title=\"互斥锁 &amp; 共享锁\"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。<br>共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/liang1101/p/6475555.html\">《ReadWriteLock场景应用》</a></li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/yunfenglw/article/details/45950305\">《“死锁”四个必要条件的合理解释》</a></p>\n<ul>\n<li>互斥、持有、不可剥夺、环形等待。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014039577/article/details/52351626\">Java如何查看死锁？</a></p>\n<ul>\n<li>JConsole 可以识别死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/bohu83/article/details/51135061\">java多线程系列：死锁及检测</a></p>\n<ul>\n<li>jstack 可以显示死锁。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><h2 id=\"计算机原理\"><a href=\"#计算机原理\" class=\"headerlink\" title=\"计算机原理\"></a>计算机原理</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000003692840\">《操作系统基础知识——操作系统的原理，类型和结构》</a></li>\n</ul>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><h3 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/zero__007/article/details/54089730\">《从Java视角理解CPU缓存和伪共享》</a></li>\n</ul>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>TODO</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ul>\n<li><a href=\"https://blog.csdn.net/asdf_1024/article/details/78978437\">《线程的生命周期及状态转换详解》</a></li>\n</ul>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><ul>\n<li><a href=\"https://www.thinksaas.cn/group/topic/839375/\">《终结python协程—-从yield到actor模型的实现》</a><ul>\n<li>线程的调度是由操作系统负责，协程调度是程序自行负责</li>\n<li>与线程相比，协程减少了无谓的操作系统切换.</li>\n<li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><ul>\n<li><a href=\"http://www.runoob.com/linux/linux-command-manual.html\">《Linux 命令大全》</a></li>\n</ul>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h2 id=\"设计模式的六大原则\"><a href=\"#设计模式的六大原则\" class=\"headerlink\" title=\"设计模式的六大原则\"></a>设计模式的六大原则</h2><ul>\n<li><a href=\"https://blog.csdn.net/q291611265/article/details/48465113\">《设计模式的六大原则》</a><ul>\n<li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li>\n<li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li>\n<li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li>\n<li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li>\n<li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li>\n<li>合成复用原则：尽量使用合成/聚合,而不是使用继承。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"23种常见设计模式\"><a href=\"#23种常见设计模式\" class=\"headerlink\" title=\"23种常见设计模式\"></a>23种常见设计模式</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/design-pattern-tutorial.html\">《设计模式》</a></li>\n<li><a href=\"https://www.cnblogs.com/susanws/p/5510229.html\">《23种设计模式全解析》</a></li>\n<li><a href=\"https://github.com/ToryZhou/design-pattern\">《设计模式类图与示例》</a></li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/winkey4986/p/5148953.html\">《细数JDK里的设计模式》</a></p>\n<ul>\n<li><p>结构型模式：</p>\n<ul>\n<li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li>\n<li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li>\n<li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li>\n<li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li>\n<li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li>\n<li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li>\n</ul>\n</li>\n<li><p>创建模式:</p>\n<ul>\n<li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li>\n<li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li>\n<li>工厂方法：就是 <strong>一个返回</strong>具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li>\n<li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li>\n<li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li>\n</ul>\n</li>\n<li><p>行为模式：</p>\n<ul>\n<li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li>\n<li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li>\n<li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li>\n<li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li>\n<li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li>\n<li>空对象模式：如 java.util.Collections#emptyList()。</li>\n<li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li>\n<li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/hwaggLee/p/4510687.html\">《Spring-涉及到的设计模式汇总》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u012387062/article/details/54719114\">《Mybatis使用的设计模式》</a></p>\n</li>\n</ul>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><ul>\n<li><a href=\"https://blog.csdn.net/YECrazy/article/details/79481964\">《单例模式的三种实现 以及各自的优缺点》</a></li>\n<li><a href=\"https://www.cnblogs.com/ttylinux/p/6498822.html\">《单例模式－－反射－－防止序列化破坏单例模式》</a><ul>\n<li>使用枚举类型。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>TODO</p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/mvc-pattern.html\">《MVC 模式》</a><ul>\n<li>模型(model)－视图(view)－控制器(controller) </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/23277575\">《理解 IOC》</a></li>\n<li><a href=\"https://www.cnblogs.com/NancyStartOnce/p/6813162.html\">《IOC 的理解与解释》</a><ul>\n<li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li>\n<li>作用：用于模块解耦。</li>\n<li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><ul>\n<li><a href=\"https://blog.csdn.net/yanquan345/article/details/19760027\">《轻松理解AOP(面向切面编程)》</a></li>\n<li><a href=\"https://www.cnblogs.com/hongwz/p/5764917.html\">《Spring AOP详解》</a></li>\n<li><a href=\"http://www.importnew.com/24305.html\">《Spring AOP的实现原理》</a><ul>\n<li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li>\n</ul>\n</li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/\">《Spring AOP 实现原理与 CGLIB 应用》</a><ul>\n<li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><ul>\n<li><a href=\"https://www.w3cschool.cn/uml_tutorial/\">《UML教程》</a></li>\n</ul>\n<h2 id=\"微服务思想\"><a href=\"#微服务思想\" class=\"headerlink\" title=\"微服务思想\"></a>微服务思想</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/6219259.html\">《微服务架构设计》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/micro-service-technology-stack\">《微服务架构技术栈选型手册》</a></li>\n</ul>\n<h3 id=\"康威定律\"><a href=\"#康威定律\" class=\"headerlink\" title=\"康威定律\"></a>康威定律</h3><ul>\n<li><p><a href=\"https://yq.aliyun.com/articles/8611\">《微服务架构的理论基础 - 康威定律》</a></p>\n<ul>\n<li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li>\n<li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li>\n<li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li>\n<li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li>\n</ul>\n</li>\n<li><p><a href=\"https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf\">《微服务架构核⼼20讲》</a></p>\n</li>\n</ul>\n<h1 id=\"运维-amp-统计-amp-技术支持\"><a href=\"#运维-amp-统计-amp-技术支持\" class=\"headerlink\" title=\"运维 &amp; 统计 &amp; 技术支持\"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id=\"常规监控\"><a href=\"#常规监控\" class=\"headerlink\" title=\"常规监控\"></a>常规监控</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/77849205\">《腾讯业务系统监控的修炼之路》</a></p>\n<ul>\n<li>监控的方式：主动、被动、旁路(比如舆情监控)</li>\n<li>监控类型： 基础监控、服务端监控、客户端监控、<br>监控、用户端监控</li>\n<li>监控的目标：全、块、准</li>\n<li>核心指标：请求量、成功率、耗时</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.oschina.net/news/67525/monitoring-tools\">《开源还是商用？十大云运维监控工具横评》</a></p>\n<ul>\n<li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li>\n</ul>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/201612/525373.htm\">《监控报警系统搭建及二次开发经验》</a></p>\n</li>\n</ul>\n<p><strong>命令行监控工具</strong></p>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html\">《常用命令行监控工具》</a></p>\n<ul>\n<li>top、sar、tsar、nload</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.jobbole.com/96846/\">《20个命令行工具监控 Linux 系统性能》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/feichexia/blog/196575\">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></p>\n</li>\n</ul>\n<h2 id=\"APM\"><a href=\"#APM\" class=\"headerlink\" title=\"APM\"></a>APM</h2><p>APM —  Application Performance Management</p>\n<ul>\n<li><p><a href=\"http://bigbully.github.io/Dapper-translation/\">《Dapper，大规模分布式系统的跟踪系统》</a></p>\n</li>\n<li><p><a href=\"http://opentracing.io\">CNCF OpenTracing</a>，<a href=\"https://github.com/opentracing-contrib/opentracing-specification-zh\">中文版</a></p>\n</li>\n<li><p>主要开源软件，按字母排序</p>\n<ul>\n<li><a href=\"https://github.com/apache/incubator-skywalking\">Apache SkyWalking</a></li>\n<li><a href=\"https://github.com/dianping/cat\">CAT</a></li>\n<li><a href=\"https://github.com/jaegertracing/jaeger\">CNCF jaeger</a></li>\n<li><a href=\"https://github.com/naver/pinpoint\">Pinpoint</a></li>\n<li><a href=\"https://github.com/openzipkin/zipkin\">Zipkin</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/apm-Pinpoint-practice\">《开源APM技术选型与实战》</a></p>\n<ul>\n<li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"统计分析\"><a href=\"#统计分析\" class=\"headerlink\" title=\"统计分析\"></a>统计分析</h2><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/25195217\">《流量统计的基础：埋点》</a></p>\n<ul>\n<li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.25xt.com/company/17066.html\">《APP埋点常用的统计工具、埋点目标和埋点内容》</a></p>\n<ul>\n<li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li>\n</ul>\n</li>\n<li><p><a href=\"https://tech.meituan.com/mt_mobile_analytics_practice.html\">《美团点评前端无痕埋点实践》</a></p>\n<ul>\n<li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"持续集成-CI-CD\"><a href=\"#持续集成-CI-CD\" class=\"headerlink\" title=\"持续集成(CI/CD)\"></a>持续集成(CI/CD)</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\">《持续集成是什么？》</a></li>\n<li><a href=\"http://www.51testing.com/html/74/n-3723774.html\">《8个流行的持续集成工具》</a></li>\n</ul>\n<h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><ul>\n<li><a href=\"https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000\">《使用Jenkins进行持续集成》</a></li>\n</ul>\n<h3 id=\"环境分离\"><a href=\"#环境分离\" class=\"headerlink\" title=\"环境分离\"></a>环境分离</h3><p>开发、测试、生成环境分离。</p>\n<ul>\n<li><a href=\"https://my.oschina.net/sancuo/blog/214904\">《开发环境、生产环境、测试环境的基本理解和区》</a></li>\n</ul>\n<h2 id=\"自动化运维\"><a href=\"#自动化运维\" class=\"headerlink\" title=\"自动化运维\"></a>自动化运维</h2><h3 id=\"Ansible\"><a href=\"#Ansible\" class=\"headerlink\" title=\"Ansible\"></a>Ansible</h3><ul>\n<li><a href=\"http://www.ansible.com.cn/\">《Ansible中文权威指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/heiye123/articles/7855890.html\">《Ansible基础配置和企业级项目实用案例》</a></li>\n</ul>\n<h3 id=\"puppet\"><a href=\"#puppet\" class=\"headerlink\" title=\"puppet\"></a>puppet</h3><ul>\n<li><a href=\"https://www.cnblogs.com/keerya/p/8040071.html\">《自动化运维工具——puppet详解》</a></li>\n</ul>\n<h3 id=\"chef\"><a href=\"#chef\" class=\"headerlink\" title=\"chef\"></a>chef</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/\">《Chef 的安装与使用》</a></li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"TDD-理论\"><a href=\"#TDD-理论\" class=\"headerlink\" title=\"TDD 理论\"></a>TDD 理论</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/62f16cd4fef3\">《深度解读 - TDD（测试驱动开发）》</a><ul>\n<li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li>\n<li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyzm/p/6482886.html\">《Java单元测试之JUnit篇》</a></li>\n<li><a href=\"https://blog.csdn.net/hotdust/article/details/53406086\">《JUnit 4 与 TestNG 对比》</a><ul>\n<li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 </li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/wqetfg/article/details/50900512\">《单元测试主要的测试功能点》</a><ul>\n<li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h3><ul>\n<li><a href=\"https://blog.csdn.net/blueheart20/article/details/52170790\">《Apache ab 测试使用指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/binyue/p/6141088.html\">《大型网站压力测试及优化方案》</a></li>\n<li><a href=\"http://news.chinabyte.com/466/14126966.shtml\">《10大主流压力/负载/性能测试工具推荐》</a></li>\n<li><a href=\"http://quentinxxz.iteye.com/blog/2249799\">《真实流量压测工具 tcpcopy应用浅析》</a></li>\n<li><a href=\"https://www.cnblogs.com/jwentest/p/7136727.html\">《nGrinder 简易使用教程》</a></li>\n</ul>\n<h3 id=\"全链路压测\"><a href=\"#全链路压测\" class=\"headerlink\" title=\"全链路压测\"></a>全链路压测</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot\">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30306892\">《饿了么全链路压测的探索与实践》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28355759\">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li>\n<li><a href=\"https://www.jianshu.com/p/27060fd61f72\">《全链路压测经验》</a></li>\n</ul>\n<h3 id=\"A-B-、灰度、蓝绿测试\"><a href=\"#A-B-、灰度、蓝绿测试\" class=\"headerlink\" title=\"A/B 、灰度、蓝绿测试\"></a>A/B 、灰度、蓝绿测试</h3><ul>\n<li><p><a href=\"https://testerhome.com/topics/11165\">《技术干货 | AB 测试和灰度发布探索及实践》</a></p>\n</li>\n<li><p><a href=\"http://blog.51cto.com/purplegrape/1403123\">《nginx 根据IP 进行灰度发布》</a></p>\n</li>\n<li><p><a href=\"https://www.v2ex.com/t/344341\">《蓝绿部署、A/B 测试以及灰度发布》</a></p>\n</li>\n</ul>\n<h2 id=\"虚拟化\"><a href=\"#虚拟化\" class=\"headerlink\" title=\"虚拟化\"></a>虚拟化</h2><ul>\n<li><a href=\"https://blog.csdn.net/enweitech/article/details/52910082\">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li>\n</ul>\n<h3 id=\"KVM\"><a href=\"#KVM\" class=\"headerlink\" title=\"KVM\"></a>KVM</h3><ul>\n<li><a href=\"http://blog.chinaunix.net/uid-20201831-id-5775661.html\">《KVM详解，太详细太深入了，经典》</a></li>\n<li><a href=\"https://www.coderxing.com/kvm-install.html\">《【图文】KVM 虚拟机安装详解》</a></li>\n</ul>\n<h3 id=\"Xen\"><a href=\"#Xen\" class=\"headerlink\" title=\"Xen\"></a>Xen</h3><ul>\n<li><a href=\"https://www.cnblogs.com/sddai/p/5931201.html\">《Xen虚拟化基本原理详解》</a></li>\n</ul>\n<h3 id=\"OpenVZ\"><a href=\"#OpenVZ\" class=\"headerlink\" title=\"OpenVZ\"></a>OpenVZ</h3><ul>\n<li><a href=\"https://blog.csdn.net/longerzone/article/details/44829255\">《开源Linux容器 OpenVZ 快速上手指南》</a></li>\n</ul>\n<h2 id=\"容器技术\"><a href=\"#容器技术\" class=\"headerlink\" title=\"容器技术\"></a>容器技术</h2><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ul>\n<li><a href=\"https://www.cnblogs.com/SzeCheng/p/6822905.html\">《几张图帮你理解 docker 基本原理及快速入门》</a></li>\n<li><a href=\"https://draveness.me/docker\">《Docker 核心技术与实现原理》</a></li>\n<li><a href=\"http://www.runoob.com/docker/docker-tutorial.html\">《Docker 教程》</a></li>\n</ul>\n<h2 id=\"云技术\"><a href=\"#云技术\" class=\"headerlink\" title=\"云技术\"></a>云技术</h2><h3 id=\"OpenStack\"><a href=\"#OpenStack\" class=\"headerlink\" title=\"OpenStack\"></a>OpenStack</h3><ul>\n<li><a href=\"https://www.cnblogs.com/klb561/p/8660264.html\">《OpenStack构架知识梳理》</a></li>\n</ul>\n<h2 id=\"DevOps\"><a href=\"#DevOps\" class=\"headerlink\" title=\"DevOps\"></a>DevOps</h2><ul>\n<li><a href=\"https://www.cnblogs.com/jetzhang/p/6068773.html\">《一分钟告诉你究竟DevOps是什么鬼？》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/detail-analysis-of-devops\">《DevOps详解》</a></li>\n</ul>\n<h2 id=\"文档管理\"><a href=\"#文档管理\" class=\"headerlink\" title=\"文档管理\"></a>文档管理</h2><ul>\n<li><a href=\"http://www.confluence.cn/\">Confluence-收费文档管理系统</a></li>\n<li>GitLab?</li>\n<li>Wiki</li>\n</ul>\n<h1 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h1><h2 id=\"Web-Server\"><a href=\"#Web-Server\" class=\"headerlink\" title=\"Web Server\"></a>Web Server</h2><h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_25797077/article/details/52200722\">《Ngnix的基本学习-多进程和Apache的比较》</a></p>\n<ul>\n<li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li>\n<li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/cunkouzh/p/5410154.html\">《nginx与Apache的对比以及优缺点》</a></p>\n<ul>\n<li>nginx只适合静态和反向代理，不适合处理动态请求。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"OpenResty\"><a href=\"#OpenResty\" class=\"headerlink\" title=\"OpenResty\"></a>OpenResty</h3><ul>\n<li><a href=\"http://openresty.org/cn/\">官方网站</a></li>\n<li><a href=\"http://www.linkedkeeper.com/detail/blog.action?bid=1034\">《浅谈 OpenResty》</a><ul>\n<li>通过 Lua 模块可以在Nginx上进行开发。   </li>\n</ul>\n</li>\n<li><a href=\"https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html\">agentzh 的 Nginx 教程</a>  </li>\n</ul>\n<h3 id=\"Tengine\"><a href=\"#Tengine\" class=\"headerlink\" title=\"Tengine\"></a>Tengine</h3><ul>\n<li><a href=\"http://tengine.taobao.org/\">官方网站</a>  </li>\n</ul>\n<h3 id=\"Apache-Httpd\"><a href=\"#Apache-Httpd\" class=\"headerlink\" title=\"Apache Httpd\"></a>Apache Httpd</h3><ul>\n<li><a href=\"http://httpd.apache.org/\">官方网站</a></li>\n</ul>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><h4 id=\"架构原理\"><a href=\"#架构原理\" class=\"headerlink\" title=\"架构原理\"></a>架构原理</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/hggen/p/6264475.html\">《TOMCAT原理详解及请求过程》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/crazylqy/p/4706223.html\">《Tomcat服务器原理详解》</a></p>\n</li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/\">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xlgen157387/article/details/79006434\">《四张图带你了解Tomcat系统架构》</a></p>\n</li>\n<li><p><a href=\"https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/\">《JBoss vs. Tomcat: Choosing A Java Application Server》</a></p>\n<ul>\n<li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。</li>\n<li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"调优方案\"><a href=\"#调优方案\" class=\"headerlink\" title=\"调优方案\"></a>调优方案</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/sunfenqing/p/7339058.html\">《Tomcat 调优方案》</a></p>\n<ul>\n<li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.chinaunix.net/uid-20662363-id-3012760.html\">《tomcat http协议与ajp协议》</a></p>\n</li>\n<li><p><a href=\"http://dmouse.iteye.com/blog/1354527\">《AJP与HTTP比较和分析》</a></p>\n<ul>\n<li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li>\n<li>并发高时，AJP协议优于HTTP协议。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Jetty\"><a href=\"#Jetty\" class=\"headerlink\" title=\"Jetty\"></a>Jetty</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jetty/\">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li>\n<li><a href=\"https://blog.csdn.net/doutao6677/article/details/51957288\">《jetty和tomcat优势比较》</a><ul>\n<li>架构比较:Jetty的架构比Tomcat的更为简单。</li>\n<li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li>\n<li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ul>\n<li><a href=\"https://blog.csdn.net/clementad/article/details/48229243\">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li>\n</ul>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html\">《HashMap本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html\">《EhCache本地缓存》</a></p>\n<ul>\n<li>堆内、堆外、磁盘三级缓存。</li>\n<li>可按照缓存空间容量进行设置。</li>\n<li>按照时间、次数等过期策略。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html\">《Guava Cache》</a></p>\n<ul>\n<li>简单轻量、无堆外、磁盘缓存。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html\">《Nginx本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html\">《Pagespeed—懒人工具，服务器端加速》</a></p>\n</li>\n</ul>\n<h2 id=\"客户端缓存\"><a href=\"#客户端缓存\" class=\"headerlink\" title=\"客户端缓存\"></a>客户端缓存</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html\">《浏览器端缓存》</a></p>\n<ul>\n<li>主要是利用 Cache-Control 参数。</li>\n</ul>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w\">《H5 和移动端 WebView 缓存机制解析与实战》</a></p>\n</li>\n</ul>\n<h2 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a>服务端缓存</h2><h3 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h3><ul>\n<li><a href=\"https://github.com/jiangwenyuan/nuster\">nuster</a> - nuster cache</li>\n<li><a href=\"https://github.com/varnishcache/varnish-cache\">varnish</a> - varnish cache</li>\n<li><a href=\"https://github.com/squid-cache/squid\">squid</a> - squid cache</li>\n</ul>\n<h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><ul>\n<li><p><a href=\"http://www.runoob.com/Memcached/Memcached-tutorial.html\">《Memcached 教程》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chenleixing/article/details/47035453\">《深入理解Memcached原理》</a></p>\n<ul>\n<li>采用多路复用技术提高并发性。</li>\n<li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/36e5cd400580\">《Memcached软件工作原理》</a></p>\n</li>\n<li><p><a href=\"http://zhihuzeye.com/archives/2361\">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/liu251890347/article/details/37690045\">《memcache 中 add 、 set 、replace 的区别》</a></p>\n<ul>\n<li>区别在于当key存在还是不存在时，返回值是true和false的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=\"><strong>《memcached全面剖析》</strong></a></p>\n</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ul>\n<li><p><a href=\"http://www.runoob.com/redis/redis-tutorial.html\">《Redis 教程》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/wcf373722432/article/details/78678504\">《redis底层原理》</a></p>\n<ul>\n<li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li>\n<li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://doc.redisfans.com/topic/persistence.html\">《Redis持久化方式》</a></p>\n<ul>\n<li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li>\n<li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li>\n<li>也可以两者结合使用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chunlongyu/article/details/53346436\">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><a href=\"https://blog.csdn.net/sunhuiliang85/article/details/73656830\">《Redis单线程架构》</a></li>\n</ul>\n<h4 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h4><ul>\n<li><a href=\"https://blog.csdn.net/qq_29108585/article/details/63251491\">《redis的回收策略》</a></li>\n</ul>\n<h3 id=\"Tair\"><a href=\"#Tair\" class=\"headerlink\" title=\"Tair\"></a>Tair</h3><ul>\n<li><a href=\"https://github.com/alibaba/tair\">官方网站</a></li>\n<li><a href=\"http://blog.csdn.net/farphone/article/details/53522383\">《Tair和Redis的对比》</a></li>\n<li>特点：可以配置备份节点数目，通过异步同步到备份节点</li>\n<li>一致性Hash算法。</li>\n<li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li>\n</ul>\n<p>几种存储引擎:</p>\n<ul>\n<li>MDB，完全内存性，可以用来存储Session等数据。</li>\n<li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li>\n<li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li>\n<li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li>\n</ul>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/charlesblc/p/6045238.html\">《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》</a></p>\n<ul>\n<li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li>\n<li>Kafka 默认是拉模式。</li>\n<li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li>\n<li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yunfeng482/article/details/72856762\">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></p>\n</li>\n</ul>\n<h3 id=\"消息总线\"><a href=\"#消息总线\" class=\"headerlink\" title=\"消息总线\"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanghua_kobe/article/details/43877281\">《消息总线VS消息队列》</a></li>\n</ul>\n<h3 id=\"消息的顺序\"><a href=\"#消息的顺序\" class=\"headerlink\" title=\"消息的顺序\"></a>消息的顺序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/cjsblog/p/8267892.html\">《如何保证消费者接收消息的顺序》</a></li>\n</ul>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/whoamiyang/article/details/54954780\">《RabbitMQ的应用场景以及基本原理介绍》</a></li>\n<li><a href=\"https://www.jianshu.com/p/79ca08116d57\">《消息队列之 RabbitMQ》</a> </li>\n<li><a href=\"https://blog.csdn.net/u013256816/article/details/55515234\">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li>\n</ul>\n<h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/824066d70da8\">《RocketMQ 实战之快速入门》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome\">《RocketMQ 源码解析》</a></li>\n</ul>\n<h3 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/3962302.html\">《ActiveMQ消息队列介绍》</a></li>\n</ul>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p>\n<ul>\n<li><a href=\"http://kafka.apache.org/\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/allthesametome/article/details/47362451\">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li>\n<li><a href=\"http://lxw1234.com/archives/2015/10/538.htm\">《Kafka分区机制介绍与示例》</a></li>\n</ul>\n<h3 id=\"Redis-消息推送\"><a href=\"#Redis-消息推送\" class=\"headerlink\" title=\"Redis 消息推送\"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_34212276/article/details/78455004\">《Redis学习笔记之十：Redis用作消息队列》</a></li>\n</ul>\n<h3 id=\"ZeroMQ\"><a href=\"#ZeroMQ\" class=\"headerlink\" title=\"ZeroMQ\"></a>ZeroMQ</h3><p> TODO</p>\n<h2 id=\"定时调度\"><a href=\"#定时调度\" class=\"headerlink\" title=\"定时调度\"></a>定时调度</h2><h3 id=\"单机定时调度\"><a href=\"#单机定时调度\" class=\"headerlink\" title=\"单机定时调度\"></a>单机定时调度</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/shuaiqing/p/7742382.html\">《linux定时任务cron配置》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/daquan/blog/483305\">《Linux cron运行原理》</a></p>\n<ul>\n<li>fork 进程 + sleep 轮询</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/drift-ice/p/3817269.html\">《Quartz使用总结》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/wenniuwuren/article/details/42082981/\">《Quartz源码解析 —- 触发器按时启动原理》</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/bab8e4e32952\">《quartz原理揭秘和源码解读》</a></p>\n<ul>\n<li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式定时调度\"><a href=\"#分布式定时调度\" class=\"headerlink\" title=\"分布式定时调度\"></a>分布式定时调度</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_16216221/article/details/70314337\">《这些优秀的国产分布式任务调度系统，你用过几个？》</a></p>\n<ul>\n<li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html\">《Quartz任务调度的基本实现原理》</a></p>\n<ul>\n<li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 </li>\n</ul>\n</li>\n<li><p><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome\">《Elastic-Job-Lite 源码解析》</a></p>\n</li>\n<li><p><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome\">《Elastic-Job-Cloud 源码解析》</a></p>\n</li>\n</ul>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/top_code/article/details/54615853\">《从零开始实现RPC框架 - RPC原理及实现》</a></p>\n<ul>\n<li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/testcs_dn/article/details/78050590\">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></p>\n</li>\n</ul>\n<h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><ul>\n<li><a href=\"http://dubbo.apache.org/\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/steven520213/p/7606598.html\">dubbo实现原理简单介绍</a></li>\n</ul>\n<p>** SPI **<br>TODO</p>\n<h3 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h3><ul>\n<li><a href=\"http://thrift.apache.org/\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/kesonyk/article/details/50924489\">《Thrift RPC详解》</a><ul>\n<li>支持多语言，通过中间语言定义接口。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p>\n<ul>\n<li><a href=\"https://grpc.io/\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/LBSer/p/4853234.html\">《你应该知道的RPC原理》</a></li>\n</ul>\n<h2 id=\"数据库中间件\"><a href=\"#数据库中间件\" class=\"headerlink\" title=\"数据库中间件\"></a>数据库中间件</h2><h3 id=\"Sharding-Jdbc\"><a href=\"#Sharding-Jdbc\" class=\"headerlink\" title=\"Sharding Jdbc\"></a>Sharding Jdbc</h3><ul>\n<li><a href=\"http://shardingjdbc.io/\">官网</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/Sharding-JDBC/?vip&architect-awesome\">源码解析</a></li>\n</ul>\n<h2 id=\"日志系统\"><a href=\"#日志系统\" class=\"headerlink\" title=\"日志系统\"></a>日志系统</h2><h3 id=\"日志搜集\"><a href=\"#日志搜集\" class=\"headerlink\" title=\"日志搜集\"></a>日志搜集</h3><ul>\n<li><a href=\"http://cjting.me/misc/build-log-system-with-elkb/\">《从零开始搭建一个ELKB日志收集系统》</a></li>\n<li><a href=\"https://blog.csdn.net/lzw_2006/article/details/51280058\">《用ELK搭建简单的日志收集分析系统》</a></li>\n<li><a href=\"https://www.cnblogs.com/beginmind/p/6058194.html\">《日志收集系统-探究》</a></li>\n</ul>\n<h2 id=\"配置中心\"><a href=\"#配置中心\" class=\"headerlink\" title=\"配置中心\"></a>配置中心</h2><ul>\n<li><p><a href=\"https://github.com/ctripcorp/apollo\">Apollo - 携程开源的配置中心应用</a></p>\n<ul>\n<li>Spring Boot 和 Spring Cloud</li>\n<li>支持推、拉模式更新配置</li>\n<li>支持多种语言 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011320740/article/details/78742625\">《基于zookeeper实现统一配置管理》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/shamo89/p/8016908.html\">《 Spring Cloud Config 分布式配置中心使用教程》</a></p>\n</li>\n</ul>\n<p>servlet 3.0 异步特性可用于配置中心的客户端</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/dogdogwang/p/7151866.html\">《servlet3.0 新特性——异步处理》</a></li>\n</ul>\n<h2 id=\"API-网关\"><a href=\"#API-网关\" class=\"headerlink\" title=\"API 网关\"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p>\n<ul>\n<li><p><a href=\"http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/\">《API网关那些儿》</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo\">《谈API网关的背景、架构以及落地方案》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhanglh046/article/details/78651993\">《使用Zuul构建API Gateway》</a></p>\n</li>\n<li><p><a href=\"http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome\">《Spring Cloud Gateway 源码解析》</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A\">《HTTP API网关选择之一Kong介绍》</a></p>\n</li>\n</ul>\n<h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><h3 id=\"OSI-七层协议\"><a href=\"#OSI-七层协议\" class=\"headerlink\" title=\"OSI 七层协议\"></a>OSI 七层协议</h3><ul>\n<li><a href=\"https://www.cnblogs.com/Robin-YB/p/6668762.html\">《OSI七层协议模型、TCP/IP四层模型学习笔记》</a></li>\n</ul>\n<h3 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/onepixel/p/7092302.html\">《深入浅出 TCP/IP 协议》</a></li>\n<li><a href=\"https://blog.csdn.net/whuslei/article/details/6667471/\">《TCP协议中的三次握手和四次挥手》</a></li>\n</ul>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wangning528/p/6388464.html\">《http协议详解(超详细)》</a></li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li><a href=\"https://blog.csdn.net/zhuyiquan/article/details/69257126\">《HTTP 2.0 原理详细分析》</a></li>\n<li><a href=\"https://blog.csdn.net/u012657197/article/details/77877840\">《HTTP2.0的基本单位为二进制帧》</a><ul>\n<li>利用二进制帧负责传输。</li>\n<li>多路复用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/zhangshitong/p/6478721.html\">《https原理通俗了解》</a></p>\n<ul>\n<li>使用非对称加密协商加密算法</li>\n<li>使用对称加密方式传输数据</li>\n<li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/53213862\">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></p>\n</li>\n</ul>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><ul>\n<li><p><a href=\"http://blog.51cto.com/litaotao/1289790\">《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》</a></p>\n<ul>\n<li>五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li>\n<li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Anker/p/3265058.html\">《select、poll、epoll之间的区别总结》</a></p>\n<ul>\n<li>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li>\n<li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li>\n<li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li>\n<li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li>\n</ul>\n</li>\n<li><p><a href=\"http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/\">《select，poll，epoll比较  》</a></p>\n<ul>\n<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/geason/p/5774096.html\">《深入理解Java NIO》</a></p>\n<ul>\n<li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/skiof007/article/details/52873421\">《BIO与NIO、AIO的区别》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u013074465/article/details/46276967\">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></p>\n</li>\n</ul>\n<h3 id=\"Epoll\"><a href=\"#Epoll\" class=\"headerlink\" title=\"Epoll\"></a>Epoll</h3><ul>\n<li><a href=\"https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html\">《epoll使用详解（精髓）》</a></li>\n</ul>\n<h3 id=\"Java-NIO\"><a href=\"#Java-NIO\" class=\"headerlink\" title=\"Java NIO\"></a>Java NIO</h3><ul>\n<li><a href=\"https://www.cnblogs.com/geason/p/5774096.html\">《深入理解Java NIO》</a></li>\n<li><a href=\"https://blog.csdn.net/xidianliuy/article/details/51612676\">《Java NIO编写Socket服务器的一个例子》</a></li>\n</ul>\n<h3 id=\"kqueue\"><a href=\"#kqueue\" class=\"headerlink\" title=\"kqueue\"></a>kqueue</h3><ul>\n<li><a href=\"http://www.cnblogs.com/luminocean/p/5631336.html\">《kqueue用法简介》</a></li>\n</ul>\n<h2 id=\"连接和短连接\"><a href=\"#连接和短连接\" class=\"headerlink\" title=\"连接和短连接\"></a>连接和短连接</h2><ul>\n<li><a href=\"https://www.cnblogs.com/pangguoping/p/5571422.html\">《TCP/IP系列——长连接与短连接的区别》</a></li>\n</ul>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><ul>\n<li><a href=\"https://blog.csdn.net/excellentyuxiao/article/details/53390408\">《Netty原理剖析》</a><ul>\n<li>Reactor 模式介绍。</li>\n<li>Netty 是 Reactor 模式的一种实现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"零拷贝（Zero-copy）\"><a href=\"#零拷贝（Zero-copy）\" class=\"headerlink\" title=\"零拷贝（Zero-copy）\"></a>零拷贝（Zero-copy）</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\">《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》</a><ul>\n<li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"序列化-二进制协议\"><a href=\"#序列化-二进制协议\" class=\"headerlink\" title=\"序列化(二进制协议)\"></a>序列化(二进制协议)</h2><h3 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyday56/p/4268249.html\">《Hessian原理分析》</a><br>Binary-RPC;不仅仅是序列化</li>\n</ul>\n<h3 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/antgan/article/details/52103966\">《Protobuf协议的Java应用例子》</a><br>Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。</p>\n</li>\n<li><p><a href=\"https://worktile.com/tech/share/prototol-buffers\">《Protocol Buffers序列化协议及应用》</a></p>\n<pre><code>* 关于协议的解释；缺点：可读性差;</code></pre></li>\n<li><p><a href=\"https://blog.csdn.net/eric520zenobia/article/details/53766571\">《简单的使用 protobuf 和 protostuff》</a></p>\n<ul>\n<li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"基础理论\"><a href=\"#基础理论\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h2><h3 id=\"关系数据库设计的三大范式\"><a href=\"#关系数据库设计的三大范式\" class=\"headerlink\" title=\"关系数据库设计的三大范式\"></a>关系数据库设计的三大范式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/waj6511988/p/7027127.html\">《数据库的三大范式以及五大约束》</a><ul>\n<li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li>\n<li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>\n<li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/voidccc/article/details/40077329\">《MySQL的InnoDB索引原理详解》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xifeijian/article/details/20316775\">《MySQL存储引擎－－MyISAM与InnoDB区别》</a></p>\n<ul>\n<li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201211/172380.html\">《myisam和innodb索引实现的不同》</a></p>\n</li>\n</ul>\n<h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><ul>\n<li><a href=\"https://my.oschina.net/kailuncen/blog/1504217\">《一篇文章带你读懂Mysql和InnoDB》</a></li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><ul>\n<li><p><a href=\"http://vdisk.weibo.com/s/muWOT\">《MySQL36条军规》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhouyusheng/p/8038224.html\">《MYSQL性能优化的最佳20+条经验》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/when_less_is_more/article/details/70187459\">《SQL优化之道》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/sivkun/p/7518540.html\">《mysql数据库死锁的产生原因及解决办法》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/monkey_d_feilong/article/details/52291556\">《导致索引失效的可能情况》</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/0a7e3055a01f\">《 MYSQL分页limit速度太慢优化方法》</a></p>\n<ul>\n<li>原则上就是缩小扫描范围。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"聚集索引-非聚集索引\"><a href=\"#聚集索引-非聚集索引\" class=\"headerlink\" title=\"聚集索引, 非聚集索引\"></a>聚集索引, 非聚集索引</h4><ul>\n<li><a href=\"https://blog.csdn.net/no_endless/article/details/77073549\">《MySQL 聚集索引/非聚集索引简述》</a></li>\n<li><a href=\"https://www.cnblogs.com/zlcxbb/p/5757245.html\">《MyISAM和InnoDB的索引实现》</a></li>\n</ul>\n<p>MyISAM 是非聚集，InnoDB 是聚集</p>\n<h4 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/summer0space/p/7247778.html\">《复合索引的优点和注意事项》</a></p>\n<ul>\n<li>文中有一处错误：<blockquote>\n<p>对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引</p>\n</blockquote>\n</li>\n<li>原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/acode/p/7489258.html\">《MySQL查询where条件的顺序对查询效率的影响》</a></p>\n</li>\n</ul>\n<h4 id=\"自适应哈希索引-AHI\"><a href=\"#自适应哈希索引-AHI\" class=\"headerlink\" title=\"自适应哈希索引(AHI)\"></a>自适应哈希索引(AHI)</h4><ul>\n<li><a href=\"https://blog.csdn.net/Linux_ever/article/details/62043708\">《InnoDB存储引擎——自适应哈希索引》</a></li>\n</ul>\n<h3 id=\"explain\"><a href=\"#explain\" class=\"headerlink\" title=\"explain\"></a>explain</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008131735\">《MySQL 性能优化神器 Explain 使用分析》</a></li>\n</ul>\n<h2 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h2><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><ul>\n<li><a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\">MongoDB 教程</a></li>\n<li><a href=\"http://mxdxm.iteye.com/blog/2093603\">《Mongodb相对于关系型数据库的优缺点》</a><ul>\n<li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li>\n<li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hbase\"><a href=\"#Hbase\" class=\"headerlink\" title=\"Hbase\"></a>Hbase</h3><ul>\n<li><a href=\"http://www.thebigdata.cn/HBase/35831.html\">《简明 HBase 入门教程（开篇）》</a></li>\n<li><a href=\"https://www.cnblogs.com/qiaoyihang/p/6246424.html\">《深入学习HBase架构原理》</a></li>\n<li><a href=\"https://blog.csdn.net/youzhouliu/article/details/67632882\">《传统的行存储和（HBase）列存储的区别》</a></li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/lifuxiangcaohui/article/details/39891099\">《Hbase与传统数据库的区别》</a></p>\n<ul>\n<li>空数据不存储，节省空间，且适用于并发。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014091123/article/details/73163088\">《HBase Rowkey设计》</a></p>\n<ul>\n<li>rowkey 按照字典顺序排列，便于批量扫描。</li>\n<li>通过散列可以避免热点。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"搜索引擎\"><a href=\"#搜索引擎\" class=\"headerlink\" title=\"搜索引擎\"></a>搜索引擎</h1><h2 id=\"搜索引擎原理\"><a href=\"#搜索引擎原理\" class=\"headerlink\" title=\"搜索引擎原理\"></a>搜索引擎原理</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/0193dc44135b\">《倒排索引–搜索引擎入门》</a></li>\n</ul>\n<h2 id=\"Lucene\"><a href=\"#Lucene\" class=\"headerlink\" title=\"Lucene\"></a>Lucene</h2><ul>\n<li><a href=\"https://www.cnblogs.com/rodge-run/p/6551152.html\">《Lucene入门简介》</a></li>\n</ul>\n<h2 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h2><ul>\n<li><a href=\"https://blog.csdn.net/laoyang360/article/details/52244917\">《Elasticsearch学习，请先看这一篇！》</a></li>\n<li><a href=\"https://blog.csdn.net/cyony/article/details/65437708\">《Elasticsearch索引原理》</a></li>\n</ul>\n<h2 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h2><ul>\n<li><a href=\"https://blog.csdn.net/u011936655/article/details/51960005\">《 Apache Solr入门教程》</a></li>\n<li><a href=\"https://blog.csdn.net/convict_eva/article/details/53537837\">《elasticsearch与solr比较》</a></li>\n</ul>\n<h2 id=\"sphinx\"><a href=\"#sphinx\" class=\"headerlink\" title=\"sphinx\"></a>sphinx</h2><ul>\n<li><a href=\"http://blog.jobbole.com/101672/\">《Sphinx 的介绍和原理探索》</a></li>\n</ul>\n<h1 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h1><h2 id=\"性能优化方法论\"><a href=\"#性能优化方法论\" class=\"headerlink\" title=\"性能优化方法论\"></a>性能优化方法论</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread\">《15天的性能优化工作，5方面的调优经验》</a></p>\n<ul>\n<li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/tenglizhe/article/details/44563135\">《系统性能优化的几个方面》</a></p>\n</li>\n</ul>\n<h2 id=\"容量评估\"><a href=\"#容量评估\" class=\"headerlink\" title=\"容量评估\"></a>容量评估</h2><ul>\n<li><a href=\"https://blog.csdn.net/u012528360/article/details/70054156\">《联网性能与容量评估的方法论和典型案例》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect\">《互联网架构，如何进行容量设计？》</a><ul>\n<li>评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CDN-网络\"><a href=\"#CDN-网络\" class=\"headerlink\" title=\"CDN 网络\"></a>CDN 网络</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wxiaona/p/5867685.html\">《CDN加速原理》</a></li>\n<li><a href=\"https://www.zhihu.com/question/20536932\">《国内有哪些比较好的 CDN？》</a></li>\n</ul>\n<h2 id=\"连接池\"><a href=\"#连接池\" class=\"headerlink\" title=\"连接池\"></a>连接池</h2><ul>\n<li><a href=\"https://blog.csdn.net/fysuccess/article/details/66972554\">《主流Java数据库连接池比较与开发配置实战》</a></li>\n</ul>\n<h2 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h2><ul>\n<li><a href=\"https://blog.csdn.net/yethyeth/article/details/73266455\">《九大Java性能调试工具，必备至少一款》</a></li>\n</ul>\n<h1 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h1><h2 id=\"流式计算\"><a href=\"#流式计算\" class=\"headerlink\" title=\"流式计算\"></a>流式计算</h2><h3 id=\"Storm\"><a href=\"#Storm\" class=\"headerlink\" title=\"Storm\"></a>Storm</h3><ul>\n<li><a href=\"http://storm.apache.org/\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/uisoul/article/details/77989927\">《最详细的Storm入门教程》</a></li>\n</ul>\n<h3 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h3><ul>\n<li><a href=\"https://blog.csdn.net/lisi1129/article/details/54844919\">《Flink之一 Flink基本原理介绍》</a></li>\n</ul>\n<h3 id=\"Kafka-Stream\"><a href=\"#Kafka-Stream\" class=\"headerlink\" title=\"Kafka Stream\"></a>Kafka Stream</h3><ul>\n<li><a href=\"https://yq.aliyun.com/articles/58382\">《Kafka Stream调研：一种轻量级流计算模式》</a></li>\n</ul>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>例如：</p>\n<ul>\n<li>广告相关实时统计；</li>\n<li>推荐系统用户画像标签实时更新；</li>\n<li>线上服务健康状况实时监测；</li>\n<li>实时榜单；</li>\n<li>实时数据统计。</li>\n</ul>\n<h2 id=\"Hadoop\"><a href=\"#Hadoop\" class=\"headerlink\" title=\"Hadoop\"></a>Hadoop</h2><ul>\n<li><a href=\"https://blog.csdn.net/houbin0912/article/details/72967178\">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li>\n<li><a href=\"http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html\">《史上最详细的Hadoop环境搭建》</a></li>\n</ul>\n<h3 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000011575458\">《【Hadoop学习】HDFS基本原理》</a></li>\n</ul>\n<h3 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h3><ul>\n<li><a href=\"https://blog.csdn.net/oppo62258801/article/details/72884633\">《用通俗易懂的大白话讲解Map/Reduce原理》</a></li>\n<li><a href=\"https://blog.csdn.net/foye12/article/details/78358292\">《 简单的map-reduce的java例子》</a></li>\n</ul>\n<h3 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h3><ul>\n<li><a href=\"http://www.cnblogs.com/codeOfLife/p/5492740.html\">《初步掌握Yarn的架构及原理》</a></li>\n</ul>\n<h2 id=\"Spark\"><a href=\"#Spark\" class=\"headerlink\" title=\"Spark\"></a>Spark</h2><ul>\n<li><a href=\"http://www.cnblogs.com/tgzhu/p/5818374.html\">《Spark(一): 基本架构及原理》</a></li>\n<li><a href=\"http://dblab.xmu.edu.cn/blog/1709-2/\">《子雨大数据之Spark入门教程(Python版)》</a></li>\n</ul>\n<h1 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h1><h2 id=\"web-安全\"><a href=\"#web-安全\" class=\"headerlink\" title=\"web 安全\"></a>web 安全</h2><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><ul>\n<li><a href=\"https://blog.csdn.net/qq_21956483/article/details/54377947\">《xss攻击原理与解决方法》</a><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html\">《CSRF原理及防范》</a></li>\n</ul>\n<h3 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html\">《SQL注入》</a></li>\n</ul>\n<h3 id=\"Hash-Dos\"><a href=\"#Hash-Dos\" class=\"headerlink\" title=\"Hash Dos\"></a>Hash Dos</h3><ul>\n<li><a href=\"http://www.freebuf.com/articles/web/14199.html\">《邪恶的JAVA HASH DOS攻击》</a><ul>\n<li>利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li>\n</ul>\n</li>\n<li><a href=\"http://blog.it2048.cn/article_hash-collision.html\">《一种高级的DoS攻击-Hash碰撞攻击》</a></li>\n<li><a href=\"http://www.iteye.com/news/23939/\">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li>\n</ul>\n<h3 id=\"脚本注入\"><a href=\"#脚本注入\" class=\"headerlink\" title=\"脚本注入\"></a>脚本注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html\">《上传文件漏洞原理及防范》</a></li>\n</ul>\n<h3 id=\"漏洞扫描工具\"><a href=\"#漏洞扫描工具\" class=\"headerlink\" title=\"漏洞扫描工具\"></a>漏洞扫描工具</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html\">《DVWA》</a></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html\">W3af</a></li>\n<li><a href=\"https://blog.csdn.net/xygg0801/article/details/53610640\">OpenVAS详解</a></li>\n</ul>\n<h3 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/niaonao/article/details/51112686\">《验证码原理分析及实现》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/jiangbianwanghai/blog/1031031\">《详解滑动验证码的实现原理》</a></p>\n<ul>\n<li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/xcj26/p/5242758.html\">《淘宝滑动验证码研究》</a></p>\n</li>\n</ul>\n<h2 id=\"DDoS-防范\"><a href=\"#DDoS-防范\" class=\"headerlink\" title=\"DDoS 防范\"></a>DDoS 防范</h2><ul>\n<li><a href=\"http://netsecurity.51cto.com/art/201601/503799.htm\">《学习手册：DDoS的攻击方式及防御手段》</a></li>\n<li><a href=\"http://netsecurity.51cto.com/art/201406/442756.htm\">《免费DDoS攻击测试工具大合集》</a></li>\n</ul>\n<h2 id=\"用户隐私信息保护\"><a href=\"#用户隐私信息保护\" class=\"headerlink\" title=\"用户隐私信息保护\"></a>用户隐私信息保护</h2><ol>\n<li>用户密码非明文保存，加动态salt。</li>\n<li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li>\n<li>联系方式在的显示与否由用户自己控制。</li>\n<li>TODO</li>\n</ol>\n<ul>\n<li><p><a href=\"https://zhidao.baidu.com/question/1988017976673661587.html\">《个人隐私包括哪些》</a></p>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/20137108\">《在互联网上，隐私的范围包括哪些？》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html\">《用户密码保存》</a></p>\n</li>\n</ul>\n<h2 id=\"序列化漏洞\"><a href=\"#序列化漏洞\" class=\"headerlink\" title=\"序列化漏洞\"></a>序列化漏洞</h2><ul>\n<li><a href=\"https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/\">《Lib之过？Java反序列化漏洞通用利用分析》</a></li>\n</ul>\n<h2 id=\"加密解密\"><a href=\"#加密解密\" class=\"headerlink\" title=\"加密解密\"></a>加密解密</h2><h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html\">《常见对称加密算法》</a><ul>\n<li>DES、3DES、Blowfish、AES</li>\n<li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li>\n<li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html\">《常用的哈希算法》</a></p>\n<ul>\n<li>MD5 和 SHA-1 已经不再安全，已被弃用。</li>\n<li>目前 SHA-256 是比较安全的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhangruhong168/article/details/78033202\">《基于Hash摘要签名的公网URL签名验证设计方案》</a></p>\n</li>\n</ul>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html\">《常见非对称加密算法》</a></p>\n<ul>\n<li><p>RSA、DSA、ECDSA(螺旋曲线加密算法)</p>\n</li>\n<li><p>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</p>\n</li>\n<li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p>\n<p>  <a href=\"http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc\">《区块链的加密技术》</a>    </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务器安全\"><a href=\"#服务器安全\" class=\"headerlink\" title=\"服务器安全\"></a>服务器安全</h2><ul>\n<li><a href=\"http://www.freebuf.com/articles/system/121540.html\">《Linux强化论：15步打造一个安全的Linux服务器》</a></li>\n</ul>\n<h2 id=\"数据安全\"><a href=\"#数据安全\" class=\"headerlink\" title=\"数据安全\"></a>数据安全</h2><h3 id=\"数据备份\"><a href=\"#数据备份\" class=\"headerlink\" title=\"数据备份\"></a>数据备份</h3><p>TODO</p>\n<h2 id=\"网络隔离\"><a href=\"#网络隔离\" class=\"headerlink\" title=\"网络隔离\"></a>网络隔离</h2><h3 id=\"内外网分离\"><a href=\"#内外网分离\" class=\"headerlink\" title=\"内外网分离\"></a>内外网分离</h3><p>TODO</p>\n<h3 id=\"登录跳板机\"><a href=\"#登录跳板机\" class=\"headerlink\" title=\"登录跳板机\"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p>\n<ul>\n<li><a href=\"http://blog.51cto.com/zero01/2062618\">《搭建简易堡垒机》</a></li>\n</ul>\n<h2 id=\"授权、认证\"><a href=\"#授权、认证\" class=\"headerlink\" title=\"授权、认证\"></a>授权、认证</h2><ul>\n<li><a href=\"https://docs.authing.cn/authing/\">授权认证知识库</a></li>\n</ul>\n<h3 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h3><ul>\n<li><a href=\"https://www.cnblogs.com/zq8024/p/5003050.html\">《基于组织角色的权限设计》</a></li>\n<li><a href=\"https://www.cnblogs.com/shijiaqi1066/p/3793894.html\">《权限系统与RBAC模型概述》</a></li>\n<li><a href=\"https://blog.csdn.net/he90227/article/details/38663553\">《Spring整合Shiro做权限控制模块详细案例分析》</a></li>\n</ul>\n<h3 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">《理解OAuth 2.0》</a></li>\n<li><a href=\"https://www.cnblogs.com/flashsun/p/7424071.html\">《一张图搞定OAuth2.0》</a></li>\n</ul>\n<h3 id=\"OIDC\"><a href=\"#OIDC\" class=\"headerlink\" title=\"OIDC\"></a>OIDC</h3><ul>\n<li><a href=\"https://docs.authing.cn/authing/advanced/oidc/li-jie-oidc-liu-cheng\">理解 OIDC</a></li>\n</ul>\n<h3 id=\"SAML\"><a href=\"#SAML\" class=\"headerlink\" title=\"SAML\"></a>SAML</h3><ul>\n<li><a href=\"https://docs.authing.cn/authing/advanced/use-saml/li-jie-saml-liu-cheng\">理解 SAML</a></li>\n</ul>\n<h3 id=\"双因素认证（2FA）\"><a href=\"#双因素认证（2FA）\" class=\"headerlink\" title=\"双因素认证（2FA）\"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p>\n<p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p>\n<ul>\n<li>【《双因素认证（2FA）教程》】(<a href=\"http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html\">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a>)</li>\n</ul>\n<h3 id=\"单点登录-SSO\"><a href=\"#单点登录-SSO\" class=\"headerlink\" title=\"单点登录(SSO)\"></a>单点登录(SSO)</h3><ul>\n<li><a href=\"https://www.cnblogs.com/ywlaker/p/6113927.html\">《单点登录原理与简单实现》</a></li>\n<li><a href=\"https://github.com/apereo/cas\">CAS单点登录框架</a></li>\n<li><a href=\"https://docs.authing.cn/authing/quickstart/implement-sso-with-authing\">使用 Authing 实现单点登录</a></li>\n</ul>\n<h1 id=\"常用开源框架\"><a href=\"#常用开源框架\" class=\"headerlink\" title=\"常用开源框架\"></a>常用开源框架</h1><h2 id=\"开源协议\"><a href=\"#开源协议\" class=\"headerlink\" title=\"开源协议\"></a>开源协议</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html\">《开源协议的选择》</a></p>\n</li>\n<li><p><a href=\"http://choosealicense.online/\">如何选择一个开源软件协议</a></p>\n</li>\n</ul>\n<h2 id=\"日志框架\"><a href=\"#日志框架\" class=\"headerlink\" title=\"日志框架\"></a>日志框架</h2><h3 id=\"Log4j、Log4j2\"><a href=\"#Log4j、Log4j2\" class=\"headerlink\" title=\"Log4j、Log4j2\"></a>Log4j、Log4j2</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012422446/article/details/51199724\">《log4j 详细讲解》</a></li>\n<li><a href=\"https://blog.csdn.net/vbirdbest/article/details/71751835\">《log4j2 实际使用详解》</a></li>\n<li><a href=\"https://my.oschina.net/OutOfMemory/blog/789267\">《Log4j1,Logback以及Log4j2性能测试对比》</a><ul>\n<li>Log4J 异步日志性能优异。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Logback\"><a href=\"#Logback\" class=\"headerlink\" title=\"Logback\"></a>Logback</h3><ul>\n<li><a href=\"https://blog.csdn.net/rulon147/article/details/52620541\">《最全LogBack 详解、含java案例和配置说明》</a></li>\n</ul>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><ul>\n<li><a href=\"https://blog.csdn.net/sinat_34093604/article/details/53082000\">《ORM框架使用优缺点》</a><ul>\n<li>主要目的是为了提高开发效率。 </li>\n</ul>\n</li>\n</ul>\n<p><strong>MyBatis：</strong></p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/winclpt/articles/7511672.html\">《mybatis缓存机制详解》</a></p>\n<ul>\n<li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li>\n<li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/baidu_32877851/article/details/53959268\">《MyBatis学习之代码生成器Generator》</a></p>\n</li>\n</ul>\n<h2 id=\"网络框架\"><a href=\"#网络框架\" class=\"headerlink\" title=\"网络框架\"></a>网络框架</h2><p>TODO</p>\n<h2 id=\"Web-框架\"><a href=\"#Web-框架\" class=\"headerlink\" title=\"Web 框架\"></a>Web 框架</h2><h3 id=\"Spring-家族\"><a href=\"#Spring-家族\" class=\"headerlink\" title=\"Spring 家族\"></a>Spring 家族</h3><p><strong>Spring</strong></p>\n<ul>\n<li><a href=\"https://www.w3cschool.cn/wkspring/\">Spring 简明教程</a></li>\n</ul>\n<p><strong>Spring Boot</strong></p>\n<ul>\n<li><a href=\"http://projects.spring.io/spring-boot/\">官方网站</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\">《Spring Boot基础教程》</a></li>\n</ul>\n<p><strong>Spring Cloud</strong></p>\n<ul>\n<li><a href=\"http://springboot.fun/\">Spring Boot 中文索引站</a></li>\n<li><a href=\"https://springcloud.cc/\">Spring Cloud 中文文档</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\">《Spring Cloud基础教程》</a></li>\n</ul>\n<h2 id=\"工具框架\"><a href=\"#工具框架\" class=\"headerlink\" title=\"工具框架\"></a>工具框架</h2><ul>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4872236.html\">《Apache Commons 工具类介绍及简单使用》</a></li>\n<li><a href=\"http://ifeve.com/google-guava/\">《Google guava 中文教程》</a></li>\n</ul>\n<h1 id=\"分布式设计\"><a href=\"#分布式设计\" class=\"headerlink\" title=\"分布式设计\"></a>分布式设计</h1><h2 id=\"扩展性设计\"><a href=\"#扩展性设计\" class=\"headerlink\" title=\"扩展性设计\"></a>扩展性设计</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/hemin1003/article/details/53633926\">《架构师不可不知的十大可扩展架构》</a></p>\n<ul>\n<li>总结下来，通用的套路就是分布、缓存及异步处理。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://yq.aliyun.com/articles/38119\">《可扩展性设计之数据切分》</a></p>\n<ul>\n<li>水平切分+垂直切分</li>\n<li>利用中间件进行分片如，MySQL Proxy。</li>\n<li>利用分片策略进行切分，如按照ID取模。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/deniro_li/article/details/78458306\">《说说如何实现可扩展性的大型网站架构》</a></p>\n<ul>\n<li>分布式服务+消息队列。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chaofanwei/article/details/29191073\">《大型网站技术架构（七）–网站的可扩展性架构》</a></p>\n</li>\n</ul>\n<h2 id=\"稳定性-amp-高可用\"><a href=\"#稳定性-amp-高可用\" class=\"headerlink\" title=\"稳定性 &amp; 高可用\"></a>稳定性 &amp; 高可用</h2><ul>\n<li><a href=\"https://blog.csdn.net/hustspy1990/article/details/78008324\">《系统设计：关于高可用系统的一些技术方案》</a><ul>\n<li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li>\n<li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li>\n<li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li>\n<li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li>\n<li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li>\n<li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li>\n<li>自动化测试：通过完善的测试，减少发布引起的故障。</li>\n<li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><a href=\"https://coolshell.cn/articles/17459.html\">《关于高可用的系统》</a><ul>\n<li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"硬件负载均衡\"><a href=\"#硬件负载均衡\" class=\"headerlink\" title=\"硬件负载均衡\"></a>硬件负载均衡</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/wuyun-blog/p/6186198.html\">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a></p>\n<ul>\n<li>主要是和F5对比。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lcword/p/5773296.html\">《软/硬件负载均衡产品 你知多少？》</a></p>\n</li>\n</ul>\n<h3 id=\"软件负载均衡\"><a href=\"#软件负载均衡\" class=\"headerlink\" title=\"软件负载均衡\"></a>软件负载均衡</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/tianzhiliang/articles/2317808.html\">《几种负载均衡算法》</a><br>  轮寻、权重、负载、最少连接、QoS</p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html\">《DNS负载均衡》</a></p>\n<ul>\n<li>配置简单，更新速度慢。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html\">《Nginx负载均衡》</a></p>\n<ul>\n<li>简单轻量、学习成本低；主要适用于web应用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/edisonchou/p/4281978.html\">《借助LVS+Keepalived实现负载均衡 》</a></p>\n<ul>\n<li>配置比较负载、只支持到4层，性能较高。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ttlsa.com/linux/haproxy-study-tutorial/\">《HAProxy用法详解 全网最详细中文文档》</a></p>\n<ul>\n<li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.itpub.net/25704976/viewspace-1319781/\">《Haproxy+Keepalived+MySQL实现读均衡负载》</a></p>\n<ul>\n<li>主要是用户读请求的负载均衡。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lylife/p/5584019.html\">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></p>\n</li>\n</ul>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><ul>\n<li><a href=\"https://www.cnblogs.com/haoxinyue/p/6792309.html\">《谈谈高并发系统的限流》</a><ul>\n<li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li>\n<li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li>\n<li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li>\n<li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层容灾\"><a href=\"#应用层容灾\" class=\"headerlink\" title=\"应用层容灾\"></a>应用层容灾</h3><ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000005988895\">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a></p>\n<ul>\n<li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 </li>\n<li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li>\n<li>Hystrix设计原则：<ul>\n<li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li>\n<li>熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。</li>\n<li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\">《缓存击穿、失效以及热点key问题》</a> </p>\n<ul>\n<li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li>\n<li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"跨机房容灾\"><a href=\"#跨机房容灾\" class=\"headerlink\" title=\"跨机房容灾\"></a>跨机房容灾</h3><ul>\n<li><p><a href=\"http://dc.idcquan.com/ywgl/71559.shtml\">《“异地多活”多机房部署经验谈》</a></p>\n<ul>\n<li>通过自研中间件进行数据同步。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/jeffreynicole/article/details/48135093\">《异地多活（异地双活）实践经验》</a></p>\n<ul>\n<li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li>\n<li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li>\n<li>不能依赖于程序端数据双写，要有自动同步方案。 </li>\n<li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li>\n<li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li>\n<li>异地多活监控部署、测试也要跟上。</li>\n<li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li>\n<li>控制跨机房消息体大小，越小越好。</li>\n<li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yoara/article/details/38013751\">容灾技术及建设经验介绍</a></p>\n</li>\n</ul>\n<h3 id=\"容灾演练流程\"><a href=\"#容灾演练流程\" class=\"headerlink\" title=\"容灾演练流程\"></a>容灾演练流程</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5\">《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》</a><ul>\n<li>常见故障画像</li>\n<li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平滑启动\"><a href=\"#平滑启动\" class=\"headerlink\" title=\"平滑启动\"></a>平滑启动</h3><ul>\n<li>平滑重启应用思路</li>\n</ul>\n<p>1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/u011001084/article/details/73480432\">《JVM安全退出（如何优雅的关闭java服务）》</a><br>推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</li>\n<li><a href=\"http://ju.outofmemory.cn/entry/337235\">《常见Java应用如何优雅关闭》</a><br>Java、Spring、Dubbo 优雅关闭方式。</li>\n</ul>\n<h2 id=\"数据库扩展\"><a href=\"#数据库扩展\" class=\"headerlink\" title=\"数据库扩展\"></a>数据库扩展</h2><h3 id=\"读写分离模式\"><a href=\"#读写分离模式\" class=\"headerlink\" title=\"读写分离模式\"></a>读写分离模式</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/houdj/p/6563771.html\">《Mysql主从方案的实现》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/edisonchou/p/4133148.html\">《搭建MySQL主从复制经典架构》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/nimasike/article/details/48048341\">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhangsubai/p/6801764.html\">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a></p>\n<ul>\n<li>DRDB 进行磁盘复制，避免单点问题。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html\">《MySQL Cluster 方式》</a></p>\n</li>\n</ul>\n<h3 id=\"分片模式\"><a href=\"#分片模式\" class=\"headerlink\" title=\"分片模式\"></a>分片模式</h3><ul>\n<li><p><a href=\"https://www.jianshu.com/p/32b3e91aa22c\">《分库分表需要考虑的问题及方案》</a></p>\n<ul>\n<li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li>\n<li>问题：事务、Join、迁移、扩容、ID、分页等。</li>\n<li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li>\n<li>分库策略：数值范围；取模；日期等。</li>\n<li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201503/380348.html\">《MySql分表和表分区详解》</a></p>\n<ul>\n<li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li>\n<li>分表：物理上创建不同的表、客户端需要管理分表路由。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h2><h3 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/jiaolongdy/article/details/51188798\">《永不失联！如何实现微服务架构中的服务发现？》</a></p>\n<ul>\n<li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li>\n<li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u010963948/article/details/71730165\">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a></p>\n<ul>\n<li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li>\n<li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://mobile.51cto.com/news-502394.htm\">《基于Zookeeper的服务注册与发现》</a></p>\n<ul>\n<li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务路由控制\"><a href=\"#服务路由控制\" class=\"headerlink\" title=\"服务路由控制\"></a>服务路由控制</h3><ul>\n<li><a href=\"https://blog.csdn.net/xundh/article/details/59492750\">《分布式服务框架学习笔记4 服务路由》</a><ul>\n<li>原则：透明化路由</li>\n<li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li>\n<li>本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li>\n<li>配置方式：统一注册表；本地配置；动态下发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式一致\"><a href=\"#分布式一致\" class=\"headerlink\" title=\"分布式一致\"></a>分布式一致</h2><h3 id=\"CAP-与-BASE-理论\"><a href=\"#CAP-与-BASE-理论\" class=\"headerlink\" title=\"CAP 与 BASE 理论\"></a>CAP 与 BASE 理论</h3><ul>\n<li><a href=\"http://www.cnblogs.com/szlbm/p/5588543.html\">《从分布式一致性谈到CAP理论、BASE理论》</a><ul>\n<li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li>\n<li>CAP：一致性、可用性、分区容错性(网络故障引起)</li>\n<li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li>\n<li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><p><a href=\"http://www.hollischuang.com/archives/1716\">《分布式锁的几种实现方式》</a></p>\n<ul>\n<li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li>\n<li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li>\n<li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.tuicool.com/articles/VZJr6fY\">《基于Zookeeper的分布式锁》</a></p>\n<ul>\n<li>清楚的原理描述 + Java 代码示例。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/0201zcr/p/5942748.html\">《jedisLock—redis分布式锁实现》</a></p>\n<ul>\n<li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/albertfly/article/details/77412333\">《Memcached 和 Redis 分布式锁方案》</a></p>\n<ul>\n<li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致性算法\"><a href=\"#分布式一致性算法\" class=\"headerlink\" title=\"分布式一致性算法\"></a>分布式一致性算法</h3><h4 id=\"PAXOS\"><a href=\"#PAXOS\" class=\"headerlink\" title=\"PAXOS\"></a>PAXOS</h4><ul>\n<li><a href=\"https://www.cnblogs.com/linbingdong/p/6253479.html\">《分布式系列文章——Paxos算法原理与推导》</a></li>\n<li><a href=\"https://blog.csdn.net/u010039929/article/details/70171672\">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li>\n<li><a href=\"https://www.cnblogs.com/leesf456/p/6012777.html\">《【分布式】Zookeeper与Paxos》</a></li>\n</ul>\n<h4 id=\"Zab\"><a href=\"#Zab\" class=\"headerlink\" title=\"Zab\"></a>Zab</h4><ul>\n<li><a href=\"https://www.jianshu.com/p/fb527a64deee\">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li>\n</ul>\n<h4 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h4><ul>\n<li><a href=\"http://www.cnblogs.com/mindwind/p/5231986.html\">《Raft 为什么是更易理解的分布式一致性算法》</a><ul>\n<li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li>\n<li>通过随机等待的方式发出投票，得票多的获胜。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Gossip\"><a href=\"#Gossip\" class=\"headerlink\" title=\"Gossip\"></a>Gossip</h4><ul>\n<li><a href=\"http://blog.51cto.com/tianya23/530743\">《Gossip算法》</a></li>\n</ul>\n<h4 id=\"两阶段提交、多阶段提交\"><a href=\"#两阶段提交、多阶段提交\" class=\"headerlink\" title=\"两阶段提交、多阶段提交\"></a>两阶段提交、多阶段提交</h4><ul>\n<li><a href=\"http://blog.jobbole.com/95632/\">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li>\n</ul>\n<h3 id=\"幂等\"><a href=\"#幂等\" class=\"headerlink\" title=\"幂等\"></a>幂等</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wxgblogs/p/6639272.html\">《分布式系统—幂等性设计》</a><ul>\n<li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li>\n<li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致方案\"><a href=\"#分布式一致方案\" class=\"headerlink\" title=\"分布式一致方案\"></a>分布式一致方案</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency\">《分布式系统事务一致性解决方案》</a></li>\n<li><a href=\"https://weibo.com/ttarticle/p/show?id=2309403965965003062676\">《保证分布式系统数据一致性的6种方案》</a></li>\n</ul>\n<h3 id=\"分布式-Leader-节点选举\"><a href=\"#分布式-Leader-节点选举\" class=\"headerlink\" title=\"分布式 Leader 节点选举\"></a>分布式 Leader 节点选举</h3><ul>\n<li><a href=\"https://blog.csdn.net/johnson_moon/article/details/78809995\">《利用zookeeper实现分布式leader节点选举》</a></li>\n</ul>\n<h3 id=\"TCC-Try-Confirm-Cancel-柔性事务\"><a href=\"#TCC-Try-Confirm-Cancel-柔性事务\" class=\"headerlink\" title=\"TCC(Try/Confirm/Cancel) 柔性事务\"></a>TCC(Try/Confirm/Cancel) 柔性事务</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/ab1a1c6b08a1\">《传统事务与柔性事务》</a><ul>\n<li>基于BASE理论：基本可用、柔性状态、最终一致。</li>\n<li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式文件系统\"><a href=\"#分布式文件系统\" class=\"headerlink\" title=\"分布式文件系统\"></a>分布式文件系统</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27666295\">说说分布式文件存储系统-基本架构</a> ？</li>\n<li><a href=\"https://blog.csdn.net/gatieme/article/details/44982961\">《各种分布式文件系统的比较》</a> ？<ul>\n<li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li>\n<li>FastDFS：轻量级、适合小文件。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"唯一ID-生成\"><a href=\"#唯一ID-生成\" class=\"headerlink\" title=\"唯一ID 生成\"></a>唯一ID 生成</h2><h3 id=\"全局唯一ID\"><a href=\"#全局唯一ID\" class=\"headerlink\" title=\"全局唯一ID\"></a>全局唯一ID</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/baiwa/p/5318432.html\">《高并发分布式系统中生成全局唯一Id汇总》</a></p>\n<ul>\n<li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li>\n<li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” </li>\n<li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li>\n<li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/hdu09075340/article/details/79103851\">《TDDL 在分布式下的SEQUENCE原理》</a></p>\n<ul>\n<li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li>\n<li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li>\n<li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一致性Hash算法\"><a href=\"#一致性Hash算法\" class=\"headerlink\" title=\"一致性Hash算法\"></a>一致性Hash算法</h2><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html\">《一致性哈希算法》</a></li>\n</ul>\n<h1 id=\"设计思想-amp-开发模式\"><a href=\"#设计思想-amp-开发模式\" class=\"headerlink\" title=\"设计思想 &amp; 开发模式\"></a>设计思想 &amp; 开发模式</h1><h2 id=\"DDD-Domain-driven-Design-领域驱动设计\"><a href=\"#DDD-Domain-driven-Design-领域驱动设计\" class=\"headerlink\" title=\"DDD(Domain-driven Design - 领域驱动设计)\"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/netfocus/p/5548025.html\">《浅谈我对DDD领域驱动设计的理解》</a></p>\n<ul>\n<li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li>\n<li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li>\n<li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/butterfly100/p/7827870.html\">《领域驱动设计的基础知识总结》</a></p>\n<ul>\n<li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li>\n<li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li>\n<li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li>\n<li>领域通用语言：领域专家、开发设计人员都能理解的语言或工具。</li>\n<li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li>\n<li>使用的模式：<ul>\n<li>关联尽量少，尽量单项，尽量降低整体复杂度。</li>\n<li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li>\n<li>值对象（Value Object）：没有唯一标识，且属性值不可变，小而简单的对象，比如Date。</li>\n<li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li>\n<li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li>\n<li>工厂（Factory）：类似于设计模式中的工厂模式。</li>\n<li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Leo_wl/p/3866629.html\">《领域驱动设计(DDD)实现之路》</a></p>\n<ul>\n<li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.hollischuang.com/archives/553\">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></p>\n</li>\n</ul>\n<h3 id=\"命令查询职责分离-CQRS\"><a href=\"#命令查询职责分离-CQRS\" class=\"headerlink\" title=\"命令查询职责分离(CQRS)\"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/cnblogsfans/p/4551990.html\">《领域驱动设计系列 (六)：CQRS》</a></p>\n<ul>\n<li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml\">《DDD CQRS架构和传统架构的优缺点比较》</a></p>\n<ul>\n<li>最终一致的设计理念；依赖于高可用消息中间件。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/netfocus/p/4055346.html\">《CQRS架构简介》</a></p>\n<ul>\n<li>一个实现 CQRS 的抽象案例。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.uml.org.cn/zjjs/201609221.asp\">《深度长文：我对CQRS/EventSourcing架构的思考》</a></p>\n<ul>\n<li>CQRS 模式分析 + 12306 抢票案例</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"贫血，充血模型\"><a href=\"#贫血，充血模型\" class=\"headerlink\" title=\"贫血，充血模型\"></a>贫血，充血模型</h3><ul>\n<li><a href=\"https://kb.cnblogs.com/page/520743/\">《贫血，充血模型的解释以及一些经验》</a><ul>\n<li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li>\n<li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li>\n<li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li>\n<li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li>\n<li>作者主张使用贫血模式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Actor-模式\"><a href=\"#Actor-模式\" class=\"headerlink\" title=\"Actor 模式\"></a>Actor 模式</h2><p>TODO</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><h3 id=\"Reactor\"><a href=\"#Reactor\" class=\"headerlink\" title=\"Reactor\"></a>Reactor</h3><p>TODO</p>\n<h3 id=\"RxJava\"><a href=\"#RxJava\" class=\"headerlink\" title=\"RxJava\"></a>RxJava</h3><p>TODO</p>\n<h3 id=\"Vert-x\"><a href=\"#Vert-x\" class=\"headerlink\" title=\"Vert.x\"></a>Vert.x</h3><p>TODO</p>\n<h2 id=\"DODAF2-0\"><a href=\"#DODAF2-0\" class=\"headerlink\" title=\"DODAF2.0\"></a>DODAF2.0</h2><ul>\n<li><a href=\"http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml\">《DODAF2.0方法论》</a></li>\n<li><a href=\"http://blog.51cto.com/xiaoyong/1553164\">《DODAF2.0之能力视角如何落地》</a></li>\n</ul>\n<h2 id=\"Serverless\"><a href=\"#Serverless\" class=\"headerlink\" title=\"Serverless\"></a>Serverless</h2><p>无需过多关系服务器的服务架构理念。</p>\n<ul>\n<li><p><a href=\"http://www.jdon.com/soa/serverless.html\">《什么是Serverless无服务器架构？》</a></p>\n<ul>\n<li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li>\n<li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li>\n<li>Serverless 不代表某个具体的框架。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless\">《如何理解Serverless？》</a></p>\n<ul>\n<li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Service-Mesh\"><a href=\"#Service-Mesh\" class=\"headerlink\" title=\"Service Mesh\"></a>Service Mesh</h2><ul>\n<li><a href=\"https://time.geekbang.org/article/2355\">《什么是Service Mesh？》</a></li>\n<li><a href=\"https://www.jianshu.com/p/e23e3e74538e\">《初识 Service Mesh》</a></li>\n</ul>\n<h1 id=\"项目管理\"><a href=\"#项目管理\" class=\"headerlink\" title=\"项目管理\"></a>项目管理</h1><h2 id=\"架构评审\"><a href=\"#架构评审\" class=\"headerlink\" title=\"架构评审\"></a>架构评审</h2><ul>\n<li><a href=\"http://developer.51cto.com/art/201506/478486.htm\">《架构设计之如何评审架构设计说明书》</a></li>\n<li><a href=\"https://blog.csdn.net/wireless_com/article/details/45935591\">《人人都是架构师：非功能性需求》</a></li>\n</ul>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/architect-12-rules-complete/\">《架构之重构的12条军规》</a></li>\n</ul>\n<h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><ul>\n<li><a href=\"https://github.com/alibaba/p3c\">《阿里巴巴Java开发手册》</a></li>\n</ul>\n<h2 id=\"代码-Review\"><a href=\"#代码-Review\" class=\"headerlink\" title=\"代码 Review\"></a>代码 Review</h2><p>制度还是制度!<br>另外，每个公司需要根据自己的需求和目标制定自己的 check list</p>\n<ul>\n<li><p><a href=\"http://www.sohu.com/a/229745352_181657\">《为什么你做不好 Code Review？》</a></p>\n<ul>\n<li>代码 review 做的好，在于制度建设。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/uxyheaven/article/details/49773619\">《从零开始Code Review》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zuoping/p/5477047.html\">《Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://dzone.com/articles/java-code-review-checklist\">《Java Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/legend0011/article/details/45585575\">《如何用 gitlab 做 code review》</a></p>\n</li>\n</ul>\n<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2><ul>\n<li><a href=\"https://blog.csdn.net/apanious/article/details/51011946\">《运用RUP 4+1视图方法进行软件架构设计》</a></li>\n</ul>\n<h2 id=\"看板管理\"><a href=\"#看板管理\" class=\"headerlink\" title=\"看板管理\"></a>看板管理</h2><ul>\n<li><a href=\"https://blog.csdn.net/tkchen/article/details/51637643\">《说说看板在项目中的应用》</a></li>\n</ul>\n<h2 id=\"SCRUM\"><a href=\"#SCRUM\" class=\"headerlink\" title=\"SCRUM\"></a>SCRUM</h2><p>SCRUM - 争球</p>\n<ul>\n<li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li>\n<li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li>\n<li>五个价值观：专注、勇气、公开、承诺、尊重。</li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/inny100_100/article/details/54633757\">《敏捷项目管理流程-Scrum框架最全总结！》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/superkunkun/article/details/52951142\">《敏捷其实很简单3—敏捷方法之scrum》</a></p>\n</li>\n</ul>\n<h2 id=\"敏捷开发\"><a href=\"#敏捷开发\" class=\"headerlink\" title=\"敏捷开发\"></a>敏捷开发</h2><p>TODO</p>\n<h2 id=\"极限编程（XP）\"><a href=\"#极限编程（XP）\" class=\"headerlink\" title=\"极限编程（XP）\"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p>\n<ul>\n<li><p><a href=\"http://www.woshipm.com/pmd/406917.html\">《主流敏捷开发方法：极限编程XP》</a></p>\n<ul>\n<li><p>是一种指导开发人员的方法论。</p>\n</li>\n<li><p>4大价值：</p>\n<ul>\n<li>沟通：鼓励口头沟通，提高效率。</li>\n<li>简单：够用就好。</li>\n<li>反馈：及时反馈、通知相关人。</li>\n<li>勇气：提倡拥抱变化，敢于重构。</li>\n</ul>\n</li>\n<li><p>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</p>\n</li>\n<li><p>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"结对编程\"><a href=\"#结对编程\" class=\"headerlink\" title=\"结对编程\"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B\">《结对编程》</a></li>\n</ul>\n<h2 id=\"PDCA-循环质量管理\"><a href=\"#PDCA-循环质量管理\" class=\"headerlink\" title=\"PDCA 循环质量管理\"></a>PDCA 循环质量管理</h2><p>P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/PDCA\">《PDCA》</a></li>\n</ul>\n<h2 id=\"FMEA管理模式\"><a href=\"#FMEA管理模式\" class=\"headerlink\" title=\"FMEA管理模式\"></a>FMEA管理模式</h2><p>TODO</p>\n<h1 id=\"通用业务术语\"><a href=\"#通用业务术语\" class=\"headerlink\" title=\"通用业务术语\"></a>通用业务术语</h1><p>TODO</p>\n<h1 id=\"技术趋势\"><a href=\"#技术趋势\" class=\"headerlink\" title=\"技术趋势\"></a>技术趋势</h1><p>TODO</p>\n<h1 id=\"政策、法规\"><a href=\"#政策、法规\" class=\"headerlink\" title=\"政策、法规\"></a>政策、法规</h1><h2 id=\"法律\"><a href=\"#法律\" class=\"headerlink\" title=\"法律\"></a>法律</h2><ul>\n<li><p><a href=\"https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/16843044\">《中华人民共和国网络安全法》</a></p>\n<ul>\n<li>2016年11月7日发布，自2017年6月1日起施行</li>\n</ul>\n</li>\n<li><p><a href=\"https://baike.baidu.com/item/个人信息保护法/8343360\">《个人信息保护法》</a></p>\n<ul>\n<li>个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。</li>\n</ul>\n</li>\n<li><p><a href=\"https://baike.baidu.com/item/最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释/20497481\">《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》</a></p>\n<ul>\n<li>《解释》共十三条，自2017年6月1日起施行<blockquote>\n<ul>\n<li>1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”；</li>\n<li>2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上；</li>\n<li>3、对于其他公民个人信息，标准为 5000条以上。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://baike.baidu.com/item/中华人民共和国电子商务法/16467544\">《中华人民共和国电子商务法》</a></p>\n<ul>\n<li>2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行</li>\n<li><a href=\"https://v.youku.com/v_show/id_XNDAzNjAyNDM0MA==.html\">解读电子商务法（一）什么是电商</a></li>\n<li><a href=\"https://v.youku.com/v_show/id_XNDA1OTc0OTQ5Mg==.html\">解读电子商务法（二）电商经营者</a></li>\n<li><a href=\"https://v.youku.com/v_show/id_XNDA4NzIyNjI4MA==.html\">解读电子商务法（三）电商行为规范</a></li>\n<li><a href=\"https://v.qq.com/x/page/e08443fc1cr.html\">解读电子商务法（四）电商的法律关系</a></li>\n<li><a href=\"https://v.youku.com/v_show/id_XNDA4MTQ2Nzk4NA==.html\">解读电子商务法（外传）电商挣钱的秘密</a></li>\n<li><a href=\"https://v.qq.com/x/page/j0844twjwr5.html\">解读电子商务法（外传）电商模式</a></li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/a331685690/article/details/79917772\">程序员需要知道的法律常识</a></p>\n</li>\n<li><p><a href=\"https://time.geekbang.org/column/132\">白话法律42讲-为程序员打造的专属法律武器</a></p>\n</li>\n</ul>\n<h3 id=\"严格遵守刑法253法条\"><a href=\"#严格遵守刑法253法条\" class=\"headerlink\" title=\"严格遵守刑法253法条\"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p>\n<blockquote>\n<ul>\n<li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li>\n<li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 </li>\n<li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li>\n</ul>\n</blockquote>\n<p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA\">《非法获取公民个人信息罪》</a></li>\n</ul>\n<h3 id=\"避风港原则\"><a href=\"#避风港原则\" class=\"headerlink\" title=\"避风港原则\"></a>避风港原则</h3><p>“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E9%81%BF%E9%A3%8E%E6%B8%AF%E5%8E%9F%E5%88%99/588459?fr=aladdin\">《避风港原则》</a></li>\n</ul>\n<h1 id=\"架构师素质\"><a href=\"#架构师素质\" class=\"headerlink\" title=\"架构师素质\"></a>架构师素质</h1><ul>\n<li><p><a href=\"http://hellojava.info/?p=430\">《架构师画像》</a></p>\n<ul>\n<li>业务理解和抽象能力</li>\n<li>NB的代码能力</li>\n<li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； </li>\n<li>全局：是否考虑到了对上下游的系统的影响。</li>\n<li>权衡：权衡投入产出比；优先级和节奏控制；</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know\">《关于架构优化和设计，架构师必须知道的事情》</a></p>\n<ul>\n<li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。</li>\n<li>基础设施、配置、测试、开发、运维综合考虑。</li>\n<li>考虑人、团队、和组织的影响。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/19841397\">《如何才能真正的提高自己，成为一名出色的架构师？》</a> </p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129\">《架构师的必备素质和成长途径》</a></p>\n<ul>\n<li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li>\n<li>成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.51cto.com/frankfan/1248401\">《架构设计师—你在哪层楼？》</a></p>\n<ul>\n<li>第一层的架构师看到的只是产品本身</li>\n<li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li>\n<li>第三层的架构师看到的是商业价值 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"团队管理\"><a href=\"#团队管理\" class=\"headerlink\" title=\"团队管理\"></a>团队管理</h1><p>TODO</p>\n<h2 id=\"招聘\"><a href=\"#招聘\" class=\"headerlink\" title=\"招聘\"></a>招聘</h2><h1 id=\"资讯\"><a href=\"#资讯\" class=\"headerlink\" title=\"资讯\"></a>资讯</h1><h2 id=\"行业资讯\"><a href=\"#行业资讯\" class=\"headerlink\" title=\"行业资讯\"></a>行业资讯</h2><ul>\n<li><a href=\"http://36kr.com/\">36kr</a></li>\n<li><a href=\"http://www.techweb.com.cn/\">Techweb</a></li>\n</ul>\n<h2 id=\"公众号列表\"><a href=\"#公众号列表\" class=\"headerlink\" title=\"公众号列表\"></a>公众号列表</h2><p>TODO</p>\n<h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><h3 id=\"团队博客\"><a href=\"#团队博客\" class=\"headerlink\" title=\"团队博客\"></a>团队博客</h3><ul>\n<li><a href=\"http://jm.taobao.org/\">阿里中间件博客</a></li>\n<li><a href=\"https://tech.meituan.com\">美团点评技术团队博客</a></li>\n</ul>\n<h3 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/\">阮一峰的网络日志</a></li>\n<li><a href=\"https://coolshell.cn/\">酷壳 - COOLSHELL-陈皓</a></li>\n<li><a href=\"http://hellojava.info/\">hellojava-阿里毕玄</a></li>\n<li><a href=\"http://cmsblogs.com/\">Cm’s Blog</a></li>\n<li><a href=\"http://blog.didispace.com/\">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li>\n</ul>\n<h2 id=\"综合门户、社区\"><a href=\"#综合门户、社区\" class=\"headerlink\" title=\"综合门户、社区\"></a>综合门户、社区</h2><p><strong>国内：</strong></p>\n<ul>\n<li><p><a href=\"http://csdn.net\">CSDN</a><br>   老牌技术社区、不必解释。</p>\n</li>\n<li><p><a href=\"http://www.51cto.com/\">51cto.com</a></p>\n</li>\n<li><p><a href=\"http://www.iteye.com/\">ITeye</a></p>\n<ul>\n<li>偏 Java 方向 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com\">博客园</a></p>\n</li>\n<li><p><a href=\"http://www.chinaunix.net/\">ChinaUnix</a></p>\n<ul>\n<li>偏 Linux 方向 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.oschina.net/\">开源中国社区</a></p>\n</li>\n<li><p><a href=\"https://www.infoq.cn/\">InfoQ</a></p>\n</li>\n<li><p><a href=\"http://www.open-open.com/\">深度开源</a></p>\n</li>\n<li><p><a href=\"http://www.jobbole.com/\">伯乐在线</a></p>\n<ul>\n<li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.itpub.net/\">ITPUB</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/column\">腾讯云— 云+社区</a></p>\n</li>\n<li><p><a href=\"https://yq.aliyun.com/\">阿里云— 云栖社区</a></p>\n</li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/\">IBM DeveloperWorks</a></p>\n</li>\n<li><p><a href=\"https://toutiao.io/\">开发者头条</a></p>\n</li>\n<li><p><a href=\"http://www.linkedkeeper.com\">LinkedKeeper</a></p>\n</li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"https://dzone.com\">DZone</a></li>\n<li><a href=\"https://www.reddit.com\">Reddit</a></li>\n</ul>\n<h2 id=\"问答、讨论类社区\"><a href=\"#问答、讨论类社区\" class=\"headerlink\" title=\"问答、讨论类社区\"></a>问答、讨论类社区</h2><ul>\n<li><a href=\"https://segmentfault.com\">segmentfault</a><ul>\n<li>问答+专栏 </li>\n</ul>\n</li>\n<li><a href=\"https://www.zhihu.com/\">知乎</a></li>\n<li><a href=\"https://stackoverflow.com/\">stackoverflow</a></li>\n</ul>\n<h2 id=\"行业数据分析\"><a href=\"#行业数据分析\" class=\"headerlink\" title=\"行业数据分析\"></a>行业数据分析</h2><ul>\n<li><p><a href=\"http://report.iresearch.cn/\">艾瑞网</a></p>\n</li>\n<li><p><a href=\"https://www.questmobile.com.cn\">QUEST MOBILE</a></p>\n</li>\n<li><p><a href=\"http://data.stats.gov.cn/\">国家数据</a></p>\n</li>\n<li><p><a href=\"http://www.talkingdata.com/\">TalkingData</a></p>\n</li>\n</ul>\n<h2 id=\"专项网站\"><a href=\"#专项网站\" class=\"headerlink\" title=\"专项网站\"></a>专项网站</h2><ul>\n<li><p>测试:</p>\n<ul>\n<li><a href=\"http://www.ltesting.net/\">领测国际</a> </li>\n<li><a href=\"https://www.testwo.com/\">测试窝</a></li>\n<li><a href=\"https://testerhome.com\">TesterHome</a></li>\n</ul>\n</li>\n<li><p>运维:</p>\n<pre><code>* [运维派](http://www.yunweipai.com/) \n* [Abcdocker](https://www.abcdocker.com/)</code></pre></li>\n<li><p>Java:</p>\n<ul>\n<li><a href=\"http://www.importnew.com/\">ImportNew</a><ul>\n<li>专注于 Java 技术分享</li>\n</ul>\n</li>\n<li><a href=\"https://howtodoinjava.com/\">HowToDoInJava</a><ul>\n<li>英文博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>安全</p>\n<ul>\n<li><a href=\"https://www.2cto.com/\">红黑联盟</a> </li>\n<li><a href=\"http://www.freebuf.com/\">FreeBuf</a></li>\n</ul>\n</li>\n<li><p>大数据</p>\n<ul>\n<li><a href=\"http://www.thebigdata.cn/\">中国大数据</a> </li>\n</ul>\n</li>\n<li><p>其他专题网站：</p>\n<ul>\n<li><a href=\"http://www.infoq.com/cn/\">InfoQ</a><ul>\n<li>偏重于基础架构、运维方向</li>\n</ul>\n</li>\n<li><a href=\"http://www.dockerinfo.net/\">DockerInfo</a><ul>\n<li>专注于 Docker 应用及咨询、教程的网站</li>\n</ul>\n</li>\n<li><a href=\"https://www.linuxidc.com/\">Linux公社</a><ul>\n<li>Linux 主题社区</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其他类\"><a href=\"#其他类\" class=\"headerlink\" title=\"其他类\"></a>其他类</h2><ul>\n<li><a href=\"https://github.com/TeamStuQ/skill-map\">程序员技能图谱</a></li>\n</ul>\n<h2 id=\"推荐参考书\"><a href=\"#推荐参考书\" class=\"headerlink\" title=\"推荐参考书\"></a>推荐参考书</h2><h3 id=\"在线电子书\"><a href=\"#在线电子书\" class=\"headerlink\" title=\"在线电子书\"></a>在线电子书</h3><ul>\n<li><a href=\"https://github.com/forezp/SpringCloudLearning\">《深入理解Spring Cloud与微服务构建》</a></li>\n</ul>\n<ul>\n<li><p><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf\">《阿里技术参考图册-研发篇》</a></p>\n</li>\n<li><p><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf\">《阿里技术参考图册-算法篇》</a></p>\n</li>\n<li><p><a href=\"http://dpurl.cn/n/1lqcX\">《2018美团点评技术年货（合辑）》70M</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/architect/\">InfoQ《架构师》月刊</a></p>\n</li>\n<li><p><a href=\"https://www.w3cschool.cn/architectroad/\">《架构师之路》</a></p>\n</li>\n</ul>\n<h3 id=\"纸质书\"><a href=\"#纸质书\" class=\"headerlink\" title=\"纸质书\"></a>纸质书</h3><p><b style=\"color:red\">更多架构方面书籍参考:</b> <a href=\"https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%9E%B6%E6%9E%84\">awesome-java-books</a></p>\n<h4 id=\"开发方面\"><a href=\"#开发方面\" class=\"headerlink\" title=\"开发方面\"></a>开发方面</h4><ul>\n<li>《阿里巴巴Java开发手册》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BfL5CR\">详情</a></li>\n</ul>\n<h4 id=\"架构方面\"><a href=\"#架构方面\" class=\"headerlink\" title=\"架构方面\"></a>架构方面</h4><ul>\n<li><p>《软件架构师的12项修炼：技术技能篇》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=rTlo0m\">详情</a></p>\n</li>\n<li><p>《架构之美》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=1KECBZ\">详情</a> </p>\n</li>\n<li><p>《分布式服务架构》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=hkzqtK\">详情</a> </p>\n</li>\n<li><p>《聊聊架构》 <a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=A8Nd6Z\">详情</a> </p>\n</li>\n<li><p>《云原生应用架构实践》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=D4WCpd\">详情</a> </p>\n</li>\n<li><p>《亿级流量网站架构核心技术》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Rdmd21\">详情</a></p>\n</li>\n<li><p>《淘宝技术这十年》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=CoUdGG\">详情</a></p>\n</li>\n<li><p>《企业IT架构转型之道-中台战略思想与架构实战》 <a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BxS6eI\">详情</a> </p>\n</li>\n<li><p>《高可用架构（第1卷）》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BcjUwS\">详情</a> </p>\n</li>\n</ul>\n<h4 id=\"技术管理方面\"><a href=\"#技术管理方面\" class=\"headerlink\" title=\"技术管理方面\"></a>技术管理方面</h4><ul>\n<li>《CTO说》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Gl3QAo\">详情</a> </li>\n<li>《技术管理之巅》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=MeloLt\">详情</a></li>\n<li>《网易一千零一夜：互联网产品项目管理实战》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=qPuqMg\">详情</a> </li>\n</ul>\n<h4 id=\"基础理论-1\"><a href=\"#基础理论-1\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h4><ul>\n<li>《数学之美》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=0seUpO\">详情</a> </li>\n<li>《编程珠玑》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=I7jj9r\">详情</a> </li>\n</ul>\n<h4 id=\"工具方面\"><a href=\"#工具方面\" class=\"headerlink\" title=\"工具方面\"></a>工具方面</h4><p>TODO</p>\n<h4 id=\"大数据方面\"><a href=\"#大数据方面\" class=\"headerlink\" title=\"大数据方面\"></a>大数据方面</h4><h1 id=\"技术资源\"><a href=\"#技术资源\" class=\"headerlink\" title=\"技术资源\"></a>技术资源</h1><h2 id=\"开源资源\"><a href=\"#开源资源\" class=\"headerlink\" title=\"开源资源\"></a>开源资源</h2><ul>\n<li><p><a href=\"https://github.com\">github</a></p>\n</li>\n<li><p><a href=\"https://www.apache.org/index.html\">Apache 软件基金会</a></p>\n</li>\n</ul>\n<h2 id=\"手册、文档、教程\"><a href=\"#手册、文档、教程\" class=\"headerlink\" title=\"手册、文档、教程\"></a>手册、文档、教程</h2><p><strong>国内：</strong></p>\n<ul>\n<li><p><a href=\"http://w3cschool.cn\">W3Cschool</a> </p>\n</li>\n<li><p><a href=\"http://www.runoob.com/\">Runoob.com</a></p>\n<ul>\n<li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li>\n</ul>\n</li>\n<li><p><a href=\"https://love2.io/\">Love2.io</a></p>\n<ul>\n<li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li>\n</ul>\n</li>\n<li><p><a href=\"http://gitbook.cn/\">gitbook.cn</a></p>\n<ul>\n<li>付费电子书。 </li>\n</ul>\n</li>\n<li><p><a href=\"http://www.apachecn.org/\">ApacheCN</a></p>\n<ul>\n<li>AI、大数据方面系列中文文档。</li>\n</ul>\n</li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"http://www.quickcode.co/\">Quick Code</a><ul>\n<li>免费在线技术教程。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.com\">gitbook.com</a><ul>\n<li>有部分中文电子书。</li>\n</ul>\n</li>\n<li><a href=\"https://www.cheatography.com/\">Cheatography</a><ul>\n<li>Cheat Sheets 大全，单页文档网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.tutorialspoint.com/index.htm\">Tutorialspoint</a><ul>\n<li>知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。</li>\n</ul>\n</li>\n<li><a href=\"https://leetcode.com/problemset/all/\">LeetCode</a><ul>\n<li>知名题库网站，提供Java、Python、C#、C++、算法、SQL、等高质量各程度题库和解决办法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在线课堂\"><a href=\"#在线课堂\" class=\"headerlink\" title=\"在线课堂\"></a>在线课堂</h2><ul>\n<li><a href=\"http://www.xuetuwuyou.com/\">学徒无忧</a></li>\n<li><a href=\"https://time.geekbang.org/\">极客时间</a></li>\n<li><a href=\"https://segmentfault.com/lives\">segmentfault</a></li>\n<li><a href=\"https://new.stuq.org/course/explore\">斯达克学院</a></li>\n<li><a href=\"http://nowcoder.com\">牛客网</a></li>\n<li><a href=\"https://www.jikexueyuan.com/\">极客学院</a></li>\n<li><a href=\"http://edu.51cto.com/\">51CTO学院</a></li>\n</ul>\n<h2 id=\"会议、活动\"><a href=\"#会议、活动\" class=\"headerlink\" title=\"会议、活动\"></a>会议、活动</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/qcon/\">QCon</a></li>\n<li><a href=\"https://archsummit.com\">ArchSummit</a></li>\n<li><a href=\"http://www.thegitc.com/\">GITC全球互联网技术大会</a></li>\n</ul>\n<p><strong>活动发布平台:</strong> </p>\n<ul>\n<li><a href=\"http://www.huodongxing.com/\">活动行</a></li>\n</ul>\n<h2 id=\"常用APP\"><a href=\"#常用APP\" class=\"headerlink\" title=\"常用APP\"></a>常用APP</h2><ul>\n<li><a href=\"https://time.geekbang.org\">极客时间</a></li>\n<li><a href=\"https://www.igetget.com\">得到</a></li>\n</ul>\n<h2 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h2><ul>\n<li><a href=\"https://www.zhipin.com\">Boss直聘</a></li>\n<li><a href=\"https://www.lagou.com\">拉勾网</a></li>\n<li><a href=\"https://www.liepin.com\">猎聘</a></li>\n<li><a href=\"https://cn.100offer.com/\">100Offer</a></li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><a href=\"https://s.geekbang.org/\">极客搜索</a><ul>\n<li>技术文章搜索引擎。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码托管\"><a href=\"#代码托管\" class=\"headerlink\" title=\"代码托管\"></a>代码托管</h2><ul>\n<li><a href=\"https://coding.net\">Coding</a></li>\n<li><a href=\"https://gitee.com/\">码云</a></li>\n</ul>\n<h2 id=\"文件服务\"><a href=\"#文件服务\" class=\"headerlink\" title=\"文件服务\"></a>文件服务</h2><ul>\n<li>七牛</li>\n<li>又拍云</li>\n</ul>\n<h2 id=\"综合云服务商\"><a href=\"#综合云服务商\" class=\"headerlink\" title=\"综合云服务商\"></a>综合云服务商</h2><ul>\n<li>阿里云</li>\n<li><a href=\"https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c\">腾讯云</a></li>\n<li>百度云</li>\n<li>新浪云</li>\n<li>金山云</li>\n<li><a href=\"https://amazonaws-china.com/cn/\">亚马逊云(AWS)</a></li>\n<li><a href=\"https://cloud.google.com/?hl=zh-cn\">谷歌云</a></li>\n<li><a href=\"https://azure.microsoft.com/zh-cn/\">微软云</a></li>\n</ul>\n<h3 id=\"VPS\"><a href=\"#VPS\" class=\"headerlink\" title=\"VPS\"></a>VPS</h3><ul>\n<li><a href=\"http://linode.com\">Linode</a></li>\n<li><a href=\"https://www.digitalocean.com\">DigitalOcean</a></li>\n<li><a href=\"https://www.vultr.com/\">Vultr</a></li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"櫻玲桉","link":"https://dlizi.com","avatar":"https://cdn.jsdelivr.net/gh/Musenxi/CDN/favicon.png","descr":"是微甜的呀～"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Github","link":"https://github.com/tanxinzheng","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.CrfHDaVmhSd6poZDvbwlhwHaHa?o=6&pid=Api&w=1080&h=1080&rs=1","descr":"国际最大基友社交平台"},{"name":"Gitee","link":"https://gitee.com/tanxinzheng","avatar":"https://gitee.com/index/gitee-people/images/mayun_logo.png","descr":"中国最大基友社交平台"},{"name":"Pug","link":"https://www.pugjs.cn/api/getting-started.html","avatar":"https://tse2-mm.cn.bing.net/th/id/OIP.a8FM1mul-mzI6O8DRKOMWgHaHa?o=6&pid=Api&rs=1","descr":"Pug中文文档库"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"},{"name":"Google Fonts","link":"http://www.googlefonts.cn/","avatar":"https://tse3-mm.cn.bing.net/th/id/OIP.WQyWuZZ_6C5jCgnifD6C_QHaHa?w=178&h=180&c=7&o=5&dpr=2&pid=1.7","descr":"众多优美酷炫字体可供选择"},{"name":"Font Awesome","link":"http://www.fontawesome.com.cn/faicons/","avatar":"https://www.bootcss.com/p/font-awesome/assets/img/contribution-sample.png","descr":"完美的图标字体，只为Bootstrap设计"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p><b style=\"color:red\">推荐:</b> <a href=\"https://github.com/sorenduan/awesome-java-books\">《Java技术书籍大全》 - awesome-java-books</a></p>\n<p>从初级开发者到资深架构师，看这些书就够了</p>\n<hr/>\n<!-- \n[![知识共享协议（CC协议）](https://img.shields.io/badge/License-Creative%20Commons-DC3D24.svg)](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)[![GitHub stars](https://img.shields.io/github/stars/xingshaocheng/architect-awesome.svg?style=flat&label=Star)](https://github.com/xingshaocheng/architect-awesome/stargazers)[![GitHub forks](https://img.shields.io/github/forks/xingshaocheng/architect-awesome.svg?style=flat&label=Fork)](https://github.com/xingshaocheng/architect-awesome/fork)[![GitHub watchers](https://img.shields.io/github/watchers/xingshaocheng/architect-awesome.svg?style=flat&label=Watch)](https://github.com/xingshaocheng/architect-awesome/watchers)[![GitHub followers](https://img.shields.io/github/followers/xingshaocheng.svg?label=%E5%85%B3%E6%B3%A8)](https://github.com/xingshaocheng) -->\n\n<!-- **（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）** -->\n\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/lemon-flm/p/7877898.html\">《java队列——queue详细分析》</a></p>\n<ul>\n<li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li>\n<li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/mantu/p/5802393.html\">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></p>\n</li>\n</ul>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_33642117/article/details/52040345\">《Java Set集合的详解》</a></li>\n</ul>\n<h2 id=\"链表、数组\"><a href=\"#链表、数组\" class=\"headerlink\" title=\"链表、数组\"></a>链表、数组</h2><ul>\n<li><a href=\"https://blog.csdn.net/wz249863091/article/details/52853360\">《Java集合详解–什么是List》</a></li>\n</ul>\n<h2 id=\"字典、关联数组\"><a href=\"#字典、关联数组\" class=\"headerlink\" title=\"字典、关联数组\"></a>字典、关联数组</h2><ul>\n<li><a href=\"https://baike.xsoftlab.net/view/250.html\">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><a href=\"https://blog.csdn.net/javazejian/article/details/53362993\">《java数据结构与算法之栈（Stack）设计与实现》</a></li>\n<li><a href=\"http://www.runoob.com/java/java-stack-class.html\">《Java Stack 类》</a></li>\n<li><a href=\"https://blog.csdn.net/f2006116/article/details/51375225\">《java stack的详细实现分析》</a><ul>\n<li>Stack 是线程安全的。</li>\n<li>内部使用数组保存数据，不够时翻倍。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/cai2016/article/details/52589952\">《二叉树》</a></li>\n</ul>\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin\">《完全二叉树》</a><ul>\n<li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/polly333/p/4798944.html\">《浅谈数据结构-平衡二叉树》</a></li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html\">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li>\n</ul>\n<h3 id=\"二叉查找树（BST）\"><a href=\"#二叉查找树（BST）\" class=\"headerlink\" title=\"二叉查找树（BST）\"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html\">《浅谈算法和数据结构: 七 二叉查找树》</a></li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><ul>\n<li><a href=\"https://blog.csdn.net/sun_tttt/article/details/65445754\">《最容易懂得红黑树》</a><ul>\n<li>添加阶段后，左旋或者右旋从而再次达到平衡。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html\">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li>\n</ul>\n<h3 id=\"B，B-，B-树\"><a href=\"#B，B-，B-树\" class=\"headerlink\" title=\"B，B+，B*树\"></a>B，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/aqzwss/article/details/53074186\">《B-树，B+树，B*树详解》</a></li>\n<li><a href=\"https://blog.csdn.net/bigtree_3721/article/details/73632405\">《B-树，B+树与B*树的优缺点比较》</a><ul>\n<li>B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。<h3 id=\"LSM-树\"><a href=\"#LSM-树\" class=\"headerlink\" title=\"LSM 树\"></a>LSM 树</h3></li>\n</ul>\n</li>\n</ul>\n<p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。<br>Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/dbanote/article/details/8897599\">《LSM树 VS B+树》</a></p>\n<ul>\n<li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。</li>\n<li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014774781/article/details/52105708\">《LSM树（Log-Structured Merge Tree）存储引擎》</a></p>\n<ul>\n<li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li>\n<li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li>\n<li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"BitSet\"><a href=\"#BitSet\" class=\"headerlink\" title=\"BitSet\"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p>\n<ul>\n<li><a href=\"http://www.runoob.com/java/java-bitset-class.html\">《Java Bitset类》</a></li>\n<li><a href=\"https://blog.csdn.net/caiandyong/article/details/51581160\">《Java BitSet（位集）》</a></li>\n</ul>\n<h1 id=\"常用算法\"><a href=\"#常用算法\" class=\"headerlink\" title=\"常用算法\"></a>常用算法</h1><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h2 id=\"排序、查找算法\"><a href=\"#排序、查找算法\" class=\"headerlink\" title=\"排序、查找算法\"></a>排序、查找算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/shen-hua/p/5424059.html\">《Java中的经典算法之选择排序（SelectionSort）》</a><ul>\n<li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li><a href=\"https://blog.csdn.net/shuaizai88/article/details/73250615\">《冒泡排序的2种写法》</a><ul>\n<li>相邻元素前后交换、把最大的排到最后。</li>\n<li>时间复杂度 O(n²) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/hapjin/p/5517667.html\">《排序算法总结之插入排序》</a></li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li><a href=\"https://blog.csdn.net/afjaklsdflka/article/details/52829030\">《坐在马桶上看算法：快速排序》</a><ul>\n<li>一侧比另外一侧都大或小。 <h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3></li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/chengxiao/p/6194356.html\">《图解排序算法(四)之归并排序》</a><ul>\n<li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>TODO</p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/chengxiao/p/6129630.html\">《图解排序算法(三)之堆排序》</a><ul>\n<li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/suvllian/p/5495780.html\">《计数排序和桶排序》</a><ul>\n<li>和桶排序过程比较像，差别在于桶的数量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li><a href=\"http://blog.51cto.com/ahalei/1362789\">《【啊哈！算法】最快最简单的排序——桶排序》</a></li>\n<li><a href=\"https://blog.csdn.net/sunjinshengli/article/details/70738527\">《排序算法（三）：计数排序与桶排序》</a><ul>\n<li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li>\n<li>每个桶单独进行排序，然后再遍历每个桶。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/51695211\">《排序算法系列：基数排序》</a></li>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/3603669.html\">《基数排序》</a></li>\n</ul>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/coderising/p/5708632.html\">《二分查找(java实现)》</a></p>\n<ul>\n<li>要求待查找的序列有序。</li>\n<li>时间复杂度 O(logN)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/maoyuanming0806/article/details/78176957\">《java实现二分查找-两种方式》</a></p>\n<ul>\n<li>while + 递归。<h3 id=\"Java-中的排序工具\"><a href=\"#Java-中的排序工具\" class=\"headerlink\" title=\"Java 中的排序工具\"></a>Java 中的排序工具</h3></li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1\">《Arrays.sort和Collections.sort实现原理解析》</a></p>\n<ul>\n<li>Collections.sort算法调用的是合并排序。</li>\n<li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。<br>核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。<br>优点：空间和时间效率都很高。<br>缺点：随着存入的元素数量增加，误算率随之增加。</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000002729689\">《布隆过滤器 – 空间效率很高的数据结构》</a></li>\n<li><a href=\"https://blog.csdn.net/zdxiq000/article/details/57626464\">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li>\n<li><a href=\"https://blog.csdn.net/qq_30242609/article/details/71024458\">《基于Redis的布隆过滤器的实现》</a><ul>\n<li>基于 Redis 的 Bitmap 数据结构。</li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/47973715\">《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》</a><ul>\n<li>使用Java中的 BitSet 类 和 加权和hash算法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h2><h3 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP）<br>核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\">《字符串匹配的KMP算法》</a></li>\n</ul>\n<h2 id=\"深度优先、广度优先\"><a href=\"#深度优先、广度优先\" class=\"headerlink\" title=\"深度优先、广度优先\"></a>深度优先、广度优先</h2><ul>\n<li><a href=\"https://www.cnblogs.com/0kk470/p/7555033.html\">《广度优先搜索BFS和深度优先搜索DFS》</a></li>\n</ul>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><ul>\n<li><a href=\"https://www.cnblogs.com/MrSaver/p/8641971.html\">《算法：贪婪算法基础》</a></li>\n<li><a href=\"https://blog.csdn.net/a345017062/article/details/52443781\">《常见算法及问题场景——贪心算法》</a></li>\n</ul>\n<h2 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qfikh/article/details/51960331\">《 五大常用算法之四：回溯法》</a></li>\n</ul>\n<h2 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luningcsdn/article/details/50930276\">《α-β剪枝算法》</a></li>\n</ul>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><ul>\n<li><a href=\"https://www.cnblogs.com/little-YTMM/p/5372680.html\">《详解动态规划——邹博讲动态规划》</a></li>\n<li><a href=\"https://blog.csdn.net/yao_zi_jie/article/details/54580283\">《动态规划算法的个人理解》</a></li>\n</ul>\n<h2 id=\"朴素贝叶斯\"><a href=\"#朴素贝叶斯\" class=\"headerlink\" title=\"朴素贝叶斯\"></a>朴素贝叶斯</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/amds123/article/details/70173402\">《带你搞懂朴素贝叶斯分类算法》</a></p>\n<ul>\n<li>P(B|A)=P(A|B)P(B)/P(A)</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html\">《贝叶斯推断及其互联网应用1》</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html\">《贝叶斯推断及其互联网应用2》</a></p>\n</li>\n</ul>\n<h2 id=\"推荐算法\"><a href=\"#推荐算法\" class=\"headerlink\" title=\"推荐算法\"></a>推荐算法</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01\">《推荐算法综述》</a></li>\n<li><a href=\"https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems\">《TOP 10 开源的推荐系统简介》</a></li>\n</ul>\n<h2 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luoshixian099/article/details/51908175\">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li>\n</ul>\n<h2 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_35644234/article/details/60870719\">《Dijkstra算法详解》</a></li>\n</ul>\n<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h1><h2 id=\"Java-并发\"><a href=\"#Java-并发\" class=\"headerlink\" title=\"Java 并发\"></a>Java 并发</h2><ul>\n<li><a href=\"https://github.com/CL0610/Java-concurrency\">Java 并发知识合集</a></li>\n<li><a href=\"https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png\">JAVA并发知识图谱</a></li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xrq730/p/5060921.html\">《40个Java多线程问题总结》</a></li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><ul>\n<li><a href=\"https://www.cnblogs.com/zhanht/p/5450325.html\">《Java并发编程——线程安全及解决机制简介》</a></li>\n</ul>\n<h2 id=\"一致性、事务\"><a href=\"#一致性、事务\" class=\"headerlink\" title=\"一致性、事务\"></a>一致性、事务</h2><h3 id=\"事务-ACID-特性\"><a href=\"#事务-ACID-特性\" class=\"headerlink\" title=\"事务 ACID 特性\"></a>事务 ACID 特性</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012440687/article/details/52116108\">《数据库事务ACID特性》</a></li>\n</ul>\n<h3 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h3><ul>\n<li><p>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</p>\n</li>\n<li><p>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</p>\n</li>\n<li><p>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</p>\n</li>\n<li><p>序列化：所有事物串行处理（牺牲了效率）</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_33290787/article/details/51924963\">《理解事务的4种隔离级别》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/z-sm/p/7245981.html\">数据库事务的四大特性及事务隔离级别</a></p>\n</li>\n<li><p><a href=\"http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html\">《MySQL的InnoDB的幻读问题 》</a></p>\n<ul>\n<li>幻读的例子非常清楚。</li>\n<li>通过 SELECT … FOR UPDATE 解决。</li>\n</ul>\n</li>\n<li><p><a href=\"https://draveness.me/mysql-innodb\">《一篇文章带你读懂MySQL和InnoDB》</a></p>\n<ul>\n<li>图解脏读、不可重复读、幻读问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/chenpingzhao/p/5065316.html\">《【mysql】关于innodb中MVCC的一些理解》</a></p>\n<ul>\n<li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li>\n<li>MVCC 会产生幻读问题（更新时异常。）</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/whoamiyang/article/details/51901888\">《轻松理解MYSQL MVCC 实现机制》</a></p>\n<ul>\n<li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li>\n<li>每次只操作比当前版本小（或等于）的 行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"Java中的锁和同步类\"><a href=\"#Java中的锁和同步类\" class=\"headerlink\" title=\"Java中的锁和同步类\"></a>Java中的锁和同步类</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/qifengshi/p/6831055.html\">《Java中的锁分类》</a></p>\n<ul>\n<li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\">《Java并发之AQS详解》</a></p>\n</li>\n<li><p><a href=\"http://cuisuqiang.iteye.com/blog/2020146\">《Java中信号量 Semaphore》</a></p>\n<ul>\n<li>有数量控制</li>\n<li>申请用 acquire，申请不要则阻塞；释放用 release。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/davidwang456/p/6094947.html\">《java开发中的Mutex vs Semaphore》</a></p>\n<ul>\n<li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"公平锁-amp-非公平锁\"><a href=\"#公平锁-amp-非公平锁\" class=\"headerlink\" title=\"公平锁 &amp; 非公平锁\"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/EthanWhite/article/details/55508357\">《公平锁与非公平锁》</a><ul>\n<li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/zhiqian-ali/p/6200874.html\">《【MySQL】悲观锁&amp;乐观锁》</a></p>\n<ul>\n<li>乐观锁的方式：版本号+重试方式</li>\n<li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/Lawson/p/5008741.html\">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a></p>\n<ul>\n<li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li>\n<li>锁相同数据的不同索引条件可能会引起死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zejin2008/p/5262751.html\">《Mysql并发时经典常见的死锁原因及解决方法》</a></p>\n</li>\n</ul>\n<h3 id=\"乐观锁-amp-CAS\"><a href=\"#乐观锁-amp-CAS\" class=\"headerlink\" title=\"乐观锁 &amp; CAS\"></a>乐观锁 &amp; CAS</h3><ul>\n<li><a href=\"https://blog.csdn.net/u011514810/article/details/76895723/\">《乐观锁的一种实现方式——CAS》</a><ul>\n<li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ABA-问题\"><a href=\"#ABA-问题\" class=\"headerlink\" title=\"ABA 问题\"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/549294286/p/3766717.html\">《Java CAS 和ABA问题》</a></li>\n<li><a href=\"https://blog.csdn.net/li954644351/article/details/50511879\">《Java 中 ABA问题及避免》</a><ul>\n<li>AtomicStampedReference 和 AtomicStampedReference。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CopyOnWrite容器\"><a href=\"#CopyOnWrite容器\" class=\"headerlink\" title=\"CopyOnWrite容器\"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/hapjin/p/4840107.html\">《JAVA中写时复制(Copy-On-Write)Map实现》</a></p>\n<ul>\n<li>实现读写分离，读取发生在原始数据上，写入发生在副本上。  </li>\n<li>不用加锁，通过最终一致实现一致性。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/a494303877/article/details/53404623\">《聊聊并发-Java中的Copy-On-Write容器》</a></p>\n</li>\n</ul>\n<h3 id=\"RingBuffer\"><a href=\"#RingBuffer\" class=\"headerlink\" title=\"RingBuffer\"></a>RingBuffer</h3><ul>\n<li><a href=\"http://www.cnblogs.com/l00l/p/4115001.html\">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li>\n</ul>\n<h3 id=\"可重入锁-amp-不可重入锁\"><a href=\"#可重入锁-amp-不可重入锁\" class=\"headerlink\" title=\"可重入锁 &amp; 不可重入锁\"></a>可重入锁 &amp; 不可重入锁</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/dj3839/p/6580765.html\">《可重入锁和不可重入锁》</a></p>\n<ul>\n<li>通过简单代码举例说明可重入锁和不可重入锁。</li>\n<li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li>\n<li>可重入锁可以用户避免死锁。</li>\n<li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/baizhanshi/p/7211802.html\">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a></p>\n<ul>\n<li>synchronized 使用方便，编译器来加锁，是非公平锁。</li>\n<li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li>\n<li>相同加锁场景下，推荐使用 synchronized。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"互斥锁-amp-共享锁\"><a href=\"#互斥锁-amp-共享锁\" class=\"headerlink\" title=\"互斥锁 &amp; 共享锁\"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。<br>共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/liang1101/p/6475555.html\">《ReadWriteLock场景应用》</a></li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/yunfenglw/article/details/45950305\">《“死锁”四个必要条件的合理解释》</a></p>\n<ul>\n<li>互斥、持有、不可剥夺、环形等待。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014039577/article/details/52351626\">Java如何查看死锁？</a></p>\n<ul>\n<li>JConsole 可以识别死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/bohu83/article/details/51135061\">java多线程系列：死锁及检测</a></p>\n<ul>\n<li>jstack 可以显示死锁。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><h2 id=\"计算机原理\"><a href=\"#计算机原理\" class=\"headerlink\" title=\"计算机原理\"></a>计算机原理</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000003692840\">《操作系统基础知识——操作系统的原理，类型和结构》</a></li>\n</ul>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><h3 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/zero__007/article/details/54089730\">《从Java视角理解CPU缓存和伪共享》</a></li>\n</ul>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>TODO</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ul>\n<li><a href=\"https://blog.csdn.net/asdf_1024/article/details/78978437\">《线程的生命周期及状态转换详解》</a></li>\n</ul>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><ul>\n<li><a href=\"https://www.thinksaas.cn/group/topic/839375/\">《终结python协程—-从yield到actor模型的实现》</a><ul>\n<li>线程的调度是由操作系统负责，协程调度是程序自行负责</li>\n<li>与线程相比，协程减少了无谓的操作系统切换.</li>\n<li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><ul>\n<li><a href=\"http://www.runoob.com/linux/linux-command-manual.html\">《Linux 命令大全》</a></li>\n</ul>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h2 id=\"设计模式的六大原则\"><a href=\"#设计模式的六大原则\" class=\"headerlink\" title=\"设计模式的六大原则\"></a>设计模式的六大原则</h2><ul>\n<li><a href=\"https://blog.csdn.net/q291611265/article/details/48465113\">《设计模式的六大原则》</a><ul>\n<li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li>\n<li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li>\n<li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li>\n<li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li>\n<li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li>\n<li>合成复用原则：尽量使用合成/聚合,而不是使用继承。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"23种常见设计模式\"><a href=\"#23种常见设计模式\" class=\"headerlink\" title=\"23种常见设计模式\"></a>23种常见设计模式</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/design-pattern-tutorial.html\">《设计模式》</a></li>\n<li><a href=\"https://www.cnblogs.com/susanws/p/5510229.html\">《23种设计模式全解析》</a></li>\n<li><a href=\"https://github.com/ToryZhou/design-pattern\">《设计模式类图与示例》</a></li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/winkey4986/p/5148953.html\">《细数JDK里的设计模式》</a></p>\n<ul>\n<li><p>结构型模式：</p>\n<ul>\n<li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li>\n<li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li>\n<li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li>\n<li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li>\n<li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li>\n<li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li>\n</ul>\n</li>\n<li><p>创建模式:</p>\n<ul>\n<li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li>\n<li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li>\n<li>工厂方法：就是 <strong>一个返回</strong>具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li>\n<li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li>\n<li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li>\n</ul>\n</li>\n<li><p>行为模式：</p>\n<ul>\n<li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li>\n<li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li>\n<li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li>\n<li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li>\n<li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li>\n<li>空对象模式：如 java.util.Collections#emptyList()。</li>\n<li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li>\n<li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/hwaggLee/p/4510687.html\">《Spring-涉及到的设计模式汇总》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u012387062/article/details/54719114\">《Mybatis使用的设计模式》</a></p>\n</li>\n</ul>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><ul>\n<li><a href=\"https://blog.csdn.net/YECrazy/article/details/79481964\">《单例模式的三种实现 以及各自的优缺点》</a></li>\n<li><a href=\"https://www.cnblogs.com/ttylinux/p/6498822.html\">《单例模式－－反射－－防止序列化破坏单例模式》</a><ul>\n<li>使用枚举类型。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>TODO</p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/mvc-pattern.html\">《MVC 模式》</a><ul>\n<li>模型(model)－视图(view)－控制器(controller) </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/23277575\">《理解 IOC》</a></li>\n<li><a href=\"https://www.cnblogs.com/NancyStartOnce/p/6813162.html\">《IOC 的理解与解释》</a><ul>\n<li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li>\n<li>作用：用于模块解耦。</li>\n<li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><ul>\n<li><a href=\"https://blog.csdn.net/yanquan345/article/details/19760027\">《轻松理解AOP(面向切面编程)》</a></li>\n<li><a href=\"https://www.cnblogs.com/hongwz/p/5764917.html\">《Spring AOP详解》</a></li>\n<li><a href=\"http://www.importnew.com/24305.html\">《Spring AOP的实现原理》</a><ul>\n<li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li>\n</ul>\n</li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/\">《Spring AOP 实现原理与 CGLIB 应用》</a><ul>\n<li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><ul>\n<li><a href=\"https://www.w3cschool.cn/uml_tutorial/\">《UML教程》</a></li>\n</ul>\n<h2 id=\"微服务思想\"><a href=\"#微服务思想\" class=\"headerlink\" title=\"微服务思想\"></a>微服务思想</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/6219259.html\">《微服务架构设计》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/micro-service-technology-stack\">《微服务架构技术栈选型手册》</a></li>\n</ul>\n<h3 id=\"康威定律\"><a href=\"#康威定律\" class=\"headerlink\" title=\"康威定律\"></a>康威定律</h3><ul>\n<li><p><a href=\"https://yq.aliyun.com/articles/8611\">《微服务架构的理论基础 - 康威定律》</a></p>\n<ul>\n<li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li>\n<li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li>\n<li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li>\n<li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li>\n</ul>\n</li>\n<li><p><a href=\"https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf\">《微服务架构核⼼20讲》</a></p>\n</li>\n</ul>\n<h1 id=\"运维-amp-统计-amp-技术支持\"><a href=\"#运维-amp-统计-amp-技术支持\" class=\"headerlink\" title=\"运维 &amp; 统计 &amp; 技术支持\"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id=\"常规监控\"><a href=\"#常规监控\" class=\"headerlink\" title=\"常规监控\"></a>常规监控</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/77849205\">《腾讯业务系统监控的修炼之路》</a></p>\n<ul>\n<li>监控的方式：主动、被动、旁路(比如舆情监控)</li>\n<li>监控类型： 基础监控、服务端监控、客户端监控、<br>监控、用户端监控</li>\n<li>监控的目标：全、块、准</li>\n<li>核心指标：请求量、成功率、耗时</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.oschina.net/news/67525/monitoring-tools\">《开源还是商用？十大云运维监控工具横评》</a></p>\n<ul>\n<li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li>\n</ul>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/201612/525373.htm\">《监控报警系统搭建及二次开发经验》</a></p>\n</li>\n</ul>\n<p><strong>命令行监控工具</strong></p>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html\">《常用命令行监控工具》</a></p>\n<ul>\n<li>top、sar、tsar、nload</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.jobbole.com/96846/\">《20个命令行工具监控 Linux 系统性能》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/feichexia/blog/196575\">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></p>\n</li>\n</ul>\n<h2 id=\"APM\"><a href=\"#APM\" class=\"headerlink\" title=\"APM\"></a>APM</h2><p>APM —  Application Performance Management</p>\n<ul>\n<li><p><a href=\"http://bigbully.github.io/Dapper-translation/\">《Dapper，大规模分布式系统的跟踪系统》</a></p>\n</li>\n<li><p><a href=\"http://opentracing.io\">CNCF OpenTracing</a>，<a href=\"https://github.com/opentracing-contrib/opentracing-specification-zh\">中文版</a></p>\n</li>\n<li><p>主要开源软件，按字母排序</p>\n<ul>\n<li><a href=\"https://github.com/apache/incubator-skywalking\">Apache SkyWalking</a></li>\n<li><a href=\"https://github.com/dianping/cat\">CAT</a></li>\n<li><a href=\"https://github.com/jaegertracing/jaeger\">CNCF jaeger</a></li>\n<li><a href=\"https://github.com/naver/pinpoint\">Pinpoint</a></li>\n<li><a href=\"https://github.com/openzipkin/zipkin\">Zipkin</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/apm-Pinpoint-practice\">《开源APM技术选型与实战》</a></p>\n<ul>\n<li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"统计分析\"><a href=\"#统计分析\" class=\"headerlink\" title=\"统计分析\"></a>统计分析</h2><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/25195217\">《流量统计的基础：埋点》</a></p>\n<ul>\n<li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.25xt.com/company/17066.html\">《APP埋点常用的统计工具、埋点目标和埋点内容》</a></p>\n<ul>\n<li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li>\n</ul>\n</li>\n<li><p><a href=\"https://tech.meituan.com/mt_mobile_analytics_practice.html\">《美团点评前端无痕埋点实践》</a></p>\n<ul>\n<li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"持续集成-CI-CD\"><a href=\"#持续集成-CI-CD\" class=\"headerlink\" title=\"持续集成(CI/CD)\"></a>持续集成(CI/CD)</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\">《持续集成是什么？》</a></li>\n<li><a href=\"http://www.51testing.com/html/74/n-3723774.html\">《8个流行的持续集成工具》</a></li>\n</ul>\n<h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><ul>\n<li><a href=\"https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000\">《使用Jenkins进行持续集成》</a></li>\n</ul>\n<h3 id=\"环境分离\"><a href=\"#环境分离\" class=\"headerlink\" title=\"环境分离\"></a>环境分离</h3><p>开发、测试、生成环境分离。</p>\n<ul>\n<li><a href=\"https://my.oschina.net/sancuo/blog/214904\">《开发环境、生产环境、测试环境的基本理解和区》</a></li>\n</ul>\n<h2 id=\"自动化运维\"><a href=\"#自动化运维\" class=\"headerlink\" title=\"自动化运维\"></a>自动化运维</h2><h3 id=\"Ansible\"><a href=\"#Ansible\" class=\"headerlink\" title=\"Ansible\"></a>Ansible</h3><ul>\n<li><a href=\"http://www.ansible.com.cn/\">《Ansible中文权威指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/heiye123/articles/7855890.html\">《Ansible基础配置和企业级项目实用案例》</a></li>\n</ul>\n<h3 id=\"puppet\"><a href=\"#puppet\" class=\"headerlink\" title=\"puppet\"></a>puppet</h3><ul>\n<li><a href=\"https://www.cnblogs.com/keerya/p/8040071.html\">《自动化运维工具——puppet详解》</a></li>\n</ul>\n<h3 id=\"chef\"><a href=\"#chef\" class=\"headerlink\" title=\"chef\"></a>chef</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/\">《Chef 的安装与使用》</a></li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"TDD-理论\"><a href=\"#TDD-理论\" class=\"headerlink\" title=\"TDD 理论\"></a>TDD 理论</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/62f16cd4fef3\">《深度解读 - TDD（测试驱动开发）》</a><ul>\n<li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li>\n<li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyzm/p/6482886.html\">《Java单元测试之JUnit篇》</a></li>\n<li><a href=\"https://blog.csdn.net/hotdust/article/details/53406086\">《JUnit 4 与 TestNG 对比》</a><ul>\n<li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 </li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/wqetfg/article/details/50900512\">《单元测试主要的测试功能点》</a><ul>\n<li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h3><ul>\n<li><a href=\"https://blog.csdn.net/blueheart20/article/details/52170790\">《Apache ab 测试使用指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/binyue/p/6141088.html\">《大型网站压力测试及优化方案》</a></li>\n<li><a href=\"http://news.chinabyte.com/466/14126966.shtml\">《10大主流压力/负载/性能测试工具推荐》</a></li>\n<li><a href=\"http://quentinxxz.iteye.com/blog/2249799\">《真实流量压测工具 tcpcopy应用浅析》</a></li>\n<li><a href=\"https://www.cnblogs.com/jwentest/p/7136727.html\">《nGrinder 简易使用教程》</a></li>\n</ul>\n<h3 id=\"全链路压测\"><a href=\"#全链路压测\" class=\"headerlink\" title=\"全链路压测\"></a>全链路压测</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot\">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30306892\">《饿了么全链路压测的探索与实践》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28355759\">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li>\n<li><a href=\"https://www.jianshu.com/p/27060fd61f72\">《全链路压测经验》</a></li>\n</ul>\n<h3 id=\"A-B-、灰度、蓝绿测试\"><a href=\"#A-B-、灰度、蓝绿测试\" class=\"headerlink\" title=\"A/B 、灰度、蓝绿测试\"></a>A/B 、灰度、蓝绿测试</h3><ul>\n<li><p><a href=\"https://testerhome.com/topics/11165\">《技术干货 | AB 测试和灰度发布探索及实践》</a></p>\n</li>\n<li><p><a href=\"http://blog.51cto.com/purplegrape/1403123\">《nginx 根据IP 进行灰度发布》</a></p>\n</li>\n<li><p><a href=\"https://www.v2ex.com/t/344341\">《蓝绿部署、A/B 测试以及灰度发布》</a></p>\n</li>\n</ul>\n<h2 id=\"虚拟化\"><a href=\"#虚拟化\" class=\"headerlink\" title=\"虚拟化\"></a>虚拟化</h2><ul>\n<li><a href=\"https://blog.csdn.net/enweitech/article/details/52910082\">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li>\n</ul>\n<h3 id=\"KVM\"><a href=\"#KVM\" class=\"headerlink\" title=\"KVM\"></a>KVM</h3><ul>\n<li><a href=\"http://blog.chinaunix.net/uid-20201831-id-5775661.html\">《KVM详解，太详细太深入了，经典》</a></li>\n<li><a href=\"https://www.coderxing.com/kvm-install.html\">《【图文】KVM 虚拟机安装详解》</a></li>\n</ul>\n<h3 id=\"Xen\"><a href=\"#Xen\" class=\"headerlink\" title=\"Xen\"></a>Xen</h3><ul>\n<li><a href=\"https://www.cnblogs.com/sddai/p/5931201.html\">《Xen虚拟化基本原理详解》</a></li>\n</ul>\n<h3 id=\"OpenVZ\"><a href=\"#OpenVZ\" class=\"headerlink\" title=\"OpenVZ\"></a>OpenVZ</h3><ul>\n<li><a href=\"https://blog.csdn.net/longerzone/article/details/44829255\">《开源Linux容器 OpenVZ 快速上手指南》</a></li>\n</ul>\n<h2 id=\"容器技术\"><a href=\"#容器技术\" class=\"headerlink\" title=\"容器技术\"></a>容器技术</h2><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ul>\n<li><a href=\"https://www.cnblogs.com/SzeCheng/p/6822905.html\">《几张图帮你理解 docker 基本原理及快速入门》</a></li>\n<li><a href=\"https://draveness.me/docker\">《Docker 核心技术与实现原理》</a></li>\n<li><a href=\"http://www.runoob.com/docker/docker-tutorial.html\">《Docker 教程》</a></li>\n</ul>\n<h2 id=\"云技术\"><a href=\"#云技术\" class=\"headerlink\" title=\"云技术\"></a>云技术</h2><h3 id=\"OpenStack\"><a href=\"#OpenStack\" class=\"headerlink\" title=\"OpenStack\"></a>OpenStack</h3><ul>\n<li><a href=\"https://www.cnblogs.com/klb561/p/8660264.html\">《OpenStack构架知识梳理》</a></li>\n</ul>\n<h2 id=\"DevOps\"><a href=\"#DevOps\" class=\"headerlink\" title=\"DevOps\"></a>DevOps</h2><ul>\n<li><a href=\"https://www.cnblogs.com/jetzhang/p/6068773.html\">《一分钟告诉你究竟DevOps是什么鬼？》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/detail-analysis-of-devops\">《DevOps详解》</a></li>\n</ul>\n<h2 id=\"文档管理\"><a href=\"#文档管理\" class=\"headerlink\" title=\"文档管理\"></a>文档管理</h2><ul>\n<li><a href=\"http://www.confluence.cn/\">Confluence-收费文档管理系统</a></li>\n<li>GitLab?</li>\n<li>Wiki</li>\n</ul>\n<h1 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h1><h2 id=\"Web-Server\"><a href=\"#Web-Server\" class=\"headerlink\" title=\"Web Server\"></a>Web Server</h2><h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_25797077/article/details/52200722\">《Ngnix的基本学习-多进程和Apache的比较》</a></p>\n<ul>\n<li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li>\n<li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/cunkouzh/p/5410154.html\">《nginx与Apache的对比以及优缺点》</a></p>\n<ul>\n<li>nginx只适合静态和反向代理，不适合处理动态请求。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"OpenResty\"><a href=\"#OpenResty\" class=\"headerlink\" title=\"OpenResty\"></a>OpenResty</h3><ul>\n<li><a href=\"http://openresty.org/cn/\">官方网站</a></li>\n<li><a href=\"http://www.linkedkeeper.com/detail/blog.action?bid=1034\">《浅谈 OpenResty》</a><ul>\n<li>通过 Lua 模块可以在Nginx上进行开发。   </li>\n</ul>\n</li>\n<li><a href=\"https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html\">agentzh 的 Nginx 教程</a>  </li>\n</ul>\n<h3 id=\"Tengine\"><a href=\"#Tengine\" class=\"headerlink\" title=\"Tengine\"></a>Tengine</h3><ul>\n<li><a href=\"http://tengine.taobao.org/\">官方网站</a>  </li>\n</ul>\n<h3 id=\"Apache-Httpd\"><a href=\"#Apache-Httpd\" class=\"headerlink\" title=\"Apache Httpd\"></a>Apache Httpd</h3><ul>\n<li><a href=\"http://httpd.apache.org/\">官方网站</a></li>\n</ul>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><h4 id=\"架构原理\"><a href=\"#架构原理\" class=\"headerlink\" title=\"架构原理\"></a>架构原理</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/hggen/p/6264475.html\">《TOMCAT原理详解及请求过程》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/crazylqy/p/4706223.html\">《Tomcat服务器原理详解》</a></p>\n</li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/\">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xlgen157387/article/details/79006434\">《四张图带你了解Tomcat系统架构》</a></p>\n</li>\n<li><p><a href=\"https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/\">《JBoss vs. Tomcat: Choosing A Java Application Server》</a></p>\n<ul>\n<li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。</li>\n<li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"调优方案\"><a href=\"#调优方案\" class=\"headerlink\" title=\"调优方案\"></a>调优方案</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/sunfenqing/p/7339058.html\">《Tomcat 调优方案》</a></p>\n<ul>\n<li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.chinaunix.net/uid-20662363-id-3012760.html\">《tomcat http协议与ajp协议》</a></p>\n</li>\n<li><p><a href=\"http://dmouse.iteye.com/blog/1354527\">《AJP与HTTP比较和分析》</a></p>\n<ul>\n<li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li>\n<li>并发高时，AJP协议优于HTTP协议。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Jetty\"><a href=\"#Jetty\" class=\"headerlink\" title=\"Jetty\"></a>Jetty</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jetty/\">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li>\n<li><a href=\"https://blog.csdn.net/doutao6677/article/details/51957288\">《jetty和tomcat优势比较》</a><ul>\n<li>架构比较:Jetty的架构比Tomcat的更为简单。</li>\n<li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li>\n<li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ul>\n<li><a href=\"https://blog.csdn.net/clementad/article/details/48229243\">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li>\n</ul>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html\">《HashMap本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html\">《EhCache本地缓存》</a></p>\n<ul>\n<li>堆内、堆外、磁盘三级缓存。</li>\n<li>可按照缓存空间容量进行设置。</li>\n<li>按照时间、次数等过期策略。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html\">《Guava Cache》</a></p>\n<ul>\n<li>简单轻量、无堆外、磁盘缓存。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html\">《Nginx本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html\">《Pagespeed—懒人工具，服务器端加速》</a></p>\n</li>\n</ul>\n<h2 id=\"客户端缓存\"><a href=\"#客户端缓存\" class=\"headerlink\" title=\"客户端缓存\"></a>客户端缓存</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html\">《浏览器端缓存》</a></p>\n<ul>\n<li>主要是利用 Cache-Control 参数。</li>\n</ul>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w\">《H5 和移动端 WebView 缓存机制解析与实战》</a></p>\n</li>\n</ul>\n<h2 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a>服务端缓存</h2><h3 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h3><ul>\n<li><a href=\"https://github.com/jiangwenyuan/nuster\">nuster</a> - nuster cache</li>\n<li><a href=\"https://github.com/varnishcache/varnish-cache\">varnish</a> - varnish cache</li>\n<li><a href=\"https://github.com/squid-cache/squid\">squid</a> - squid cache</li>\n</ul>\n<h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><ul>\n<li><p><a href=\"http://www.runoob.com/Memcached/Memcached-tutorial.html\">《Memcached 教程》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chenleixing/article/details/47035453\">《深入理解Memcached原理》</a></p>\n<ul>\n<li>采用多路复用技术提高并发性。</li>\n<li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/36e5cd400580\">《Memcached软件工作原理》</a></p>\n</li>\n<li><p><a href=\"http://zhihuzeye.com/archives/2361\">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/liu251890347/article/details/37690045\">《memcache 中 add 、 set 、replace 的区别》</a></p>\n<ul>\n<li>区别在于当key存在还是不存在时，返回值是true和false的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=\"><strong>《memcached全面剖析》</strong></a></p>\n</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ul>\n<li><p><a href=\"http://www.runoob.com/redis/redis-tutorial.html\">《Redis 教程》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/wcf373722432/article/details/78678504\">《redis底层原理》</a></p>\n<ul>\n<li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li>\n<li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://doc.redisfans.com/topic/persistence.html\">《Redis持久化方式》</a></p>\n<ul>\n<li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li>\n<li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li>\n<li>也可以两者结合使用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chunlongyu/article/details/53346436\">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><a href=\"https://blog.csdn.net/sunhuiliang85/article/details/73656830\">《Redis单线程架构》</a></li>\n</ul>\n<h4 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h4><ul>\n<li><a href=\"https://blog.csdn.net/qq_29108585/article/details/63251491\">《redis的回收策略》</a></li>\n</ul>\n<h3 id=\"Tair\"><a href=\"#Tair\" class=\"headerlink\" title=\"Tair\"></a>Tair</h3><ul>\n<li><a href=\"https://github.com/alibaba/tair\">官方网站</a></li>\n<li><a href=\"http://blog.csdn.net/farphone/article/details/53522383\">《Tair和Redis的对比》</a></li>\n<li>特点：可以配置备份节点数目，通过异步同步到备份节点</li>\n<li>一致性Hash算法。</li>\n<li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li>\n</ul>\n<p>几种存储引擎:</p>\n<ul>\n<li>MDB，完全内存性，可以用来存储Session等数据。</li>\n<li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li>\n<li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li>\n<li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li>\n</ul>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/charlesblc/p/6045238.html\">《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》</a></p>\n<ul>\n<li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li>\n<li>Kafka 默认是拉模式。</li>\n<li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li>\n<li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yunfeng482/article/details/72856762\">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></p>\n</li>\n</ul>\n<h3 id=\"消息总线\"><a href=\"#消息总线\" class=\"headerlink\" title=\"消息总线\"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanghua_kobe/article/details/43877281\">《消息总线VS消息队列》</a></li>\n</ul>\n<h3 id=\"消息的顺序\"><a href=\"#消息的顺序\" class=\"headerlink\" title=\"消息的顺序\"></a>消息的顺序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/cjsblog/p/8267892.html\">《如何保证消费者接收消息的顺序》</a></li>\n</ul>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/whoamiyang/article/details/54954780\">《RabbitMQ的应用场景以及基本原理介绍》</a></li>\n<li><a href=\"https://www.jianshu.com/p/79ca08116d57\">《消息队列之 RabbitMQ》</a> </li>\n<li><a href=\"https://blog.csdn.net/u013256816/article/details/55515234\">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li>\n</ul>\n<h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/824066d70da8\">《RocketMQ 实战之快速入门》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome\">《RocketMQ 源码解析》</a></li>\n</ul>\n<h3 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/3962302.html\">《ActiveMQ消息队列介绍》</a></li>\n</ul>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p>\n<ul>\n<li><a href=\"http://kafka.apache.org/\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/allthesametome/article/details/47362451\">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li>\n<li><a href=\"http://lxw1234.com/archives/2015/10/538.htm\">《Kafka分区机制介绍与示例》</a></li>\n</ul>\n<h3 id=\"Redis-消息推送\"><a href=\"#Redis-消息推送\" class=\"headerlink\" title=\"Redis 消息推送\"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_34212276/article/details/78455004\">《Redis学习笔记之十：Redis用作消息队列》</a></li>\n</ul>\n<h3 id=\"ZeroMQ\"><a href=\"#ZeroMQ\" class=\"headerlink\" title=\"ZeroMQ\"></a>ZeroMQ</h3><p> TODO</p>\n<h2 id=\"定时调度\"><a href=\"#定时调度\" class=\"headerlink\" title=\"定时调度\"></a>定时调度</h2><h3 id=\"单机定时调度\"><a href=\"#单机定时调度\" class=\"headerlink\" title=\"单机定时调度\"></a>单机定时调度</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/shuaiqing/p/7742382.html\">《linux定时任务cron配置》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/daquan/blog/483305\">《Linux cron运行原理》</a></p>\n<ul>\n<li>fork 进程 + sleep 轮询</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/drift-ice/p/3817269.html\">《Quartz使用总结》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/wenniuwuren/article/details/42082981/\">《Quartz源码解析 —- 触发器按时启动原理》</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/bab8e4e32952\">《quartz原理揭秘和源码解读》</a></p>\n<ul>\n<li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式定时调度\"><a href=\"#分布式定时调度\" class=\"headerlink\" title=\"分布式定时调度\"></a>分布式定时调度</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_16216221/article/details/70314337\">《这些优秀的国产分布式任务调度系统，你用过几个？》</a></p>\n<ul>\n<li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html\">《Quartz任务调度的基本实现原理》</a></p>\n<ul>\n<li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 </li>\n</ul>\n</li>\n<li><p><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome\">《Elastic-Job-Lite 源码解析》</a></p>\n</li>\n<li><p><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome\">《Elastic-Job-Cloud 源码解析》</a></p>\n</li>\n</ul>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/top_code/article/details/54615853\">《从零开始实现RPC框架 - RPC原理及实现》</a></p>\n<ul>\n<li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/testcs_dn/article/details/78050590\">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></p>\n</li>\n</ul>\n<h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><ul>\n<li><a href=\"http://dubbo.apache.org/\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/steven520213/p/7606598.html\">dubbo实现原理简单介绍</a></li>\n</ul>\n<p>** SPI **<br>TODO</p>\n<h3 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h3><ul>\n<li><a href=\"http://thrift.apache.org/\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/kesonyk/article/details/50924489\">《Thrift RPC详解》</a><ul>\n<li>支持多语言，通过中间语言定义接口。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p>\n<ul>\n<li><a href=\"https://grpc.io/\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/LBSer/p/4853234.html\">《你应该知道的RPC原理》</a></li>\n</ul>\n<h2 id=\"数据库中间件\"><a href=\"#数据库中间件\" class=\"headerlink\" title=\"数据库中间件\"></a>数据库中间件</h2><h3 id=\"Sharding-Jdbc\"><a href=\"#Sharding-Jdbc\" class=\"headerlink\" title=\"Sharding Jdbc\"></a>Sharding Jdbc</h3><ul>\n<li><a href=\"http://shardingjdbc.io/\">官网</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/Sharding-JDBC/?vip&architect-awesome\">源码解析</a></li>\n</ul>\n<h2 id=\"日志系统\"><a href=\"#日志系统\" class=\"headerlink\" title=\"日志系统\"></a>日志系统</h2><h3 id=\"日志搜集\"><a href=\"#日志搜集\" class=\"headerlink\" title=\"日志搜集\"></a>日志搜集</h3><ul>\n<li><a href=\"http://cjting.me/misc/build-log-system-with-elkb/\">《从零开始搭建一个ELKB日志收集系统》</a></li>\n<li><a href=\"https://blog.csdn.net/lzw_2006/article/details/51280058\">《用ELK搭建简单的日志收集分析系统》</a></li>\n<li><a href=\"https://www.cnblogs.com/beginmind/p/6058194.html\">《日志收集系统-探究》</a></li>\n</ul>\n<h2 id=\"配置中心\"><a href=\"#配置中心\" class=\"headerlink\" title=\"配置中心\"></a>配置中心</h2><ul>\n<li><p><a href=\"https://github.com/ctripcorp/apollo\">Apollo - 携程开源的配置中心应用</a></p>\n<ul>\n<li>Spring Boot 和 Spring Cloud</li>\n<li>支持推、拉模式更新配置</li>\n<li>支持多种语言 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011320740/article/details/78742625\">《基于zookeeper实现统一配置管理》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/shamo89/p/8016908.html\">《 Spring Cloud Config 分布式配置中心使用教程》</a></p>\n</li>\n</ul>\n<p>servlet 3.0 异步特性可用于配置中心的客户端</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/dogdogwang/p/7151866.html\">《servlet3.0 新特性——异步处理》</a></li>\n</ul>\n<h2 id=\"API-网关\"><a href=\"#API-网关\" class=\"headerlink\" title=\"API 网关\"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p>\n<ul>\n<li><p><a href=\"http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/\">《API网关那些儿》</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo\">《谈API网关的背景、架构以及落地方案》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhanglh046/article/details/78651993\">《使用Zuul构建API Gateway》</a></p>\n</li>\n<li><p><a href=\"http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome\">《Spring Cloud Gateway 源码解析》</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A\">《HTTP API网关选择之一Kong介绍》</a></p>\n</li>\n</ul>\n<h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><h3 id=\"OSI-七层协议\"><a href=\"#OSI-七层协议\" class=\"headerlink\" title=\"OSI 七层协议\"></a>OSI 七层协议</h3><ul>\n<li><a href=\"https://www.cnblogs.com/Robin-YB/p/6668762.html\">《OSI七层协议模型、TCP/IP四层模型学习笔记》</a></li>\n</ul>\n<h3 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/onepixel/p/7092302.html\">《深入浅出 TCP/IP 协议》</a></li>\n<li><a href=\"https://blog.csdn.net/whuslei/article/details/6667471/\">《TCP协议中的三次握手和四次挥手》</a></li>\n</ul>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wangning528/p/6388464.html\">《http协议详解(超详细)》</a></li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li><a href=\"https://blog.csdn.net/zhuyiquan/article/details/69257126\">《HTTP 2.0 原理详细分析》</a></li>\n<li><a href=\"https://blog.csdn.net/u012657197/article/details/77877840\">《HTTP2.0的基本单位为二进制帧》</a><ul>\n<li>利用二进制帧负责传输。</li>\n<li>多路复用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/zhangshitong/p/6478721.html\">《https原理通俗了解》</a></p>\n<ul>\n<li>使用非对称加密协商加密算法</li>\n<li>使用对称加密方式传输数据</li>\n<li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/53213862\">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></p>\n</li>\n</ul>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><ul>\n<li><p><a href=\"http://blog.51cto.com/litaotao/1289790\">《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》</a></p>\n<ul>\n<li>五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li>\n<li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Anker/p/3265058.html\">《select、poll、epoll之间的区别总结》</a></p>\n<ul>\n<li>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li>\n<li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li>\n<li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li>\n<li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li>\n</ul>\n</li>\n<li><p><a href=\"http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/\">《select，poll，epoll比较  》</a></p>\n<ul>\n<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/geason/p/5774096.html\">《深入理解Java NIO》</a></p>\n<ul>\n<li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/skiof007/article/details/52873421\">《BIO与NIO、AIO的区别》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u013074465/article/details/46276967\">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></p>\n</li>\n</ul>\n<h3 id=\"Epoll\"><a href=\"#Epoll\" class=\"headerlink\" title=\"Epoll\"></a>Epoll</h3><ul>\n<li><a href=\"https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html\">《epoll使用详解（精髓）》</a></li>\n</ul>\n<h3 id=\"Java-NIO\"><a href=\"#Java-NIO\" class=\"headerlink\" title=\"Java NIO\"></a>Java NIO</h3><ul>\n<li><a href=\"https://www.cnblogs.com/geason/p/5774096.html\">《深入理解Java NIO》</a></li>\n<li><a href=\"https://blog.csdn.net/xidianliuy/article/details/51612676\">《Java NIO编写Socket服务器的一个例子》</a></li>\n</ul>\n<h3 id=\"kqueue\"><a href=\"#kqueue\" class=\"headerlink\" title=\"kqueue\"></a>kqueue</h3><ul>\n<li><a href=\"http://www.cnblogs.com/luminocean/p/5631336.html\">《kqueue用法简介》</a></li>\n</ul>\n<h2 id=\"连接和短连接\"><a href=\"#连接和短连接\" class=\"headerlink\" title=\"连接和短连接\"></a>连接和短连接</h2><ul>\n<li><a href=\"https://www.cnblogs.com/pangguoping/p/5571422.html\">《TCP/IP系列——长连接与短连接的区别》</a></li>\n</ul>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><ul>\n<li><a href=\"https://blog.csdn.net/excellentyuxiao/article/details/53390408\">《Netty原理剖析》</a><ul>\n<li>Reactor 模式介绍。</li>\n<li>Netty 是 Reactor 模式的一种实现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"零拷贝（Zero-copy）\"><a href=\"#零拷贝（Zero-copy）\" class=\"headerlink\" title=\"零拷贝（Zero-copy）\"></a>零拷贝（Zero-copy）</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\">《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》</a><ul>\n<li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"序列化-二进制协议\"><a href=\"#序列化-二进制协议\" class=\"headerlink\" title=\"序列化(二进制协议)\"></a>序列化(二进制协议)</h2><h3 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyday56/p/4268249.html\">《Hessian原理分析》</a><br>Binary-RPC;不仅仅是序列化</li>\n</ul>\n<h3 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/antgan/article/details/52103966\">《Protobuf协议的Java应用例子》</a><br>Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。</p>\n</li>\n<li><p><a href=\"https://worktile.com/tech/share/prototol-buffers\">《Protocol Buffers序列化协议及应用》</a></p>\n<pre><code>* 关于协议的解释；缺点：可读性差;</code></pre></li>\n<li><p><a href=\"https://blog.csdn.net/eric520zenobia/article/details/53766571\">《简单的使用 protobuf 和 protostuff》</a></p>\n<ul>\n<li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"基础理论\"><a href=\"#基础理论\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h2><h3 id=\"关系数据库设计的三大范式\"><a href=\"#关系数据库设计的三大范式\" class=\"headerlink\" title=\"关系数据库设计的三大范式\"></a>关系数据库设计的三大范式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/waj6511988/p/7027127.html\">《数据库的三大范式以及五大约束》</a><ul>\n<li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li>\n<li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>\n<li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/voidccc/article/details/40077329\">《MySQL的InnoDB索引原理详解》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xifeijian/article/details/20316775\">《MySQL存储引擎－－MyISAM与InnoDB区别》</a></p>\n<ul>\n<li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201211/172380.html\">《myisam和innodb索引实现的不同》</a></p>\n</li>\n</ul>\n<h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><ul>\n<li><a href=\"https://my.oschina.net/kailuncen/blog/1504217\">《一篇文章带你读懂Mysql和InnoDB》</a></li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><ul>\n<li><p><a href=\"http://vdisk.weibo.com/s/muWOT\">《MySQL36条军规》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhouyusheng/p/8038224.html\">《MYSQL性能优化的最佳20+条经验》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/when_less_is_more/article/details/70187459\">《SQL优化之道》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/sivkun/p/7518540.html\">《mysql数据库死锁的产生原因及解决办法》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/monkey_d_feilong/article/details/52291556\">《导致索引失效的可能情况》</a></p>\n</li>\n<li><p><a href=\"https://www.jianshu.com/p/0a7e3055a01f\">《 MYSQL分页limit速度太慢优化方法》</a></p>\n<ul>\n<li>原则上就是缩小扫描范围。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"聚集索引-非聚集索引\"><a href=\"#聚集索引-非聚集索引\" class=\"headerlink\" title=\"聚集索引, 非聚集索引\"></a>聚集索引, 非聚集索引</h4><ul>\n<li><a href=\"https://blog.csdn.net/no_endless/article/details/77073549\">《MySQL 聚集索引/非聚集索引简述》</a></li>\n<li><a href=\"https://www.cnblogs.com/zlcxbb/p/5757245.html\">《MyISAM和InnoDB的索引实现》</a></li>\n</ul>\n<p>MyISAM 是非聚集，InnoDB 是聚集</p>\n<h4 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/summer0space/p/7247778.html\">《复合索引的优点和注意事项》</a></p>\n<ul>\n<li>文中有一处错误：<blockquote>\n<p>对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引</p>\n</blockquote>\n</li>\n<li>原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/acode/p/7489258.html\">《MySQL查询where条件的顺序对查询效率的影响》</a></p>\n</li>\n</ul>\n<h4 id=\"自适应哈希索引-AHI\"><a href=\"#自适应哈希索引-AHI\" class=\"headerlink\" title=\"自适应哈希索引(AHI)\"></a>自适应哈希索引(AHI)</h4><ul>\n<li><a href=\"https://blog.csdn.net/Linux_ever/article/details/62043708\">《InnoDB存储引擎——自适应哈希索引》</a></li>\n</ul>\n<h3 id=\"explain\"><a href=\"#explain\" class=\"headerlink\" title=\"explain\"></a>explain</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008131735\">《MySQL 性能优化神器 Explain 使用分析》</a></li>\n</ul>\n<h2 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h2><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><ul>\n<li><a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\">MongoDB 教程</a></li>\n<li><a href=\"http://mxdxm.iteye.com/blog/2093603\">《Mongodb相对于关系型数据库的优缺点》</a><ul>\n<li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li>\n<li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hbase\"><a href=\"#Hbase\" class=\"headerlink\" title=\"Hbase\"></a>Hbase</h3><ul>\n<li><a href=\"http://www.thebigdata.cn/HBase/35831.html\">《简明 HBase 入门教程（开篇）》</a></li>\n<li><a href=\"https://www.cnblogs.com/qiaoyihang/p/6246424.html\">《深入学习HBase架构原理》</a></li>\n<li><a href=\"https://blog.csdn.net/youzhouliu/article/details/67632882\">《传统的行存储和（HBase）列存储的区别》</a></li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/lifuxiangcaohui/article/details/39891099\">《Hbase与传统数据库的区别》</a></p>\n<ul>\n<li>空数据不存储，节省空间，且适用于并发。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014091123/article/details/73163088\">《HBase Rowkey设计》</a></p>\n<ul>\n<li>rowkey 按照字典顺序排列，便于批量扫描。</li>\n<li>通过散列可以避免热点。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"搜索引擎\"><a href=\"#搜索引擎\" class=\"headerlink\" title=\"搜索引擎\"></a>搜索引擎</h1><h2 id=\"搜索引擎原理\"><a href=\"#搜索引擎原理\" class=\"headerlink\" title=\"搜索引擎原理\"></a>搜索引擎原理</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/0193dc44135b\">《倒排索引–搜索引擎入门》</a></li>\n</ul>\n<h2 id=\"Lucene\"><a href=\"#Lucene\" class=\"headerlink\" title=\"Lucene\"></a>Lucene</h2><ul>\n<li><a href=\"https://www.cnblogs.com/rodge-run/p/6551152.html\">《Lucene入门简介》</a></li>\n</ul>\n<h2 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h2><ul>\n<li><a href=\"https://blog.csdn.net/laoyang360/article/details/52244917\">《Elasticsearch学习，请先看这一篇！》</a></li>\n<li><a href=\"https://blog.csdn.net/cyony/article/details/65437708\">《Elasticsearch索引原理》</a></li>\n</ul>\n<h2 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h2><ul>\n<li><a href=\"https://blog.csdn.net/u011936655/article/details/51960005\">《 Apache Solr入门教程》</a></li>\n<li><a href=\"https://blog.csdn.net/convict_eva/article/details/53537837\">《elasticsearch与solr比较》</a></li>\n</ul>\n<h2 id=\"sphinx\"><a href=\"#sphinx\" class=\"headerlink\" title=\"sphinx\"></a>sphinx</h2><ul>\n<li><a href=\"http://blog.jobbole.com/101672/\">《Sphinx 的介绍和原理探索》</a></li>\n</ul>\n<h1 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h1><h2 id=\"性能优化方法论\"><a href=\"#性能优化方法论\" class=\"headerlink\" title=\"性能优化方法论\"></a>性能优化方法论</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread\">《15天的性能优化工作，5方面的调优经验》</a></p>\n<ul>\n<li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/tenglizhe/article/details/44563135\">《系统性能优化的几个方面》</a></p>\n</li>\n</ul>\n<h2 id=\"容量评估\"><a href=\"#容量评估\" class=\"headerlink\" title=\"容量评估\"></a>容量评估</h2><ul>\n<li><a href=\"https://blog.csdn.net/u012528360/article/details/70054156\">《联网性能与容量评估的方法论和典型案例》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect\">《互联网架构，如何进行容量设计？》</a><ul>\n<li>评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CDN-网络\"><a href=\"#CDN-网络\" class=\"headerlink\" title=\"CDN 网络\"></a>CDN 网络</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wxiaona/p/5867685.html\">《CDN加速原理》</a></li>\n<li><a href=\"https://www.zhihu.com/question/20536932\">《国内有哪些比较好的 CDN？》</a></li>\n</ul>\n<h2 id=\"连接池\"><a href=\"#连接池\" class=\"headerlink\" title=\"连接池\"></a>连接池</h2><ul>\n<li><a href=\"https://blog.csdn.net/fysuccess/article/details/66972554\">《主流Java数据库连接池比较与开发配置实战》</a></li>\n</ul>\n<h2 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h2><ul>\n<li><a href=\"https://blog.csdn.net/yethyeth/article/details/73266455\">《九大Java性能调试工具，必备至少一款》</a></li>\n</ul>\n<h1 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h1><h2 id=\"流式计算\"><a href=\"#流式计算\" class=\"headerlink\" title=\"流式计算\"></a>流式计算</h2><h3 id=\"Storm\"><a href=\"#Storm\" class=\"headerlink\" title=\"Storm\"></a>Storm</h3><ul>\n<li><a href=\"http://storm.apache.org/\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/uisoul/article/details/77989927\">《最详细的Storm入门教程》</a></li>\n</ul>\n<h3 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h3><ul>\n<li><a href=\"https://blog.csdn.net/lisi1129/article/details/54844919\">《Flink之一 Flink基本原理介绍》</a></li>\n</ul>\n<h3 id=\"Kafka-Stream\"><a href=\"#Kafka-Stream\" class=\"headerlink\" title=\"Kafka Stream\"></a>Kafka Stream</h3><ul>\n<li><a href=\"https://yq.aliyun.com/articles/58382\">《Kafka Stream调研：一种轻量级流计算模式》</a></li>\n</ul>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>例如：</p>\n<ul>\n<li>广告相关实时统计；</li>\n<li>推荐系统用户画像标签实时更新；</li>\n<li>线上服务健康状况实时监测；</li>\n<li>实时榜单；</li>\n<li>实时数据统计。</li>\n</ul>\n<h2 id=\"Hadoop\"><a href=\"#Hadoop\" class=\"headerlink\" title=\"Hadoop\"></a>Hadoop</h2><ul>\n<li><a href=\"https://blog.csdn.net/houbin0912/article/details/72967178\">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li>\n<li><a href=\"http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html\">《史上最详细的Hadoop环境搭建》</a></li>\n</ul>\n<h3 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000011575458\">《【Hadoop学习】HDFS基本原理》</a></li>\n</ul>\n<h3 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h3><ul>\n<li><a href=\"https://blog.csdn.net/oppo62258801/article/details/72884633\">《用通俗易懂的大白话讲解Map/Reduce原理》</a></li>\n<li><a href=\"https://blog.csdn.net/foye12/article/details/78358292\">《 简单的map-reduce的java例子》</a></li>\n</ul>\n<h3 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h3><ul>\n<li><a href=\"http://www.cnblogs.com/codeOfLife/p/5492740.html\">《初步掌握Yarn的架构及原理》</a></li>\n</ul>\n<h2 id=\"Spark\"><a href=\"#Spark\" class=\"headerlink\" title=\"Spark\"></a>Spark</h2><ul>\n<li><a href=\"http://www.cnblogs.com/tgzhu/p/5818374.html\">《Spark(一): 基本架构及原理》</a></li>\n<li><a href=\"http://dblab.xmu.edu.cn/blog/1709-2/\">《子雨大数据之Spark入门教程(Python版)》</a></li>\n</ul>\n<h1 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h1><h2 id=\"web-安全\"><a href=\"#web-安全\" class=\"headerlink\" title=\"web 安全\"></a>web 安全</h2><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><ul>\n<li><a href=\"https://blog.csdn.net/qq_21956483/article/details/54377947\">《xss攻击原理与解决方法》</a><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html\">《CSRF原理及防范》</a></li>\n</ul>\n<h3 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html\">《SQL注入》</a></li>\n</ul>\n<h3 id=\"Hash-Dos\"><a href=\"#Hash-Dos\" class=\"headerlink\" title=\"Hash Dos\"></a>Hash Dos</h3><ul>\n<li><a href=\"http://www.freebuf.com/articles/web/14199.html\">《邪恶的JAVA HASH DOS攻击》</a><ul>\n<li>利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li>\n</ul>\n</li>\n<li><a href=\"http://blog.it2048.cn/article_hash-collision.html\">《一种高级的DoS攻击-Hash碰撞攻击》</a></li>\n<li><a href=\"http://www.iteye.com/news/23939/\">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li>\n</ul>\n<h3 id=\"脚本注入\"><a href=\"#脚本注入\" class=\"headerlink\" title=\"脚本注入\"></a>脚本注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html\">《上传文件漏洞原理及防范》</a></li>\n</ul>\n<h3 id=\"漏洞扫描工具\"><a href=\"#漏洞扫描工具\" class=\"headerlink\" title=\"漏洞扫描工具\"></a>漏洞扫描工具</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html\">《DVWA》</a></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html\">W3af</a></li>\n<li><a href=\"https://blog.csdn.net/xygg0801/article/details/53610640\">OpenVAS详解</a></li>\n</ul>\n<h3 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/niaonao/article/details/51112686\">《验证码原理分析及实现》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/jiangbianwanghai/blog/1031031\">《详解滑动验证码的实现原理》</a></p>\n<ul>\n<li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/xcj26/p/5242758.html\">《淘宝滑动验证码研究》</a></p>\n</li>\n</ul>\n<h2 id=\"DDoS-防范\"><a href=\"#DDoS-防范\" class=\"headerlink\" title=\"DDoS 防范\"></a>DDoS 防范</h2><ul>\n<li><a href=\"http://netsecurity.51cto.com/art/201601/503799.htm\">《学习手册：DDoS的攻击方式及防御手段》</a></li>\n<li><a href=\"http://netsecurity.51cto.com/art/201406/442756.htm\">《免费DDoS攻击测试工具大合集》</a></li>\n</ul>\n<h2 id=\"用户隐私信息保护\"><a href=\"#用户隐私信息保护\" class=\"headerlink\" title=\"用户隐私信息保护\"></a>用户隐私信息保护</h2><ol>\n<li>用户密码非明文保存，加动态salt。</li>\n<li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li>\n<li>联系方式在的显示与否由用户自己控制。</li>\n<li>TODO</li>\n</ol>\n<ul>\n<li><p><a href=\"https://zhidao.baidu.com/question/1988017976673661587.html\">《个人隐私包括哪些》</a></p>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/20137108\">《在互联网上，隐私的范围包括哪些？》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html\">《用户密码保存》</a></p>\n</li>\n</ul>\n<h2 id=\"序列化漏洞\"><a href=\"#序列化漏洞\" class=\"headerlink\" title=\"序列化漏洞\"></a>序列化漏洞</h2><ul>\n<li><a href=\"https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/\">《Lib之过？Java反序列化漏洞通用利用分析》</a></li>\n</ul>\n<h2 id=\"加密解密\"><a href=\"#加密解密\" class=\"headerlink\" title=\"加密解密\"></a>加密解密</h2><h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html\">《常见对称加密算法》</a><ul>\n<li>DES、3DES、Blowfish、AES</li>\n<li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li>\n<li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html\">《常用的哈希算法》</a></p>\n<ul>\n<li>MD5 和 SHA-1 已经不再安全，已被弃用。</li>\n<li>目前 SHA-256 是比较安全的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhangruhong168/article/details/78033202\">《基于Hash摘要签名的公网URL签名验证设计方案》</a></p>\n</li>\n</ul>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html\">《常见非对称加密算法》</a></p>\n<ul>\n<li><p>RSA、DSA、ECDSA(螺旋曲线加密算法)</p>\n</li>\n<li><p>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</p>\n</li>\n<li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p>\n<p>  <a href=\"http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc\">《区块链的加密技术》</a>    </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务器安全\"><a href=\"#服务器安全\" class=\"headerlink\" title=\"服务器安全\"></a>服务器安全</h2><ul>\n<li><a href=\"http://www.freebuf.com/articles/system/121540.html\">《Linux强化论：15步打造一个安全的Linux服务器》</a></li>\n</ul>\n<h2 id=\"数据安全\"><a href=\"#数据安全\" class=\"headerlink\" title=\"数据安全\"></a>数据安全</h2><h3 id=\"数据备份\"><a href=\"#数据备份\" class=\"headerlink\" title=\"数据备份\"></a>数据备份</h3><p>TODO</p>\n<h2 id=\"网络隔离\"><a href=\"#网络隔离\" class=\"headerlink\" title=\"网络隔离\"></a>网络隔离</h2><h3 id=\"内外网分离\"><a href=\"#内外网分离\" class=\"headerlink\" title=\"内外网分离\"></a>内外网分离</h3><p>TODO</p>\n<h3 id=\"登录跳板机\"><a href=\"#登录跳板机\" class=\"headerlink\" title=\"登录跳板机\"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p>\n<ul>\n<li><a href=\"http://blog.51cto.com/zero01/2062618\">《搭建简易堡垒机》</a></li>\n</ul>\n<h2 id=\"授权、认证\"><a href=\"#授权、认证\" class=\"headerlink\" title=\"授权、认证\"></a>授权、认证</h2><ul>\n<li><a href=\"https://docs.authing.cn/authing/\">授权认证知识库</a></li>\n</ul>\n<h3 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h3><ul>\n<li><a href=\"https://www.cnblogs.com/zq8024/p/5003050.html\">《基于组织角色的权限设计》</a></li>\n<li><a href=\"https://www.cnblogs.com/shijiaqi1066/p/3793894.html\">《权限系统与RBAC模型概述》</a></li>\n<li><a href=\"https://blog.csdn.net/he90227/article/details/38663553\">《Spring整合Shiro做权限控制模块详细案例分析》</a></li>\n</ul>\n<h3 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\">《理解OAuth 2.0》</a></li>\n<li><a href=\"https://www.cnblogs.com/flashsun/p/7424071.html\">《一张图搞定OAuth2.0》</a></li>\n</ul>\n<h3 id=\"OIDC\"><a href=\"#OIDC\" class=\"headerlink\" title=\"OIDC\"></a>OIDC</h3><ul>\n<li><a href=\"https://docs.authing.cn/authing/advanced/oidc/li-jie-oidc-liu-cheng\">理解 OIDC</a></li>\n</ul>\n<h3 id=\"SAML\"><a href=\"#SAML\" class=\"headerlink\" title=\"SAML\"></a>SAML</h3><ul>\n<li><a href=\"https://docs.authing.cn/authing/advanced/use-saml/li-jie-saml-liu-cheng\">理解 SAML</a></li>\n</ul>\n<h3 id=\"双因素认证（2FA）\"><a href=\"#双因素认证（2FA）\" class=\"headerlink\" title=\"双因素认证（2FA）\"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p>\n<p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p>\n<ul>\n<li>【《双因素认证（2FA）教程》】(<a href=\"http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html\">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a>)</li>\n</ul>\n<h3 id=\"单点登录-SSO\"><a href=\"#单点登录-SSO\" class=\"headerlink\" title=\"单点登录(SSO)\"></a>单点登录(SSO)</h3><ul>\n<li><a href=\"https://www.cnblogs.com/ywlaker/p/6113927.html\">《单点登录原理与简单实现》</a></li>\n<li><a href=\"https://github.com/apereo/cas\">CAS单点登录框架</a></li>\n<li><a href=\"https://docs.authing.cn/authing/quickstart/implement-sso-with-authing\">使用 Authing 实现单点登录</a></li>\n</ul>\n<h1 id=\"常用开源框架\"><a href=\"#常用开源框架\" class=\"headerlink\" title=\"常用开源框架\"></a>常用开源框架</h1><h2 id=\"开源协议\"><a href=\"#开源协议\" class=\"headerlink\" title=\"开源协议\"></a>开源协议</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html\">《开源协议的选择》</a></p>\n</li>\n<li><p><a href=\"http://choosealicense.online/\">如何选择一个开源软件协议</a></p>\n</li>\n</ul>\n<h2 id=\"日志框架\"><a href=\"#日志框架\" class=\"headerlink\" title=\"日志框架\"></a>日志框架</h2><h3 id=\"Log4j、Log4j2\"><a href=\"#Log4j、Log4j2\" class=\"headerlink\" title=\"Log4j、Log4j2\"></a>Log4j、Log4j2</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012422446/article/details/51199724\">《log4j 详细讲解》</a></li>\n<li><a href=\"https://blog.csdn.net/vbirdbest/article/details/71751835\">《log4j2 实际使用详解》</a></li>\n<li><a href=\"https://my.oschina.net/OutOfMemory/blog/789267\">《Log4j1,Logback以及Log4j2性能测试对比》</a><ul>\n<li>Log4J 异步日志性能优异。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Logback\"><a href=\"#Logback\" class=\"headerlink\" title=\"Logback\"></a>Logback</h3><ul>\n<li><a href=\"https://blog.csdn.net/rulon147/article/details/52620541\">《最全LogBack 详解、含java案例和配置说明》</a></li>\n</ul>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><ul>\n<li><a href=\"https://blog.csdn.net/sinat_34093604/article/details/53082000\">《ORM框架使用优缺点》</a><ul>\n<li>主要目的是为了提高开发效率。 </li>\n</ul>\n</li>\n</ul>\n<p><strong>MyBatis：</strong></p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/winclpt/articles/7511672.html\">《mybatis缓存机制详解》</a></p>\n<ul>\n<li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li>\n<li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/baidu_32877851/article/details/53959268\">《MyBatis学习之代码生成器Generator》</a></p>\n</li>\n</ul>\n<h2 id=\"网络框架\"><a href=\"#网络框架\" class=\"headerlink\" title=\"网络框架\"></a>网络框架</h2><p>TODO</p>\n<h2 id=\"Web-框架\"><a href=\"#Web-框架\" class=\"headerlink\" title=\"Web 框架\"></a>Web 框架</h2><h3 id=\"Spring-家族\"><a href=\"#Spring-家族\" class=\"headerlink\" title=\"Spring 家族\"></a>Spring 家族</h3><p><strong>Spring</strong></p>\n<ul>\n<li><a href=\"https://www.w3cschool.cn/wkspring/\">Spring 简明教程</a></li>\n</ul>\n<p><strong>Spring Boot</strong></p>\n<ul>\n<li><a href=\"http://projects.spring.io/spring-boot/\">官方网站</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\">《Spring Boot基础教程》</a></li>\n</ul>\n<p><strong>Spring Cloud</strong></p>\n<ul>\n<li><a href=\"http://springboot.fun/\">Spring Boot 中文索引站</a></li>\n<li><a href=\"https://springcloud.cc/\">Spring Cloud 中文文档</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\">《Spring Cloud基础教程》</a></li>\n</ul>\n<h2 id=\"工具框架\"><a href=\"#工具框架\" class=\"headerlink\" title=\"工具框架\"></a>工具框架</h2><ul>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4872236.html\">《Apache Commons 工具类介绍及简单使用》</a></li>\n<li><a href=\"http://ifeve.com/google-guava/\">《Google guava 中文教程》</a></li>\n</ul>\n<h1 id=\"分布式设计\"><a href=\"#分布式设计\" class=\"headerlink\" title=\"分布式设计\"></a>分布式设计</h1><h2 id=\"扩展性设计\"><a href=\"#扩展性设计\" class=\"headerlink\" title=\"扩展性设计\"></a>扩展性设计</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/hemin1003/article/details/53633926\">《架构师不可不知的十大可扩展架构》</a></p>\n<ul>\n<li>总结下来，通用的套路就是分布、缓存及异步处理。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://yq.aliyun.com/articles/38119\">《可扩展性设计之数据切分》</a></p>\n<ul>\n<li>水平切分+垂直切分</li>\n<li>利用中间件进行分片如，MySQL Proxy。</li>\n<li>利用分片策略进行切分，如按照ID取模。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/deniro_li/article/details/78458306\">《说说如何实现可扩展性的大型网站架构》</a></p>\n<ul>\n<li>分布式服务+消息队列。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chaofanwei/article/details/29191073\">《大型网站技术架构（七）–网站的可扩展性架构》</a></p>\n</li>\n</ul>\n<h2 id=\"稳定性-amp-高可用\"><a href=\"#稳定性-amp-高可用\" class=\"headerlink\" title=\"稳定性 &amp; 高可用\"></a>稳定性 &amp; 高可用</h2><ul>\n<li><a href=\"https://blog.csdn.net/hustspy1990/article/details/78008324\">《系统设计：关于高可用系统的一些技术方案》</a><ul>\n<li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li>\n<li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li>\n<li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li>\n<li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li>\n<li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li>\n<li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li>\n<li>自动化测试：通过完善的测试，减少发布引起的故障。</li>\n<li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><a href=\"https://coolshell.cn/articles/17459.html\">《关于高可用的系统》</a><ul>\n<li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"硬件负载均衡\"><a href=\"#硬件负载均衡\" class=\"headerlink\" title=\"硬件负载均衡\"></a>硬件负载均衡</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/wuyun-blog/p/6186198.html\">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a></p>\n<ul>\n<li>主要是和F5对比。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lcword/p/5773296.html\">《软/硬件负载均衡产品 你知多少？》</a></p>\n</li>\n</ul>\n<h3 id=\"软件负载均衡\"><a href=\"#软件负载均衡\" class=\"headerlink\" title=\"软件负载均衡\"></a>软件负载均衡</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/tianzhiliang/articles/2317808.html\">《几种负载均衡算法》</a><br>  轮寻、权重、负载、最少连接、QoS</p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html\">《DNS负载均衡》</a></p>\n<ul>\n<li>配置简单，更新速度慢。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html\">《Nginx负载均衡》</a></p>\n<ul>\n<li>简单轻量、学习成本低；主要适用于web应用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/edisonchou/p/4281978.html\">《借助LVS+Keepalived实现负载均衡 》</a></p>\n<ul>\n<li>配置比较负载、只支持到4层，性能较高。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ttlsa.com/linux/haproxy-study-tutorial/\">《HAProxy用法详解 全网最详细中文文档》</a></p>\n<ul>\n<li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.itpub.net/25704976/viewspace-1319781/\">《Haproxy+Keepalived+MySQL实现读均衡负载》</a></p>\n<ul>\n<li>主要是用户读请求的负载均衡。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lylife/p/5584019.html\">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></p>\n</li>\n</ul>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><ul>\n<li><a href=\"https://www.cnblogs.com/haoxinyue/p/6792309.html\">《谈谈高并发系统的限流》</a><ul>\n<li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li>\n<li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li>\n<li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li>\n<li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层容灾\"><a href=\"#应用层容灾\" class=\"headerlink\" title=\"应用层容灾\"></a>应用层容灾</h3><ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000005988895\">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a></p>\n<ul>\n<li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 </li>\n<li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li>\n<li>Hystrix设计原则：<ul>\n<li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li>\n<li>熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。</li>\n<li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\">《缓存击穿、失效以及热点key问题》</a> </p>\n<ul>\n<li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li>\n<li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"跨机房容灾\"><a href=\"#跨机房容灾\" class=\"headerlink\" title=\"跨机房容灾\"></a>跨机房容灾</h3><ul>\n<li><p><a href=\"http://dc.idcquan.com/ywgl/71559.shtml\">《“异地多活”多机房部署经验谈》</a></p>\n<ul>\n<li>通过自研中间件进行数据同步。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/jeffreynicole/article/details/48135093\">《异地多活（异地双活）实践经验》</a></p>\n<ul>\n<li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li>\n<li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li>\n<li>不能依赖于程序端数据双写，要有自动同步方案。 </li>\n<li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li>\n<li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li>\n<li>异地多活监控部署、测试也要跟上。</li>\n<li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li>\n<li>控制跨机房消息体大小，越小越好。</li>\n<li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yoara/article/details/38013751\">容灾技术及建设经验介绍</a></p>\n</li>\n</ul>\n<h3 id=\"容灾演练流程\"><a href=\"#容灾演练流程\" class=\"headerlink\" title=\"容灾演练流程\"></a>容灾演练流程</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5\">《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》</a><ul>\n<li>常见故障画像</li>\n<li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平滑启动\"><a href=\"#平滑启动\" class=\"headerlink\" title=\"平滑启动\"></a>平滑启动</h3><ul>\n<li>平滑重启应用思路</li>\n</ul>\n<p>1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/u011001084/article/details/73480432\">《JVM安全退出（如何优雅的关闭java服务）》</a><br>推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</li>\n<li><a href=\"http://ju.outofmemory.cn/entry/337235\">《常见Java应用如何优雅关闭》</a><br>Java、Spring、Dubbo 优雅关闭方式。</li>\n</ul>\n<h2 id=\"数据库扩展\"><a href=\"#数据库扩展\" class=\"headerlink\" title=\"数据库扩展\"></a>数据库扩展</h2><h3 id=\"读写分离模式\"><a href=\"#读写分离模式\" class=\"headerlink\" title=\"读写分离模式\"></a>读写分离模式</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/houdj/p/6563771.html\">《Mysql主从方案的实现》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/edisonchou/p/4133148.html\">《搭建MySQL主从复制经典架构》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/nimasike/article/details/48048341\">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhangsubai/p/6801764.html\">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a></p>\n<ul>\n<li>DRDB 进行磁盘复制，避免单点问题。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html\">《MySQL Cluster 方式》</a></p>\n</li>\n</ul>\n<h3 id=\"分片模式\"><a href=\"#分片模式\" class=\"headerlink\" title=\"分片模式\"></a>分片模式</h3><ul>\n<li><p><a href=\"https://www.jianshu.com/p/32b3e91aa22c\">《分库分表需要考虑的问题及方案》</a></p>\n<ul>\n<li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li>\n<li>问题：事务、Join、迁移、扩容、ID、分页等。</li>\n<li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li>\n<li>分库策略：数值范围；取模；日期等。</li>\n<li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201503/380348.html\">《MySql分表和表分区详解》</a></p>\n<ul>\n<li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li>\n<li>分表：物理上创建不同的表、客户端需要管理分表路由。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h2><h3 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/jiaolongdy/article/details/51188798\">《永不失联！如何实现微服务架构中的服务发现？》</a></p>\n<ul>\n<li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li>\n<li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u010963948/article/details/71730165\">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a></p>\n<ul>\n<li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li>\n<li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://mobile.51cto.com/news-502394.htm\">《基于Zookeeper的服务注册与发现》</a></p>\n<ul>\n<li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务路由控制\"><a href=\"#服务路由控制\" class=\"headerlink\" title=\"服务路由控制\"></a>服务路由控制</h3><ul>\n<li><a href=\"https://blog.csdn.net/xundh/article/details/59492750\">《分布式服务框架学习笔记4 服务路由》</a><ul>\n<li>原则：透明化路由</li>\n<li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li>\n<li>本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li>\n<li>配置方式：统一注册表；本地配置；动态下发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式一致\"><a href=\"#分布式一致\" class=\"headerlink\" title=\"分布式一致\"></a>分布式一致</h2><h3 id=\"CAP-与-BASE-理论\"><a href=\"#CAP-与-BASE-理论\" class=\"headerlink\" title=\"CAP 与 BASE 理论\"></a>CAP 与 BASE 理论</h3><ul>\n<li><a href=\"http://www.cnblogs.com/szlbm/p/5588543.html\">《从分布式一致性谈到CAP理论、BASE理论》</a><ul>\n<li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li>\n<li>CAP：一致性、可用性、分区容错性(网络故障引起)</li>\n<li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li>\n<li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><p><a href=\"http://www.hollischuang.com/archives/1716\">《分布式锁的几种实现方式》</a></p>\n<ul>\n<li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li>\n<li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li>\n<li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.tuicool.com/articles/VZJr6fY\">《基于Zookeeper的分布式锁》</a></p>\n<ul>\n<li>清楚的原理描述 + Java 代码示例。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/0201zcr/p/5942748.html\">《jedisLock—redis分布式锁实现》</a></p>\n<ul>\n<li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/albertfly/article/details/77412333\">《Memcached 和 Redis 分布式锁方案》</a></p>\n<ul>\n<li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致性算法\"><a href=\"#分布式一致性算法\" class=\"headerlink\" title=\"分布式一致性算法\"></a>分布式一致性算法</h3><h4 id=\"PAXOS\"><a href=\"#PAXOS\" class=\"headerlink\" title=\"PAXOS\"></a>PAXOS</h4><ul>\n<li><a href=\"https://www.cnblogs.com/linbingdong/p/6253479.html\">《分布式系列文章——Paxos算法原理与推导》</a></li>\n<li><a href=\"https://blog.csdn.net/u010039929/article/details/70171672\">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li>\n<li><a href=\"https://www.cnblogs.com/leesf456/p/6012777.html\">《【分布式】Zookeeper与Paxos》</a></li>\n</ul>\n<h4 id=\"Zab\"><a href=\"#Zab\" class=\"headerlink\" title=\"Zab\"></a>Zab</h4><ul>\n<li><a href=\"https://www.jianshu.com/p/fb527a64deee\">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li>\n</ul>\n<h4 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h4><ul>\n<li><a href=\"http://www.cnblogs.com/mindwind/p/5231986.html\">《Raft 为什么是更易理解的分布式一致性算法》</a><ul>\n<li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li>\n<li>通过随机等待的方式发出投票，得票多的获胜。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Gossip\"><a href=\"#Gossip\" class=\"headerlink\" title=\"Gossip\"></a>Gossip</h4><ul>\n<li><a href=\"http://blog.51cto.com/tianya23/530743\">《Gossip算法》</a></li>\n</ul>\n<h4 id=\"两阶段提交、多阶段提交\"><a href=\"#两阶段提交、多阶段提交\" class=\"headerlink\" title=\"两阶段提交、多阶段提交\"></a>两阶段提交、多阶段提交</h4><ul>\n<li><a href=\"http://blog.jobbole.com/95632/\">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li>\n</ul>\n<h3 id=\"幂等\"><a href=\"#幂等\" class=\"headerlink\" title=\"幂等\"></a>幂等</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wxgblogs/p/6639272.html\">《分布式系统—幂等性设计》</a><ul>\n<li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li>\n<li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致方案\"><a href=\"#分布式一致方案\" class=\"headerlink\" title=\"分布式一致方案\"></a>分布式一致方案</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency\">《分布式系统事务一致性解决方案》</a></li>\n<li><a href=\"https://weibo.com/ttarticle/p/show?id=2309403965965003062676\">《保证分布式系统数据一致性的6种方案》</a></li>\n</ul>\n<h3 id=\"分布式-Leader-节点选举\"><a href=\"#分布式-Leader-节点选举\" class=\"headerlink\" title=\"分布式 Leader 节点选举\"></a>分布式 Leader 节点选举</h3><ul>\n<li><a href=\"https://blog.csdn.net/johnson_moon/article/details/78809995\">《利用zookeeper实现分布式leader节点选举》</a></li>\n</ul>\n<h3 id=\"TCC-Try-Confirm-Cancel-柔性事务\"><a href=\"#TCC-Try-Confirm-Cancel-柔性事务\" class=\"headerlink\" title=\"TCC(Try/Confirm/Cancel) 柔性事务\"></a>TCC(Try/Confirm/Cancel) 柔性事务</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/ab1a1c6b08a1\">《传统事务与柔性事务》</a><ul>\n<li>基于BASE理论：基本可用、柔性状态、最终一致。</li>\n<li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式文件系统\"><a href=\"#分布式文件系统\" class=\"headerlink\" title=\"分布式文件系统\"></a>分布式文件系统</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27666295\">说说分布式文件存储系统-基本架构</a> ？</li>\n<li><a href=\"https://blog.csdn.net/gatieme/article/details/44982961\">《各种分布式文件系统的比较》</a> ？<ul>\n<li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li>\n<li>FastDFS：轻量级、适合小文件。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"唯一ID-生成\"><a href=\"#唯一ID-生成\" class=\"headerlink\" title=\"唯一ID 生成\"></a>唯一ID 生成</h2><h3 id=\"全局唯一ID\"><a href=\"#全局唯一ID\" class=\"headerlink\" title=\"全局唯一ID\"></a>全局唯一ID</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/baiwa/p/5318432.html\">《高并发分布式系统中生成全局唯一Id汇总》</a></p>\n<ul>\n<li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li>\n<li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” </li>\n<li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li>\n<li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/hdu09075340/article/details/79103851\">《TDDL 在分布式下的SEQUENCE原理》</a></p>\n<ul>\n<li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li>\n<li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li>\n<li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一致性Hash算法\"><a href=\"#一致性Hash算法\" class=\"headerlink\" title=\"一致性Hash算法\"></a>一致性Hash算法</h2><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html\">《一致性哈希算法》</a></li>\n</ul>\n<h1 id=\"设计思想-amp-开发模式\"><a href=\"#设计思想-amp-开发模式\" class=\"headerlink\" title=\"设计思想 &amp; 开发模式\"></a>设计思想 &amp; 开发模式</h1><h2 id=\"DDD-Domain-driven-Design-领域驱动设计\"><a href=\"#DDD-Domain-driven-Design-领域驱动设计\" class=\"headerlink\" title=\"DDD(Domain-driven Design - 领域驱动设计)\"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/netfocus/p/5548025.html\">《浅谈我对DDD领域驱动设计的理解》</a></p>\n<ul>\n<li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li>\n<li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li>\n<li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/butterfly100/p/7827870.html\">《领域驱动设计的基础知识总结》</a></p>\n<ul>\n<li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li>\n<li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li>\n<li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li>\n<li>领域通用语言：领域专家、开发设计人员都能理解的语言或工具。</li>\n<li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li>\n<li>使用的模式：<ul>\n<li>关联尽量少，尽量单项，尽量降低整体复杂度。</li>\n<li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li>\n<li>值对象（Value Object）：没有唯一标识，且属性值不可变，小而简单的对象，比如Date。</li>\n<li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li>\n<li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li>\n<li>工厂（Factory）：类似于设计模式中的工厂模式。</li>\n<li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Leo_wl/p/3866629.html\">《领域驱动设计(DDD)实现之路》</a></p>\n<ul>\n<li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.hollischuang.com/archives/553\">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></p>\n</li>\n</ul>\n<h3 id=\"命令查询职责分离-CQRS\"><a href=\"#命令查询职责分离-CQRS\" class=\"headerlink\" title=\"命令查询职责分离(CQRS)\"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/cnblogsfans/p/4551990.html\">《领域驱动设计系列 (六)：CQRS》</a></p>\n<ul>\n<li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml\">《DDD CQRS架构和传统架构的优缺点比较》</a></p>\n<ul>\n<li>最终一致的设计理念；依赖于高可用消息中间件。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/netfocus/p/4055346.html\">《CQRS架构简介》</a></p>\n<ul>\n<li>一个实现 CQRS 的抽象案例。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.uml.org.cn/zjjs/201609221.asp\">《深度长文：我对CQRS/EventSourcing架构的思考》</a></p>\n<ul>\n<li>CQRS 模式分析 + 12306 抢票案例</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"贫血，充血模型\"><a href=\"#贫血，充血模型\" class=\"headerlink\" title=\"贫血，充血模型\"></a>贫血，充血模型</h3><ul>\n<li><a href=\"https://kb.cnblogs.com/page/520743/\">《贫血，充血模型的解释以及一些经验》</a><ul>\n<li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li>\n<li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li>\n<li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li>\n<li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li>\n<li>作者主张使用贫血模式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Actor-模式\"><a href=\"#Actor-模式\" class=\"headerlink\" title=\"Actor 模式\"></a>Actor 模式</h2><p>TODO</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><h3 id=\"Reactor\"><a href=\"#Reactor\" class=\"headerlink\" title=\"Reactor\"></a>Reactor</h3><p>TODO</p>\n<h3 id=\"RxJava\"><a href=\"#RxJava\" class=\"headerlink\" title=\"RxJava\"></a>RxJava</h3><p>TODO</p>\n<h3 id=\"Vert-x\"><a href=\"#Vert-x\" class=\"headerlink\" title=\"Vert.x\"></a>Vert.x</h3><p>TODO</p>\n<h2 id=\"DODAF2-0\"><a href=\"#DODAF2-0\" class=\"headerlink\" title=\"DODAF2.0\"></a>DODAF2.0</h2><ul>\n<li><a href=\"http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml\">《DODAF2.0方法论》</a></li>\n<li><a href=\"http://blog.51cto.com/xiaoyong/1553164\">《DODAF2.0之能力视角如何落地》</a></li>\n</ul>\n<h2 id=\"Serverless\"><a href=\"#Serverless\" class=\"headerlink\" title=\"Serverless\"></a>Serverless</h2><p>无需过多关系服务器的服务架构理念。</p>\n<ul>\n<li><p><a href=\"http://www.jdon.com/soa/serverless.html\">《什么是Serverless无服务器架构？》</a></p>\n<ul>\n<li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li>\n<li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li>\n<li>Serverless 不代表某个具体的框架。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless\">《如何理解Serverless？》</a></p>\n<ul>\n<li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Service-Mesh\"><a href=\"#Service-Mesh\" class=\"headerlink\" title=\"Service Mesh\"></a>Service Mesh</h2><ul>\n<li><a href=\"https://time.geekbang.org/article/2355\">《什么是Service Mesh？》</a></li>\n<li><a href=\"https://www.jianshu.com/p/e23e3e74538e\">《初识 Service Mesh》</a></li>\n</ul>\n<h1 id=\"项目管理\"><a href=\"#项目管理\" class=\"headerlink\" title=\"项目管理\"></a>项目管理</h1><h2 id=\"架构评审\"><a href=\"#架构评审\" class=\"headerlink\" title=\"架构评审\"></a>架构评审</h2><ul>\n<li><a href=\"http://developer.51cto.com/art/201506/478486.htm\">《架构设计之如何评审架构设计说明书》</a></li>\n<li><a href=\"https://blog.csdn.net/wireless_com/article/details/45935591\">《人人都是架构师：非功能性需求》</a></li>\n</ul>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/architect-12-rules-complete/\">《架构之重构的12条军规》</a></li>\n</ul>\n<h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><ul>\n<li><a href=\"https://github.com/alibaba/p3c\">《阿里巴巴Java开发手册》</a></li>\n</ul>\n<h2 id=\"代码-Review\"><a href=\"#代码-Review\" class=\"headerlink\" title=\"代码 Review\"></a>代码 Review</h2><p>制度还是制度!<br>另外，每个公司需要根据自己的需求和目标制定自己的 check list</p>\n<ul>\n<li><p><a href=\"http://www.sohu.com/a/229745352_181657\">《为什么你做不好 Code Review？》</a></p>\n<ul>\n<li>代码 review 做的好，在于制度建设。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/uxyheaven/article/details/49773619\">《从零开始Code Review》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zuoping/p/5477047.html\">《Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://dzone.com/articles/java-code-review-checklist\">《Java Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/legend0011/article/details/45585575\">《如何用 gitlab 做 code review》</a></p>\n</li>\n</ul>\n<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2><ul>\n<li><a href=\"https://blog.csdn.net/apanious/article/details/51011946\">《运用RUP 4+1视图方法进行软件架构设计》</a></li>\n</ul>\n<h2 id=\"看板管理\"><a href=\"#看板管理\" class=\"headerlink\" title=\"看板管理\"></a>看板管理</h2><ul>\n<li><a href=\"https://blog.csdn.net/tkchen/article/details/51637643\">《说说看板在项目中的应用》</a></li>\n</ul>\n<h2 id=\"SCRUM\"><a href=\"#SCRUM\" class=\"headerlink\" title=\"SCRUM\"></a>SCRUM</h2><p>SCRUM - 争球</p>\n<ul>\n<li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li>\n<li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li>\n<li>五个价值观：专注、勇气、公开、承诺、尊重。</li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/inny100_100/article/details/54633757\">《敏捷项目管理流程-Scrum框架最全总结！》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/superkunkun/article/details/52951142\">《敏捷其实很简单3—敏捷方法之scrum》</a></p>\n</li>\n</ul>\n<h2 id=\"敏捷开发\"><a href=\"#敏捷开发\" class=\"headerlink\" title=\"敏捷开发\"></a>敏捷开发</h2><p>TODO</p>\n<h2 id=\"极限编程（XP）\"><a href=\"#极限编程（XP）\" class=\"headerlink\" title=\"极限编程（XP）\"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p>\n<ul>\n<li><p><a href=\"http://www.woshipm.com/pmd/406917.html\">《主流敏捷开发方法：极限编程XP》</a></p>\n<ul>\n<li><p>是一种指导开发人员的方法论。</p>\n</li>\n<li><p>4大价值：</p>\n<ul>\n<li>沟通：鼓励口头沟通，提高效率。</li>\n<li>简单：够用就好。</li>\n<li>反馈：及时反馈、通知相关人。</li>\n<li>勇气：提倡拥抱变化，敢于重构。</li>\n</ul>\n</li>\n<li><p>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</p>\n</li>\n<li><p>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"结对编程\"><a href=\"#结对编程\" class=\"headerlink\" title=\"结对编程\"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B\">《结对编程》</a></li>\n</ul>\n<h2 id=\"PDCA-循环质量管理\"><a href=\"#PDCA-循环质量管理\" class=\"headerlink\" title=\"PDCA 循环质量管理\"></a>PDCA 循环质量管理</h2><p>P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/PDCA\">《PDCA》</a></li>\n</ul>\n<h2 id=\"FMEA管理模式\"><a href=\"#FMEA管理模式\" class=\"headerlink\" title=\"FMEA管理模式\"></a>FMEA管理模式</h2><p>TODO</p>\n<h1 id=\"通用业务术语\"><a href=\"#通用业务术语\" class=\"headerlink\" title=\"通用业务术语\"></a>通用业务术语</h1><p>TODO</p>\n<h1 id=\"技术趋势\"><a href=\"#技术趋势\" class=\"headerlink\" title=\"技术趋势\"></a>技术趋势</h1><p>TODO</p>\n<h1 id=\"政策、法规\"><a href=\"#政策、法规\" class=\"headerlink\" title=\"政策、法规\"></a>政策、法规</h1><h2 id=\"法律\"><a href=\"#法律\" class=\"headerlink\" title=\"法律\"></a>法律</h2><ul>\n<li><p><a href=\"https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/16843044\">《中华人民共和国网络安全法》</a></p>\n<ul>\n<li>2016年11月7日发布，自2017年6月1日起施行</li>\n</ul>\n</li>\n<li><p><a href=\"https://baike.baidu.com/item/个人信息保护法/8343360\">《个人信息保护法》</a></p>\n<ul>\n<li>个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。</li>\n</ul>\n</li>\n<li><p><a href=\"https://baike.baidu.com/item/最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释/20497481\">《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》</a></p>\n<ul>\n<li>《解释》共十三条，自2017年6月1日起施行<blockquote>\n<ul>\n<li>1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”；</li>\n<li>2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上；</li>\n<li>3、对于其他公民个人信息，标准为 5000条以上。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://baike.baidu.com/item/中华人民共和国电子商务法/16467544\">《中华人民共和国电子商务法》</a></p>\n<ul>\n<li>2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行</li>\n<li><a href=\"https://v.youku.com/v_show/id_XNDAzNjAyNDM0MA==.html\">解读电子商务法（一）什么是电商</a></li>\n<li><a href=\"https://v.youku.com/v_show/id_XNDA1OTc0OTQ5Mg==.html\">解读电子商务法（二）电商经营者</a></li>\n<li><a href=\"https://v.youku.com/v_show/id_XNDA4NzIyNjI4MA==.html\">解读电子商务法（三）电商行为规范</a></li>\n<li><a href=\"https://v.qq.com/x/page/e08443fc1cr.html\">解读电子商务法（四）电商的法律关系</a></li>\n<li><a href=\"https://v.youku.com/v_show/id_XNDA4MTQ2Nzk4NA==.html\">解读电子商务法（外传）电商挣钱的秘密</a></li>\n<li><a href=\"https://v.qq.com/x/page/j0844twjwr5.html\">解读电子商务法（外传）电商模式</a></li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/a331685690/article/details/79917772\">程序员需要知道的法律常识</a></p>\n</li>\n<li><p><a href=\"https://time.geekbang.org/column/132\">白话法律42讲-为程序员打造的专属法律武器</a></p>\n</li>\n</ul>\n<h3 id=\"严格遵守刑法253法条\"><a href=\"#严格遵守刑法253法条\" class=\"headerlink\" title=\"严格遵守刑法253法条\"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p>\n<blockquote>\n<ul>\n<li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li>\n<li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 </li>\n<li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li>\n</ul>\n</blockquote>\n<p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA\">《非法获取公民个人信息罪》</a></li>\n</ul>\n<h3 id=\"避风港原则\"><a href=\"#避风港原则\" class=\"headerlink\" title=\"避风港原则\"></a>避风港原则</h3><p>“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E9%81%BF%E9%A3%8E%E6%B8%AF%E5%8E%9F%E5%88%99/588459?fr=aladdin\">《避风港原则》</a></li>\n</ul>\n<h1 id=\"架构师素质\"><a href=\"#架构师素质\" class=\"headerlink\" title=\"架构师素质\"></a>架构师素质</h1><ul>\n<li><p><a href=\"http://hellojava.info/?p=430\">《架构师画像》</a></p>\n<ul>\n<li>业务理解和抽象能力</li>\n<li>NB的代码能力</li>\n<li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； </li>\n<li>全局：是否考虑到了对上下游的系统的影响。</li>\n<li>权衡：权衡投入产出比；优先级和节奏控制；</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know\">《关于架构优化和设计，架构师必须知道的事情》</a></p>\n<ul>\n<li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。</li>\n<li>基础设施、配置、测试、开发、运维综合考虑。</li>\n<li>考虑人、团队、和组织的影响。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/19841397\">《如何才能真正的提高自己，成为一名出色的架构师？》</a> </p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129\">《架构师的必备素质和成长途径》</a></p>\n<ul>\n<li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li>\n<li>成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.51cto.com/frankfan/1248401\">《架构设计师—你在哪层楼？》</a></p>\n<ul>\n<li>第一层的架构师看到的只是产品本身</li>\n<li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li>\n<li>第三层的架构师看到的是商业价值 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"团队管理\"><a href=\"#团队管理\" class=\"headerlink\" title=\"团队管理\"></a>团队管理</h1><p>TODO</p>\n<h2 id=\"招聘\"><a href=\"#招聘\" class=\"headerlink\" title=\"招聘\"></a>招聘</h2><h1 id=\"资讯\"><a href=\"#资讯\" class=\"headerlink\" title=\"资讯\"></a>资讯</h1><h2 id=\"行业资讯\"><a href=\"#行业资讯\" class=\"headerlink\" title=\"行业资讯\"></a>行业资讯</h2><ul>\n<li><a href=\"http://36kr.com/\">36kr</a></li>\n<li><a href=\"http://www.techweb.com.cn/\">Techweb</a></li>\n</ul>\n<h2 id=\"公众号列表\"><a href=\"#公众号列表\" class=\"headerlink\" title=\"公众号列表\"></a>公众号列表</h2><p>TODO</p>\n<h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><h3 id=\"团队博客\"><a href=\"#团队博客\" class=\"headerlink\" title=\"团队博客\"></a>团队博客</h3><ul>\n<li><a href=\"http://jm.taobao.org/\">阿里中间件博客</a></li>\n<li><a href=\"https://tech.meituan.com\">美团点评技术团队博客</a></li>\n</ul>\n<h3 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/\">阮一峰的网络日志</a></li>\n<li><a href=\"https://coolshell.cn/\">酷壳 - COOLSHELL-陈皓</a></li>\n<li><a href=\"http://hellojava.info/\">hellojava-阿里毕玄</a></li>\n<li><a href=\"http://cmsblogs.com/\">Cm’s Blog</a></li>\n<li><a href=\"http://blog.didispace.com/\">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li>\n</ul>\n<h2 id=\"综合门户、社区\"><a href=\"#综合门户、社区\" class=\"headerlink\" title=\"综合门户、社区\"></a>综合门户、社区</h2><p><strong>国内：</strong></p>\n<ul>\n<li><p><a href=\"http://csdn.net\">CSDN</a><br>   老牌技术社区、不必解释。</p>\n</li>\n<li><p><a href=\"http://www.51cto.com/\">51cto.com</a></p>\n</li>\n<li><p><a href=\"http://www.iteye.com/\">ITeye</a></p>\n<ul>\n<li>偏 Java 方向 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com\">博客园</a></p>\n</li>\n<li><p><a href=\"http://www.chinaunix.net/\">ChinaUnix</a></p>\n<ul>\n<li>偏 Linux 方向 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.oschina.net/\">开源中国社区</a></p>\n</li>\n<li><p><a href=\"https://www.infoq.cn/\">InfoQ</a></p>\n</li>\n<li><p><a href=\"http://www.open-open.com/\">深度开源</a></p>\n</li>\n<li><p><a href=\"http://www.jobbole.com/\">伯乐在线</a></p>\n<ul>\n<li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.itpub.net/\">ITPUB</a></p>\n</li>\n<li><p><a href=\"https://cloud.tencent.com/developer/column\">腾讯云— 云+社区</a></p>\n</li>\n<li><p><a href=\"https://yq.aliyun.com/\">阿里云— 云栖社区</a></p>\n</li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/\">IBM DeveloperWorks</a></p>\n</li>\n<li><p><a href=\"https://toutiao.io/\">开发者头条</a></p>\n</li>\n<li><p><a href=\"http://www.linkedkeeper.com\">LinkedKeeper</a></p>\n</li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"https://dzone.com\">DZone</a></li>\n<li><a href=\"https://www.reddit.com\">Reddit</a></li>\n</ul>\n<h2 id=\"问答、讨论类社区\"><a href=\"#问答、讨论类社区\" class=\"headerlink\" title=\"问答、讨论类社区\"></a>问答、讨论类社区</h2><ul>\n<li><a href=\"https://segmentfault.com\">segmentfault</a><ul>\n<li>问答+专栏 </li>\n</ul>\n</li>\n<li><a href=\"https://www.zhihu.com/\">知乎</a></li>\n<li><a href=\"https://stackoverflow.com/\">stackoverflow</a></li>\n</ul>\n<h2 id=\"行业数据分析\"><a href=\"#行业数据分析\" class=\"headerlink\" title=\"行业数据分析\"></a>行业数据分析</h2><ul>\n<li><p><a href=\"http://report.iresearch.cn/\">艾瑞网</a></p>\n</li>\n<li><p><a href=\"https://www.questmobile.com.cn\">QUEST MOBILE</a></p>\n</li>\n<li><p><a href=\"http://data.stats.gov.cn/\">国家数据</a></p>\n</li>\n<li><p><a href=\"http://www.talkingdata.com/\">TalkingData</a></p>\n</li>\n</ul>\n<h2 id=\"专项网站\"><a href=\"#专项网站\" class=\"headerlink\" title=\"专项网站\"></a>专项网站</h2><ul>\n<li><p>测试:</p>\n<ul>\n<li><a href=\"http://www.ltesting.net/\">领测国际</a> </li>\n<li><a href=\"https://www.testwo.com/\">测试窝</a></li>\n<li><a href=\"https://testerhome.com\">TesterHome</a></li>\n</ul>\n</li>\n<li><p>运维:</p>\n<pre><code>* [运维派](http://www.yunweipai.com/) \n* [Abcdocker](https://www.abcdocker.com/)</code></pre></li>\n<li><p>Java:</p>\n<ul>\n<li><a href=\"http://www.importnew.com/\">ImportNew</a><ul>\n<li>专注于 Java 技术分享</li>\n</ul>\n</li>\n<li><a href=\"https://howtodoinjava.com/\">HowToDoInJava</a><ul>\n<li>英文博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>安全</p>\n<ul>\n<li><a href=\"https://www.2cto.com/\">红黑联盟</a> </li>\n<li><a href=\"http://www.freebuf.com/\">FreeBuf</a></li>\n</ul>\n</li>\n<li><p>大数据</p>\n<ul>\n<li><a href=\"http://www.thebigdata.cn/\">中国大数据</a> </li>\n</ul>\n</li>\n<li><p>其他专题网站：</p>\n<ul>\n<li><a href=\"http://www.infoq.com/cn/\">InfoQ</a><ul>\n<li>偏重于基础架构、运维方向</li>\n</ul>\n</li>\n<li><a href=\"http://www.dockerinfo.net/\">DockerInfo</a><ul>\n<li>专注于 Docker 应用及咨询、教程的网站</li>\n</ul>\n</li>\n<li><a href=\"https://www.linuxidc.com/\">Linux公社</a><ul>\n<li>Linux 主题社区</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其他类\"><a href=\"#其他类\" class=\"headerlink\" title=\"其他类\"></a>其他类</h2><ul>\n<li><a href=\"https://github.com/TeamStuQ/skill-map\">程序员技能图谱</a></li>\n</ul>\n<h2 id=\"推荐参考书\"><a href=\"#推荐参考书\" class=\"headerlink\" title=\"推荐参考书\"></a>推荐参考书</h2><h3 id=\"在线电子书\"><a href=\"#在线电子书\" class=\"headerlink\" title=\"在线电子书\"></a>在线电子书</h3><ul>\n<li><a href=\"https://github.com/forezp/SpringCloudLearning\">《深入理解Spring Cloud与微服务构建》</a></li>\n</ul>\n<ul>\n<li><p><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf\">《阿里技术参考图册-研发篇》</a></p>\n</li>\n<li><p><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf\">《阿里技术参考图册-算法篇》</a></p>\n</li>\n<li><p><a href=\"http://dpurl.cn/n/1lqcX\">《2018美团点评技术年货（合辑）》70M</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/architect/\">InfoQ《架构师》月刊</a></p>\n</li>\n<li><p><a href=\"https://www.w3cschool.cn/architectroad/\">《架构师之路》</a></p>\n</li>\n</ul>\n<h3 id=\"纸质书\"><a href=\"#纸质书\" class=\"headerlink\" title=\"纸质书\"></a>纸质书</h3><p><b style=\"color:red\">更多架构方面书籍参考:</b> <a href=\"https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%9E%B6%E6%9E%84\">awesome-java-books</a></p>\n<h4 id=\"开发方面\"><a href=\"#开发方面\" class=\"headerlink\" title=\"开发方面\"></a>开发方面</h4><ul>\n<li>《阿里巴巴Java开发手册》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BfL5CR\">详情</a></li>\n</ul>\n<h4 id=\"架构方面\"><a href=\"#架构方面\" class=\"headerlink\" title=\"架构方面\"></a>架构方面</h4><ul>\n<li><p>《软件架构师的12项修炼：技术技能篇》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=rTlo0m\">详情</a></p>\n</li>\n<li><p>《架构之美》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=1KECBZ\">详情</a> </p>\n</li>\n<li><p>《分布式服务架构》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=hkzqtK\">详情</a> </p>\n</li>\n<li><p>《聊聊架构》 <a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=A8Nd6Z\">详情</a> </p>\n</li>\n<li><p>《云原生应用架构实践》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=D4WCpd\">详情</a> </p>\n</li>\n<li><p>《亿级流量网站架构核心技术》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Rdmd21\">详情</a></p>\n</li>\n<li><p>《淘宝技术这十年》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=CoUdGG\">详情</a></p>\n</li>\n<li><p>《企业IT架构转型之道-中台战略思想与架构实战》 <a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BxS6eI\">详情</a> </p>\n</li>\n<li><p>《高可用架构（第1卷）》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BcjUwS\">详情</a> </p>\n</li>\n</ul>\n<h4 id=\"技术管理方面\"><a href=\"#技术管理方面\" class=\"headerlink\" title=\"技术管理方面\"></a>技术管理方面</h4><ul>\n<li>《CTO说》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Gl3QAo\">详情</a> </li>\n<li>《技术管理之巅》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=MeloLt\">详情</a></li>\n<li>《网易一千零一夜：互联网产品项目管理实战》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=qPuqMg\">详情</a> </li>\n</ul>\n<h4 id=\"基础理论-1\"><a href=\"#基础理论-1\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h4><ul>\n<li>《数学之美》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=0seUpO\">详情</a> </li>\n<li>《编程珠玑》<a href=\"https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=I7jj9r\">详情</a> </li>\n</ul>\n<h4 id=\"工具方面\"><a href=\"#工具方面\" class=\"headerlink\" title=\"工具方面\"></a>工具方面</h4><p>TODO</p>\n<h4 id=\"大数据方面\"><a href=\"#大数据方面\" class=\"headerlink\" title=\"大数据方面\"></a>大数据方面</h4><h1 id=\"技术资源\"><a href=\"#技术资源\" class=\"headerlink\" title=\"技术资源\"></a>技术资源</h1><h2 id=\"开源资源\"><a href=\"#开源资源\" class=\"headerlink\" title=\"开源资源\"></a>开源资源</h2><ul>\n<li><p><a href=\"https://github.com\">github</a></p>\n</li>\n<li><p><a href=\"https://www.apache.org/index.html\">Apache 软件基金会</a></p>\n</li>\n</ul>\n<h2 id=\"手册、文档、教程\"><a href=\"#手册、文档、教程\" class=\"headerlink\" title=\"手册、文档、教程\"></a>手册、文档、教程</h2><p><strong>国内：</strong></p>\n<ul>\n<li><p><a href=\"http://w3cschool.cn\">W3Cschool</a> </p>\n</li>\n<li><p><a href=\"http://www.runoob.com/\">Runoob.com</a></p>\n<ul>\n<li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li>\n</ul>\n</li>\n<li><p><a href=\"https://love2.io/\">Love2.io</a></p>\n<ul>\n<li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li>\n</ul>\n</li>\n<li><p><a href=\"http://gitbook.cn/\">gitbook.cn</a></p>\n<ul>\n<li>付费电子书。 </li>\n</ul>\n</li>\n<li><p><a href=\"http://www.apachecn.org/\">ApacheCN</a></p>\n<ul>\n<li>AI、大数据方面系列中文文档。</li>\n</ul>\n</li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"http://www.quickcode.co/\">Quick Code</a><ul>\n<li>免费在线技术教程。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.com\">gitbook.com</a><ul>\n<li>有部分中文电子书。</li>\n</ul>\n</li>\n<li><a href=\"https://www.cheatography.com/\">Cheatography</a><ul>\n<li>Cheat Sheets 大全，单页文档网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.tutorialspoint.com/index.htm\">Tutorialspoint</a><ul>\n<li>知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。</li>\n</ul>\n</li>\n<li><a href=\"https://leetcode.com/problemset/all/\">LeetCode</a><ul>\n<li>知名题库网站，提供Java、Python、C#、C++、算法、SQL、等高质量各程度题库和解决办法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在线课堂\"><a href=\"#在线课堂\" class=\"headerlink\" title=\"在线课堂\"></a>在线课堂</h2><ul>\n<li><a href=\"http://www.xuetuwuyou.com/\">学徒无忧</a></li>\n<li><a href=\"https://time.geekbang.org/\">极客时间</a></li>\n<li><a href=\"https://segmentfault.com/lives\">segmentfault</a></li>\n<li><a href=\"https://new.stuq.org/course/explore\">斯达克学院</a></li>\n<li><a href=\"http://nowcoder.com\">牛客网</a></li>\n<li><a href=\"https://www.jikexueyuan.com/\">极客学院</a></li>\n<li><a href=\"http://edu.51cto.com/\">51CTO学院</a></li>\n</ul>\n<h2 id=\"会议、活动\"><a href=\"#会议、活动\" class=\"headerlink\" title=\"会议、活动\"></a>会议、活动</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/qcon/\">QCon</a></li>\n<li><a href=\"https://archsummit.com\">ArchSummit</a></li>\n<li><a href=\"http://www.thegitc.com/\">GITC全球互联网技术大会</a></li>\n</ul>\n<p><strong>活动发布平台:</strong> </p>\n<ul>\n<li><a href=\"http://www.huodongxing.com/\">活动行</a></li>\n</ul>\n<h2 id=\"常用APP\"><a href=\"#常用APP\" class=\"headerlink\" title=\"常用APP\"></a>常用APP</h2><ul>\n<li><a href=\"https://time.geekbang.org\">极客时间</a></li>\n<li><a href=\"https://www.igetget.com\">得到</a></li>\n</ul>\n<h2 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h2><ul>\n<li><a href=\"https://www.zhipin.com\">Boss直聘</a></li>\n<li><a href=\"https://www.lagou.com\">拉勾网</a></li>\n<li><a href=\"https://www.liepin.com\">猎聘</a></li>\n<li><a href=\"https://cn.100offer.com/\">100Offer</a></li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><a href=\"https://s.geekbang.org/\">极客搜索</a><ul>\n<li>技术文章搜索引擎。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码托管\"><a href=\"#代码托管\" class=\"headerlink\" title=\"代码托管\"></a>代码托管</h2><ul>\n<li><a href=\"https://coding.net\">Coding</a></li>\n<li><a href=\"https://gitee.com/\">码云</a></li>\n</ul>\n<h2 id=\"文件服务\"><a href=\"#文件服务\" class=\"headerlink\" title=\"文件服务\"></a>文件服务</h2><ul>\n<li>七牛</li>\n<li>又拍云</li>\n</ul>\n<h2 id=\"综合云服务商\"><a href=\"#综合云服务商\" class=\"headerlink\" title=\"综合云服务商\"></a>综合云服务商</h2><ul>\n<li>阿里云</li>\n<li><a href=\"https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c\">腾讯云</a></li>\n<li>百度云</li>\n<li>新浪云</li>\n<li>金山云</li>\n<li><a href=\"https://amazonaws-china.com/cn/\">亚马逊云(AWS)</a></li>\n<li><a href=\"https://cloud.google.com/?hl=zh-cn\">谷歌云</a></li>\n<li><a href=\"https://azure.microsoft.com/zh-cn/\">微软云</a></li>\n</ul>\n<h3 id=\"VPS\"><a href=\"#VPS\" class=\"headerlink\" title=\"VPS\"></a>VPS</h3><ul>\n<li><a href=\"http://linode.com\">Linode</a></li>\n<li><a href=\"https://www.digitalocean.com\">DigitalOcean</a></li>\n<li><a href=\"https://www.vultr.com/\">Vultr</a></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/1.png","slug":"1.png","post":"ckiyez6h4000otvcd2cti17o2","modified":0,"renderable":0},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/2.png","slug":"2.png","post":"ckiyez6h4000otvcd2cti17o2","modified":0,"renderable":0},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/3.png","slug":"3.png","post":"ckiyez6h4000otvcd2cti17o2","modified":0,"renderable":0},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/4.png","slug":"4.png","post":"ckiyez6h4000otvcd2cti17o2","modified":0,"renderable":0},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/5.png","slug":"5.png","post":"ckiyez6h4000otvcd2cti17o2","modified":0,"renderable":0},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/6.png","slug":"6.png","post":"ckiyez6h4000otvcd2cti17o2","modified":0,"renderable":0},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/7.png","slug":"7.png","post":"ckiyez6h4000otvcd2cti17o2","modified":0,"renderable":0},{"_id":"source/_posts/技术实践/spring/spring-cloud-learning/8.png","slug":"8.png","post":"ckiyez6h4000otvcd2cti17o2","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckiyez6gs0003tvcd959y8oip","category_id":"ckiyez6gv0006tvcdds3731qg","_id":"ckiyez6h3000jtvcd416ff8v9"},{"post_id":"ckiyez6gx0009tvcd1nuzd9fc","category_id":"ckiyez6h0000etvcd2p0nhvo1","_id":"ckiyez6h5000qtvcd57oobtwg"},{"post_id":"ckiyez6gy000btvcdakb76imc","category_id":"ckiyez6h3000ktvcd7isnd72g","_id":"ckiyez6h8000vtvcd4vzwafcz"},{"post_id":"ckiyez6h4000otvcd2cti17o2","category_id":"ckiyez6h0000etvcd2p0nhvo1","_id":"ckiyez6h9000ytvcd8yvihd2c"},{"post_id":"ckiyez6gz000dtvcd8rb26gkp","category_id":"ckiyez6h3000ktvcd7isnd72g","_id":"ckiyez6ha0010tvcdgvgo8zxj"},{"post_id":"ckiyez6hb0014tvcd1rxxgnbt","category_id":"ckiyez6ha0011tvcd9hs996mo","_id":"ckiyez6hk001btvcdg70j6v7n"},{"post_id":"ckiyez6h8000xtvcd0gfb8l3h","category_id":"ckiyez6ha0011tvcd9hs996mo","_id":"ckiyez6hl001gtvcd2dso2d49"},{"post_id":"ckiyez6hc0015tvcdcwik74nt","category_id":"ckiyez6h3000ktvcd7isnd72g","_id":"ckiyez6hm001jtvcdafq74nlu"},{"post_id":"ckiyez6h9000ztvcdb7n9dv6k","category_id":"ckiyez6ha0011tvcd9hs996mo","_id":"ckiyez6hn001otvcd1bqpghre"},{"post_id":"ckiyez6ha0012tvcdcgbyg4m1","category_id":"ckiyez6ha0011tvcd9hs996mo","_id":"ckiyez6hp001ptvcd3e9613di"},{"post_id":"ckiyez6hm001itvcdf1dpgo61","category_id":"ckiyez6ha0011tvcd9hs996mo","_id":"ckiyez6hp001rtvcd06x0efg5"},{"post_id":"ckiyez6hj0018tvcd4m9i8e14","category_id":"ckiyez6hm001ktvcd3mbk5lm4","_id":"ckiyez6hq001vtvcdaz6t3yvu"},{"post_id":"ckiyez6hj001atvcdevsg18co","category_id":"ckiyez6hm001ktvcd3mbk5lm4","_id":"ckiyez6hr001ztvcd0ooy62tk"},{"post_id":"ckiyez6i4003etvcddryw5knn","category_id":"ckiyez6h3000ktvcd7isnd72g","_id":"ckiyez6i6003itvcd11v30sua"},{"post_id":"ckiyez6i4003gtvcde17ee5dy","category_id":"ckiyez6hm001ktvcd3mbk5lm4","_id":"ckiyez6i6003ltvcdfx4763y3"},{"post_id":"ckiyez6i5003htvcdbxfvg5xx","category_id":"ckiyez6ha0011tvcd9hs996mo","_id":"ckiyez6i7003mtvcd640bf3av"},{"post_id":"ckiyez6ig003ztvcdcwzo74fu","category_id":"ckiyez6ig0040tvcdh5v8hb99","_id":"ckiyez6ih0043tvcd92ek8xap"},{"post_id":"ckiyez6hl001ftvcddvyt1x5c","category_id":"ckiyez6ha0011tvcd9hs996mo","_id":"ckiyfbqm60000cycdbvi4a7b1"}],"PostTag":[{"post_id":"ckiyez6gs0003tvcd959y8oip","tag_id":"ckiyez6gw0007tvcd3juz12q0","_id":"ckiyez6h4000ntvcda46dd1uk"},{"post_id":"ckiyez6gs0003tvcd959y8oip","tag_id":"ckiyez6h0000ftvcd2g9ff4xh","_id":"ckiyez6h5000ptvcd5rfqbrzw"},{"post_id":"ckiyez6gt0005tvcd10wncotl","tag_id":"ckiyez6h3000ltvcdh8bjerlp","_id":"ckiyez6hj0019tvcdgwq36r4d"},{"post_id":"ckiyez6gt0005tvcd10wncotl","tag_id":"ckiyez6h5000stvcdhep1alng","_id":"ckiyez6hk001dtvcdfk735n2z"},{"post_id":"ckiyez6gt0005tvcd10wncotl","tag_id":"ckiyez6h8000wtvcdfowg2vrj","_id":"ckiyez6hl001htvcd2zi86czw"},{"post_id":"ckiyez6gt0005tvcd10wncotl","tag_id":"ckiyez6hb0013tvcd9ri698d0","_id":"ckiyez6hn001ltvcd9wqp6qol"},{"post_id":"ckiyez6gx0009tvcd1nuzd9fc","tag_id":"ckiyez6hi0017tvcd6bvn9vbb","_id":"ckiyez6hq001ttvcd7ty48tcz"},{"post_id":"ckiyez6gx0009tvcd1nuzd9fc","tag_id":"ckiyez6hl001etvcdbgbh53lc","_id":"ckiyez6hq001wtvcdcq1b6m9f"},{"post_id":"ckiyez6gx0009tvcd1nuzd9fc","tag_id":"ckiyez6hn001mtvcdfji516zh","_id":"ckiyez6hr001ytvcd2mpudaka"},{"post_id":"ckiyez6gy000btvcdakb76imc","tag_id":"ckiyez6hp001stvcde9632grr","_id":"ckiyez6hr0021tvcdh8un3454"},{"post_id":"ckiyez6gy000btvcdakb76imc","tag_id":"ckiyez6hl001etvcdbgbh53lc","_id":"ckiyez6hr0023tvcd8o9j638u"},{"post_id":"ckiyez6gz000dtvcd8rb26gkp","tag_id":"ckiyez6hp001stvcde9632grr","_id":"ckiyez6hs0025tvcd7l57159i"},{"post_id":"ckiyez6h1000htvcd60oyby2f","tag_id":"ckiyez6hr0024tvcdhhj2h7xj","_id":"ckiyez6hs0027tvcd4qk06qck"},{"post_id":"ckiyez6h2000itvcdc409cjic","tag_id":"ckiyez6hr0024tvcdhhj2h7xj","_id":"ckiyez6ht0029tvcd62n0cskn"},{"post_id":"ckiyez6h3000mtvcdaahzetol","tag_id":"ckiyez6ht0028tvcdeugp0ew1","_id":"ckiyez6ht002btvcd0q5pgqm8"},{"post_id":"ckiyez6h4000otvcd2cti17o2","tag_id":"ckiyez6ht002atvcd8jod0l22","_id":"ckiyez6hu002ftvcddl0qe1t8"},{"post_id":"ckiyez6h4000otvcd2cti17o2","tag_id":"ckiyez6hu002ctvcddxxc3v2w","_id":"ckiyez6hu002gtvcdclqp8x69"},{"post_id":"ckiyez6h4000otvcd2cti17o2","tag_id":"ckiyez6hu002dtvcdblas0gpd","_id":"ckiyez6hv002itvcd8h8yavub"},{"post_id":"ckiyez6h6000ttvcddgcad6ut","tag_id":"ckiyez6hu002dtvcdblas0gpd","_id":"ckiyez6hv002jtvcd86659979"},{"post_id":"ckiyez6h7000utvcd1qtx9z3h","tag_id":"ckiyez6hu002dtvcdblas0gpd","_id":"ckiyez6hv002ltvcd4oqbcjuo"},{"post_id":"ckiyez6h8000xtvcd0gfb8l3h","tag_id":"ckiyez6hv002ktvcd2q8o07jv","_id":"ckiyez6hw002otvcdakz0hb9q"},{"post_id":"ckiyez6h8000xtvcd0gfb8l3h","tag_id":"ckiyez6hv002mtvcd8cqe0ipt","_id":"ckiyez6hw002ptvcd91qbhpc6"},{"post_id":"ckiyez6h9000ztvcdb7n9dv6k","tag_id":"ckiyez6hv002ktvcd2q8o07jv","_id":"ckiyez6hw002stvcddwyqfe27"},{"post_id":"ckiyez6h9000ztvcdb7n9dv6k","tag_id":"ckiyez6hv002mtvcd8cqe0ipt","_id":"ckiyez6hx002ttvcdc3qh3ijq"},{"post_id":"ckiyez6ha0012tvcdcgbyg4m1","tag_id":"ckiyez6hw002rtvcd1h2y2qrg","_id":"ckiyez6hx002wtvcd69b80hkf"},{"post_id":"ckiyez6ha0012tvcdcgbyg4m1","tag_id":"ckiyez6hx002utvcd5m5dg1s9","_id":"ckiyez6hx002xtvcd3vxg1koa"},{"post_id":"ckiyez6hb0014tvcd1rxxgnbt","tag_id":"ckiyez6hx002vtvcd91bwe1j7","_id":"ckiyez6hy002ztvcddohvg58b"},{"post_id":"ckiyez6hc0015tvcdcwik74nt","tag_id":"ckiyez6hx002vtvcd91bwe1j7","_id":"ckiyez6hy0031tvcdfokxbhon"},{"post_id":"ckiyez6hj0018tvcd4m9i8e14","tag_id":"ckiyez6hy0030tvcd57wc7kyo","_id":"ckiyez6hy0033tvcdep229inu"},{"post_id":"ckiyez6hj001atvcdevsg18co","tag_id":"ckiyez6hy0030tvcd57wc7kyo","_id":"ckiyez6hz0035tvcdek8x16yv"},{"post_id":"ckiyez6hl001ftvcddvyt1x5c","tag_id":"ckiyez6hy0030tvcd57wc7kyo","_id":"ckiyez6hz0038tvcd8rmp0zlk"},{"post_id":"ckiyez6hl001ftvcddvyt1x5c","tag_id":"ckiyez6hz0036tvcdabad19x4","_id":"ckiyez6i00039tvcd84j66ekk"},{"post_id":"ckiyez6hm001itvcdf1dpgo61","tag_id":"ckiyez6hz0037tvcd6y7604jl","_id":"ckiyez6i0003btvcd26ob3ly9"},{"post_id":"ckiyez6hm001itvcdf1dpgo61","tag_id":"ckiyez6i0003atvcdhrl781fu","_id":"ckiyez6i0003ctvcdg6difssn"},{"post_id":"ckiyez6i2003dtvcd5oyxgzym","tag_id":"ckiyez6i4003ftvcdedlkg4pn","_id":"ckiyez6i6003ktvcd7iuz1fhm"},{"post_id":"ckiyez6i4003etvcddryw5knn","tag_id":"ckiyez6i6003jtvcd2o2b2qkz","_id":"ckiyez6i8003ptvcded541y0p"},{"post_id":"ckiyez6i4003etvcddryw5knn","tag_id":"ckiyez6i7003ntvcdfjmrhm7u","_id":"ckiyez6i8003qtvcd4ngxgcrf"},{"post_id":"ckiyez6i4003gtvcde17ee5dy","tag_id":"ckiyez6hy0030tvcd57wc7kyo","_id":"ckiyez6i8003stvcd424ff8rk"},{"post_id":"ckiyez6i4003gtvcde17ee5dy","tag_id":"ckiyez6i7003otvcdfzd11lji","_id":"ckiyez6i8003ttvcdhy1y0n7t"},{"post_id":"ckiyez6i5003htvcdbxfvg5xx","tag_id":"ckiyez6i8003rtvcdh1pp6udy","_id":"ckiyez6i9003utvcd3urxg276"},{"post_id":"ckiyez6i9003vtvcdhv6s8615","tag_id":"ckiyez6hr0024tvcdhhj2h7xj","_id":"ckiyez6ib003xtvcd2lj19u3m"},{"post_id":"ckiyez6i9003vtvcdhv6s8615","tag_id":"ckiyez6ia003wtvcdgnkvhvsj","_id":"ckiyez6ib003ytvcd1cd72byc"},{"post_id":"ckiyez6ig003ztvcdcwzo74fu","tag_id":"ckiyez6ih0041tvcd5xai0dpp","_id":"ckiyez6ih0044tvcd3r4ndw0l"},{"post_id":"ckiyez6ig003ztvcdcwzo74fu","tag_id":"ckiyez6ih0042tvcdd6qxgiab","_id":"ckiyez6ih0045tvcd39um9vm3"}],"Tag":[{"name":"数据结构","_id":"ckiyez6gw0007tvcd3juz12q0"},{"name":"算法","_id":"ckiyez6h0000ftvcd2g9ff4xh"},{"name":"redis","_id":"ckiyez6h3000ltvcdh8bjerlp"},{"name":"cluster","_id":"ckiyez6h5000stvcdhep1alng"},{"name":"docker","_id":"ckiyez6h8000wtvcdfowg2vrj"},{"name":"docker-compose","_id":"ckiyez6hb0013tvcd9ri698d0"},{"name":"hosts","_id":"ckiyez6hi0017tvcd6bvn9vbb"},{"name":"github","_id":"ckiyez6hl001etvcdbgbh53lc"},{"name":"python","_id":"ckiyez6hn001mtvcdfji516zh"},{"name":"git","_id":"ckiyez6hp001stvcde9632grr"},{"name":"Linux","_id":"ckiyez6hr0024tvcdhhj2h7xj"},{"name":"Docker","_id":"ckiyez6ht0028tvcdeugp0ew1"},{"name":"Spring","_id":"ckiyez6ht002atvcd8jod0l22"},{"name":"Spring Cloud","_id":"ckiyez6hu002ctvcddxxc3v2w"},{"name":"Java","_id":"ckiyez6hu002dtvcdblas0gpd"},{"name":"RAS","_id":"ckiyez6hv002ktvcd2q8o07jv"},{"name":"Mac","_id":"ckiyez6hv002mtvcd8cqe0ipt"},{"name":"mac","_id":"ckiyez6hw002rtvcd1h2y2qrg"},{"name":"node","_id":"ckiyez6hx002utvcd5m5dg1s9"},{"name":"Markdown","_id":"ckiyez6hx002vtvcd91bwe1j7"},{"name":"Hexo","_id":"ckiyez6hy0030tvcd57wc7kyo"},{"name":"Github","_id":"ckiyez6hz0036tvcdabad19x4"},{"name":"https","_id":"ckiyez6hz0037tvcd6y7604jl"},{"name":"ssl","_id":"ckiyez6i0003atvcdhrl781fu"},{"name":"MySQL","_id":"ckiyez6i4003ftvcdedlkg4pn"},{"name":"正则表达式","_id":"ckiyez6i6003jtvcd2o2b2qkz"},{"name":"regex","_id":"ckiyez6i7003ntvcdfjmrhm7u"},{"name":"NexT","_id":"ckiyez6i7003otvcdfzd11lji"},{"name":"Kafka","_id":"ckiyez6i8003rtvcdh1pp6udy"},{"name":"Centos","_id":"ckiyez6ia003wtvcdgnkvhvsj"},{"name":"java","_id":"ckiyez6ih0041tvcd5xai0dpp"},{"name":"架构师","_id":"ckiyez6ih0042tvcdd6qxgiab"}]}}